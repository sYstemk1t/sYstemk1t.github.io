<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Windows-Assembly-3 - sYstemk1t&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="sYstemk1t"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="sYstemk1t"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="从”Hello，World”开始！"><meta property="og:type" content="blog"><meta property="og:title" content="Windows-Assembly-3"><meta property="og:url" content="http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/"><meta property="og:site_name" content="sYstemk1t&#039;s blog"><meta property="og:description" content="从”Hello，World”开始！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/Windows-Assembly-3%5C3.png"><meta property="og:image" content="http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/4.png"><meta property="og:image" content="http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/5.png"><meta property="og:image" content="http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/6.png"><meta property="article:published_time" content="2020-04-02T13:37:44.000Z"><meta property="article:modified_time" content="2020-04-06T17:53:59.522Z"><meta property="article:author" content="sYstemk1t"><meta property="article:tag" content="Assembly"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2020/04/02/Windows-Assembly-3/Windows-Assembly-3%5C3.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/"},"headline":"sYstemk1t's blog","image":["http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/Windows-Assembly-3%5C3.png","http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/4.png","http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/5.png","http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/6.png"],"datePublished":"2020-04-02T13:37:44.000Z","dateModified":"2020-04-06T17:53:59.522Z","author":{"@type":"Person","name":"sYstemk1t"},"description":"从”Hello，World”开始！"}</script><link rel="canonical" href="http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="fontawesome"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/head.jpg" alt="sYstemk1t&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-02T13:37:44.000Z" title="2020-04-02T13:37:44.000Z">2020-04-02</time>发表</span><span class="level-item"><time dateTime="2020-04-06T17:53:59.522Z" title="2020-04-06T17:53:59.522Z">2020-04-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Windows32%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/">Windows32汇编语言设计</a></span><span class="level-item">1 小时读完 (大约6994个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Windows-Assembly-3</h1><div class="content"><p>从”Hello，World”开始！</p>
<a id="more"></a>

<h2 id="Win32汇编程序结构"><a href="#Win32汇编程序结构" class="headerlink" title="Win32汇编程序结构"></a>Win32汇编程序结构</h2><p>首先看看C语言实现”Hello，World”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在c语言比重，我们不必为堆栈段、数据段核代码段的定义而担心，因为编译器会将程序中的字符串核代码语言存放到它们应该去的地方，程序开始的时候会找到main()函数。</p>
<p>在汇编中，我们需要自己去定义每个数据存放的段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">;堆栈段</span><br><span class="line">stack	segment	stack</span><br><span class="line">		db	100	dup	(?)</span><br><span class="line">stack	ends</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">data	segment	</span><br><span class="line">szHello	db	&#39;Hello,World&#39;</span><br><span class="line">data	ends</span><br><span class="line"></span><br><span class="line">;代码段</span><br><span class="line">code	segment</span><br><span class="line">		assume cs:code,ds:code,ss:stack</span><br><span class="line">start:</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ah,9</span><br><span class="line">		mov dx,offset szHello</span><br><span class="line">		int 21h</span><br><span class="line">		mov ah,4ch</span><br><span class="line">		int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<p>我们首先自己写一个Win32版本的Hello程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">		.386</span><br><span class="line">		.model flat,stdcall</span><br><span class="line">		option casemap:none</span><br><span class="line">;文件定义</span><br><span class="line">include	windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib  kernel32.lib</span><br><span class="line">includelib  user32.lib</span><br><span class="line"></span><br><span class="line">;数据段</span><br><span class="line">        .data</span><br><span class="line">szCaption   db  &#39;First Elastic frame&#39;,0</span><br><span class="line">szText      db  &#39;Hello,World&#39;, 0</span><br><span class="line"></span><br><span class="line">;代码段</span><br><span class="line">        .code</span><br><span class="line">start:</span><br><span class="line">        invoke MessageBoxA,NULL,offset szText,offset szCaption,0</span><br><span class="line">        invoke ExitProcess,NULL</span><br><span class="line"></span><br><span class="line">        end start</span><br></pre></td></tr></table></figure>



<h4 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h4><p>.386是汇编语言的伪指令，它在低版本的宏汇编就已经存在，类似的指令还有.8086，.186，.386等，用于告诉编译器在编译本程序中使用的指令集。<strong>在DOS程序默认使用8086指令集</strong></p>
<h4 id="model语句"><a href="#model语句" class="headerlink" title=".model语句"></a>.model语句</h4><p>.model语句是用来定义程序工作的模式，它的使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.model	内存模式[语言模式][其他模式]</span><br></pre></td></tr></table></figure>

<p>内存模式的定义可以直接影响生成的可执行文件，可执行文件的大小从小到大，可以分为很多种，在DOS的可执行程序中，有只用到 64KB的.com文件。到了Win32的情况下，又有了4GB内存的PE格式的可执行文件，编写不同类型的可执行文件要用不同的.model语句定义不同的参数。</p>
<p><img src="/2020/04/02/Windows-Assembly-3/Windows-Assembly-3%5C3.png"></p>
<p><strong>Windows的API调用使用的stdcall格式，四朋哟早Win32汇编中没有选项，必须在.model中加上stdcall传递参数的细节</strong></p>
<h4 id="option语句"><a href="#option语句" class="headerlink" title="option语句"></a>option语句</h4><p>用option语句定义的选项有很多，在Win32汇编中必须定义这个选项，因为Win32API是对API区分大写。</p>
<h3 id="段的定义"><a href="#段的定义" class="headerlink" title="段的定义"></a>段的定义</h3><p>把编写的Hello源代码中的语句归纳一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    .386</span><br><span class="line">    .model flat,stdcall</span><br><span class="line">    option casemap:none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Include语句&gt;</span><br><span class="line">    .stack [堆栈段的大小]</span><br><span class="line">    .data</span><br><span class="line">    &lt;初始化后的数据&gt;</span><br><span class="line">    .data?</span><br><span class="line">    &lt;未初始化后的数据&gt;</span><br><span class="line">    .const</span><br><span class="line">    &lt;一些常量定义&gt;</span><br><span class="line">    .code</span><br><span class="line">    &lt;代码&gt;</span><br><span class="line">    &lt;开始标号&gt;</span><br><span class="line">        &lt;其他语句&gt;</span><br><span class="line"></span><br><span class="line">    end &lt;开始标号&gt;</span><br></pre></td></tr></table></figure>

<p><strong>.stack，.data，.data?，.const和.code是分段伪指令，Win32中实际只有代码和数据之分，由于Win32汇编不必考虑堆栈，系统会分配一个向下的、足够大的段作为堆栈段，所以.stack经常会被忽略定义</strong></p>
<h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><p>.data，.data?和.const定义的是数据段，分别对应不同的数据定义方式，在最后也放在不同的节区中。<strong>程序中的数据定义一般可以归纳为三类。</strong></p>
<ul>
<li>第一类是可读可写的已定义变量。</li>
<li>第二类是可读可写的未定义变量</li>
<li>第三类是一些常量。</li>
</ul>
<h4 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h4><p>.code段是代码段，所有的指令都必须写在代码段中，在可执行文件中，代码段一般是放在TEXT节区中。Win32环境中的数据段是不可执行的，只有代码段有可执行数据。堆与工作在环3层的应用来说，.code段是不可写的。</p>
<h4 id="堆栈段"><a href="#堆栈段" class="headerlink" title="堆栈段"></a>堆栈段</h4><p>在程序中不必定义堆栈段，系统会自动分配堆栈空间。唯一值得一提的是：<strong>堆栈段的内存属性是可读可写可执行的</strong>。</p>
<h3 id="注释和换行"><a href="#注释和换行" class="headerlink" title="注释和换行"></a>注释和换行</h3><p>汇编中的注释是以”;”开始，如果一行写不下的代码，可以加一个”&quot;。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">invoke MessageBoxA	\</span><br><span class="line">		NULL	;父窗口句柄</span><br><span class="line">		offset szText	;消息窗口的文字</span><br><span class="line">		offset szCapTion	;标题文字</span><br><span class="line">		MB_OK	;弹出方式</span><br></pre></td></tr></table></figure>





<h2 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h2><h3 id="API是什么"><a href="#API是什么" class="headerlink" title="API是什么"></a>API是什么</h3><p>Win32程序是构筑在Win32 API上的。在Win32API中，包含了大量的函数、结构体和消息等，它们不仅被程序调用，也是自身的一部分。</p>
<p>应用程序在使用的时候是由Windows自助装入DLL程序并调用相应的函数</p>
<ul>
<li>Kernel32.dll-系统服务功能。包括内存管理、任务管理和动态链接等。</li>
<li>GdI32.dll-图形设备接口。利用VGA等显示设备驱动程序完成显示</li>
<li>User32.dll-用户接口服务。建立窗口和传送消息等</li>
</ul>
<h3 id="调用API-1"><a href="#调用API-1" class="headerlink" title="调用API"></a>调用API</h3><p>Win32API是通过堆栈来传递参数的，调用者把参数一个个压入栈，DLL中的函数程序再从堆栈中取出参数处理，并在返回前将堆栈中无用的参数丢弃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int MessageBox(</span><br><span class="line">  HWND    hWnd,</span><br><span class="line">  LPCTSTR lpText,</span><br><span class="line">  LPCTSTR lpCaption,</span><br><span class="line">  UINT    uType</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>Win32环境中的实际参数只有一个类型，那就是一个32位的整数，所以这些参数都是dword类型，之所以可以定义成不同的模样，是为了说明其用途。</strong></p>
<p>在汇编中调用MessageBox函数的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push uType</span><br><span class="line">push lpCaption</span><br><span class="line">push lpText</span><br><span class="line">push hWnd</span><br><span class="line">call MessageBox</span><br></pre></td></tr></table></figure>

<p>源程序编译链接称为可执行文件后，call MessageBox语句中的MessageBox会被替换成一个地址，指向可执行文件中的导入表。</p>
<h4 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h4><p>invoke伪指令，它的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke	函数名[,参数1][,参数2].....</span><br></pre></td></tr></table></figure>

<p>对MessageBox的调用可以写为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke MessageBox,NULL,offset szText,offset szCaption,MB_OK</span><br></pre></td></tr></table></figure>

<p><strong>invoke并不是80386处理器的指令，而是一个伪指令，在编译的时候由编译器把上面的指令展开称为我们需要的4个push指令和1个call指令</strong></p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回值的类型对汇编程序来说也是一种dword类型，它永远存放在eax中。如果返回值的内容一个eax不能容纳，Win32API采用的方法一般都是eax中反汇一个指向数据的指针，或者在调用参数中提供一个缓冲区的地址，干脆把数据返回到缓冲区中。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>在调用API函数的时候，必须预先声明，否则，编译器不会认识这个函数。</p>
<p>invoke伪指令也无法检查参数个数。声明函数的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名 proto [距离][语言][参数1]:数据类型[参数2]:数据类型</span><br></pre></td></tr></table></figure>

<p>proto伪指令的距离是NEAR、FAR、NEAR16、NEAR32，FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以定义的时候是忽略的，语言类型就是.model那些类型。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto hWnd:dword,lpText:dword,lpCaption:dword,uType:dword</span><br><span class="line">MessageBox Proto :dword,:dword,:dword,:dword</span><br></pre></td></tr></table></figure>







<h4 id="Include"><a href="#Include" class="headerlink" title="Include"></a>Include</h4><p>对于所有要用到的API函数，在程序的开始部分必须预先声明，但这个步骤比较麻烦，为了简约，可以采用各种通用的操作方法，就是把所有的声明写在一个文件中，然后包含。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include user32.inc</span><br><span class="line">include	kernel32.inc</span><br></pre></td></tr></table></figure>

<p>include语句还可以在源文件中包含其他文件，当多个源程序用到相同的函数定义、常量定义、甚至源代码的时候，可以把相同的部分写成一个文件，然后再不同的源程序中include。</p>
<p><strong>编译器对include的处理仅仅只是把这一行用指定的文件内容替换</strong></p>
<p>如果遇到文件和关键字同名可能会引起编译器混淆的时候，可以用”&lt;&gt;”将文件名括起来。</p>
<h4 id="Includelib"><a href="#Includelib" class="headerlink" title="Includelib"></a>Includelib</h4><p>在Win32汇编中使用API函数，程序必须知道调用的API函数存在于那个DLL中，否则，操作系统必须搜索系统中所有的DLL，并且无法处理不同DLL中的同名函数，这显然是不显示的，所以，必须有文件包含DLL库正确的定位信息。</p>
<p><strong>Win32环境中，程序链接的时候仍然使用函数库来定位函数信息，只不过由于函数代码存放于DLL中，库文件中只留着函数的定位信息和参数数据等简单信息，这种库称为导入库，一个DLL文件对应一个导入库</strong></p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">includelib	库文件名</span><br><span class="line">includelib	&lt;库文件名&gt;</span><br></pre></td></tr></table></figure>



<h3 id="标号、变量和数据结构"><a href="#标号、变量和数据结构" class="headerlink" title="标号、变量和数据结构"></a>标号、变量和数据结构</h3><p><strong>当程序需要跳转到另外一个位置的时候，需要有一个标识来指示新的位置，这就是标号。</strong></p>
<p>变量是计算机内存中已命名的存储位置，变量的之再运行中是需要改变的，所以它必须定义在可写的段中，或者堆栈中。</p>
<p>在MASM中标号和变量的命名规划如下：</p>
<ul>
<li>可以用字母、数字、夏欢及符号@、$和?。</li>
<li>第一个符号不可以为数字。</li>
<li>长度不可以超过240个字符。</li>
<li>不可以使用指令关键字。</li>
<li>在作用域必须是唯一的。</li>
</ul>
<h4 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h4><h5 id="标号-1"><a href="#标号-1" class="headerlink" title="标号"></a>标号</h5><p>在程序使用跳转指令的时候，可以使用标号来标识转的目的地，编译器在编译的时候将它替换为地址，标号即可以定义在目的指令同一行的头部，也可以在目的指令前一行单独用一行定义，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标号名:		目的指令		;方法1</span><br><span class="line">或</span><br><span class="line">标号名::		目的指令		;方法2</span><br></pre></td></tr></table></figure>

<p>标号的作用域是当前的子程序，在单个子程序中标号不能同名，否则编译器不知道该使用哪个地址，但在不同的子程序中可以有相同名称的标号。</p>
<h5 id><a href="#" class="headerlink" title="@@"></a>@@</h5><p>在DOS的年代，为标号起名字很麻烦，因为汇编使用的跳转指令很多，所以程序中会有很多个标号。</p>
<p>事实上，很多标号使用一到两次，并不一定需要一个有意义的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	mov cx,1234h</span><br><span class="line">	cmp flag,1</span><br><span class="line">	jz	1oc1</span><br><span class="line">	mov cx,1000h</span><br><span class="line"></span><br><span class="line">loc1:</span><br><span class="line">	...</span><br><span class="line">	loop loc1</span><br></pre></td></tr></table></figure>

<p>对于上面这样的程序，高版本的MASM使用@@标号去代替它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	mov cx,1234h</span><br><span class="line">	cmp flag,1</span><br><span class="line">	jz	@F</span><br><span class="line">	mov cx,1000h</span><br><span class="line"></span><br><span class="line">@@:</span><br><span class="line">	...</span><br><span class="line">	loop @B</span><br></pre></td></tr></table></figure>



<p><strong>当使用了@@作为标号的时候，可以使用@F和@B来引用，@F标识本条指令后第一个@@标号，@B标识本条指令前的第一个@@标号，程序中可以有很多个@@标号，但是@F和@B只寻找距离自己最近的那个</strong></p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><h5 id="全局变量的定义"><a href="#全局变量的定义" class="headerlink" title="全局变量的定义"></a>全局变量的定义</h5><p>全局变量的作用域在整个程序，Win32汇编的全局变量定义在.data或.data?段内，剋有同时定义变量的类型和长度、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名	类型	初始值1,初始值2,...</span><br><span class="line">变量名	类型	重复数据 dup (初始值1,初始值2...)</span><br></pre></td></tr></table></figure>



<p><img src="/2020/04/02/Windows-Assembly-3/4.png"></p>
<p>所有使用到变量类型的情况中，只有定义全局变量的时候才可以使用缩写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	.data</span><br><span class="line">wHour	dw	?	;未初始化的word类型变量</span><br><span class="line">wMinute	dw	10	;初始化为10的变量</span><br><span class="line">_hWnd	dd	?	;双字类型的变量</span><br><span class="line">word_Buffer	dw	100	dup	(1,2)	;以0001，0002，0001，0002在内存中重复100次</span><br><span class="line">szBuffer	byte	1024	dup	(?)	;1024字节缓冲区</span><br><span class="line">szText	db	&#39;Hello,World!&#39;	;字符串共占12字节。</span><br></pre></td></tr></table></figure>





<h5 id="全局变量的初始化"><a href="#全局变量的初始化" class="headerlink" title="全局变量的初始化"></a>全局变量的初始化</h5><p>全局变量在定义在即可只当初值，也可以使用？预留空间，在.data?段中，只可以用？预留空间。因为.data？不能初始值。<strong>如果用问号指定全局变量如果要以0为初始值的话，在程序中不必特意赋值。</strong></p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><h5 id="局部变量定义"><a href="#局部变量定义" class="headerlink" title="局部变量定义"></a>局部变量定义</h5><p>MASM用local伪指令提供了对局部变量的支持：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local	变量名1[[重复数据]][:类型],变量名2[[重复数据]][:类型]...</span><br></pre></td></tr></table></figure>



<p>local伪指令必须紧接在子程序定义的伪指令proc后、其他指令开始前，因为局部变量的数据在子程序开始之前就要确定下来。<strong>win32默认的类型是dword，当定义数组的时候，可以使用[]括号括起来，不能使用定义全局变量的dup伪指令。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local	loc1[1024]:byte	;1024字节长的局部变量locl</span><br><span class="line">local	loc2	;loc2的局部变量，默认类型为dword</span><br><span class="line">local	loc3:WNDCLASS	;WNDCLASS的数据结构</span><br></pre></td></tr></table></figure>

<p>使用局部变量的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TestProc	proc</span><br><span class="line">	local	@locl:dword,@loc2:word</span><br><span class="line">	local	@loc3:byte</span><br><span class="line">	mov eax,@loc1</span><br><span class="line">	mov ax,@loc2</span><br><span class="line">	mov al,@loc3</span><br><span class="line">	</span><br><span class="line">TestProc	endp</span><br></pre></td></tr></table></figure>





<p>我们可以查看一下它的反汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00401000 &gt; $  	55            push ebp</span><br><span class="line">00401001   .  8BEC          mov ebp,esp</span><br><span class="line">00401003   .  83C4 F8       add esp,-0x8</span><br><span class="line">00401006   .  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]           ;  kernel32.BaseThreadInitThunk</span><br><span class="line">00401009   .  66:8B45 FA    mov ax,word ptr ss:[ebp-0x6]</span><br><span class="line">0040100D   .  8A45 F9       mov al,byte ptr ss:[ebp-0x7]</span><br><span class="line">00401010	.	C9				leave</span><br><span class="line">00401011	.	C3				ret</span><br></pre></td></tr></table></figure>

<p>可以看到，反汇编后的指令比源程序多了前后两段指令，分别是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401000 &gt; $  	55            push ebp</span><br><span class="line">00401001   .  8BEC          mov ebp,esp</span><br><span class="line">00401003   .  83C4 F8       add esp,-0x8</span><br><span class="line">...</span><br><span class="line">00401010	.	C9				leave</span><br></pre></td></tr></table></figure>



<p>这些就是局部变量所必须的指令，分别用于局部变量的准备和收尾，执行了call指令后，CPU把反汇的地址压入栈，再转移到子程序执行，esp在程序执行过程中随时用到，不可以使用esp做指针来存取局部变量。于是在初始化之前，先使用push ebp指令把原来的ebp保存起来，然后把esp放入ebp中，供存取变量做指针用，在后面就是在堆中分配空间，堆的生长空间是向下的。所以需要增加一个负值。</p>
<p><strong>在程序结束的时候，必须把正确的esp设置回去，否则ret指令会从堆中读取到错误的地址返回。</strong></p>
<h5 id="局部变量初始化"><a href="#局部变量初始化" class="headerlink" title="局部变量初始化"></a>局部变量初始化</h5><p>局部变量的起始值是随机的，是其他子程序执行后堆栈里留下的垃圾数据，所以使用局部变量的值一定要初始化，特别是定义为结构体后当参数传递给API函数的时候。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>数据结构是由多个字段组成的数据”样板”，相当于自定义的数据类型，数据结构中每一个字段可以是字节、字、双字、字符串或其他可能的数据类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASS	struct</span><br><span class="line">style	DWORD	?</span><br><span class="line">lpfnWndProc	DWORD ?</span><br><span class="line">cbClsExtra	DWORD	?</span><br><span class="line">cbWndExtra	DWORD	?</span><br><span class="line">hInstance	DWORD	?</span><br><span class="line">hIcon	DWORD	?</span><br><span class="line">hCursor	DWORD	?</span><br><span class="line">hbrBackground	DWORD	?</span><br><span class="line">lpszMenuName	DWORD	?</span><br><span class="line">lpszClassName	DWORD	?</span><br><span class="line">WNDCLASS	ends</span><br></pre></td></tr></table></figure>



<p>需要使用定义的结构体的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	.data?</span><br><span class="line">stWndClass	WNDCLASS	&lt;&gt;	;使用未定义方法</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	.data</span><br><span class="line">stWndClass	WNDCLASS	&lt;1,1,1,1,1,1,1,1,1,1&gt;	;将结构体中每个字段都初始化为1</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>





<p>在汇编中，数据结构的引用方法有很多种，如果需要使用某个字段的时候，最直接的办法就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,stWndClass.lpfnWndProc	;把lpfnWndProc字段的值存入eax中</span><br></pre></td></tr></table></figure>

<p>但是在操作系统中，内存地址会代替这个名称，比如stWndClass在内存中的地址是00403000h，这句指令就会被编译称为mov eax,[00403004h]，因为lpfnWndProc是stWndClass中第二个字段，第一个字段为dword，已经占用了4字节空间。</p>
<p>在实际使用中， 常常有使用指针存取数据结构的情况，如果使用esi寄存器做指针寻址，可以使用下列语句完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov esi,offset stWndClass</span><br><span class="line">assume	esi:ptr WNDCLASS</span><br><span class="line">mov eax,[esi].lpfnWndProc</span><br><span class="line">....</span><br><span class="line">assume	esi:nothing</span><br></pre></td></tr></table></figure>

<p><strong>在不再使用esi寄存器做指针的时候要用assume esi:nothing取消定义</strong></p>
<h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><h5 id="以不同的类型访问数据"><a href="#以不同的类型访问数据" class="headerlink" title="以不同的类型访问数据"></a>以不同的类型访问数据</h5><p>在MASM中以不同的类型访问不同的数据不会对变量造成影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">szBuffer	db	1024	dup	(?)</span><br></pre></td></tr></table></figure>



<p>然后从其他地方获取了数据，但数据格式是以字为组织的，要处理数据，最有效的方法就是两个字节两个字节的处理。<strong>所以在MASM要用指定类型之外的长度访问变量，必须显式的指出要访问的长度</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型	ptr	变量名</span><br></pre></td></tr></table></figure>

<p><strong>变量名可以是byte、word、dword、fword、qword、real8个real0</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,word	ptr	szBuffer</span><br><span class="line">mov	eax,dword ptr szBuffer</span><br></pre></td></tr></table></figure>

<p><strong>指定类型的参数访问并不会检测长度是否溢出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">		.data</span><br><span class="line">bTest1	db	12h</span><br><span class="line">wTest2	dw	1234h</span><br><span class="line">dwTest3	dd	12345678h</span><br><span class="line">		....</span><br><span class="line">		.code</span><br><span class="line">mov al,bTest1</span><br><span class="line">mov ax,word	ptr	bTest1</span><br><span class="line">mov eax,dword ptr bTest1</span><br></pre></td></tr></table></figure>



<p>我们查看一下反汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401000 &gt; $  A0 00204000   mov al,byte ptr ds:[0x402000]</span><br><span class="line">00401005   .  66:A1 0020400&gt;mov ax,word ptr ds:[0x402000]</span><br><span class="line">0040100B   .  A1 00204000   mov eax,dword ptr ds:[0x402000]</span><br></pre></td></tr></table></figure>







<p>如果需要把一个字节扩展称为一个字或一个双字再存放，可以使用80386的扩展指令来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movzx	ax,bTest1</span><br><span class="line">movzx	eax,bTest1</span><br><span class="line">movzx	eax,c1</span><br><span class="line">movzx	eax,ax</span><br></pre></td></tr></table></figure>



<p><strong>用movzx指令进行数据长度扩展是32位汇编经常使用的，该指令总是将扩展数据位用0替代。使用另一条指令movsx可以完成带符号位的扩展，当被扩展数据的做高位为0时，效果和movzx相同；当最高位为1时，则扩展部分的数据位全部用1填充。</strong></p>
<h5 id="变量的尺寸和数量"><a href="#变量的尺寸和数量" class="headerlink" title="变量的尺寸和数量"></a>变量的尺寸和数量</h5><p>在源程序中用到变量的尺寸和数量的时候，可以使用sizeof和lengthof伪指令来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof	变量名、数据类型或数据结构名</span><br><span class="line">lengthof	变量名、数据类型或数据结构名</span><br></pre></td></tr></table></figure>



<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stWndClass	WNDCLASS	&lt;&gt;</span><br><span class="line">SzHello		db	&#39;Hello,World!&#39;,	0</span><br><span class="line">dwTest		dd	1,2,3,4</span><br><span class="line">		.code</span><br><span class="line">		mov eax,sizeof stWndClass</span><br><span class="line">		mov ebx,sizeof	WNDCLASS</span><br><span class="line">		mov ecx,sizeof	szHello</span><br><span class="line">		mov edx,sizeof	dword</span><br><span class="line">		mov esi,sizeof	dwTest</span><br></pre></td></tr></table></figure>





<p>我们查看一下反汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00401000 &gt; $  B8 28000000   mov eax,0x28</span><br><span class="line">00401005   .  BB 28000000   mov ebx,0x28</span><br><span class="line">0040100A   ?  B9 0D000000   mov ecx,0xD</span><br><span class="line">0040100F   ?  BA 04000000   mov edx,0x4</span><br><span class="line">00401014   .  BE 10000000   mov esi,0x10</span><br></pre></td></tr></table></figure>







<p><strong>sizeof和lengthor的数值是编译时候产生的，由编译器直接替换到指令中去。</strong></p>
<h5 id="获取变量地址"><a href="#获取变量地址" class="headerlink" title="获取变量地址"></a>获取变量地址</h5><p>获取变量地址的操作对于全局变量和局部变量是不同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov	寄存器,offset	变量名</span><br></pre></td></tr></table></figure>

<p><strong>offset是取变量地址的伪操作符，它仅仅把变量的地址代入到指令中，这个操作是在编译时而不是运行时完成的。</strong></p>
<p>对于局部变量，它是用ebp来做指针操作的，假设ebp的值是401000h，那么局部变量1的地址是ebp-4即400FCh，由于ebp的值是随着程序的执行环境不同而不同的，所以局部变量的地址值在编译的时候也是不确定的，不可能使用offset伪操作符来获取它的地址。</p>
<p>所以80386处理器中有一条指令来取指针的地址，就是lea指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea	eax,[ebp-4]</span><br></pre></td></tr></table></figure>



<p><strong>该指令可以在运行时按照ebp的值实际计算出地址放到eax中</strong></p>
<p>如果在invoke的参数中需要使用局部变量的地址，那么可以使用addr来获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr	局部变量名或全局变量名</span><br></pre></td></tr></table></figure>



<p><strong>当addr后跟全局变量名的时候，编译器自动按照offset的用法来使用；当addr后面跟着局部变量名的时候，编译器会自动用lea指令先把地址取到eax中，然后用eax来代替局部变量使用</strong></p>
<h3 id="使用子程序"><a href="#使用子程序" class="headerlink" title="使用子程序"></a>使用子程序</h3><p>当程序中需要重复调用一段代码的时候，可以将它实现为一个子程序，在主程序中用call指令来调用它，这样可以不用写重复代码，仅仅使用call指令就可以完成多次同样的工作。</p>
<h4 id="子程序的定义"><a href="#子程序的定义" class="headerlink" title="子程序的定义"></a>子程序的定义</h4><p>子程序的定义方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">子程序名	proc	[距离][语言类型][可视区域][USES寄存器列表][,参数:类型]...[VARARG]</span><br><span class="line">local	局部变量列表</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line">	指令</span><br><span class="line">	</span><br><span class="line">子程序名	endp</span><br></pre></td></tr></table></figure>

<p>proc和endp伪指令定义了子程序开始和结束的位置，proc后面跟的参数是子程序的属性和输入参数，子程序的属性有:</p>
<ul>
<li>距离：可以是NEAR，FAR，NEAR16，NEAR32，FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以对距离的定义忽略。</li>
<li>语言类型：表示参数的使用方式和堆栈平衡的方式，可以是stdcall，c，syscall，basic，fortran和pascal，如果虎烈，则使用程序头部.model的值</li>
<li>可视区域：可以是PRIVATE，PUBLIC和EXPORT</li>
<li>USES寄存器列表：由编译器在子程序指令开始前安排push这些寄存器的指令，并在ret前自动安排pop指令，用于保存执行环境。</li>
<li>参数和类型：参数指参数的名称，在定义参数名的时候不能跟全局变量和子程序的局部变量崇明。对于类型，Win32中的参数类型只有32位的dword类型。</li>
</ul>
<p>完成定义之后，可以用invoke来调用子程序，当invoke伪指令位于被调用的子程序代码之前的时候，编译器处理到invoke语句的时候还没有扫描到子程序的定义信息。所以避免出现这种错误，必须在程序的头部用proto伪操作定义程序的信息。</p>
<h4 id="参数传递和堆栈平衡"><a href="#参数传递和堆栈平衡" class="headerlink" title="参数传递和堆栈平衡"></a>参数传递和堆栈平衡</h4><p>在调用子程序时，参数的传递是通过堆栈进行的，也就是说：调用者把要传递给子程序的参数压入堆栈，子程序在堆栈中取出相应的值再使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SubRouting(Var1,Var2,Var3)</span><br></pre></td></tr></table></figure>

<p>反汇编后的代码可能是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push Var3</span><br><span class="line">push Var2</span><br><span class="line">push Var1</span><br><span class="line">add esp,0xb		;b代表12</span><br></pre></td></tr></table></figure>



<p>调用约定如下：</p>
<p><img src="/2020/04/02/Windows-Assembly-3/5.png"></p>
<p>写一个Demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Sub1	proc	C	_Var1,Var2</span><br><span class="line">		mov eax,_Var1</span><br><span class="line">		mov ebx,_Var2</span><br><span class="line">		ret</span><br><span class="line">Sub1	endp</span><br><span class="line"></span><br><span class="line">Sub2	proc	PASCAL	_Var1,Var2</span><br><span class="line">		mov eax,_Var1</span><br><span class="line">		mov ebx,_Var2</span><br><span class="line">		ret</span><br><span class="line">Sub2	endp</span><br><span class="line"></span><br><span class="line">Sub3	proc	_Var1,Var2</span><br><span class="line">		mov eax,_Var1</span><br><span class="line">		mov ebx,_Var2</span><br><span class="line">		ret</span><br><span class="line">Sub3	endp</span><br><span class="line"></span><br><span class="line">	invoke Sub1,1,2</span><br><span class="line">	invoke Sub2,1,2</span><br><span class="line">	invoke Sub3,1,2</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我们查看一下反汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">;这里是Sub1-C类型</span><br><span class="line">.text:00401000 sub_401000      proc near               ; CODE XREF: .text:00401029↓p</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000 arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 mov     eax, [ebp+arg_0]</span><br><span class="line">.text:00401006                 mov     ebx, [ebp+arg_4]</span><br><span class="line">.text:00401009                 leave</span><br><span class="line">.text:0040100A                 retn</span><br><span class="line">.text:0040100A sub_401000      endp</span><br><span class="line"></span><br><span class="line">;这里是Sub1-PASCAL类型</span><br><span class="line">.text:0040100B sub_40100B      proc near               ; CODE XREF: .text:00401035↓p</span><br><span class="line">.text:0040100B</span><br><span class="line">.text:0040100B arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:0040100B arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:0040100B</span><br><span class="line">.text:0040100B                 push    ebp</span><br><span class="line">.text:0040100C                 mov     ebp, esp</span><br><span class="line">.text:0040100E                 mov     eax, [ebp+arg_4]</span><br><span class="line">.text:00401011                 mov     ebx, [ebp+arg_0]</span><br><span class="line">.text:00401014                 leave</span><br><span class="line">.text:00401015                 retn    8</span><br><span class="line">.text:00401015 sub_40100B      endp</span><br><span class="line"></span><br><span class="line">;这里是Sub1-StaCall类型</span><br><span class="line">.text:00401018 sub_401018      proc near               ; CODE XREF: .text:0040103E↓p</span><br><span class="line">.text:00401018</span><br><span class="line">.text:00401018 arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:00401018 arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401018</span><br><span class="line">.text:00401018                 push    ebp</span><br><span class="line">.text:00401019                 mov     ebp, esp</span><br><span class="line">.text:0040101B                 mov     eax, [ebp+arg_0]</span><br><span class="line">.text:0040101E                 mov     ebx, [ebp+arg_4]</span><br><span class="line">.text:00401021                 leave</span><br><span class="line">.text:00401022                 retn    8</span><br><span class="line">.text:00401022 sub_401018      endp</span><br><span class="line"></span><br><span class="line">.text:00401025 start:</span><br><span class="line">;C类型</span><br><span class="line">.text:00401025                 push    2</span><br><span class="line">.text:00401027                 push    1</span><br><span class="line">.text:00401029                 call    sub_401000</span><br><span class="line">.text:0040102E                 add     esp, 8</span><br><span class="line">;PASCAL类型</span><br><span class="line">.text:00401031                 push    1</span><br><span class="line">.text:00401033                 push    2</span><br><span class="line">.text:00401035                 call    sub_40100B</span><br><span class="line">;StaCall类型</span><br><span class="line">.text:0040103A                 push    2</span><br><span class="line">.text:0040103C                 push    1</span><br><span class="line">.text:0040103E                 call    sub_401018</span><br></pre></td></tr></table></figure>

<p>C类型和StaCall类型都是先把右边的参数压入栈，而PASCAL类型是先把左边的压入栈。在平衡堆栈上，C类型是在调用者使用call指令后，自行平衡堆栈，而PASCAl和StaCall的调用者则是不需要管理堆栈，堆栈平衡的操作都是由子程序完成。</p>
<p><strong>Win32默认使用StdCall，所以在调用子程序或API后，不需要自行平衡堆栈</strong></p>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><h4 id="条件测试语句"><a href="#条件测试语句" class="headerlink" title="条件测试语句"></a>条件测试语句</h4><p>在高级语言中，所有的分支和循环语句首先都要涉及条件，也就是涉及一个表达式的结果是”TRUE”还是”FALSE”的问题，表达式中往往有用来做比较和计算的操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">寄存器或变量	操作符	操作数</span><br></pre></td></tr></table></figure>

<p>两个以上的表达式可以用逻辑运算符链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(表达式1)逻辑运算符(表达式2)逻辑运算符(表达式3)</span><br></pre></td></tr></table></figure>



<p>标志寄存器的各种标志位来做条件跳转，它们本身相当于一个表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CARRY?        表示Carry位是否置位</span><br><span class="line">OVERFLOW?     表示Overflow位是否置位</span><br><span class="line">PARITY?       表示Parity位是否置位</span><br><span class="line">SIGN?         表示Sign位是否置位</span><br><span class="line">ZERO?         表示Zero位是否置位</span><br></pre></td></tr></table></figure>





<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>分支语句用来根据条件表达式测试的真假执行不同的代码模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.if	条件表达式1</span><br><span class="line">	表达式1为&quot;真&quot;时执行的指令</span><br><span class="line">.elseif	条件表达式2</span><br><span class="line">	表达式2为&quot;真&quot;时执行的指令</span><br><span class="line">.elseif	条件表达式3</span><br><span class="line">	表达式3为&quot;真&quot;时执行的指令</span><br><span class="line">.else</span><br><span class="line">	所有表达式为&quot;假&quot;时执行的指令</span><br><span class="line">.endif</span><br></pre></td></tr></table></figure>

<p><strong>关键字if/elseif/else/endif的前面有个小数点，如果不加小数点，就变成宏汇编中的条件汇编伪操作了，结果差距很大</strong></p>
<p>书上的Demo未通过，因为没有定义dWY和dWY，不误导。</p>
<p>Demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	.386</span><br><span class="line">	.model flat,stdcall</span><br><span class="line">	option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line"></span><br><span class="line">include gdi32.inc</span><br><span class="line">includelib gdi32.lib</span><br><span class="line">		.data</span><br><span class="line">	dWX	dd	?</span><br><span class="line">	dWY	dd	?</span><br><span class="line">		.code</span><br><span class="line">start:</span><br><span class="line">	</span><br><span class="line">	.if eax &amp;&amp; (ebx &gt;&#x3D; dWX) || !(dWY !&#x3D; ecx)</span><br><span class="line">	    mov    esi,01</span><br><span class="line">	.elseif edx</span><br><span class="line">	    mov    esi,02</span><br><span class="line">	.elseif esi &amp; 1</span><br><span class="line">	    mov    esi,03</span><br><span class="line">	.elseif ZERO? &amp;&amp; CARRY?</span><br><span class="line">	    mov    esi,04</span><br><span class="line">	.endif</span><br><span class="line">	</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>得到的汇编指令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	;.if eax</span><br><span class="line">.text:00401000                 or      eax, eax</span><br><span class="line">.text:00401002                 je      short loc_40100C</span><br><span class="line">	;(ebx&gt;&#x3D;dWX)</span><br><span class="line">.text:00401004                 cmp     ebx, dword_402000</span><br><span class="line">.text:0040100A                 jnb     short loc_401014</span><br><span class="line">	;(dWY!&#x3D;ecx)</span><br><span class="line">.text:0040100C                 cmp     dword_402004, ecx</span><br><span class="line">.text:00401012                 jne     short loc_40101B</span><br><span class="line">.text:00401014                 mov     esi, 1</span><br><span class="line">.text:00401019                 jmp     short near ptr word_40103E</span><br><span class="line">	;elseif edx</span><br><span class="line">.text:0040101B                 or      edx, edx</span><br><span class="line">.text:0040101D                 je      short loc_401026</span><br><span class="line">.text:0040101F                 mov     esi, 2</span><br><span class="line">.text:00401024                 jmp     short near ptr word_40103E</span><br><span class="line">	;elseif esi &amp; 1</span><br><span class="line">.text:00401026                 test    esi, 1</span><br><span class="line">.text:0040102C                 jz      short loc_401035</span><br><span class="line">.text:0040102E                 mov     esi, 3</span><br><span class="line">.text:00401033                 jmp     short near ptr word_40103E</span><br><span class="line">	;ZERO?</span><br><span class="line">.text:00401035                 jnz     short near ptr word_40103E</span><br><span class="line">	;CARRY?</span><br><span class="line">.text:00401037                 jnb     short near ptr word_40103E</span><br><span class="line">.text:00401039                 mov     esi, 4</span><br></pre></td></tr></table></figure>







<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>MASM的循环伪指令可以根据条件表达式的真假来控制循环是否继续，也可以在循环体中直接退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.while 条件测试表达式</span><br><span class="line">    指令</span><br><span class="line">    [.break [.if 退出条件]]</span><br><span class="line">    [.continue]</span><br><span class="line">.endw</span><br><span class="line">;或</span><br><span class="line">.repeat</span><br><span class="line">    指令</span><br><span class="line">    [.break [.if 退出条件]]</span><br><span class="line">    [.continue]</span><br><span class="line">    .until    条件测试表达式    (或 .untilcxz [条件测试表达式])</span><br></pre></td></tr></table></figure>



<p>我们写一个Demo:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">	.386</span><br><span class="line">	.model flat,stdcall</span><br><span class="line">	option casemap:none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line"></span><br><span class="line">include gdi32.inc</span><br><span class="line">includelib gdi32.lib</span><br><span class="line"></span><br><span class="line">	.code</span><br><span class="line">start:</span><br><span class="line">   .while  eax &gt; 1</span><br><span class="line"></span><br><span class="line">    mov     esi,1</span><br><span class="line"></span><br><span class="line">        .break  .if ebx</span><br><span class="line"></span><br><span class="line">        .continue</span><br><span class="line"></span><br><span class="line">        mov     esi,2</span><br><span class="line"></span><br><span class="line">    .endw</span><br><span class="line"></span><br><span class="line">    .repeat</span><br><span class="line"></span><br><span class="line">        mov     esi,1</span><br><span class="line"></span><br><span class="line">        .break  .if !ebx</span><br><span class="line"></span><br><span class="line">        .continue</span><br><span class="line"></span><br><span class="line">        mov     esi,2</span><br><span class="line"></span><br><span class="line">    .until      eax &gt; 1</span><br><span class="line"></span><br><span class="line">    .repeat</span><br><span class="line"></span><br><span class="line">        mov     esi,1</span><br><span class="line"></span><br><span class="line">        .break</span><br><span class="line"></span><br><span class="line">    .untilcxz</span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>





<p>查看一下反汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;.while第一个循环开始</span><br><span class="line">.text:00401000 start:</span><br><span class="line">.text:00401000                 jmp     short loc_401012</span><br><span class="line">.text:00401002</span><br><span class="line">.text:00401002                 mov     esi, 1</span><br><span class="line">.text:00401007                 or      ebx, ebx</span><br><span class="line">;.break .if ebx</span><br><span class="line">.text:00401009                 jnz     short loc_401017</span><br><span class="line">;.continue</span><br><span class="line">.text:0040100B                 jmp     short loc_401012</span><br><span class="line">.text:0040100D                 mov     esi, 2</span><br><span class="line">;while eax &gt; 1</span><br><span class="line">.text:00401012                 cmp     eax, 1</span><br><span class="line">.text:00401015                 ja      short loc_401002</span><br><span class="line">.text:00401017</span><br><span class="line">;.rapeat第二个循环开始</span><br><span class="line">.text:00401017                 mov     esi, 1</span><br><span class="line">;.break .if !ebx</span><br><span class="line">.text:0040101C                 or      ebx, ebx</span><br><span class="line">.text:0040101E                 jz      short loc_40102C</span><br><span class="line">;.continue</span><br><span class="line">.text:00401020                 jmp     short loc_401027</span><br><span class="line">.text:00401022                 mov     esi, 2</span><br><span class="line">;.until eax &gt; 1</span><br><span class="line">.text:00401027                 cmp     eax, 1</span><br><span class="line">.text:0040102A                 jbe     short loc_401017</span><br><span class="line">;.repeat第三个循环开始</span><br><span class="line">.text:0040102C</span><br><span class="line">;.break</span><br><span class="line">.text:0040102C                 mov     esi, 1</span><br><span class="line">;.untilcxz</span><br><span class="line">.text:00401031                 jmp     short near ptr byte_401035</span><br><span class="line">.text:00401033   .^\E2 F7         loopd short while.0040102C	;注意这里是loop指令！</span><br></pre></td></tr></table></figure>

<p><strong>.break翻译成一个跳转指令跳转到循环结束的地方</strong></p>
<p><strong>.continue是一个无条件跳转指令跳到循环开始的地方</strong></p>
<p><strong>.while是先比较条件再执行循环体</strong></p>
<p><strong>.repeat是先执行循环体再比较条件</strong></p>
<p><strong>loop指令可以自动递减ecx的值来控制循环，不适用loop将会在循环体内多设置一条递减指令</strong></p>
<h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><h4 id="匈牙利"><a href="#匈牙利" class="headerlink" title="匈牙利"></a>匈牙利</h4><p><img src="/2020/04/02/Windows-Assembly-3/6.png"></p>
<p>补充：</p>
<p><strong>对局部变量的地址引用要用lea指令或者addr伪操作，全局变量要用offset</strong></p>
<p><strong>在参数的前面加下划线，在局部变量前加@，在内部程序的名称前面加下划线</strong></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Windows-Assembly-3</p><p><a href="http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/">http://systemk1t.github.io/2020/04/02/Windows-Assembly-3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>sYstemk1t</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-04-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-04-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Assembly/">Assembly</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipayimg.jpg" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatimg.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/04/07/Windows-Assembly-4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Windows-Assembly-4</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/01/01/%E7%9C%8B%E9%9B%AACrackMe002/"><span class="level-item">看雪CrackMe002</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="sYstemk1t"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">sYstemk1t</p><p class="is-size-6 is-block">翩若惊鸿，婉若游龙</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShenZhen, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">128</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/sYstemk1t" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/sYstemk1t"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://r00tk1ts.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">r00tk1t</span></span><span class="level-right"><span class="level-item tag">r00tk1ts.github.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Bugku/"><span class="level-start"><span class="level-item">Bugku</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/C-%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">C++黑客编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CrackMe/"><span class="level-start"><span class="level-item">CrackMe</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/C%E4%B8%8E%E6%8C%87%E9%92%88/"><span class="level-start"><span class="level-item">C与指针</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C程序设计语言</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"><span class="level-start"><span class="level-item">Windows-API开发详解</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">Windows-PE权威指南</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows32%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">Windows32汇编语言设计</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><span class="level-start"><span class="level-item">Windows内核原理与实现</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">Windows核心编程</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">Windows程序设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"><span class="level-start"><span class="level-item">加密与解密</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8F%8D%E6%B1%87%E7%BC%96/"><span class="level-start"><span class="level-item">反汇编</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">汇编语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%9F%BA%E4%BA%8Ex86%E5%A4%84%E7%90%86%E5%99%A8/"><span class="level-start"><span class="level-item">汇编语言-基于x86处理器</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">网络编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">逆向工程权威指南</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">逆向工程核心原理</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">黑客编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-02T02:23:17.000Z">2020-11-02</time></p><p class="title"><a href="/2020/11/02/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E4%B8%B4%E7%95%8C%E5%8C%BA/">Windows应用程序 - 临界区</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-01T01:28:57.000Z">2020-11-01</time></p><p class="title"><a href="/2020/11/01/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/">Windows应用程序 - 线程创建</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-30T03:19:41.000Z">2020-10-30</time></p><p class="title"><a href="/2020/10/30/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E5%8F%A5%E6%9F%84%E8%A1%A8/">Windows应用程序 - 句柄表</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-28T01:09:17.000Z">2020-10-28</time></p><p class="title"><a href="/2020/10/28/PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-PE%E6%96%87%E4%BB%B6%E5%A4%B4/">PE权威指南 - PE文件头</a></p><p class="categories"><a href="/categories/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">Windows-PE权威指南</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-21T02:34:23.000Z">2020-10-21</time></p><p class="title"><a href="/2020/10/21/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/">Windows应用程序 - 进程创建</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">35</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CrackMe/"><span class="tag">CrackMe</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HOOK/"><span class="tag">HOOK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hacker/"><span class="tag">Hacker</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reverse/"><span class="tag">Reverse</span><span class="tag">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scoket/"><span class="tag">Scoket</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-Kernel/"><span class="tag">Windows-Kernel</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="tag">Windows-PE权威指南</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><span class="tag">Windows核心编程</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">Windows程序设计</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c</span><span class="tag">8</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/head.jpg" alt="sYstemk1t&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2020 sYstemk1t</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>