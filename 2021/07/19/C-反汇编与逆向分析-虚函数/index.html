<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"systemk1t.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="对象的多态性需要通过虚表和虚表指针来完成，虚表指针被定义在对象首地址的前四字节，因此虚函数必须作为成员函数使用。由于非成员函数没有this指针，也就无法获得虚表指针，进而无法获得虚表；">
<meta property="og:type" content="article">
<meta property="og:title" content="C++反汇编与逆向分析 - 虚函数">
<meta property="og:url" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="sYstemk1t&#39;s blog">
<meta property="og:description" content="对象的多态性需要通过虚表和虚表指针来完成，虚表指针被定义在对象首地址的前四字节，因此虚函数必须作为成员函数使用。由于非成员函数没有this指针，也就无法获得虚表指针，进而无法获得虚表；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/0.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/1.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/2.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/3.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/4.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/5.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/6.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/7.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/8.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/9.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/10.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/11.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/12.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/13.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/14.png">
<meta property="og:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/15.png">
<meta property="article:published_time" content="2021-07-19T05:34:38.000Z">
<meta property="article:modified_time" content="2021-07-19T12:04:16.833Z">
<meta property="article:author" content="sYstemk1t">
<meta property="article:tag" content="反汇编与逆向分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/0.png">

<link rel="canonical" href="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++反汇编与逆向分析 - 虚函数 | sYstemk1t's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">sYstemk1t's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="sYstemk1t">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sYstemk1t's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++反汇编与逆向分析 - 虚函数
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-19 13:34:38 / 修改时间：20:04:16" itemprop="dateCreated datePublished" datetime="2021-07-19T13:34:38+08:00">2021-07-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">逆向分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>对象的多态性需要通过虚表和虚表指针来完成，虚表指针被定义在对象首地址的前四字节，因此虚函数必须作为成员函数使用。由于非成员函数没有this指针，也就无法获得虚表指针，进而无法获得虚表；</p>
<a id="more"></a>

<p>运行环境：</p>
<ul>
<li>操作系统： Windows 7家庭版</li>
<li>编译器：VC6 VS2013</li>
</ul>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><h2 id="虚函数机制"><a href="#虚函数机制" class="headerlink" title="虚函数机制"></a>虚函数机制</h2><p>在C++中，使用关键字virtual声明函数为虚函数。当类中定义有虚函数时，编译器会将该类中所有虚函数的首地址保存在一张地址表中，这正表称为虚函数地址表，简称虚表；同时，编译器还会再类中添加一个隐藏数据成员，称为虚表指针。该指针中保存着虚表的首地址；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class CVirtual</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CVirtual();</span><br><span class="line">	~CVirtual();</span><br><span class="line">	virtual void Show1();</span><br><span class="line">	virtual void Show2();</span><br><span class="line">private:</span><br><span class="line">	int m_Numebr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVirtual::CVirtual()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtual::~CVirtual()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CVirtual::Show1()</span><br><span class="line">&#123;	</span><br><span class="line">	printf(&quot;This is virtual Func1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CVirtual::Show2()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;This is virtual Func2\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	CVirtual cv;</span><br><span class="line">	cv.Show1();</span><br><span class="line">	cv.Show2();</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/0.png"></p>
<p>ECX寄存器传递对象的首地址，直接使用ECX寄存器；而01041466处有一个赋值，在构造函数内部，这个地址是指向一个数组：</p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/1.png"></p>
<p><strong>这些数组中的内容就是虚函数的指针</strong></p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/2.png"></p>
<p>如果没有虚指针的存在，那么CVirtual大小就是4字节，有了虚指针的存在就是8字节；</p>
<p>我们可以发现，我们并没有实现构造函数，但是编译器自作主张帮我们插入了代码，实现了对虚表的初始化。<strong>当我们不提供任何构造篇函数的话，编译器就会提供一个默认的构造函数对虚表进行初始化</strong></p>
<p><strong>当函数被调用时，会间接访问虚表，得到对应的虚函数的地址，并调用执行。这种通过虚表间接寻址的情况只有在使用对象的指针或引用这个虚函数的时候才出现。当直接使用对象调用自身的虚函数时，没有必要查表访问。因为已经明确调用自身的成员函数了，没有构成多态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class CVirtual</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CVirtual();</span><br><span class="line">	~CVirtual();</span><br><span class="line">	CVirtual(int n);</span><br><span class="line">	virtual void Show1();</span><br><span class="line">	virtual void Show2();</span><br><span class="line">private:</span><br><span class="line">	int m_Numebr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVirtual::CVirtual()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtual::~CVirtual()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtual::CVirtual(int n)</span><br><span class="line">&#123;</span><br><span class="line">	m_Numebr &#x3D; n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CVirtual::Show1()</span><br><span class="line">&#123;	</span><br><span class="line">	printf(&quot;This is virtual Func1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CVirtual::Show2()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;This is virtual Func2\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CVirtualS : public CVirtual</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CVirtualS();</span><br><span class="line">	~CVirtualS();</span><br><span class="line">	CVirtualS(int n) : CVirtual(n)</span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVirtualS::CVirtualS()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtualS::~CVirtualS()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	CVirtual cv;</span><br><span class="line">	cv.Show1();</span><br><span class="line">	CVirtual *pcv &#x3D; new CVirtualS();</span><br><span class="line">	pcv-&gt;Show1();</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>直接通过对象调用虚表的时候，就是直接用对象的地址作为隐式参数传递给这个虚函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	CVirtual cv;</span><br><span class="line">00DF417D  lea         ecx,[cv]  </span><br><span class="line">00DF4180  call        CVirtual::CVirtual (0DF11EAh)  </span><br><span class="line">00DF4185  mov         dword ptr [ebp-4],0  </span><br><span class="line">	cv.Show1();</span><br><span class="line">00DF418C  lea         ecx,[cv]  </span><br><span class="line">00DF418F  call        CVirtual::Show1 (0DF11C7h)  </span><br></pre></td></tr></table></figure>

<p>这个时候虚函数和普通成员函数没有区别，之所以要隐含传递都西昂的地址，是为了能够准确的使用对象中所包含的数据成员；</p>
<p>但是如果构成了多态，那么调用方式不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">	CVirtual *pcv &#x3D; new CVirtualS();</span><br><span class="line">00DF4194  push        8  						;对象大小</span><br><span class="line">00DF4196  call        operator new (0DF122Bh)  	;new</span><br><span class="line">00DF419B  add         esp,4  					</span><br><span class="line">00DF419E  mov         dword ptr [ebp-0FCh],eax  	;new申请地址返回到eax中，eax保存对象首地址</span><br><span class="line">00DF41A4  mov         byte ptr [ebp-4],1  			;1是确定它是一个对象</span><br><span class="line">00DF41A8  cmp         dword ptr [ebp-0FCh],0  		;确定是否申请成功地址</span><br><span class="line">00DF41AF  je          wmain+84h (0DF41C4h)  		;申请失败则跳转</span><br><span class="line">00DF41B1  mov         ecx,dword ptr [ebp-0FCh]  	;对象首地址存入ecx中</span><br><span class="line">00DF41B7  call        CVirtualS::CVirtualS (0DF1221h)  	;构造函数，返回值存入eax，这个返回值无法被我们使用</span><br><span class="line">00DF41BC  mov         dword ptr [ebp-110h],eax  	;CVirtualS首地址</span><br><span class="line">00DF41C2  jmp         wmain+8Eh (0DF41CEh)  		;</span><br><span class="line">00DF41C4  mov         dword ptr [ebp-110h],0  </span><br><span class="line">00DF41CE  mov         eax,dword ptr [ebp-110h]  	;</span><br><span class="line">00DF41D4  mov         dword ptr [ebp-108h],eax  </span><br><span class="line">00DF41DA  mov         byte ptr [ebp-4],0  </span><br><span class="line">00DF41DE  mov         ecx,dword ptr [ebp-108h]  </span><br><span class="line">00DF41E4  mov         dword ptr [pcv],ecx  			;CVirtualS首地址传递给指针pcv</span><br><span class="line">	pcv-&gt;Show1();</span><br><span class="line">00DF41E7  mov         eax,dword ptr [pcv]  			;间接调用需用</span><br><span class="line">00DF41EA  mov         edx,dword ptr [eax]  </span><br><span class="line">00DF41EC  mov         esi,esp  </span><br><span class="line">00DF41EE  mov         ecx,dword ptr [pcv]  </span><br><span class="line">00DF41F1  mov         eax,dword ptr [edx]  </span><br><span class="line">00DF41F3  call        eax  </span><br></pre></td></tr></table></figure>

<p>间接调用的两种方式：</p>
<ul>
<li>call reg</li>
<li>call [xxx]</li>
</ul>
<p>实际上我们并不知道pcv指针指向的具体类型说什么，所以要在需表中找到真正对象的虚函数；</p>
<p><strong>虚表指针的初始化，是判断一个函数是构造函数的充分条件</strong></p>
<p>为什么构造函数需要使用函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Test.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">class CVirtual</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CVirtual();</span><br><span class="line">	~CVirtual();</span><br><span class="line">	CVirtual(int n);</span><br><span class="line">	virtual void Show1();</span><br><span class="line">	virtual void Show2();</span><br><span class="line">private:</span><br><span class="line">	int m_Numebr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVirtual::CVirtual()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtual::~CVirtual()</span><br><span class="line">&#123;</span><br><span class="line">	Show1();</span><br><span class="line">	Show2();</span><br><span class="line">	printf(&quot;Destructor\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtual::CVirtual(int n)</span><br><span class="line">&#123;</span><br><span class="line">	m_Numebr &#x3D; n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CVirtual::Show1()</span><br><span class="line">&#123;	</span><br><span class="line">	printf(&quot;This is virtual Func1\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CVirtual::Show2()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;This is virtual Func2\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CVirtualS : public CVirtual</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CVirtualS();</span><br><span class="line">	~CVirtualS();</span><br><span class="line">	CVirtualS(int n) : CVirtual(n)</span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVirtualS::CVirtualS()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtualS::~CVirtualS()</span><br><span class="line">&#123;</span><br><span class="line">	Show1();</span><br><span class="line">	Show2();</span><br><span class="line">	printf(&quot;Destructor\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	CVirtual cv;</span><br><span class="line">	cv.Show1();</span><br><span class="line">	*&#x2F;</span><br><span class="line">	CVirtual *pcv &#x3D; new CVirtualS();</span><br><span class="line">	delete pcv;</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们执行delete 指针以后，会出现以下流程：</p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/3.png"></p>
<p>如果当我们把析构函数做虚函数时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtual</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CVirtual();</span><br><span class="line">	<span class="keyword">virtual</span> ~CVirtual();</span><br><span class="line">	CVirtual(<span class="keyword">int</span> n);</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_Numebr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVirtual::CVirtual()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtual::~CVirtual()</span><br><span class="line">&#123;</span><br><span class="line">	Show1();</span><br><span class="line">	Show2();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Destructor\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtual::CVirtual(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	m_Numebr = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CVirtual::Show1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is virtual Func1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CVirtual::Show2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is virtual Func2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CVirtualS</span> :</span> <span class="keyword">public</span> CVirtual</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	CVirtualS();</span><br><span class="line">	<span class="keyword">virtual</span> ~CVirtualS();</span><br><span class="line">	CVirtualS(<span class="keyword">int</span> n) : CVirtual(n)</span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVirtualS::CVirtualS()</span><br><span class="line">&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVirtualS::~CVirtualS()</span><br><span class="line">&#123;</span><br><span class="line">	Show1();</span><br><span class="line">	Show2();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Destructor\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	CVirtual cv;</span></span><br><span class="line"><span class="comment">	cv.Show1();</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	CVirtual *pcv = <span class="keyword">new</span> CVirtualS();</span><br><span class="line">	<span class="keyword">delete</span> pcv;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/4.png"></p>
<p>可以发现，如果不把析构函数作为虚函数时，只调用了父类的虚函数；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	delete pcv;</span><br><span class="line">01134276  mov         eax,dword ptr [pcv]  </span><br><span class="line">01134279  mov         dword ptr [ebp-0E0h],eax  </span><br><span class="line">0113427F  mov         ecx,dword ptr [ebp-0E0h]  </span><br><span class="line">01134285  mov         dword ptr [ebp-0ECh],ecx  </span><br><span class="line">0113428B  cmp         dword ptr [ebp-0ECh],0  </span><br><span class="line">01134292  je          wmain+0D9h (011342B9h)  </span><br><span class="line">01134294  mov         esi,esp  </span><br><span class="line">01134296  push        1  </span><br><span class="line">01134298  mov         edx,dword ptr [ebp-0ECh]  </span><br><span class="line">0113429E  mov         eax,dword ptr [edx]  </span><br><span class="line">011342A0  mov         ecx,dword ptr [ebp-0ECh]  </span><br><span class="line">011342A6  mov         edx,dword ptr [eax]  </span><br><span class="line">011342A8  call        edx  </span><br></pre></td></tr></table></figure>

<p>delete删除指针的时候调用的子类的虚函数，则子类的虚函数外部又调用了弗雷的虚函数。而调用父类的虚函数之前，ecx指针中仍保留的是子类对象的首地址;</p>
<p>子类的析构函数调用自身的虚成员函数：</p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/5.png"></p>
<p>子类对象调用父类对象的析构函数：</p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/6.png"></p>
<p>在地址00BE1566处并没有间接赋值，而是直接调用Show1和Show2；</p>
<p><strong>无论是子类对象还说父类对象的析构函数中都会有把当前的虚表的首地址赋值到虚表指针当中去，这是为了防止调用虚函数时取到非自身的虚表</strong></p>
<p>我们先查看调用A的构造函数：</p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/7.png"></p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/8.png"></p>
<p>我们查看this指针的地址，因为它会填充到这个地址中；</p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/9.png"></p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/10.png"></p>
<p>继续调用虚函数：</p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/11.png"></p>
<p>调用完A的构造函数，继续往下执行构造函数中其他的部分，为了能够继续调用B的func2，必须还原虚表；</p>
<h2 id="虚函数的识别"><a href="#虚函数的识别" class="headerlink" title="虚函数的识别"></a>虚函数的识别</h2><p> 1）特征：</p>
<p>1、类中隐式定义了一个数据成员；</p>
<p>2、该数据成员在首地址处；</p>
<p>3、构造函数会将此数据成员初始化为某个数组的首地址；</p>
<p>4、这个地址属于数据区，是相对固定的地址；</p>
<p>5、数组内每个元素都是函数的指针；</p>
<p>6、数组中的这些函数被调用时，第一个参数必然是this指针；</p>
<p>7、这些函数内部有可能对this指针进行相对间接的访问。</p>
<p>2）验证父类和子类的虚表指针：</p>
<p>初始化父类后，父类的两个虚函数地址为：</p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/12.png"></p>
<p>我们发现，A的虚表中和B的虚表中的第一个函数地址是相同的，不同的是第二个函数的地址。<strong>在构造B的时候先构造A，而在构造A的时候要赋值一个虚表指针，是为了防止在A的构造函数中使用使用了虚函数，而无意间调用了B的虚函数</strong>。而实际上，构造完B之后，B中就不存在刚刚A的那个虚表指针了。</p>
<h2 id="构造函数不可以是虚函数"><a href="#构造函数不可以是虚函数" class="headerlink" title="构造函数不可以是虚函数"></a>构造函数不可以是虚函数</h2><ol>
<li><p>虚函数对应一个虚指针，虚指针其实是存储在对象的内存空间的。如果构造函数是虚的，就需要通过 虚指针执行那个虚函数表（编译期间生成属于类）来调用，可是对象还没有实例化，也就是内存空间还没有，就没有虚指针，所以构造函数不能是虚函数。</p>
</li>
<li><p>虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，</p>
</li>
</ol>
<p>因此也就规定构造函数不能是虚函数。</p>
<ol start="3">
<li>讲道理</li>
</ol>
<p>(1)  父类A 派生出子类B</p>
<p>(2)  A *pA = &amp;B</p>
<p>(3)  A 类指针析构，调用的是谁的析构</p>
<p>(4)  如果析构不是虚的，调用A的析构</p>
<p>(5)  实际上要析构B</p>
<p>(6)  有残留</p>
<ol start="4">
<li>如果构造变成虚的</li>
</ol>
<p>(1)  A *pA = <strong>new</strong> B</p>
<p>(2)  构造先构造A，再构造B (3)如果是虚的，B先构造了</p>
<p>没有间接访问，不会虚调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">C++源码</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Show</span><span class="params">(CMyString  str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(str.GetString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span>  <span class="keyword">char</span>*  <span class="title">GetString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="number">0.</span>	申请了虚函数</span><br><span class="line"><span class="number">1.</span>	如果没有使用指针，引用方式，去访问对应的成员函数</span><br><span class="line"><span class="number">2.</span>	使用名称粉碎，call到固定地址</span><br><span class="line">call	@ILT+<span class="number">55</span>(CMyString::GetString)  (<span class="number">0040103</span>c)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>	C++里面管理成员函数通过名称粉碎来做的 OBJ</span><br><span class="line">|成员函数名|所属作用域名|参数列表|调用约定Y  返回值</span><br><span class="line">?SetString@CMyString@@UAEPADPAD@Z??<span class="number">2</span>@YAPAXI@Z</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>	另一种观察名称粉碎的办法</span><br><span class="line">Setting ‐‐&gt; C\C++ ‐‐&gt; listing File ‐‐&gt; ListFile type</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>	什么时候使用名称粉碎的机制？</span><br><span class="line">(<span class="number">1</span>)	点调用的时候,str.GetString()</span><br><span class="line">(<span class="number">2</span>)	编译器获得了对象类型，函数类型，参数列表等</span><br><span class="line"><span class="number">6.</span>	Show函数名称粉碎，参数为对象Show@@YAXVCMyString@@@Z</span><br><span class="line"></span><br><span class="line"><span class="number">6.1</span>	Show函数名称粉碎，参数为对象指针</span><br><span class="line">?Show@@YAXPAVCMyString@@@Z</span><br><span class="line"></span><br><span class="line"><span class="number">6.2</span>	Show函数名称粉碎，参数为对象引用，底层是指针</span><br><span class="line">?Show@@YAXAAVCMyString@@@Z</span><br><span class="line">分析:</span><br><span class="line">YAX 表示调用约定</span><br><span class="line">V 对 象</span><br><span class="line">PAV 对象指针</span><br><span class="line">AAV 对象引用</span><br><span class="line"><span class="number">7.</span> 对于编译器来说是个模糊查找</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h3 id="使用指针或引用访问成员函数"><a href="#使用指针或引用访问成员函数" class="headerlink" title="使用指针或引用访问成员函数"></a>使用指针或引用访问成员函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">. 成员函数是虚函数时，会产生虚调用</span><br><span class="line"></span><br><span class="line">printf(pStr.GetString());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首先拿到对象首地址</span><br><span class="line">mov eax, DWORD PTR _pStr$[ebp]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 取首4字节给EDX</span><br><span class="line">mov edx, DWORD PTR [eax] mov esi, esp</span><br><span class="line">mov ecx, DWORD PTR _pStr$[ebp]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 间接调用虚表内的函数指针</span><br><span class="line">call	DWORD PTR [edx+8]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;‐‐‐‐‐‐VC6 DEBUG‐‐‐‐‐‐‐‐‐‐‐‐‐</span><br><span class="line">&#x2F;&#x2F; 传递this指针</span><br><span class="line">mov	ecx,dword  ptr  [ebp+8]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用函数</span><br><span class="line">call	dword ptr [edx+8]</span><br><span class="line">call [xxx] call reg</span><br><span class="line"></span><br><span class="line">2.	对象的前4字节，就是虚表首地址,函数指针数组首地址</span><br><span class="line">3.	总结步骤</span><br><span class="line">(1)	先访问对象的前4字节</span><br><span class="line">(2)	前4字节，间隔偏移，做个间接访问，call</span><br><span class="line"></span><br><span class="line">4.	是在，全局，只读数据区 0x0042xxxx</span><br><span class="line">5.	虚表(vtptr\_vfptr)里面都是代码段的地址</span><br><span class="line">6.	虚函数肯定是成员函数，没有静态虚函数</span><br><span class="line">7.	虚函数需要this指针 查虚表</span><br><span class="line">8.	虚调用的触发条件</span><br><span class="line">(1)	别调用函数被声明为virtual</span><br><span class="line">(2)	调用时使用对象的指针或引用</span><br><span class="line">(3)	其他情况将会结合名称粉碎机制</span><br><span class="line">(4)	产生直接调用的代码</span><br><span class="line">(5)	直接调用，不产生多态行为和效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="发生函数指针错误"><a href="#发生函数指针错误" class="headerlink" title="发生函数指针错误"></a>发生函数指针错误</h3><p>如果调用函数前，后栈不平衡</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov esi,esp</span><br><span class="line">...</span><br><span class="line">cmp esi,esp</span><br><span class="line">;会出现错误窗口</span><br><span class="line">call __chkesp</span><br></pre></td></tr></table></figure>





<h2 id="虚函数识别"><a href="#虚函数识别" class="headerlink" title="虚函数识别"></a>虚函数识别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.	通过虚表</span><br><span class="line">2.	通过调用 VC6 Release 高级版 没区别</span><br><span class="line">mov ecx，[esp + arg_0] mov eax,[ecx]</span><br><span class="line">call dword ptr [eax+8]</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">1.	首先识别出虚调用来</span><br><span class="line">2.	阅读代码找到this指针位置</span><br><span class="line">3.	找到虚表位置</span><br><span class="line">4.	一网打尽所有虚函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.	写了构造</span><br><span class="line">2.	有虚函数，一定有构造</span><br><span class="line">VC6 debug 有虚函数</span><br><span class="line">CTest t;</span><br><span class="line">lea	ecx,[ebp‐14h]</span><br><span class="line">call	@ILT+80(CTest::CTest)</span><br><span class="line">...</span><br><span class="line">1.	能鉴定 后面offset 是虚表</span><br><span class="line">2.	有填写虚表指针的动作(冲分条件)</span><br><span class="line">3.	是构造函数，一定是有虚函数</span><br><span class="line">mov	eax,dword  ptr  [ebp‐4]</span><br><span class="line">mov	dword  ptr  [eax],offset  CTest::&#96;vftable&#39;  (00425070)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">4.	析构里面也会填写虚表指针</span><br><span class="line">mov	eax,dword  ptr  [ebp‐4]</span><br><span class="line">mov	dword  ptr  [eax],offset  CTest::&#96;vftable&#39;  (00425050)</span><br><span class="line">5.	没有默认析构</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="图解虚函数需要构造原理"><a href="#图解虚函数需要构造原理" class="headerlink" title="图解虚函数需要构造原理"></a>图解虚函数需要构造原理</h2><p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/13.png"></p>
<h2 id="虚函数基本机制"><a href="#虚函数基本机制" class="headerlink" title="虚函数基本机制"></a>虚函数基本机制</h2><p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/14.png"></p>
<p><img src="/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/15.png"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>sYstemk1t
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://systemk1t.github.io/2021/07/19/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E8%99%9A%E5%87%BD%E6%95%B0/" title="C++反汇编与逆向分析 - 虚函数">http://systemk1t.github.io/2021/07/19/C-反汇编与逆向分析-虚函数/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/" rel="tag"># 反汇编与逆向分析</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/18/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84/" rel="prev" title="C++反汇编与逆向分析 - 构造析构">
      <i class="fa fa-chevron-left"></i> C++反汇编与逆向分析 - 构造析构
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/20/C-%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90-%E7%BB%A7%E6%89%BF/" rel="next" title="C++反汇编与逆向分析 - 继承">
      C++反汇编与逆向分析 - 继承 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>





  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.</span> <span class="nav-text">虚函数机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%86%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">虚函数的识别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">构造函数不可以是虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">使用指针或引用访问成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E9%94%99%E8%AF%AF"><span class="nav-number">1.3.2.</span> <span class="nav-text">发生函数指针错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%86%E5%88%AB"><span class="nav-number">1.4.</span> <span class="nav-text">虚函数识别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E8%99%9A%E5%87%BD%E6%95%B0%E9%9C%80%E8%A6%81%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">图解虚函数需要构造原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.</span> <span class="nav-text">虚函数基本机制</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="sYstemk1t"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">sYstemk1t</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sYstemk1t" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sYstemk1t" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:sYstemk1t@126.com" title="E-Mail → mailto:sYstemk1t@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://r00tk1ts.github.io/" title="https:&#x2F;&#x2F;r00tk1ts.github.io&#x2F;" rel="noopener" target="_blank">r00tk1ts</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://drunkmars.top/" title="https:&#x2F;&#x2F;drunkmars.top" rel="noopener" target="_blank">Drunkmars</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sYstemk1t</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">390k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:54</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  















  

  

</body>
</html>
