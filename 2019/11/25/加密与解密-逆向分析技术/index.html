<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>加密与解密-逆向分析技术 | sYstemk1t&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="将可执行程序反汇编，通过分析反汇编代码来理解其代码功能，然后用高级语言重新描述这段代码，逆向分析原始原始软件思路，这个过程就称为逆向工程。">
<meta property="og:type" content="article">
<meta property="og:title" content="加密与解密-逆向分析技术">
<meta property="og:url" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="sYstemk1t&#39;s blog">
<meta property="og:description" content="将可执行程序反汇编，通过分析反汇编代码来理解其代码功能，然后用高级语言重新描述这段代码，逆向分析原始原始软件思路，这个过程就称为逆向工程。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/0.png">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/1.png">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/2.png">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/3.png">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/4.png">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/5.png">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/6.png">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/12.png">
<meta property="og:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/7.png">
<meta property="article:published_time" content="2019-11-25T02:09:34.000Z">
<meta property="article:modified_time" content="2019-12-26T07:35:08.846Z">
<meta property="article:author" content="sYstemk1t">
<meta property="article:tag" content="Hacker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/0.png">
  
    <link rel="alternative" href="/atom.xml" title="sYstemk1t&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 5.2.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hi Mate"></a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/Home">博客首页</a></li>
                        
                            <li><a href="/archives">所有文章</a></li>
                        
                            <li><a href="/tags">标签</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto: sYstemk1t@126.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/sYstemk1t" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="https://www.zhihu.com/people/sYstemk1t" title="zhihu">zhihu</a>
                            
                                <a class="fl QQ" target="_blank" href="https://user.qzone.qq.com/806310294" title="QQ">QQ</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Assembly/" style="font-size: 20px;">Assembly</a> <a href="/tags/C/" style="font-size: 15.71px;">C++</a> <a href="/tags/CTF/" style="font-size: 12.86px;">CTF</a> <a href="/tags/CrackMe/" style="font-size: 14.29px;">CrackMe</a> <a href="/tags/HOOK/" style="font-size: 10px;">HOOK</a> <a href="/tags/Hacker/" style="font-size: 17.14px;">Hacker</a> <a href="/tags/Reverse/" style="font-size: 18.57px;">Reverse</a> <a href="/tags/Scoket/" style="font-size: 12.86px;">Scoket</a> <a href="/tags/Windows-Kernel/" style="font-size: 18.57px;">Windows-Kernel</a> <a href="/tags/Windows-PE/" style="font-size: 12.86px;">Windows-PE</a> <a href="/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="font-size: 11.43px;">Windows程序设计</a> <a href="/tags/c/" style="font-size: 17.14px;">c</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://r00tk1ts.github.io/">r00tk1ts</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">二进制狗一枚，懂点Web安全，一个伪装成程序员混迹在某公司的菜鸡。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/Home">博客首页</a></li>
                
                    <li><a href="/archives">所有文章</a></li>
                
                    <li><a href="/tags">标签</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto: sYstemk1t@126.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/sYstemk1t" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/sYstemk1t" title="zhihu">zhihu</a>
                    
                        <a class="QQ" target="_blank" href="https://user.qzone.qq.com/806310294" title="QQ">QQ</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-加密与解密-逆向分析技术" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" class="article-date">
      <time datetime="2019-11-25T02:09:34.000Z" itemprop="datePublished">2019-11-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      加密与解密-逆向分析技术
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/">加密与解密</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hacker/" rel="tag">Hacker</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>将可执行程序反汇编，通过分析反汇编代码来理解其代码功能，然后用高级语言重新描述这段代码，逆向分析原始原始软件思路，这个过程就称为逆向工程。</p>
<a id="more"></a>

<h2 id="32位软件逆向技术"><a href="#32位软件逆向技术" class="headerlink" title="32位软件逆向技术"></a>32位软件逆向技术</h2><h3 id="启动函数"><a href="#启动函数" class="headerlink" title="启动函数"></a>启动函数</h3><p>在编写Win32的项目中，都必须在源码中实现一个WinMain函数，但Windows不是从WinMain函数开始的。首先被执行的是启动函数的相关代码，这段代码是由编译器生成的。在启动代码初始化进程完成后，才会调用WinMain函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetStartupInfo (&amp;StartupInfo);</span><br><span class="line">Int nMainRetVal = WinMain(GetModuleHandle(<span class="literal">NULL</span>),<span class="literal">NULL</span>,pszCommandLineAnsi,StartupInfo.wShowWindow:SW__SHOWDEFAULT);</span><br></pre></td></tr></table></figure>



<p>进入入口点时，启动函数便用C运行库的exit函数，将返回值(nMainRetVal)传递给它，进行一些必要的处理，最后调用系统函数ExitProcess退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.text:00401180                 push    ebp</span><br><span class="line">.text:00401181                 mov     ebp, esp</span><br><span class="line">.text:00401183                 push    0FFFFFFFFh</span><br><span class="line">.text:00401185                 push    offset stru_4040D0</span><br><span class="line">.text:0040118A                 push    offset __except_handler3</span><br><span class="line">.text:0040118F                 mov     eax, large fs:0</span><br><span class="line">.text:00401195                 push    eax</span><br><span class="line">.text:00401196                 mov     large fs:0, esp</span><br><span class="line">.text:0040119D                 sub     esp, 58h</span><br><span class="line">.text:004011A0                 push    ebx</span><br><span class="line">.text:004011A1                 push    esi</span><br><span class="line">.text:004011A2                 push    edi</span><br><span class="line">.text:004011A3                 mov     [ebp+ms_exc.old_esp], esp</span><br><span class="line">.text:004011A6                 call    ds:GetVersion	;确定Windows版本</span><br><span class="line">......</span><br><span class="line">.text:004011F4                 call    ds:GetCommandLineA	;指向进程的完整命令行指针</span><br><span class="line">......</span><br><span class="line">.text:0040121E                 push    eax             ; 获取进程启动信息</span><br><span class="line">......</span><br><span class="line">.text:00401241                 push    esi             ; lpModuleName</span><br><span class="line">.text:00401242                 call    ds:GetModuleHandleA	;返回进程地址空间执行文件</span><br><span class="line">.text:00401248                 push    eax             ; hInstance</span><br><span class="line">.text:00401249                 call    _WinMain@16     ; 调用用户编写的进入点函数WinMain</span><br><span class="line">......</span><br><span class="line">.text:0040124E                 mov     [ebp+var_60], eax	;</span><br><span class="line">.text:00401251                 push    eax             ; int</span><br><span class="line">.text:00401252                 call    _exit			;退出程序</span><br><span class="line">......</span><br><span class="line">.text:0040124E                 mov     [ebp+var_60], eax</span><br><span class="line">.text:00401251                 push    eax             ; int</span><br><span class="line">.text:00401252                 call    _exit</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>程序都是由具有不同功能的函数组成的，因此在逆向分析中将重点放在函数的识别及餐厨的传递上是很有必要的。函数是一个程序模块，用来实现一个特定的功能。</p>
<h4 id="函数的识别"><a href="#函数的识别" class="headerlink" title="函数的识别"></a>函数的识别</h4><p>首先我们写一个小的Demo：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">6</span>;</span><br><span class="line">	Add(a,b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对应我们给出IDA中反汇编的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 var_8           &#x3D; dword ptr -8</span><br><span class="line">.text:00401000 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401000 argc            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  10h</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 sub     esp, 8			;抬高栈</span><br><span class="line">.text:00401006                 mov     [ebp+var_4], 5	</span><br><span class="line">.text:0040100D                 mov     [ebp+var_8], 6	;使参数进入栈</span><br><span class="line">.text:00401014                 mov     eax, [ebp+var_8]	;a&#x3D;5</span><br><span class="line">.text:00401017                 push    eax</span><br><span class="line">.text:00401018                 mov     ecx, [ebp+var_4]	;b&#x3D;6</span><br><span class="line">.text:0040101B                 push    ecx</span><br><span class="line">.text:0040101C                 call    sub_40102A		;进入函数内部</span><br><span class="line">.text:00401021                 add     esp, 8			;恢复栈</span><br><span class="line">.text:00401024                 xor     eax, eax</span><br><span class="line">.text:00401026                 mov     esp, ebp</span><br><span class="line">.text:00401028                 pop     ebp</span><br><span class="line">.text:00401029                 retn</span><br><span class="line">.text:00401029 _main           endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:0040102A arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:0040102A arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:0040102A</span><br><span class="line">.text:0040102A                 push    ebp			</span><br><span class="line">.text:0040102B                 mov     ebp, esp</span><br><span class="line">.text:0040102D                 mov     eax, [ebp+arg_0]		;eax中压入6</span><br><span class="line">.text:00401030                 add     eax, [ebp+arg_4]		;[ebp+arg_4]5+6</span><br><span class="line">.text:00401033                 pop     ebp					;恢复栈空间</span><br><span class="line">.text:00401034                 retn</span><br><span class="line">.text:00401034 sub_40102A      endp</span><br></pre></td></tr></table></figure>







<h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><p>函数传递参数的方式有三种，分别是：”栈传递”、”寄存器方式”、”全局变量隐含参数传递”。</p>
<h5 id="栈传递"><a href="#栈传递" class="headerlink" title="栈传递"></a>栈传递</h5><p>栈是一种”先进后出”的存储区，栈顶指针esp指向栈中第一个可用的数据项，在调用函数时，调用者依此把参数压入栈，然后调用函数。函数被调用以后，在栈中取得数据并进行计算。函数计算结束以后，由调用者或者函数本身修改栈，使栈恢复原样。</p>
<p><strong>函数调用约定：</strong></p>
<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/0.png"></p>
<p>C规范(即_cdecl)函数的参数从右到左的顺序入栈，由调用者负责清除栈。_cedel是c和c++程序的默认调用约定。</p>
<p>psacal规范按从左到右的顺序参数入栈，要求被调用函数负责清除栈空间。</p>
<p>stdcall调用约定是Win32 API采用的方法，采用C调用约定的入栈顺序和pascal调用约定的调整栈指针方式，即函数入口参数按从右往左的顺序入栈，并由被调用的函数在返回前清理传送参数的内存栈，函数参数的个数固定。由于函数体本身知道传入参数的个数，被调用的函数可以在反汇前使用一个”retn”指令直接清理传递参数的栈。</p>
<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/1.png"></p>
<p><strong>_cedel类型stdcall类型先把右边的参数压入栈，pascal则相反。在栈平衡上，_cedel类型由调用者用”add esp,0c”指令把12字节的参数空间清除，pascal和stdcall类型则由子程序负责清除。</strong></p>
<p>函数对参数的存取及局部变量都是通过栈来定义的，非优化编译器用一个专门的寄存器对参数进行寻址。</p>
<ul>
<li>调用者将函数执行完毕时应返回的地址、参数压入栈</li>
<li>子程序使用”ebp指针+偏移量”对栈中的参数进行寻址并取出，完成操作</li>
<li>子程序使用”ret”或”retn”指令返回。此时，CPU将eip置为栈中保存的地址，并且继续执行</li>
</ul>
<p>例子，按stdcall约定调用函数test2(Pat1,Par2)，其汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">push par2		;参数2</span><br><span class="line">push par1		;参数1</span><br><span class="line">call test2		;调用子程序test2</span><br><span class="line">(</span><br><span class="line">	push ebp	;保存现场原来的ebp指针</span><br><span class="line">	mov ebp,esp	;设置新的ebp指针，使其指向栈定</span><br><span class="line">	mov eax,dword ptr [ebp+0c]	;调用参数2</span><br><span class="line">	mov ebx,dword ptr [ebp+08]	;调用参数1</span><br><span class="line">	sub esp,8	;若函数使用局部变量，则要在栈中留出空间</span><br><span class="line">	......</span><br><span class="line">	add esp,8	;释放局部变量占用的栈</span><br><span class="line">	pop ebp		;恢复现场的ebp指针</span><br><span class="line">	ret 8		;ret后面的值等于参数的个数乘以4h</span><br><span class="line">	</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>因为esp是栈指针，所以一般使用ebp来存取栈，其栈建立过程如下：</p>
<ul>
<li>因此函数中有2个参数，假设执行函数前栈指针的esp为K</li>
<li>根据stdcall调用约定，先将参数par2压入栈，此时esp为k-04h</li>
<li>将参数par1压入栈，此时esp为k-08h</li>
<li>参数入栈后，程序开始执行call指令。call指令把返回地址压入栈，这时esp为k-0ch</li>
<li>现在已经在子程序中，可以使用ebp来存取参数，但是为了在返回时恢复ebp的值，需要执行”push ebp”指令来保存，此时esp为k-10h</li>
<li>执行”mov ebp,esp”指令，ebp被用来在栈中寻找调用者压入的参数，这时[ebp+8]就是参数1，[ebp+c]就是参数2.</li>
<li>“sub esp,8”指令表示中定义局部变量。局部变量1和局部变量2对应的地址分别是”[ebp-4]”、”ebp-8”。函数结束的时候，调用”add esp,8”指令释放局部变量占用的栈。局部变量的作用域是定义该变量的函数，也就是说，挡函数调用结束后局部变量就会消失。</li>
<li>调用”ret 8”指令来平衡栈。在ret指令后加一个操作数，表示在ret指令后给栈指针esp加上操作数，完成同样的操作。</li>
</ul>
<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/2.png"></p>
<p>指令”enter”和”leave”可以帮助进行栈的维护。enter语句的作用是”push ebp”、”mov ebp,esp”、”sub esp,xxx”，而leave语句则完成”add esp,xxx”、”pop ebp”的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enter xxxx,0	;0表示创建xxxx空间来放置局部变量</span><br><span class="line">......</span><br><span class="line">leave 				;恢复栈</span><br><span class="line">ret 8				;返回</span><br></pre></td></tr></table></figure>





<p>开启VC6里的优化选项为”Maximisz Speed”。其汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">push par2		;参数2</span><br><span class="line">push par1		;参数1</span><br><span class="line">call test2		;调用子程序test2</span><br><span class="line">(</span><br><span class="line">	push ebp	;保存现场原来的ebp指针</span><br><span class="line">	mov ebp,esp	;设置新的ebp指针，使其指向栈定</span><br><span class="line">	mov eax,dword ptr [ebp+04]	;调用参数2</span><br><span class="line">	mov ebx,dword ptr [ebp+08]	;调用参数1</span><br><span class="line">	......</span><br><span class="line">	ret 8		;返回</span><br><span class="line">	</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>程序这个时候使用esp来传递参数了。</p>
<ul>
<li>假设执行函数前栈指针esp为k</li>
<li>根据stdcall调用约定，先将参数Par2压入栈，此时esp为k-04h</li>
<li>将Par1压入栈，此时esp为k-08h</li>
<li>参数入栈以后，程序开始执行call指令。call指令把返回地址压入栈，此时esp为k-0ch</li>
<li>现在程序已经在子程序中了，可以使用esp来存取参数了</li>
</ul>
<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/3.png"></p>
<h5 id="寄存器传递参数"><a href="#寄存器传递参数" class="headerlink" title="寄存器传递参数"></a>寄存器传递参数</h5><p>寄存器传递参数的方式没有标准，但绝大多数都使用Fastcall，顾名思义，特别就是快。</p>
<p>不同的编译器实现得Fastcall稍有不同，VC++编译器采用Fastcall规范传递参数时，左边的2个不大于4字节(DWORD)的参数分别放在ecx和edx寄存器中，寄存器用完就要使用栈，其余剩下的参数按从右往左的顺序压入栈、</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _fastcall <span class="title">Add</span><span class="params">(<span class="keyword">char</span>,<span class="keyword">long</span>,<span class="keyword">int</span> ,<span class="keyword">int</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _fastcall <span class="title">Add</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">long</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>相对应汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 push    4		;后两个参数从右往左入栈，先压入4h</span><br><span class="line">.text:00401005                 push    3		;将第三个参数压入栈，压入3h</span><br><span class="line">.text:00401007                 mov     edx, 2	;将第二个参数的值2h放入edx寄存器中</span><br><span class="line">.text:0040100C                 mov     cl, 1	;字符类型的变量，大小为8位，所以用寄存器的高八位</span><br><span class="line">.text:0040100E                 call    sub_401017	;函数调用</span><br><span class="line">.text:00401013                 xor     eax, eax</span><br><span class="line">.text:00401015                 pop     ebp</span><br><span class="line">.text:00401016                 retn</span><br><span class="line">......</span><br><span class="line">.text:00401017 var_8           &#x3D; dword ptr -8</span><br><span class="line">.text:00401017 var_4           &#x3D; byte ptr -4</span><br><span class="line">.text:00401017 arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:00401017 arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401017</span><br><span class="line">.text:00401017                 push    ebp		</span><br><span class="line">.text:00401018                 mov     ebp, esp</span><br><span class="line">.text:0040101A                 sub     esp, 8	;为局部变量分配8个字节</span><br><span class="line">.text:0040101D                 mov     [ebp+var_8], edx	;将第二个参数放到局部变量[ebp-08]中</span><br><span class="line">.text:00401020                 mov     [ebp+var_4], cl	;将第一个参数放到局部变量[ebp-04]中</span><br><span class="line">.text:00401023                 movsx   eax, [ebp+var_4]	;将字符类型符号扩展为一个双字</span><br><span class="line">.text:00401027                 add     eax, [ebp+var_8]	;将左边两个参数相加</span><br><span class="line">.text:0040102A                 add     eax, [ebp+arg_0]	;用eax中的结果加第三个参数</span><br><span class="line">.text:0040102D                 add     eax, [ebp+arg_4]	;用eax中的结果加第四个参数</span><br><span class="line">.text:00401030                 mov     esp, ebp</span><br><span class="line">.text:00401032                 pop     ebp</span><br><span class="line">.text:00401033                 retn    8</span><br></pre></td></tr></table></figure>





<p>thiscall也用到了寄存器传递参数，thiscall是C++中的非静态类成员函数的默认调用约定，对象的每个函数隐含接受this参数。<strong>采用thiscall约定时，函数的参数按照从右往左的顺序入栈 ，被调用的函数在返回前清理传送参数的栈，仅通过ecx寄存器传递一个额外的参数，this指针</strong></p>
<p>定义一个类，并在类中顶一个成员函数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//实际Add原型具有如下形式:Add(this,int a,int b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a + b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">	CSum sum;</span><br><span class="line">	sum.Add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用VC++进行编译，汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 push    ecx</span><br><span class="line">.text:00401004                 push    2			;第三个参数</span><br><span class="line">.text:00401006                 push    1			;第二个参数</span><br><span class="line">.text:00401008                 lea     ecx, [ebp+var_4]	;this指针通过ecx寄存器传递</span><br><span class="line">.text:0040100B                 call    sub_401020	;sum.Add()函数(1,2)</span><br><span class="line">.text:00401010                 mov     esp, ebp</span><br><span class="line">.text:00401012                 pop     ebp</span><br><span class="line">.text:00401013                 retn</span><br><span class="line">......</span><br><span class="line">.text:00401020 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401020 arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:00401020 arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401020</span><br><span class="line">.text:00401020                 push    ebp</span><br><span class="line">.text:00401021                 mov     ebp, esp</span><br><span class="line">.text:00401023                 push    ecx</span><br><span class="line">.text:00401024                 mov     [ebp+var_4], ecx	;第三个参数</span><br><span class="line">.text:00401027                 mov     eax, [ebp+arg_0]	;第二个参数</span><br><span class="line">.text:0040102A                 add     eax, [ebp+arg_4]	;第一个参数</span><br><span class="line">.text:0040102D                 mov     esp, ebp</span><br><span class="line">.text:0040102F                 pop     ebp</span><br><span class="line">.text:00401030                 retn    8</span><br></pre></td></tr></table></figure>





<h5 id="名称修饰约定"><a href="#名称修饰约定" class="headerlink" title="名称修饰约定"></a>名称修饰约定</h5><p>为了允许使用操作符和函数重载，C++编译器往往会按照某种规则改写每一个入口点的函数名，从而允许同一个名字(具有不同的参数类型或不同的作用域)有多个用法且不会破坏现有的基于C的链接器。</p>
<ul>
<li>stdcall调用约定在函数名前面加一个下划线前缀，在后面加一个@符号机器参数的字节数。</li>
<li>_cdecl调用约定仅在输出函数名前加一个下划线前缀。</li>
<li>Fastcall调用约定在前面加一个@符号，在后面加一个@符号机器参数的字节数</li>
</ul>
<p>它们均不改变输出函数名中的字符大小写。这和pascal调用约定不同。pascal约定输出的函数名不能有任何其他修饰且全部为大写</p>
<ul>
<li>stdcall调用约定以”?”标识函数名的开始，后跟函数名；在函数名后面，以”@@YG”标识参数表的开始，后跟参数表；参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型，指针标识在其所指数据类型前；在其参数表后面，以”@z”标识整个名字的结束。</li>
<li>_cdecl调用约定规矩与上面的stdcall调用约定规则相同，只是参数表的开始标识由”@@YG”变成了”@@YA”</li>
<li>Fastcall调用约定规则与上面的stdcall调用约定规则相同，只是参数表的开始由”@@YG”变成了”@@YI”</li>
</ul>
<h4 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h4><p>函数被调用执行后，将向调用者返回1个或多个执行结果，称为函数返回值。返回值最常见的形式是return操作符，还有通过参数按传引用方式返回值、通过全局变量返回值等。</p>
<h5 id="return返回值"><a href="#return返回值" class="headerlink" title="return返回值"></a>return返回值</h5><p>在一般情况下，函数的返回值存放在eax寄存器中返回，如果处理结果大小超过eax寄存器的容量，其高32位就会被存放在edx寄存器中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">main( )</span><br><span class="line">&#123;</span><br><span class="line">	Add(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Add(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp=x+y;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 push    6	;从右往左方式调用，第一个参数为6</span><br><span class="line">.text:00401005                 push    5</span><br><span class="line">.text:00401007                 call    sub_401013	;调用子程序</span><br><span class="line">.text:0040100C                 add     esp, 8</span><br><span class="line">.text:0040100F                 xor     eax, eax</span><br><span class="line">.text:00401011                 pop     ebp</span><br><span class="line">.text:00401012                 retn</span><br><span class="line">......</span><br><span class="line">.text:00401013 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401013 arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:00401013 arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401013</span><br><span class="line">.text:00401013                 push    ebp		;保存ebp</span><br><span class="line">.text:00401014                 mov     ebp, esp	;设置新的ebp指针</span><br><span class="line">.text:00401016                 push    ecx		;为局部变量分配内存空间</span><br><span class="line">.text:00401017                 mov     eax, [ebp+arg_0]	;取第一个参数</span><br><span class="line">.text:0040101A                 add     eax, [ebp+arg_4]	;相加</span><br><span class="line">.text:0040101D                 mov     [ebp+var_4], eax	;将结果存入局部变量中</span><br><span class="line">.text:00401020                 mov     eax, [ebp+var_4]	;将结果存入eax中</span><br><span class="line">.text:00401023                 mov     esp, ebp	;恢复现场</span><br><span class="line">.text:00401025                 pop     ebp		;平衡堆栈</span><br><span class="line">.text:00401026                 retn				;退出</span><br></pre></td></tr></table></figure>





<h5 id="参数按传引用方式返回"><a href="#参数按传引用方式返回" class="headerlink" title="参数按传引用方式返回"></a>参数按传引用方式返回</h5><p>给函数传递参数的方法有两种，分别是传引用和传值。进行传递调用的时候，会建立参数的一份副本，并把它传递给调用函数，在调用函数中修改参数值不会影响原始的变量值。传引用调用允许调用函数修改原始变量的值。调用某个函数得时候，当把变量的地址传递给函数时，可以在函数中用间接引用运算符修改调用函数内存单元中该变量得值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>;</span><br><span class="line">main( )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">6</span>;</span><br><span class="line">	max(&amp;a, &amp;b); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a、b中较大的数是%d&quot;</span>,a); <span class="comment">//将最大的数显示出来</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max</span><span class="params">( <span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(*a &lt; *b)</span><br><span class="line">		*a=*b; 		<span class="comment">//经比较后，将较大的数放到a变量之中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 var_8           &#x3D; dword ptr -8</span><br><span class="line">.text:00401000 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401000 argc            &#x3D; dword ptr  4</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 sub     esp, 8	;为局部变量分配内存</span><br><span class="line">.text:00401003                 lea     eax, [esp+8+var_4]	;eax指向变量，值为k-4h</span><br><span class="line">.text:00401007                 lea     ecx, [esp+8+var_8]	;ecx指向变量，值为k-8h</span><br><span class="line">.text:0040100B                 push    eax	;指向参数b的字符指针入栈</span><br><span class="line">.text:0040100C                 push    ecx	;指向参数a的字符指针入栈</span><br><span class="line">.text:0040100D                 mov     [esp+10h+var_8], 5	;[esp-8h],将参数a的值放入</span><br><span class="line">.text:00401015                 mov     [esp+10h+var_4], 6	;[esp-4h],将参数b的值放入</span><br><span class="line">.text:0040101D                 call    sub_401040			;调用子程序</span><br><span class="line">.text:00401022                 mov     edx, [esp+10h+var_8]	;利用变量[esp+08]返回函数值</span><br><span class="line">.text:00401026                 push    edx</span><br><span class="line">.text:00401027                 push    offset unk_407030</span><br><span class="line">.text:0040102C                 call    sub_401060</span><br><span class="line">.text:00401031                 xor     eax, eax</span><br><span class="line">.text:00401033                 add     esp, 18h</span><br><span class="line">.text:00401036                 retn</span><br><span class="line">.......</span><br><span class="line">.text:00401040 arg_0           &#x3D; dword ptr  4</span><br><span class="line">.text:00401040 arg_4           &#x3D; dword ptr  8</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 mov     eax, [esp+arg_4]		;执行后，eax就是指向参数b的指针</span><br><span class="line">.text:00401044                 mov     ecx, [esp+arg_0]		;执行后，，ecx就是指向参数a的指针</span><br><span class="line">.text:00401048                 mov     eax, [eax]			;将参数b的值加载到寄存器eax中</span><br><span class="line">.text:0040104A                 mov     edx, [ecx]			;将参数a的值加载到寄存器edx中</span><br><span class="line">.text:0040104C                 cmp     edx, eax				;比较edx和eax的大小</span><br><span class="line">.text:0040104E                 jge     short locret_401052	;若a&lt;b，则不跳转</span><br><span class="line">.text:00401050                 mov     [ecx], eax			;将较大的值放到参数a指向的数据区中</span><br></pre></td></tr></table></figure>





<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量是函数内部定义的一个变量，其作用域和生命周期都局限于所在函数内，使用局部变量使程序模块化封装称为可能。</p>
<h5 id="栈存放局部变量"><a href="#栈存放局部变量" class="headerlink" title="栈存放局部变量"></a>栈存放局部变量</h5><p>局部变量在栈中进行分配，函数执行后释放这些栈。</p>
<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/4.png"></p>
<p><strong>编译器可能会使用”push reg”指令取代”sub esp,4”指令</strong></p>
<p>例子代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">6</span>;</span><br><span class="line">	add(a,b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">	z = x + y;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 var_8           &#x3D; dword ptr -8</span><br><span class="line">.text:00401000 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401000 argc            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  10h</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 sub     esp, 8		;为参数开辟局部变量空间</span><br><span class="line">.text:00401006                 mov     [ebp+var_4], 5	;将参数1存入局部变量[ebp+04]04代表的值是-4，相当于[ebp-04]</span><br><span class="line">.text:0040100D                 mov     [ebp+var_8], 6	;将参数2存入局部变量[ebp-08]中</span><br><span class="line">.text:00401014                 mov     eax, [ebp+var_8]</span><br><span class="line">.text:00401017                 push    eax</span><br><span class="line">.text:00401018                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:0040101B                 push    ecx</span><br><span class="line">.text:0040101C                 call    sub_40102A</span><br><span class="line">.text:00401021                 add     esp, 8</span><br><span class="line">.text:00401024                 xor     eax, eax</span><br><span class="line">.text:00401026                 mov     esp, ebp</span><br><span class="line">.text:00401028                 pop     ebp</span><br><span class="line">.text:00401029                 retn</span><br><span class="line">......</span><br><span class="line">.text:0040102A var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:0040102A arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:0040102A arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:0040102A</span><br><span class="line">.text:0040102A                 push    ebp</span><br><span class="line">.text:0040102B                 mov     ebp, esp</span><br><span class="line">.text:0040102D                 push    ecx				;给局部变量开辟内存空间</span><br><span class="line">.text:0040102E                 mov     eax, [ebp+arg_0]	;取参数1</span><br><span class="line">.text:00401031                 add     eax, [ebp+arg_4]</span><br><span class="line">.text:00401034                 mov     [ebp+var_4], eax</span><br><span class="line">.text:00401037                 mov     eax, [ebp+var_4]	;将a+b的值存入eax寄存器中</span><br><span class="line">.text:0040103A                 mov     esp, ebp</span><br><span class="line">.text:0040103C                 pop     ebp</span><br><span class="line">.text:0040103D                 retn</span><br></pre></td></tr></table></figure>

<p><strong>局部变量的起始值是随机的，是其他函数执行后在栈中的垃圾数据，因此需要对该值进行初始化，初始化局部变量有两种方法；一种是通过mov指令为其变量赋值，另外一个使用push指令直接压值入栈</strong></p>
<h5 id="寄存器存放局部变量"><a href="#寄存器存放局部变量" class="headerlink" title="寄存器存放局部变量"></a>寄存器存放局部变量</h5><p>除了栈利用了两个寄存器，编译器会利用剩下的6个寄存器尽可能有效的存放局部变量，这样可以少产生代码，提高程序的效率。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局变量作用域整个程序，它一直存在，存放在全局变量的内存区中。</p>
<p>在大多数情况下，在汇编代码中识别全局代码比在其他结构中要容易的多。全局变量通常位于数据区块(.data)的一个固定地址处，当程序需要访问全局变量的时候，一般会使用一个固定的硬编码地址直接对内存进行寻址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr[4084c0h]	;直接调用全局变量，其中4084c0h是全局变量的地址</span><br></pre></td></tr></table></figure>

<p>全局变量可以被捅一文件的所有函数改变，如果在某个函数中改变了全局变量的值，就能影响其他函数，因此，可以利用全局变量来传递参数和函数返回值等。<strong>全局变量在程序的整个可执行过程中占用内存单元，而不像局部变量那样在使用的时候开辟内存空间</strong></p>
<p>C代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 var_8           &#x3D; dword ptr -8</span><br><span class="line">.text:00401000 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401000 argc            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  10h</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 sub     esp, 8</span><br><span class="line">.text:00401006                 mov     [ebp+var_4], 5	;[ebp-04]是局部变量，将参数1放入</span><br><span class="line">.text:0040100D                 mov     [ebp+var_8], 6	;[ebp-08]是局部变量，将参数2放入</span><br><span class="line">.text:00401014                 mov     dword_405428, 7	;对全局变量[00405428]这个地址进行初始化</span><br><span class="line">.text:0040101E                 mov     eax, [ebp+var_8]</span><br><span class="line">.text:00401021                 push    eax</span><br><span class="line">.text:00401022                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:00401025                 push    ecx</span><br><span class="line">.text:00401026                 call    sub_401034</span><br><span class="line">.text:0040102B                 add     esp, 8</span><br><span class="line">.text:0040102E                 xor     eax, eax</span><br><span class="line">.text:00401030                 mov     esp, ebp</span><br><span class="line">.text:00401032                 pop     ebp</span><br><span class="line">.text:00401033                 retn</span><br><span class="line">......</span><br><span class="line">.text:00401034 arg_0           &#x3D; dword ptr  8</span><br><span class="line">.text:00401034 arg_4           &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401034</span><br><span class="line">.text:00401034                 push    ebp</span><br><span class="line">.text:00401035                 mov     ebp, esp</span><br><span class="line">.text:00401037                 mov     eax, [ebp+arg_0]	;[ebp+08]为参数1</span><br><span class="line">.text:0040103A                 add     eax, [ebp+arg_4]	;[ebp+04]为参数2</span><br><span class="line">.text:0040103D                 add     eax, dword_405428	;调用了全局变量[00405428]</span><br><span class="line">.text:00401043                 pop     ebp</span><br><span class="line">.text:00401044                 retn</span><br></pre></td></tr></table></figure>

<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/5.png"></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是相同数据类型元素的集合，它们在内存中按顺序连续存放在一起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0x11</span>,<span class="number">0x22</span>,<span class="number">0x33</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i,s=<span class="number">0</span>,b[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s=s+a[i];</span><br><span class="line">		b[i] = s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 var_10          &#x3D; dword ptr -10h</span><br><span class="line">.text:00401000 var_C           &#x3D; byte ptr -0Ch</span><br><span class="line">.text:00401000 argc            &#x3D; dword ptr  4</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 sub     esp, 0Ch		;为局部变量分配内存，用来存放b[i]</span><br><span class="line">.text:00401003                 xor     ecx, ecx		;s&#x3D;0</span><br><span class="line">.text:00401005                 xor     eax, eax		;i&#x3D;0</span><br><span class="line">.text:00401007                 push    esi</span><br><span class="line">.text:00401008                 push    edi</span><br><span class="line">.text:00401009</span><br><span class="line">.text:00401009 loc_401009:                             ; CODE XREF: _main+1Bj</span><br><span class="line">.text:00401009                 mov     edi, dword_407030[eax]	;407030指向a[]数组，即数组的基址</span><br><span class="line">.text:0040100F                 add     eax, 4		;访问数组的索引</span><br><span class="line">.text:00401012                 add     ecx, edi		;s&#x3D;s+a[i]</span><br><span class="line">.text:00401014                 cmp     eax, 0Ch</span><br><span class="line">.text:00401017                 mov     [esp+eax+14h+var_10], ecx	;b[i]&#x3D;s</span><br><span class="line">.text:0040101B                 jl      short loc_401009</span><br><span class="line">.text:0040101D                 lea     esi, [esp+14h+var_C]</span><br><span class="line">.text:00401021                 mov     edi, 3		;计数器</span><br><span class="line">.text:00401026</span><br><span class="line">.text:00401026 loc_401026:                             ; CODE XREF: _main+3Aj</span><br><span class="line">.text:00401026                 mov     eax, [esi]	;esi指向b[]数组</span><br><span class="line">.text:00401028                 push    eax</span><br><span class="line">.text:00401029                 push    offset unk_40703C</span><br><span class="line">.text:0040102E                 call    sub_401050	;printf</span><br><span class="line">.text:00401033                 add     esp, 8</span><br><span class="line">.text:00401036                 add     esi, 4		;指向数组下一元素</span><br><span class="line">.text:00401039                 dec     edi</span><br><span class="line">.text:0040103A                 jnz     short loc_401026</span><br><span class="line">.text:0040103C                 pop     edi</span><br><span class="line">.text:0040103D                 xor     eax, eax</span><br><span class="line">.text:0040103F                 pop     esi</span><br><span class="line">.text:00401040                 add     esp, 0Ch</span><br><span class="line">.text:00401043                 retn</span><br></pre></td></tr></table></figure>



<p>在内存中，数组可以存在于栈、数据段及动态内存中，其寻址用”基址+偏移量”实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[407030h + eax]</span><br><span class="line">		;基址		偏移量</span><br></pre></td></tr></table></figure>





<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>C++的对象模型的核心概念并没有很多，最重要的概念就是虚函数。虚函数是在程序运行时定义的函数。虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的引用通常放在一个专门的数组–虚函数表中，数组的每个元素中存放的就是类中虚函数的地址。调用虚函数时，程序先取出虚函数表指针，得到虚函数表地址，再根据这个地址到虚函数表中取出该函数的地址，最后调用该函数</p>
<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/6.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a + b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (a - b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CSum *pSCum = <span class="keyword">new</span> CSum;</span><br><span class="line">	pSCum-&gt;Add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	pSCum-&gt;Sub(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>优化后汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 argc            &#x3D; dword ptr  4</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    esi</span><br><span class="line">.text:00401001                 push    4               ; </span><br><span class="line">.text:00401003                 call    ??2@YAPAXI@Z    ; new函数，为新建对象分配4字节内存</span><br><span class="line">.text:00401008                 add     esp, 4</span><br><span class="line">.text:0040100B                 test    eax, eax</span><br><span class="line">.text:0040100D                 jz      short loc_401019</span><br><span class="line">.text:0040100F                 mov     dword ptr [eax], offset off_4050A0	</span><br><span class="line">;将4050A0写到创建的对象实例中</span><br><span class="line">;4050A0是CSum类虚函数表中的指针</span><br><span class="line">;表中的元素是CSum类的虚函数，指向CSum的成员</span><br><span class="line">.text:00401015                 mov     esi, eax		;esi&#x3D;VTBL</span><br><span class="line">													;;用NULL来指向对象实例指针</span><br><span class="line">													</span><br><span class="line">.text:00401017                 jmp     short loc_40101B	;在内存分配失败的时候来到该分支，空指针将激活SEH</span><br><span class="line">.text:00401019 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401019</span><br><span class="line">.text:00401019 loc_401019:                             ; CODE XREF: _main+Dj</span><br><span class="line">.text:00401019                 xor     esi, esi		</span><br><span class="line">													;</span><br><span class="line">.text:0040101B</span><br><span class="line">.text:0040101B loc_40101B:                             ; CODE XREF: _main+17j</span><br><span class="line">.text:0040101B                 mov     eax, [esi]		;EAX&#x3D;*VTBL&#x3D;**Add()</span><br><span class="line">.text:0040101D                 push    2</span><br><span class="line">.text:0040101F                 push    1</span><br><span class="line">.text:00401021                 mov     ecx, esi			;ECX&#x3D;this</span><br><span class="line">.text:00401023                 call    dword ptr [eax]	;pCSum-&gt;ADd(1,2)</span><br><span class="line">.text:00401025                 mov     edx, [esi]		;</span><br><span class="line">.text:00401027                 push    2</span><br><span class="line">.text:00401029                 push    1</span><br><span class="line">.text:0040102B                 mov     ecx, esi</span><br><span class="line">.text:0040102D                 call    dword ptr [edx+4]</span><br><span class="line">.text:00401030                 pop     esi</span><br><span class="line">.text:00401031                 retn</span><br></pre></td></tr></table></figure>



<p>这段代码先调用了NEW函数分配class所需要的内存。调用成功以后，eax保存分配内存的指针，然后将对象实例指向CSum类虚函数表(VTBL)004050A0h。004050A0处的数据如下：</p>
<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/12.png"></p>
<p>VTBL中的两组数据分别在图中做了标识：</p>
<ul>
<li>00401040</li>
<li>00401050</li>
</ul>
<p>根据这两个指针的地址去查看内容:</p>
<p>00401040处的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00401040 arg_0           &#x3D; dword ptr  4</span><br><span class="line">.text:00401040 arg_4           &#x3D; dword ptr  8</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040                 mov     eax, [esp+arg_4]</span><br><span class="line">.text:00401044                 mov     ecx, [esp+arg_0]</span><br><span class="line">.text:00401048                 add     eax, ecx</span><br><span class="line">.text:0040104A                 retn    8</span><br></pre></td></tr></table></figure>



<p>00401050处的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00401050 arg_0           &#x3D; dword ptr  4</span><br><span class="line">.text:00401050 arg_4           &#x3D; dword ptr  8</span><br><span class="line">.text:00401050</span><br><span class="line">.text:00401050                 mov     eax, [esp+arg_0]</span><br><span class="line">.text:00401054                 mov     ecx, [esp+arg_4]</span><br><span class="line">.text:00401058                 sub     eax, ecx</span><br><span class="line">.text:0040105A                 retn    8</span><br></pre></td></tr></table></figure>



<p><strong>虚函数是通过指向虚函数表的指针间接地加以调用</strong></p>
<h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>在高级语言中，用IF-ELSE、WSITCH-CASE等语句来构建判断流程。但是其汇编代码比较复杂，我们会看到需要cmp等指令后加各类跳转指令。</p>
<h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p>call：调用<br> jmp：无条件跳转<br> jo：溢出跳转（OF=1），对应于jno<br> jb：低于/进位跳转（CF=1），对应jnb（bottom）<br> ja：高于跳转，对应jna（tall）<br> jbe：低于等于跳转<br> jae：高于等于跳转<br> je/jz：相等跳转（ZF=1），对应jne/jnz<br> js：符号为负跳转（SF=1），对应jns<br> jl：小于跳转，对应jnl（low）<br> jle：小于等于跳转<br> jg：大于跳转，对应jng（big，great，large）<br> jge：大于等于跳转<br> nop：不跳转，空指针</p>
<h5 id="ZF-零标志位"><a href="#ZF-零标志位" class="headerlink" title="ZF 零标志位"></a>ZF 零标志位</h5><p> flag 的第 6 位是 ZF，零标志位。它记录相关指令执行后，其结果是否为 0，如果结果为 0，那么 zf=1；如果结果不为 0，那么 zf=0。 </p>
<h5 id="PF-标志"><a href="#PF-标志" class="headerlink" title="PF 标志"></a>PF 标志</h5><p> flag 的第 2 位是 PF，奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果 1 的个数为偶数，pf=1，如果为奇数，那么 pf=0. </p>
<h5 id="SF-标志"><a href="#SF-标志" class="headerlink" title="SF 标志"></a>SF 标志</h5><p> flag 的第 7 位是 SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负数，sf=1；如果非负，sf=0。 </p>
<h5 id="CF-标志"><a href="#CF-标志" class="headerlink" title="CF 标志"></a>CF 标志</h5><p> flag的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 </p>
<h5 id="OF-标志"><a href="#OF-标志" class="headerlink" title="OF 标志"></a>OF 标志</h5><p>flag的第11位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0.</p>
<p>一定要注意CF和OF的区别：CF是对无符号运算有意义的标志位，而OF是对有符号运算有意义的标志位。 </p>
<h5 id="DF标志"><a href="#DF标志" class="headerlink" title="DF标志"></a>DF标志</h5><p> flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。 </p>
<p>df=0 每次操作后si、di递增</p>
<p>df=1  每次操作后si、di递减</p>
<h4 id="IF-THEL-ELSE语句"><a href="#IF-THEL-ELSE语句" class="headerlink" title="IF-THEL-ELSE语句"></a>IF-THEL-ELSE语句</h4><p>将语句IF-THEN-ELSE编译成后边代码后，整数用cmp指令进行比较，浮点用fcom、fcomp等指令进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp a,b</span><br><span class="line">jz(jnz) xxx</span><br></pre></td></tr></table></figure>

<p>cmp指令不会修改操作书。两个操作书之间的结果会影响处理的几个标志。</p>
<p><strong>实际中，很多编译器会使用test或者or之列的较短的逻辑来替换cmp指令</strong></p>
<p>实例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a,b=<span class="number">5</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入数字:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">if</span>(a==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a=<span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401000 argc            &#x3D; dword ptr  4</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ecx				;为局部变量分配内存空间</span><br><span class="line">.text:00401001                 push    offset aIFI     ; &quot;请输入</span><br><span class="line">.text:00401006                 call    _printf			;指向printf函数</span><br><span class="line">.text:0040100B                 lea     eax, [esp+8+var_4]	;eax指向局部变量</span><br><span class="line">.text:0040100F                 push    eax				;将eax压入栈</span><br><span class="line">.text:00401010                 push    offset aD       ; &quot;%d&quot;</span><br><span class="line">.text:00401015                 call    _scanf			;scanf输入函数u</span><br><span class="line">.text:0040101A                 mov     eax, [esp+10h+var_4]	;局部变量存入eax寄存器中</span><br><span class="line">.text:0040101E                 add     esp, 0Ch			;函数调用，平衡栈</span><br><span class="line">.text:00401021                 test    eax, eax			;若eax寄存器为0，则ZF为1，否则ZF为0</span><br><span class="line">.text:00401023                 jnz     short loc_40102A	;若ZF&#x3D;1就不跳转，否则跳转</span><br><span class="line">.text:00401025                 mov     eax, 8</span><br><span class="line">.text:0040102A</span><br><span class="line">.text:0040102A loc_40102A:                             ; CODE XREF: _main+23j</span><br><span class="line">.text:0040102A                 add     eax, 5			</span><br><span class="line">.text:0040102D                 pop     ecx			;释放局部变量使用的内存</span><br><span class="line">.text:0040102E                 retn</span><br></pre></td></tr></table></figure>





<h4 id="SWITCH-CASE语句"><a href="#SWITCH-CASE语句" class="headerlink" title="SWITCH-CASE语句"></a>SWITCH-CASE语句</h4><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">switch</span>(a)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span> :	<span class="built_in">printf</span>(<span class="string">&quot;a=1&quot;</span>);	</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span> :	<span class="built_in">printf</span>(<span class="string">&quot;a=2&quot;</span>);	</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span> :	<span class="built_in">printf</span>(<span class="string">&quot;a=10&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span> :	<span class="built_in">printf</span>(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不优化的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 var_8           &#x3D; dword ptr -8</span><br><span class="line">.text:00401000 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401000 argc            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  10h</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ebp			</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 sub     esp, 8		;;为局部变量分配内存</span><br><span class="line">.text:00401006                 lea     eax, [ebp+var_4]</span><br><span class="line">.text:00401009                 push    eax</span><br><span class="line">.text:0040100A                 push    offset aD       ; &quot;%d&quot;</span><br><span class="line">.text:0040100F                 call    _scanf			;scanf(%d,&amp;a)</span><br><span class="line">.text:00401014                 add     esp, 8</span><br><span class="line">.text:00401017                 mov     ecx, [ebp+var_4]	;将输入结果传递给ecx</span><br><span class="line">.text:0040101A                 mov     [ebp+var_8], ecx</span><br><span class="line">.text:0040101D                 cmp     [ebp+var_8], 1	;case 1</span><br><span class="line">.text:00401021                 jz      short loc_401031</span><br><span class="line">.text:00401023                 cmp     [ebp+var_8], 2	;case 2</span><br><span class="line">.text:00401027                 jz      short loc_401040</span><br><span class="line">.text:00401029                 cmp     [ebp+var_8], 0Ah	;case 10</span><br><span class="line">.text:0040102D                 jz      short loc_40104F</span><br><span class="line">.text:0040102F                 jmp     short loc_40105E	;default</span><br><span class="line">.text:00401031 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401031</span><br><span class="line">.text:00401031 loc_401031:                             ; CODE XREF: _main+21j</span><br><span class="line">.text:00401031                 push    offset aA1      ; &quot;a&#x3D;1&quot;</span><br><span class="line">.text:00401036                 call    _printf</span><br><span class="line">.text:0040103B                 add     esp, 4</span><br><span class="line">.text:0040103E                 jmp     short loc_40106B</span><br><span class="line">.text:00401040 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 loc_401040:                             ; CODE XREF: _main+27j</span><br><span class="line">.text:00401040                 push    offset aA2      ; &quot;a&#x3D;2&quot;</span><br><span class="line">.text:00401045                 call    _printf</span><br><span class="line">.text:0040104A                 add     esp, 4</span><br><span class="line">.text:0040104D                 jmp     short loc_40106B</span><br><span class="line">.text:0040104F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040104F</span><br><span class="line">.text:0040104F loc_40104F:                             ; CODE XREF: _main+2Dj</span><br><span class="line">.text:0040104F                 push    offset aA10     ; &quot;a&#x3D;10&quot;</span><br><span class="line">.text:00401054                 call    _printf</span><br><span class="line">.text:00401059                 add     esp, 4</span><br><span class="line">.text:0040105C                 jmp     short loc_40106B</span><br><span class="line">.text:0040105E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040105E</span><br><span class="line">.text:0040105E loc_40105E:                             ; CODE XREF: _main+2Fj</span><br><span class="line">.text:0040105E                 push    offset aDefault ; &quot;default&quot;</span><br><span class="line">.text:00401063                 call    _printf</span><br><span class="line">.text:00401068                 add     esp, 4</span><br><span class="line">.text:0040106B</span><br><span class="line">.text:0040106B loc_40106B:                             ; CODE XREF: _main+3Ej</span><br><span class="line">.text:0040106B                                         ; _main+4Dj ...</span><br><span class="line">.text:0040106B                 mov     esp, ebp</span><br><span class="line">.text:0040106D                 pop     ebp</span><br><span class="line">.text:0040106E                 retn</span><br></pre></td></tr></table></figure>



<p>开启优化选项后的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ecx</span><br><span class="line">.text:00401001                 lea     eax, [esp+4+var_4]</span><br><span class="line">.text:00401005                 push    eax</span><br><span class="line">.text:00401006                 push    offset aD       ; &quot;%d&quot;</span><br><span class="line">.text:0040100B                 call    _scanf</span><br><span class="line">.text:00401010                 mov     eax, [esp+0Ch+var_4]	;将scanf的结果存入ax中</span><br><span class="line">.text:00401014                 add     esp, 8		;给局部变量开辟空间</span><br><span class="line">.text:00401017                 dec     eax			;检查eax是否为1h，如果是，jz跳转</span><br><span class="line">.text:00401018                 jz      short loc_40104F	;case 1</span><br><span class="line">.text:0040101A                 dec     eax			;将eax的值减1，即eax原值为2</span><br><span class="line">.text:0040101B                 jz      short loc_401040	;case2</span><br><span class="line">.text:0040101D                 sub     eax, 8			;eax两次减1的值为8h，所以原值为10h</span><br><span class="line">.text:00401020                 jz      short loc_401031	;case10</span><br><span class="line">.text:00401022                 push    offset aDefault ; &quot;default&quot;</span><br><span class="line">.text:00401027                 call    _printf</span><br><span class="line">.text:0040102C                 add     esp, 4</span><br><span class="line">.text:0040102F                 pop     ecx</span><br><span class="line">.text:00401030                 retn</span><br><span class="line">.text:00401031 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401031</span><br><span class="line">.text:00401031 loc_401031:                             ; CODE XREF: _main+20j</span><br><span class="line">.text:00401031                 push    offset aA10     ; &quot;a&#x3D;10&quot;</span><br><span class="line">.text:00401036                 call    _printf</span><br><span class="line">.text:0040103B                 add     esp, 4</span><br><span class="line">.text:0040103E                 pop     ecx</span><br><span class="line">.text:0040103F                 retn</span><br><span class="line">.text:00401040 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401040</span><br><span class="line">.text:00401040 loc_401040:                             ; CODE XREF: _main+1Bj</span><br><span class="line">.text:00401040                 push    offset aA2      ; &quot;a&#x3D;2&quot;</span><br><span class="line">.text:00401045                 call    _printf</span><br><span class="line">.text:0040104A                 add     esp, 4</span><br><span class="line">.text:0040104D                 pop     ecx</span><br><span class="line">.text:0040104E                 retn</span><br><span class="line">.text:0040104F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040104F</span><br><span class="line">.text:0040104F loc_40104F:                             ; CODE XREF: _main+18j</span><br><span class="line">.text:0040104F                 push    offset aA1      ; &quot;a&#x3D;1&quot;</span><br><span class="line">.text:00401054                 call    _printf</span><br><span class="line">.text:00401059                 add     esp, 4</span><br><span class="line">.text:0040105C                 pop     ecx</span><br><span class="line">.text:0040105D                 retn</span><br></pre></td></tr></table></figure>



<p>如果case的取值表示一个算术级数，那么编译器就会利用一个跳转表来实现。</p>
<p>我们多写一些case语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">	 <span class="keyword">int</span> a;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	</span><br><span class="line">	 <span class="keyword">switch</span>(a)</span><br><span class="line">	 &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span> :<span class="built_in">printf</span>(<span class="string">&quot;a=1&quot;</span>);</span><br><span class="line">				    <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span> :<span class="built_in">printf</span>(<span class="string">&quot;a=2&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">&quot;a=3&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">printf</span>(<span class="string">&quot;a=4&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:<span class="built_in">printf</span>(<span class="string">&quot;a=5&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:<span class="built_in">printf</span>(<span class="string">&quot;a=6&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:<span class="built_in">printf</span>(<span class="string">&quot;a=7&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span> :<span class="built_in">printf</span>(<span class="string">&quot;a=default&quot;</span>);</span><br><span class="line">					 <span class="keyword">break</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000 var_4           &#x3D; dword ptr -4</span><br><span class="line">.text:00401000 argc            &#x3D; dword ptr  4</span><br><span class="line">.text:00401000 argv            &#x3D; dword ptr  8</span><br><span class="line">.text:00401000 envp            &#x3D; dword ptr  0Ch</span><br><span class="line">.text:00401000</span><br><span class="line">.text:00401000                 push    ecx</span><br><span class="line">.text:00401001                 lea     eax, [esp+4+var_4]</span><br><span class="line">.text:00401005                 push    eax</span><br><span class="line">.text:00401006                 push    offset aD       ; &quot;%d&quot;</span><br><span class="line">.text:0040100B                 call    _scanf</span><br><span class="line">.text:00401010                 mov     ecx, [esp+0Ch+var_4]</span><br><span class="line">.text:00401014                 add     esp, 8</span><br><span class="line">.text:00401017                 lea     eax, [ecx-1]    ; switch 7 cases</span><br><span class="line">.text:0040101A                 cmp     eax, 6		;判断是否为default节点</span><br><span class="line">.text:0040101D                 ja      short loc_40109D ; jumptable 0040101F default case</span><br><span class="line">.text:0040101F                 jmp     ds:off_4010B0[eax*4] ; switch jump</span><br><span class="line">.text:00401026                 push    offset aA1      ; jumptable case 1</span><br><span class="line">.text:0040102B                 call    sub_4010D0		;回到跳转表</span><br><span class="line">.text:00401030                 add     esp, 4</span><br><span class="line">.text:00401033                 xor     eax, eax</span><br><span class="line">.text:00401035                 pop     ecx</span><br></pre></td></tr></table></figure>



<h4 id="转移指令机器码计算"><a href="#转移指令机器码计算" class="headerlink" title="转移指令机器码计算"></a>转移指令机器码计算</h4><p>根据转移距离的不同，转移指令有以下类型：</p>
<ul>
<li>短转移(Short Jump)：无条件跳转和跳转转移的机器码均为2字节，转移范围是-128~127字节</li>
<li>长转移(Long Jump)：无条件跳转的机器码为5字节，条件转移的机器码为6字节。这是因为，条件转移需要用2字节表示其转移类型(jg,jz,jns)，其他4字节表示转移偏移量。而无条件跳转仅用1字节就可以标砖其转移类型，其他4字节表示转移偏移量。</li>
<li>子程序调用指令(call):call指令调用有两类。一类调用是我们平时经常接触的，类似于长转移；零一类调用的参数涉及寄存器、栈灯值，比较复杂，。</li>
</ul>
<p>条件转移指令的转移范围是16位模式遗留下来的。当时，为了使代码紧凑一些，CPU开发人员只给目的地址分配了1字节，这样就将跳转的长度限制在了255字节之内。</p>
<p><img src="%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/7.png"></p>
<p>有两个因素可以限制转移指令的机器码，一个是上图，一个是转移的位移量</p>
<h5 id="短转移指令机器码计算"><a href="#短转移指令机器码计算" class="headerlink" title="短转移指令机器码计算"></a>短转移指令机器码计算</h5><p>在代码中的片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:401000 jmp 401005</span><br><span class="line"></span><br><span class="line">:401005 xor eax,eax</span><br></pre></td></tr></table></figure>

<p>无条件短转移的机器码形式位”EBxx”，其中EB00h<del>EB7Fh是向后转移，EB80h</del>EBFFh是向前转移。</p>
<p><strong>位移量 = 目的地址 - 起始地址 - 跳转指令本身长度</strong></p>
<p><strong>转移指令机器码 = 转移类别机器码 + 位移量</strong></p>
<h5 id="长转移指令机器码计算"><a href="#长转移指令机器码计算" class="headerlink" title="长转移指令机器码计算"></a>长转移指令机器码计算</h5><p>在代码段中有一条无条件转移指令，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:401000 jmp 402398</span><br><span class="line"></span><br><span class="line">:402398 xor eax,eax</span><br></pre></td></tr></table></figure>

<p>无条件长跳转指令的长度是5字节，机器码是”E9”。</p>
<p><strong>00402398h-00401000h-5h=00001393h</strong></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环是高级语言中可以进行反向引用的一种语言形式，其他类型的分支语句都是由低地址向高地址引用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xor ecx,ecx	;将ecx清零</span><br><span class="line">00440000</span><br><span class="line">inc ecx		;计数</span><br><span class="line">cmp ecx,5	;循环6次</span><br><span class="line">jbe	00440000	;重复</span><br></pre></td></tr></table></figure>



<p>上面的代码改写为c语言有两种写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小例子查看汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum = sum + i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ebp</span><br><span class="line">.text:00401001                 mov     ebp, esp			;建立栈</span><br><span class="line">.text:00401003                 sub     esp, 8			;为局部变量分配内存</span><br><span class="line">.text:00401006                 mov     [ebp+var_4], 0	;初始化局部变量[ebp-4]</span><br><span class="line">.text:0040100D                 mov     [ebp+var_8], 0	;初始化局部变量[ebp-8]</span><br><span class="line">.text:00401014                 mov     [ebp+var_8], 0	;初始化局部变量[ebp-8]</span><br><span class="line">.text:0040101B                 jmp     short loc_401026	;循环从00401026处开始</span><br><span class="line">.text:0040101D ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0040101D</span><br><span class="line">.text:0040101D loc_40101D:                             ; CODE XREF: _main+35j</span><br><span class="line">.text:0040101D                 mov     eax, [ebp+var_8]	;将变量[ebp+08]的值传递给eax</span><br><span class="line">.text:00401020                 add     eax, 1			;eax加1</span><br><span class="line">.text:00401023                 mov     [ebp+var_8], eax	;更新变量[ebp+08]的值，即i++</span><br><span class="line">.text:00401026</span><br><span class="line">.text:00401026 loc_401026:                             ; CODE XREF: _main+1Bj</span><br><span class="line">.text:00401026                 cmp     [ebp+var_8], 64h	;将更新过后的局部变量与100进行比较，64h的是十六进制，100是十进制</span><br><span class="line">.text:0040102A                 jge     short loc_401037	;如果i大于100，退出循环</span><br><span class="line">.text:0040102C                 mov     ecx, [ebp+var_4]	;将变量[ebp+04]放到ecx中</span><br><span class="line">.text:0040102F                 add     ecx, [ebp+var_8]	;相当于sum+i</span><br><span class="line">.text:00401032                 mov     [ebp+var_4], ecx	;sum &#x3D; sum+i</span><br><span class="line">.text:00401035                 jmp     short loc_40101D	;这个跳转是由低地址向高地址跳转的</span><br><span class="line">.text:00401037 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00401037</span><br><span class="line">.text:00401037 loc_401037:                             ; CODE XREF: _main+2Aj</span><br><span class="line">.text:00401037                 mov     esp, ebp</span><br><span class="line">.text:00401039                 pop     ebp			;关闭栈</span><br><span class="line">.text:0040103A                 retn</span><br></pre></td></tr></table></figure>



<p>开启优化选项后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 xor     ecx, ecx	;初始化变量，sum&#x3D;0</span><br><span class="line">.text:00401002                 xor     eax, eax	;初始化变量，i&#x3D;0</span><br><span class="line">.text:00401004</span><br><span class="line">.text:00401004 loc_401004:                             ; CODE XREF: _main+Aj</span><br><span class="line">.text:00401004                 add     ecx, eax	;相当于sum&#x3D;sum+i</span><br><span class="line">.text:00401006                 inc     eax		;eax的值加1，即i++</span><br><span class="line">.text:00401007                 cmp     eax, 64h	;eax的值与64h做比较</span><br><span class="line">.text:0040100A                 jl      short loc_401004	;如果eax&gt;100,则退出循环</span><br><span class="line">.text:0040100C                 retn</span><br></pre></td></tr></table></figure>







<h3 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h3><h4 id="整数的加法和减法"><a href="#整数的加法和减法" class="headerlink" title="整数的加法和减法"></a>整数的加法和减法</h4><p>在一般情况下，整数的加法和减法都会被编译成add和sub指令。在进行编译优化的时候，很多人喜欢用lea指令代替add和sub指令。</p>
<h5 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a+b+<span class="number">0x78</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ecx		;为局部变量分配内存</span><br><span class="line">.text:00401001                 mov     eax, [esp+4+var_4]</span><br><span class="line">.text:00401005                 mov     ecx, [esp+4+var_4]</span><br><span class="line">.text:00401009                 lea     edx, [ecx+eax+78h]	;快速计算ecx+eax+78h</span><br><span class="line">.text:0040100D                 push    edx</span><br><span class="line">.text:0040100E                 push    offset aD       ; &quot;%d&quot;</span><br><span class="line">.text:00401013                 call    _printf				;printf函数</span><br><span class="line">.text:00401018                 xor     eax, eax</span><br><span class="line">.text:0040101A                 add     esp, 0Ch</span><br><span class="line">.text:0040101D                 retn</span><br></pre></td></tr></table></figure>



<p><strong>lea指令是一条纯算术指令</strong></p>
<h5 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h5><p>乘法指令一般被编译成mul、imul指令，这些指令运算速度比较慢。编译器为了速度，倾向于使用其他指令来完成同样的计算。如果一个数是2的幂次方，那么会用左移运指令shl来实现乘法运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a*<span class="number">11</span>+<span class="number">4</span>,a*<span class="number">9</span>,a*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>汇编指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ecx		;为局部变量开辟内存空间</span><br><span class="line">.text:00401001                 mov     eax, [esp+4+var_4]	;</span><br><span class="line">.text:00401005                 lea     ecx, [eax+eax]		;即a*2</span><br><span class="line">.text:00401008                 lea     edx, [eax+eax*8]		;edx&#x3D;a+8*a&#x3D;9*a</span><br><span class="line">.text:0040100B                 push    ecx</span><br><span class="line">.text:0040100C                 lea     ecx, [eax+eax*4]		;ecx&#x3D;a+4*a&#x3D;5*a</span><br><span class="line">.text:0040100F                 push    edx</span><br><span class="line">.text:00401010                 lea     edx, [eax+ecx*2+4]	;edx&#x3D;a+2*ecx+4&#x3D;11*a+4</span><br><span class="line">.text:00401014                 push    edx</span><br><span class="line">.text:00401015                 push    offset aDDD     ; &quot;%d %d %d&quot;</span><br><span class="line">.text:0040101A                 call    _printf</span><br><span class="line">.text:0040101F                 xor     eax, eax</span><br><span class="line">.text:00401021                 add     esp, 14h</span><br><span class="line">.text:00401024                 retn</span><br></pre></td></tr></table></figure>





<h5 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h5><p>除法运算符一般为编译为div，idiv指令。除法运算的代价是相当高得，大概需要比乘法运算多消费10倍得CPU时钟。</p>
<p>如果除数是2得幂次方，那么可以用快速得移位指令shr来替换。</p>
<p><strong>shr指令适合进行无符号数计算。若进行符号数计算，则使用sar指令</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a/<span class="number">11</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>未优化汇编指令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ebp			;建立栈</span><br><span class="line">.text:00401001                 mov     ebp, esp</span><br><span class="line">.text:00401003                 push    ecx			;给局部变量分配空间</span><br><span class="line">.text:00401004                 lea     eax, [ebp+var_4]</span><br><span class="line">.text:00401007                 push    eax</span><br><span class="line">.text:00401008                 push    offset aD_0     ; &quot;%d&quot;</span><br><span class="line">.text:0040100D                 call    _scanf</span><br><span class="line">.text:00401012                 add     esp, 8</span><br><span class="line">.text:00401015                 mov     eax, [ebp+var_4]	;eax中为输入得a值</span><br><span class="line">.text:00401018                 cdq						;将eax得值扩展为4字类型得值</span><br><span class="line">.text:00401019                 mov     ecx, 0Bh			;将除数11(十六进制为0bh)放入ecx</span><br><span class="line">.text:0040101E                 idiv    ecx				;除法运算，商放入eax，余数放入edx</span><br><span class="line">.text:00401020                 push    eax</span><br><span class="line">.text:00401021                 push    offset aD       ; &quot;%d&quot;</span><br><span class="line">.text:00401026                 call    _printf</span><br><span class="line">.text:0040102B                 add     esp, 8</span><br><span class="line">.text:0040102E                 xor     eax, eax</span><br><span class="line">.text:00401030                 mov     esp, ebp</span><br><span class="line">.text:00401032                 pop     ebp</span><br><span class="line">.text:00401033                 retn</span><br></pre></td></tr></table></figure>



<p>优化过后得汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:00401000                 push    ecx	;为局部变量a分配内存</span><br><span class="line">.text:00401001                 lea     eax, [esp+4+var_4]	;将变量a得值赋给ecx</span><br><span class="line">.text:00401005                 push    eax</span><br><span class="line">.text:00401006                 push    offset aD       ; &quot;%d&quot;</span><br><span class="line">.text:0040100B                 call    _scanf</span><br><span class="line">.text:00401010                 mov     ecx, [esp+0Ch+var_4]</span><br><span class="line">.text:00401014                 mov     eax, 2E8BA2E9h	;编译生成得数，用于将除法转换为乘法</span><br><span class="line">.text:00401019                 imul    ecx</span><br><span class="line">.text:0040101B                 sar     edx, 1</span><br><span class="line">.text:0040101D                 mov     ecx, edx</span><br><span class="line">.text:0040101F                 shr     ecx, 1Fh</span><br><span class="line">.text:00401022                 add     edx, ecx</span><br><span class="line">.text:00401024                 push    edx</span><br><span class="line">.text:00401025                 push    offset aD       ; &quot;%d&quot;</span><br><span class="line">.text:0040102A                 call    _printf</span><br><span class="line">.text:0040102F                 xor     eax, eax</span><br><span class="line">.text:00401031                 add     esp, 14h</span><br><span class="line">.text:00401034                 retn</span><br></pre></td></tr></table></figure>





<h3 id="文本字符串"><a href="#文本字符串" class="headerlink" title="文本字符串"></a>文本字符串</h3><h4 id="字符寻址指令"><a href="#字符寻址指令" class="headerlink" title="字符寻址指令"></a>字符寻址指令</h4><p>80x86系统支持寄存器直接寻址与寄存器间接寻址等模式。</p>
<p>mov指令将当前指令所在内存复制并放到目的寄存器中，其操作书可以是常量，也可以是指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[401000h]	;直接寻址，即把地址为00401000h的双字数据放入eax</span><br><span class="line">mov eax,[ecx]		;寄存器间接寻址，即把ecx中的地址所指的内容放入eax</span><br></pre></td></tr></table></figure>

<p><strong>“lea”的意思是”装入有效地址”，它的操作数就是地址，所以”lea eax,[addr]”就是将表达式addr的值放入eax寄存器</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea eax,[401000h]	;将值401000h写入eax寄存器</span><br></pre></td></tr></table></figure>

<p><strong>lea指令右边的操作数表示一个近指针，指令”lea eax,[401000h]与”mov eax,401000h”是等价的</strong></p>
<p>在计算索引与常量的时，编译器一般将指针放在的第一个位置，而不考虑它们在程序中的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr [eax+8],67452301</span><br><span class="line">mov dword ptr [eax+c],EFCDAB89</span><br></pre></td></tr></table></figure>



<p><strong>“lea eax,[eax+8]”等价于”add eax,8”</strong></p>
<h4 id="计算字符串的长度"><a href="#计算字符串的长度" class="headerlink" title="计算字符串的长度"></a>计算字符串的长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax,FFFFFFFF	;如果看到这一句，程序很有可能是要获得字符串的长度</span><br><span class="line">sub eax,eax		;	将eax清零</span><br><span class="line">repnz			;重复串操作，直到ecx&#x3D;0为止</span><br><span class="line">scasb			;把al的内容与edi指向的附加段中的数据逐一比较</span><br><span class="line">not ecx			;ecx&#x3D;字符长度+1</span><br><span class="line">dec ecx			;ecx是真实的长度</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
            <div class="shang_tit">
              <p>纯属好玩</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏，你说多少就多少</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weixin.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">加密与解密-逆向分析技术</a></p>
        <p><span>文章作者:</span><a href="/" title="访问  的个人博客"></a></p>
        <p><span>发布时间:</span>2019年11月25日 - 10时09分</p>
        <p><span>最后更新:</span>2019年12月26日 - 15时35分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" title="加密与解密-逆向分析技术">http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/</a>
            <span class="copy-path" data-clipboard-text="原文: http://systemk1t.github.io/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/　　作者: " title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2019/11/29/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Windows应用程序-文件系统
        
      </div>
    </a>
  
  
    <a href="/2019/11/22/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">加密与解密-静态分析</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E4%BD%8D%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E6%8A%80%E6%9C%AF"><span class="toc-number">1.</span> <span class="toc-text">32位软件逆向技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">启动函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%86%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">函数的识别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">函数的参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">栈传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">寄存器传递参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E4%BF%AE%E9%A5%B0%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">名称修饰约定</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.3.</span> <span class="toc-text">函数的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#return%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">return返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%8C%89%E4%BC%A0%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">参数按传引用方式返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%AD%98%E6%94%BE%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">栈存放局部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%98%E6%94%BE%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">寄存器存放局部变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.</span> <span class="toc-text">控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ZF-%E9%9B%B6%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">ZF 零标志位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">PF 标志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">SF 标志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">CF 标志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OF-%E6%A0%87%E5%BF%97"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">OF 标志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DF%E6%A0%87%E5%BF%97"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">DF标志</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IF-THEL-ELSE%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">IF-THEL-ELSE语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SWITCH-CASE%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.5.3.</span> <span class="toc-text">SWITCH-CASE语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E6%9C%BA%E5%99%A8%E7%A0%81%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.4.</span> <span class="toc-text">转移指令机器码计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%AD%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E6%9C%BA%E5%99%A8%E7%A0%81%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">短转移指令机器码计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%BF%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E6%9C%BA%E5%99%A8%E7%A0%81%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">长转移指令机器码计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.</span> <span class="toc-text">数学运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E6%B3%95%E5%92%8C%E5%87%8F%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">整数的加法和减法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">加法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%98%E6%B3%95"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">乘法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%A4%E6%B3%95"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">除法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.8.</span> <span class="toc-text">文本字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%AF%BB%E5%9D%80%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.1.</span> <span class="toc-text">字符寻址指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">1.8.2.</span> <span class="toc-text">计算字符串的长度</span></a></li></ol></li></ol></li></ol>
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">


<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <div id="gitments"></div>
<script src="/js/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
      id: window.location.pathname,
      owner: 'luuman',
      repo: 'luuman.github.io',
      oauth: {
        client_id: '',
        client_secret: '',
      },
    })
    gitment.render('gitments')
</script>
    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/11/29/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="上一篇: Windows应用程序-文件系统">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2019/11/22/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" title="下一篇: 加密与解密-静态分析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/09/17/c-%E5%A4%9A%E6%80%81/">c++ - 多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/16/C-%E7%BB%A7%E6%89%BF/">C++ - 继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">C++ - 运算符重载</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/14/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">C++ 拷贝构造函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B6%88%E6%81%AF/">Windows程序设计 - 窗口和消息</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/21/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Unicode/">Windows程序设计 - Unicode</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/22/C-Primer-%E5%9F%BA%E7%A1%80/">C++ Primer - 基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%A8%A1%E6%9D%BF/">C反汇编 - 模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/11/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%A4%9A%E6%80%81/">C反汇编 - 多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%BC%95%E7%94%A8/">C反汇编 - 引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/08/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%A0%86%E5%AF%B9%E8%B1%A1/">C反汇编 - 堆对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E7%BB%A7%E6%89%BF/">C反汇编 - 继承</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">C反汇编 - 构造函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-this%E6%8C%87%E9%92%88/">C反汇编 - this指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%B0%81%E8%A3%85/">C反汇编 - 封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E9%A2%84%E5%A4%84%E7%90%86/">C反汇编 - 预处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/">C反汇编 - 函数指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/">C反汇编 - 指针数组与数组指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/05/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88/">C反汇编 - 结构体指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/05/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%8C%87%E9%92%88%E5%8F%96%E5%80%BC/">C反汇编 - 指针取值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/05/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88/">C反汇编 - 字符串指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/05/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/">C反汇编 - 参数传递</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/04/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%8C%87%E9%92%88/">C反汇编 - 指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/03/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E7%BB%93%E6%9E%84%E4%BD%93/">C反汇编 - 结构体</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/02/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%95%B0%E7%BB%84/">C反汇编 - 数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/30/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%88%86%E6%94%AF/">C反汇编 - 分支</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">C反汇编 - 表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%B5%AE%E7%82%B9/">C反汇编 - 浮点</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%95%B4%E5%9E%8B/">C反汇编 - 整型</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%8F%82%E6%95%B0/">C反汇编 - 参数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%8F%98%E9%87%8F/">C反汇编 - 变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%87%BD%E6%95%B0/">C反汇编 - 函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-jcc/">汇编语言 - jcc</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/24/C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E8%A7%A3%E5%AF%86-%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0/">C逆向分析解密 - 启动函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/Cpp%E7%AC%94%E8%AE%B0-%E5%AF%B9C%E7%9A%84%E6%89%A9%E5%B1%95/">Cpp笔记 - 对C的扩展</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/17/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/">Windows核心编程 - 进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/15/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/">Windows核心编程 - 内核对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/14/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/">Windows核心编程 - 字符和字符串处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/14/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">Windows核心编程 - 错误处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/14/Win32%E6%B1%87%E7%BC%96-%E5%AE%9A%E6%97%B6%E5%99%A8/">Win32汇编-定时器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/08/Win32%E6%B1%87%E7%BC%96-%E5%86%85%E5%AD%98%E5%92%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">Win32汇编-内存和文件操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/07/Windows-Assembly-4/">Windows-Assembly-4</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/Windows-Assembly-3/">Windows-Assembly-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/01/%E7%9C%8B%E9%9B%AACrackMe002/">看雪CrackMe002</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/%E7%9C%8B%E9%9B%AACrackMe001/">看雪CrackMe001</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/27/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E6%BC%94%E7%A4%BA%E7%89%88%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/">加密与解密-演示版保护技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/CrackMe002/">CrackMe002</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/20/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-TraceMe/">加密与解密-TraceMes</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/20/CrackMe001/">CrackMe001</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/18/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">Windows应用程序-线程同步</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/13/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E8%BF%9B%E7%A8%8B/">Windows应用程序-进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/12/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B-%E5%B8%B8%E7%94%A8API/">黑客编程-常用API</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/10/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Windows应用程序-内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">Windows应用程序-文件系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">加密与解密-逆向分析技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/22/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/">加密与解密-静态分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/Reverse-Bugku-3/">Reverse-Bugku-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/Reverse-Bugku-2/">Reverse-Bugku-2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/15/Reverse-Bugku-1/">Reverse-Bugku-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90/">加密与解密-动态分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">加密与解密-基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%81%94%E5%90%88%E4%BD%93/">逆向工程权威指南-联合体</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%BB%93%E6%9E%84%E4%BD%93/">逆向工程权威指南-结构体</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BC%AA%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/">逆向工程权威指南-伪随机函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/08/WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E7%BB%9C-IP/">WinSock网络编程经络-IP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E7%BB%9C-TCP-IP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">WinSock网络编程经络-TCP/IP体系结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E7%BB%9C-Echo%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F/">WinSock网络编程经络-Echo客户/服务端程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/">黑客编程-网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-API%E6%A6%82%E8%A6%81/">Windows应用程序-API概要</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E5%85%A5%E9%97%A8/">Windows应用程序-入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B-%E5%85%A5%E9%97%A8/">黑客编程-入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-DLL%E5%8D%B8%E8%BD%BD/">逆向工程核心原理-DLL卸载</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%95%B0%E7%BB%84/">逆向工程权威指南-数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-DLL%E6%B3%A8%E5%85%A5/">逆向工程核心原理-DLL注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E6%B6%88%E6%81%AF%E9%92%A9%E5%AD%90/">逆向工程核心原理-消息钩子</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8/">逆向工程核心原理-键盘记录器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%B5%AE%E7%82%B9%E6%95%B0/">逆向工程权威指南-浮点数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4/">逆向工程权威指南-数学计算指令</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%AD%97%E7%AC%A6%E4%B8%B2/">逆向工程权威指南-字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%BE%AA%E7%8E%AF/">逆向工程权威指南-循环</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/29/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-switch/">逆向工程权威指南-switch</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/28/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%8C%87%E9%92%88/">逆向工程权威指南-指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%BF%94%E5%9B%9E%E5%80%BC/">逆向工程权威指南-返回值</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96/">逆向工程权威指南-参数获取</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-scanf/">逆向工程权威指南-scanf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4/">逆向工程权威指南-栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-printf/">逆向工程权威指南-printf</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%A0%88/">逆向工程权威指南-栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/%E6%8F%92%E5%85%A5DLL%E5%92%8C%E6%8C%82%E9%92%A9%E5%AD%90/">插入DLL和挂钩子</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%99%A8/">线程本地存储器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/11/%E5%86%85%E8%81%94%E9%92%A9%E5%AD%90/">内联钩子</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E6%A0%88%E5%B8%A7/">逆向工程核心原理-栈帧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E6%A0%88/">逆向工程核心原理-栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/03/DLL%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/">DLL高级技术</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/01/DLL%E5%9F%BA%E7%A1%80/">DLL基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-32%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/">逆向工程核心原理-32位寄存器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%80%86%E5%90%91Hello%E7%A8%8B%E5%BA%8F/">逆向工程核心原理-逆向Hello程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/11/PE%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%AF%BC%E5%85%A5%E8%A1%A8/">PE延迟加载导入表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/09/PE%E5%AF%BC%E5%87%BA%E8%A1%A8/">PE导出表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/06/Windows%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Windows内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/05/PE%E5%AF%BC%E5%85%A5%E8%A1%A8/">PE导入表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/Windows-Kernel-15/">Windows-Kernel-15</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/Windows-Kernel-14/">Windows-Kernel-14</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/Windows-Kernel-13/">Windows-Kernel-13</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/Windows-Kernel-9/">Windows-Kernel-9</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/Windows-Kernel-8/">Windows-Kernel-8</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/Assembly-x86-2/">Assembly-x86-2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/01/Assembly-x86-1/">Assembly-x86-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/30/Windows-Kernel-7/">Windows-Kernel-7</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/29/Windows-Assembly-1/">Windows-Assembly-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/28/Windows-Kernel-6/">Windows-Kernel-6</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/27/Windows-Kernel-4/">Windows-Kernel-4</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/24/Windows-Kernel-3/">Windows-Kernel-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/Assembly-2/">Assembly-2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/Assembly-1/">Assembly-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AD%E7%AB%A0/">c语言第六章</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/c%E4%B8%8E%E6%8C%87%E9%92%88-%E7%AC%AC%E5%85%AB%E7%AB%A0/">c与指针-第八章</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/22/c%E4%B8%8E%E6%8C%87%E9%92%88-%E7%AC%AC%E4%B8%83%E7%AB%A0/">c与指针-第七章</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/17/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/">c语言第二章</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/17/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E7%AB%A0/">c语言第五章</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/16/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/">C语言第四章</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/15/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/">C语言第三章</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/13/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%80%E7%AB%A0/">c语言第一章</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 sYstemk1t
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/luuman/hexo-theme-spfk" target="_blank">spfk</a> by luuman
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >海贼到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>