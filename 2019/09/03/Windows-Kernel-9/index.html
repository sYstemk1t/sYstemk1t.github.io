<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Windows-Kernel-9 - sYstemk1t&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="sYstemk1t"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="sYstemk1t"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="线程与内核对象的同步"><meta property="og:type" content="blog"><meta property="og:title" content="Windows-Kernel-9"><meta property="og:url" content="http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/"><meta property="og:site_name" content="sYstemk1t&#039;s blog"><meta property="og:description" content="线程与内核对象的同步"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/0.png"><meta property="og:image" content="http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/1.png"><meta property="og:image" content="http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/2.png"><meta property="og:image" content="http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/3.png"><meta property="og:image" content="http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/4.png"><meta property="article:published_time" content="2019-09-03T06:12:32.000Z"><meta property="article:modified_time" content="2019-09-03T09:56:05.154Z"><meta property="article:author" content="sYstemk1t"><meta property="article:tag" content="Windows-Kernel"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2019/09/03/Windows-Kernel-9/0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/"},"headline":"sYstemk1t's blog","image":["http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/0.png","http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/1.png","http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/2.png","http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/3.png","http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/4.png"],"datePublished":"2019-09-03T06:12:32.000Z","dateModified":"2019-09-03T09:56:05.154Z","author":{"@type":"Person","name":"sYstemk1t"},"description":"线程与内核对象的同步"}</script><link rel="canonical" href="http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="fontawesome"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/head.jpg" alt="sYstemk1t&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-03T06:12:32.000Z" title="2019-09-03T06:12:32.000Z">2019-09-03</time>发表</span><span class="level-item"><time dateTime="2019-09-03T09:56:05.154Z" title="2019-09-03T09:56:05.154Z">2019-09-03</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Windows核心编程</a></span><span class="level-item">38 分钟读完 (大约5677个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Windows-Kernel-9</h1><div class="content"><h1 id="线程与内核对象的同步"><a href="#线程与内核对象的同步" class="headerlink" title="线程与内核对象的同步"></a>线程与内核对象的同步</h1><a id="more"></a>

<p>用户模式下的线程同步高性能，但是存在一些局限。例如无法进行进程间线程的同步，Iterlocked系函数不会把线程切换到等待状态，</p>
<p>进入临界区无法设置最长等待时间等。</p>
<p>内核对象来进行线程同步，功能强大许多。但是唯一的缺点就是性能。</p>
<p>对于线程内核对象可能处于触发（signaled）和未触发（nosignaled）</p>
<p>进程内核对象，在创建时其内部有一个BOOL变量是FALSE， 单进程终止时该内核对象会变成TRUE 表示已经触发</p>
<p>但是这个过程是不可逆的。</p>
<p>以下列出可能处于未触发也可以处于触发状态的内核对象：</p>
<p>进程，线程，作业，文件以及控制台的标准输入流/输出流/错误流</p>
<p>事件，可等待的计时器， 信号量，互斥量</p>
<h2 id="等待函数"><a href="#等待函数" class="headerlink" title="等待函数"></a>等待函数</h2><p>等待函数可使线程自愿进入等待状态，直到一个特定的内核对象变为已通知状态。</p>
<p>WaitForSingleObject:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObject&#123;</span><br><span class="line">    HANDLE hObject,</span><br><span class="line">    DWORD dwMilliseconds</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>当线程调用该函数时，第一个参数hObject标识一个能够支持被通告/未通告的内核对象。</p>
<p>第二个参数dwMilliseconds允许该线程指明，为了等待该对象变为已通知状态，它将等待多久。</p>
<p>INFINITE是作为第二个参数传递给WaitForSingleObject，直到该进程终止运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DWORD dw = WaitForSingleObject(hProcess,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">switch</span>(dw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> WAIT_OBJECT_0:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WaitForSingleObject的返回值表示为什么调用线程又能继续执行了。</p>
<p>WaitForMultipleObjects与WaitForSingleObject函数相似，区别于允许调用线程的同时查看若干个内核对象的已通知状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD dwCount,</span></span></span><br><span class="line"><span class="function"><span class="params">    CONST HANDLE* phObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL fWaitAll,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>dwCount参数在用于指明要让函数查看的内核对象的数量。这个值介于1-64；</p>
<p>phObjects参数是指向内核对象句柄的数组的指针；</p>
<p>fWaitAll参数高速该函数，你想以何种方式调用，如果传递未TRUE，那么在所有对象变为已通知之前，该函数不允许调用线程运行；</p>
<p>dwMilliseconds函数的作用是如果在等待的时候规定的时间到了，那么该函数无论如何都返回。</p>
<p>WaitForMultipleObjects的返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h[<span class="number">3</span>];</span><br><span class="line">h[<span class="number">0</span>] = hProcess1;</span><br><span class="line">h[<span class="number">1</span>] = hProcess2;</span><br><span class="line">h[<span class="number">2</span>] = hProcess3;</span><br><span class="line">DWORD dw = WaitForMultipleObjects(<span class="number">3</span>, h, FALSE, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">switch</span> (dw) &#123;</span><br><span class="line"><span class="keyword">case</span> WAIT_FAILED:</span><br><span class="line">	<span class="comment">// Bad call to function (invalid handle?)</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WAIT_TIMEOUT:</span><br><span class="line">	<span class="comment">// None of the objects became signaled within 5000 milliseconds.</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0 + <span class="number">0</span>:</span><br><span class="line">	<span class="comment">// The process identified by h[0] (hProcess1) terminated.</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0 + <span class="number">1</span>:</span><br><span class="line">	<span class="comment">// The process identified by h[1] (hProcess1) terminated.</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WAIT_OBJECT_0 + <span class="number">2</span>:</span><br><span class="line">	<span class="comment">// The process identified by h[2] (hProcess1) terminated.</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果给bWaitAll传递TRUE那么所有内核对象都触发了以后返回值WAIT_OBJECT_0</p>
<h2 id="成功等待的副作用"><a href="#成功等待的副作用" class="headerlink" title="成功等待的副作用"></a>成功等待的副作用</h2><p>成功的调用WaitForMultipleObjects和WaitForSingleObject，实际上会改变对象的状态。成功的调用是指函数发现对象已经得到通知并且返回一个相对于WAIT_OBJECT_0的值，如果返回WAIT_TIMEOUT或WAIT_FAILED,那么调用就没有成功，没有成功的调用，内核状态也不会有任何改变。</p>
<p>当一个线程调度WaitForMultipleObjects的时候，该函数能测试所有对象的通知状态，并且能够将所有必要的副作用作为一项操作来执行。</p>
<p>两个线程相同的方式调用WaitForMultipleObjects:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE h[<span class="number">2</span>];</span><br><span class="line">h[<span class="number">0</span>] = hAutoResetEvent1;</span><br><span class="line">h[<span class="number">1</span>] = hAutoResetEvent2;</span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>,h,TRUE,INFINITE);</span><br></pre></td></tr></table></figure>



<ul>
<li>两个线程相同的代码</li>
<li>其中一个线程的状态被修改为已通知状态，两个线程都发现，该时间已经变成了已通知，但无法唤醒，所以线程继续等待</li>
<li>另外一个线程的状态也已经被触发，其中一个线程检测到两个事件都触发以后，将两个线程又重新设置为非触发状态并返回</li>
<li>另一个线程会继续等待直到两个事件同时触发为止</li>
</ul>
<p>WaitForMultipleObjects是以原子操做的方式工作的，当他检查内核对象的状态时，任何其他线程都不能在背后修改对象的状态。这就防止了死锁的发生。</p>
<h2 id="事件内核对象"><a href="#事件内核对象" class="headerlink" title="事件内核对象"></a>事件内核对象</h2><p>事件包含一个使用计数器，一个用来标识事件是自动重置还是手动重置的布尔值，以及另一个布尔值用来表示事件有没有被触发。</p>
<p>当一个手动重置事件被触发的时候，正在等待该事件的所有线程都变成可调度状态。</p>
<p>当一个自动重置事件被触发时，只有一个正在等待该事件的线程会变成可调度状态。</p>
<p>事件常用于让一个线程执行初始化工作，然后再触发另一个线程，让它执行剩余的工作。</p>
<p>下面是CreateEvent函数，用于创建内核事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	PSECURITY_ATTRIBUTES psa,</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL fManmulReset,</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL fInitalState,</span></span></span><br><span class="line"><span class="function"><span class="params">    PCTSTR pszName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>fManmulReset的参数是个布尔值，它高速系统创建一个人工重置（TRUE）的事件还是自动重置（FALSE）的事件。</p>
<p>fInitalState参数用于指明该事件是要初始化为已通知（TRUE）或未通知（FALSE）。</p>
<p>CreateEvent就将与进程相关的句柄返回给事件对象。</p>
<p><strong>其他进程中的线程可以获得该对象的访问权，方法是使用pszName参数中传递相同的值，使用继承性</strong></p>
<p>还有一个CreateEventEx函数用于创建事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateEventExW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes,</span><br><span class="line">    _In_opt_ LPCWSTR lpName,</span><br><span class="line">    _In_ DWORD dwFlags,</span><br><span class="line">    _In_ DWORD dwDesiredAccess</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>dwFlags参数可以接受两个位的掩码</p>
<p><img src="/2019/09/03/Windows-Kernel-9/0.png"></p>
<p>打开这个内核对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	DWORD fdwAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">    BOOL fInherit,</span></span></span><br><span class="line"><span class="function"><span class="params">    PCTSTR pszName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>打开一定要记得关闭，CloseHandle函数</strong></p>
<p>一旦我们不需要事件内核对象的时候调用closehandlel来关闭。通过调用SetEvent可以直接控制它的状态，变成触发状态，使用ResetEvent使得事件变成未触发状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetEvent（HANDLE hEvent）；  <span class="comment">//已通知</span></span><br><span class="line"><span class="function">BOOL <span class="title">ResetEvent</span><span class="params">(HANDLE hEvent)</span></span>;    <span class="comment">//未通知</span></span><br></pre></td></tr></table></figure>



<p>自动事件由于等待成功所引起的副作用的影响，当事件被线程等待以后会自动设置为非触发，因此不需要ResetEvent。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">HANDLE g_hEvent;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WordCount</span><span class="params">(PVOID pvParam)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Wait until the file&#x27;s data is in memory.</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Access the memory block.</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SpellCheck</span><span class="params">(PVOID pvParam)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Wait until the file&#x27;s data is in memory.</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Access the memory block.</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">GrammarCheck</span><span class="params">(PVOID pvParam)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Wait until the file&#x27;s data is in memory.</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Access the memory block.</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[], TCHAR * env[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Crate the manual-reset, nosignaled event.</span></span><br><span class="line">	g_hEvent = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Spawn 3 new threads.</span></span><br><span class="line">	HANDLE hThread[<span class="number">3</span>];</span><br><span class="line">	DWORD dwThreadID;</span><br><span class="line">	hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WordCount, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line">	hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, SpellCheck, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line">	hThread[<span class="number">2</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, GrammarCheck, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadID);</span><br><span class="line"> </span><br><span class="line">	OpenFileAndReadContentsIntoMemory(...);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Allow all 3 threads to access the memory.</span></span><br><span class="line">	SetEvent(g_hEvent);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里使用了手动重置事件，所以当主线程准备好数据以后3个子线程都能同时运行。</p>
<p>如果使用自动重置事件，那么3个子线程只会有一个能继续运行。为了让3个子线程都能执行代码，修改了一下3个子线程的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">WordCount</span><span class="params">(PVOID pvParam)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Wait until the file&#x27;s data is in memory.</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Access the memory block.</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	SetEvent(g_hEvent);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SpellCheck</span><span class="params">(PVOID pvParam)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Wait until the file&#x27;s data is in memory.</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Access the memory block.</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	SetEvent(g_hEvent);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">GrammarCheck</span><span class="params">(PVOID pvParam)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Wait until the file&#x27;s data is in memory.</span></span><br><span class="line">	WaitForSingleObject(g_hEvent, INFINITE);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Access the memory block.</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	SetEvent(g_hEvent);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个3个线程都会被系统调用，而且每个线程都能独占的读写资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PulseEvent</span><span class="params">(HANDLE hEvent)</span></span>;</span><br></pre></td></tr></table></figure>



<p>将一个事件变成触发状态以后立即恢复到未触发状态。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhou191954/article/details/13614903">Handshake</a></p>
<h2 id="等待定时器内核对象"><a href="#等待定时器内核对象" class="headerlink" title="等待定时器内核对象"></a>等待定时器内核对象</h2><p>可等待的计时器是这样一种内核对象：他们会在某个指定的时间触发，或每间隔一段时间触发。</p>
<p>创建一个可等待的计时器使用CreateWaitableTimerW</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateWaitableTimerW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpTimerAttributes,</span><br><span class="line">    _In_     BOOL bManualReset,</span><br><span class="line">    _In_opt_ LPCWSTR lpTimerName</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>





<p>打开一个可等待的计数器</p>
<p>OpenWaitableTimerW</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenWaitableTimerW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpTimerName</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>bManualReset表示要创建的是手动重置还是自动重置的计时器。</p>
<p>手动重置，等待该计时器的所有线程都变成可调度状态</p>
<p>自动重置，只有一个等待该计时器的线程会变成可调度状态</p>
<p>调用SetWaitableTimer设置计时器，能让其触发</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">SetWaitableTimer(</span><br><span class="line">    _In_ HANDLE hTimer,</span><br><span class="line">    _In_ <span class="keyword">const</span> LARGE_INTEGER * lpDueTime,</span><br><span class="line">    _In_ LONG lPeriod,</span><br><span class="line">    _In_opt_ PTIMERAPCROUTINE pfnCompletionRoutine,</span><br><span class="line">    _In_opt_ LPVOID lpArgToCompletionRoutine,</span><br><span class="line">    _In_ BOOL fResume</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>



<p>Timer ：计时器内核对象句柄</p>
<p>pDueTime ： 计时器第一次触发的时间应该在什么时候</p>
<p>lPeriod：计时器在第一次触发以后应该以怎样的频度触发。</p>
<p>例如以下代码把计时器第一次触发时间设为2019年9月3日下午6:00，以后每间隔6小时触发一次：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare our local variables.</span></span><br><span class="line">HANDLE				hTimer;</span><br><span class="line">SYSTEMTIME			st;</span><br><span class="line">FILETIME			ftLocal, ftUTC;</span><br><span class="line">LARGE_INTEGER		liUTC;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an auto-reset timer.</span></span><br><span class="line">hTimer = CreateWaitableTimer(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// First signaling is a January 1, 2018, at 1:00 P.M. (local time).</span></span><br><span class="line">st.wYear			= <span class="number">2019</span>;	<span class="comment">// Year</span></span><br><span class="line">st.wMonth			= <span class="number">9</span>;	<span class="comment">// January</span></span><br><span class="line">st.wDayOfWeek		= <span class="number">3</span>;	<span class="comment">// Ignored</span></span><br><span class="line">st.wDay				= <span class="number">6</span>;	<span class="comment">// The first of the month</span></span><br><span class="line">st.wHour			= <span class="number">13</span>;	<span class="comment">// 1PM</span></span><br><span class="line">st.wMinute			= <span class="number">0</span>;	<span class="comment">// 0 minutes into the hour</span></span><br><span class="line">st.wSecond			= <span class="number">0</span>;	<span class="comment">// 0 seconds into the minute</span></span><br><span class="line">st.wMilliseconds	= <span class="number">0</span>;	<span class="comment">// 0 milliseconds into the second</span></span><br><span class="line"></span><br><span class="line">SystemTimeToFileTime(&amp;st, &amp;ftLocal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convet local time to UTC time.</span></span><br><span class="line">LocalFileTimeToFileTime(&amp;ftLocal, &amp;ftUTC);</span><br><span class="line"><span class="comment">// Convert FILETIME to LARGE_INTEGER because of different alignment.</span></span><br><span class="line">liUTC.LowPart = ftUTC.dwLowDateTime;</span><br><span class="line">liUTC.HighPart = ftUTC.dwHighDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the timer.</span></span><br><span class="line">SetWaitableTimer(hTimer, &amp;liUTC, <span class="number">6</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE);</span><br></pre></td></tr></table></figure>

<p>注意这里有一个FILETIME 和LARGE_INTEGER结构转换的问题</p>
<p>因为前者是32位对齐，后者是64位对齐。如果直接传递可能会导致对齐错误抛出一个（EXCEPTION_DATATYPE_MISALIGNMENT异常）</p>
<p>还可以给pDueTime传入一个相对时间，给其传入负值。（100纳秒的整数倍）</p>
<p>1秒 = 1000 毫秒 = 1000 000 微妙 = 10 000 000 （个 100 纳秒）</p>
<p>以下例子把计时器第一次触发时间设置为SetWaitableTimer调用结束的5秒钟后；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare our local variables.</span></span><br><span class="line">HANDLE				hTimer;</span><br><span class="line">LARGE_INTEGER		li;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an auto-reset timer.</span></span><br><span class="line">hTimer = CreateWaitableTimer(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the timer to go off 5 seconds after calling SetWaitableTimer.</span></span><br><span class="line"><span class="comment">// Timer unit is 100 nanoseconds.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nTimerUnitsPerSecond = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Negate the time so that SetWaitableTimer knows we</span></span><br><span class="line"><span class="comment">// want relative time instead of absolute time.</span></span><br><span class="line">li.QuadPart = -(<span class="number">5</span> * nTimerUnitsPerSecond);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the timer.</span></span><br><span class="line">SetWaitableTimer(hTimer, &amp;li, <span class="number">6</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>,</span><br><span class="line">	<span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE);</span><br></pre></td></tr></table></figure>



<p>对于一次性计时器，只要给lPeriod 传递0 。然后调用CloseHandle关闭计时器即可。 或者调用SetWaitableTimer来重置计时器。</p>
<p>bResume（TRUE） 会使的计算机结束挂起模式（如果机器处于挂起模式下）并唤醒等待该计时器的线程。</p>
<p>FALSE 计时器会被触发，但是在机器继续执行前（挂起状态），被唤醒的线程都得不到CPU时间。</p>
<p>取消计时器内核对象句柄所对应的计时器：CancelWaitableTimer</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">CancelWaitableTimer(</span><br><span class="line">    _In_ HANDLE hTimer</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>另外每次调用SetWaitableTimer都会重置计时器。</p>
<p>一个倒计时的例子。从9倒计时到0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Shlobj.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Declare our local variables.</span></span><br><span class="line">HANDLE				hTimer;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __stdcall <span class="title">OnTimer</span><span class="params">(<span class="keyword">void</span> * param)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nCount = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span> (nCount--) &#123;</span><br><span class="line">		WaitForSingleObject(hTimer, INFINITE);</span><br><span class="line">		_tprintf(TEXT(<span class="string">&quot;count:\t%d\n&quot;</span>), nCount);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[], TCHAR * env[])</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">	LARGE_INTEGER		li;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create an auto-reset timer.</span></span><br><span class="line">	hTimer = CreateWaitableTimer(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Set the timer to go off 5 seconds after calling SetWaitableTimer.</span></span><br><span class="line">	<span class="comment">// Timer unit is 100 nanoseconds.</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> nTimerUnitsPerSecond = <span class="number">10000000</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Negate the time so that SetWaitableTimer knows we</span></span><br><span class="line">	<span class="comment">// want relative time instead of absolute time.</span></span><br><span class="line">	li.QuadPart = -(<span class="number">5</span> * nTimerUnitsPerSecond);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Set the timer.</span></span><br><span class="line">	SetWaitableTimer(hTimer, &amp;li, <span class="number">1000</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the OnTimer Thread</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ThreadID;</span><br><span class="line">	HANDLE hThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, OnTimer, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;ThreadID);</span><br><span class="line"> </span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>





<p><img src="/2019/09/03/Windows-Kernel-9/1.png"></p>
<h3 id="让可等待的计时器添加APC调用"><a href="#让可等待的计时器添加APC调用" class="headerlink" title="让可等待的计时器添加APC调用"></a>让可等待的计时器添加APC调用</h3><p>APC异步过程调用（asynchronous procedure call）</p>
<p>SetWaitableTimer允许传入一个APC过程，触发了计时器会调用该过程。</p>
<p>当计时器触发时，当且仅当SetWaitableTimer调用的线程处于可提醒状态（Alertable stabe）（SleepEx, WaitForSingleObjectEx, WaitForMultipleObjectEx, MsgWaitForMultipleObjectEx,SignalObjectAndWait而进入的状态）</p>
<p>如果非处于可提醒状态，系统不会把计时器的APC函数添加到队列中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TimerAPCRoutine.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetSystemTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">TimerAPCRoutinue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_opt_ LPVOID lpArgToCompletionRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_     DWORD  dwTimerLowValue,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_     DWORD  dwTimerHighValue</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LARGE_INTEGER DueTime;</span><br><span class="line">	DueTime.QuadPart = <span class="number">-30</span>;</span><br><span class="line"></span><br><span class="line">	HANDLE TimeHandle = <span class="literal">NULL</span>;</span><br><span class="line">	TimeHandle =</span><br><span class="line">		CreateWaitableTimer(</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="comment">//TRUE, //BOOL  bManualReset</span></span><br><span class="line">		FALSE,</span><br><span class="line">		<span class="literal">NULL</span></span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!SetWaitableTimer(</span><br><span class="line">		TimeHandle,</span><br><span class="line">		&amp;DueTime, <span class="comment">//第一次，The time after which the state of the timer is to be set to signaled</span></span><br><span class="line">		<span class="number">1000</span>, <span class="comment">//第二次执行与第一次执行的间隔   周期 1秒       The period of the timer</span></span><br><span class="line">		TimerAPCRoutinue,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span></span><br><span class="line">		)</span><br><span class="line">		)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;SetWaitableTimer FAIL: %d  \r\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进入可提醒状态  可提醒IO </span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	while (1)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	WaitForSingleObjectEx(TimeHandle, INFINITE,TRUE);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//这里的话只能走2次，应该是等待时间的问题</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	指针放到APC中，还没有执行，后面一次就来了。要使用SleepEx</span></span><br><span class="line"><span class="comment">	感觉这里WaitFoeSingleObjectEx 不同的地方</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//WaitForSingleObjectEx(TimeHandle, INFINITE,TRUE); //阻塞不住</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		windows核心编程 p250</span></span><br><span class="line"><span class="comment">		线程不应该在等待一个计时器句柄的同时以可提醒的方式等待同一个计时器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		HANDLE hTimer = CreateWaitableTimer(NULL,FALSE,NULL);</span></span><br><span class="line"><span class="comment">		SetWaitableTimer(hTimer,...,TimerAPCRoutinyr,...);</span></span><br><span class="line"><span class="comment">		WaitForSingleObjectEx(hTimer,INFINTE,TRUE);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		我们不应该编写此类代码，因为对WaitForSingleObjectEx的调用</span></span><br><span class="line"><span class="comment">		实际上会等待计时器两次：一次是可提醒的，另一次是内核对象句柄。</span></span><br><span class="line"><span class="comment">		当计时器被触发的时候，等待成功，线程被唤醒，这使线程退出可提醒状态</span></span><br><span class="line"><span class="comment">		APC函数没有被调用。我们一般很少有理由要在使用可等待计时器的同时使用APC函数，</span></span><br><span class="line"><span class="comment">		因为我们总是可以先等待计时器被触发，然后在执行我们想要的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		SleepEx(</span><br><span class="line">			INFINITE,     <span class="comment">// Wait forever</span></span><br><span class="line">			TRUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;input any key to exit\r\n&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">TimerAPCRoutinue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_opt_ LPVOID lpArgToCompletionRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_     DWORD  dwTimerLowValue,</span></span></span><br><span class="line"><span class="function"><span class="params">	_In_     DWORD  dwTimerHighValue</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GetSystemTime();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetSystemTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">time_t</span> t = time(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">	strftime(tmp, <span class="keyword">sizeof</span>(tmp), <span class="string">&quot;%Y/%m/%d %X %A 本年第%j天 %z&quot;</span>, localtime(&amp;t));</span><br><span class="line">	<span class="built_in">puts</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2019/09/03/Windows-Kernel-9/2.png"></p>
<p>不应该同时使用等待函数又同时以可提醒的方式等待一个计时器。</p>
<p>例如</p>
<p>SetWaitableTimer(hTimer,…, TimerAPCRountine,…);</p>
<p>WaitForSingleObjectEx(hTimer, INFINITE, TRUE);</p>
<h3 id="计时器的剩余问题"><a href="#计时器的剩余问题" class="headerlink" title="计时器的剩余问题"></a>计时器的剩余问题</h3><p>在通信协议中会大量用到计时器，但是通常为每个请求创建计时器内核对象，将严重影响系统性能。</p>
<p>有一个CreateThreadpoolTimer可以创建线程池函数对应的计时器。</p>
<p>大多数应用程序不使用APC， 而是使用IO完成端口</p>
<p>用户计时器SetTimer ：在应用程序中使用大量的用户界面基础设置，从而消费更多的资源。而且通过消息机制触发，只有一个线程能得到通知</p>
<p>（WM_TIMER不一定准时，因为其具有最低的优先级）</p>
<p>可等待计时器是内核对象，可以在多个线程间共享。多个线程可以得到通知。</p>
<h2 id="信号内核对象"><a href="#信号内核对象" class="headerlink" title="信号内核对象"></a>信号内核对象</h2><p>信号量内核对象用来对资源进行计数，除了使用计数器。还包含（32bit值）一个最大资源计数和当前资源计数。</p>
<p>如果当前资源计数大于0，信号量处于触发状态。</p>
<p>如果当前资源计数等于0，信号量处于未触发状态。</p>
<p>  创建信号量的函数CreateSemaphoreW</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateSemaphoreW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,</span><br><span class="line">    _In_     LONG lInitialCount,</span><br><span class="line">    _In_     LONG lMaximumCount,</span><br><span class="line">    _In_opt_ LPCWSTR lpName</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>





<p>psa pszName 参阅第三章</p>
<p>dwFlags是系统保留的设为0.</p>
<p>参数lMaximumCount 系统能够处理的资源的最大数量lInitialCoun</p>
<p>初始化有多少资源可用。例如给服务器进程初始化，没有客户端请求，因此使用一下代码来调用CreateSemaphore</p>
<p>HANDLE hSemaphore = CreateSemaphore(NULL, 0, 5, NULL);</p>
<p>打开一个信号量openSemaphore</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenSemaphoreW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpName</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>dwDesiredAccess参数指定访问权限</p>
<p>线程通过调用ReleaseSemahore来递增信号量的当前资源计数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">ReleaseSemaphore(</span><br><span class="line">    _In_ HANDLE hSemaphore,</span><br><span class="line">    _In_ LONG lReleaseCount,</span><br><span class="line">    _Out_opt_ LPLONG lpPreviousCount</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>





<p>lReleaseCount 的值会加到信号量当前资源计数上。</p>
<h2 id="互斥量内核对象"><a href="#互斥量内核对象" class="headerlink" title="互斥量内核对象"></a>互斥量内核对象</h2><p>互斥量（mutex）内核对象用来确保一个线程独占一个资源的访问。</p>
<p>互斥量与临界区的行为完全相同。（内部保护递归计数）</p>
<p>互斥量的规则：</p>
<ul>
<li>如果线程ID为0，那么互斥量不为任何线程所占用，它处于触发状态</li>
<li>如果线程ID为非零值，那么一个线程已经占用了该互斥量，它处与未触发状态。</li>
<li>与所有其他内核对象不同，操作系统对互斥量进行了特殊处理，允许它们违反一些常规的规则。（递归计数器的存在，运行同一个线程ID多次进入）</li>
</ul>
<p>创建互斥量的函数CreateMutexW：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateMutexW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes,</span><br><span class="line">    _In_ BOOL bInitialOwner,</span><br><span class="line">    _In_opt_ LPCWSTR lpName</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>



<p>bInitialOwner控制互斥量的初始状态。FALSE， 互斥量的线程ID和递归计数都被设为0.处于触发状态。</p>
<p>给bInitialOwner穿TRUE，那么对象的线程ID被设为调用线程的ID，递归计数器被设为1.（未触发状态）</p>
<p>或者使用CreateMutexEx:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateMutexExW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes,</span><br><span class="line">    _In_opt_ LPCWSTR lpName,</span><br><span class="line">    _In_ DWORD dwFlags,</span><br><span class="line">    _In_ DWORD dwDesiredAccess</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>dwDesiredAccess指定访问权限</p>
<p>dwFlags（代替bInitialOwned） 0表示FALSE，  CREATE_MUTEX_INITIAL_OWNER等价于TRUE</p>
<p>另一个进程可以调用OpenMutex来得到一个已经存在的互斥量句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenMutexW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpName</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>



<p>BOOL ReleaseMutex(HANDLE hMutex); </p>
<p>使互斥量对象的递归计数器减1， 当递归计数器为0时，还会设置线程ID为0，这就触发了对象。</p>
<h3 id="释放问题"><a href="#释放问题" class="headerlink" title="释放问题"></a>释放问题</h3><p>互斥量具有线程所有权的功能，即使未触发也能多次进入。</p>
<p>如果占用互斥量的线程在释放互斥量之前终止（ExitThread ，TerminateThread ，ExitProcess 或TerminateProcess）</p>
<p>系统认为互斥量被遗弃（abandoned） 此时会自动将互斥量线程ID设为0，递归计数器设为0，并检查有没有正在等待该互斥量的线程。</p>
<p>等待函数返回WAIT_ABANDONED(只适用互斥量）</p>
<h3 id="互斥对象与关键代码段的比较"><a href="#互斥对象与关键代码段的比较" class="headerlink" title="互斥对象与关键代码段的比较"></a>互斥对象与关键代码段的比较</h3><p><img src="/2019/09/03/Windows-Kernel-9/3.png"></p>
<p>互斥量的任意时间长度等待修正为： WaitForSingleObject(hmtx, dwMilliseconds);</p>
<h2 id="线程同步对象速查表"><a href="#线程同步对象速查表" class="headerlink" title="线程同步对象速查表"></a>线程同步对象速查表</h2><p><img src="/2019/09/03/Windows-Kernel-9/4.png"></p>
<h2 id="其他的线程同步函数"><a href="#其他的线程同步函数" class="headerlink" title="其他的线程同步函数"></a>其他的线程同步函数</h2><p>Wa i t F o r S i n g l e O b j e c t和Wa i t F o r M u l t i p l e O b j e c t s是进行线程同步时使用得最多的函数。但是，Wi n d o w s还提供了另外几个稍有不同的函数。</p>
<h3 id="异步设备I-O"><a href="#异步设备I-O" class="headerlink" title="异步设备I/O"></a>异步设备I/O</h3><p>步设备IO（asynchronous device I/O）允许线程开始读取操作或写入操作，但不必等待读取操作或写入操作完成。</p>
<p>设备对象是是可同步的内核对象，可以调用WaitForSingleObject并传入句柄，套接字，通信端口等。</p>
<h3 id="WaitForInputIdle"><a href="#WaitForInputIdle" class="headerlink" title="WaitForInputIdle"></a>WaitForInputIdle</h3><p>线程可以调用此函数将自己挂起</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">WaitForInputIdle(</span><br><span class="line">    _In_ HANDLE hProcess,</span><br><span class="line">    _In_ DWORD dwMilliseconds);</span><br></pre></td></tr></table></figure>



<p>常用于等待子进程，父进程知道子进程已经初始化完毕的唯一方法，就是等待子进程，直到它不再处理任何输入为止。</p>
<p>当我们要强制在应用程序中输入一些按键的时候，也可以使用WaitForInputIdle。</p>
<p>当向目标进程发送一系列按键消息以后，调用WaitForInputIdle等待其处理完按键消息，然后再发送后续的按键消息。</p>
<h3 id="MsgWaitForMultipleObjects-Ex"><a href="#MsgWaitForMultipleObjects-Ex" class="headerlink" title="MsgWaitForMultipleObjects(Ex)"></a>MsgWaitForMultipleObjects(Ex)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">MsgWaitForMultipleObjects(</span><br><span class="line">    _In_ DWORD nCount,</span><br><span class="line">    _In_reads_opt_(nCount) CONST HANDLE *pHandles,</span><br><span class="line">    _In_ BOOL fWaitAll,</span><br><span class="line">    _In_ DWORD dwMilliseconds,</span><br><span class="line">    _In_ DWORD dwWakeMask);</span><br><span class="line"> </span><br><span class="line">WINUSERAPI</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">MsgWaitForMultipleObjectsEx(</span><br><span class="line">    _In_ DWORD nCount,</span><br><span class="line">    _In_reads_opt_(nCount) CONST HANDLE *pHandles,</span><br><span class="line">    _In_ DWORD dwMilliseconds,</span><br><span class="line">    _In_ DWORD dwWakeMask,</span><br><span class="line">    _In_ DWORD dwFlags);</span><br></pre></td></tr></table></figure>

<p>函数功能:阻塞时仍可以响应消息</p>
<p>MsgWaitForMultipleObjects()函数类似WaitForMultipleObjects()，</p>
<p>但它会在“对象被激发”或“消息到达队列”时被唤醒而返回。</p>
<p>MsgWaitForMultipleObjects()多接收一个参数，允许指定哪些消息是观察对象。<br>一个应用的例子 该函数同时等待对象，若有消息到底也返回。运行主线程处理消息后继续等待。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">MSG msg;</span><br><span class="line">DWORD dwStartTime = GetTickCount();</span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//超时判断  5s  </span></span><br><span class="line">	dwRet = GetTickCount() - dwStartTime;</span><br><span class="line">	<span class="keyword">if</span> ((GetTickCount() - dwStartTime) &gt; <span class="number">10000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		AfxMessageBox(_T(<span class="string">&quot;获取数据超时，请检测设备网络连接!&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//wait for m_hThread to be over，and wait for    </span></span><br><span class="line">	<span class="comment">//QS_ALLINPUT（Any message is in the queue）   </span></span><br><span class="line">	<span class="comment">//dwRet = WaitForSingleObject(g_hRetEvent, INFINITE);  </span></span><br><span class="line">	dwRet = MsgWaitForMultipleObjects(<span class="number">1</span>, &amp;g_hRetEvent, FALSE, <span class="number">100</span>, QS_ALLINPUT);</span><br><span class="line">	<span class="keyword">switch</span> (dwRet)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WAIT_OBJECT_0: <span class="comment">//返回数据达到  </span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//break the loop    </span></span><br><span class="line">	<span class="keyword">case</span> WAIT_OBJECT_0 + <span class="number">1</span>: <span class="comment">//界面消息  </span></span><br><span class="line">		<span class="comment">//get the message from Queue    </span></span><br><span class="line">		<span class="comment">//and dispatch it to specific window    </span></span><br><span class="line">		<span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE))</span><br><span class="line">		&#123;</span><br><span class="line">			TranslateMessage(&amp;msg);</span><br><span class="line">			DispatchMessage(&amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">case</span> WAIT_TIMEOUT: <span class="comment">//超时  </span></span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		AfxMessageBox(_T(<span class="string">&quot;数据获取失败，未知错误!&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">// unexpected failure    </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="WaitForDebugEvent"><a href="#WaitForDebugEvent" class="headerlink" title="WaitForDebugEvent"></a>WaitForDebugEvent</h3><p>调试器Attach到被调试程序以后，调用WaitForDebugEvent来等待调试事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">APIENTRY</span><br><span class="line">WaitForDebugEvent(</span><br><span class="line">    _Out_ LPDEBUG_EVENT lpDebugEvent,</span><br><span class="line">    _In_ DWORD dwMilliseconds</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>





<h3 id="SignalObjectAndWait函数"><a href="#SignalObjectAndWait函数" class="headerlink" title="SignalObjectAndWait函数"></a>SignalObjectAndWait函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">DWORD</span><br><span class="line">WINAPI</span><br><span class="line">SignalObjectAndWait(</span><br><span class="line">    _In_ HANDLE hObjectToSignal,</span><br><span class="line">    _In_ HANDLE hObjectToWaitOn,</span><br><span class="line">    _In_ DWORD dwMilliseconds,</span><br><span class="line">    _In_ BOOL bAlertable</span><br><span class="line">    );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用一个原子操作来触发一个内核对象，并等待另一个内核对象。<br>hObjectToSignal必须是一个互斥量，信号量或事件。（其他任何对象将导致函数返回WAIT_FAILD）调用GetLastError返回ERROR_INVALID_HANDLE.</p>
<p>hObjectToWaitOn可以是互斥量，信号量，事件，进程，线程，作业，控制台输入变更通知，作业。等等</p>
<p>dwMilliseconds 函数最多花多长时间来等待。</p>
<p>bAlertable表示当线程处于等待状态的时候，是否能够堆添加到队列中的异步过程调用进行处理。</p>
<p>返回值：WAIT_OBJECT_0, WAIT_TIMEOUT, WAIT_FAILED, WAIT)ABANDONED, WAIT_IO_COMPLETION</p>
<p>配合PulseEvent使用。</p>
<p>SignalObjectAndWait释放一个对象，同时立即等待（原子方式）</p>
<p>能确保其100%能看见别的线程调用的PulseEvent。</p>
<h3 id="使用等待链遍历API来检测死锁"><a href="#使用等待链遍历API来检测死锁" class="headerlink" title="使用等待链遍历API来检测死锁"></a>使用等待链遍历API来检测死锁</h3><p>Vista系统以上提供了等待链遍历（Wait Chain Traversal， WCT）API，这些函数可以让我们列出所有的锁，并检测进程内部，甚至是进程之间的死锁。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Windows-Kernel-9</p><p><a href="http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/">http://systemk1t.github.io/2019/09/03/Windows-Kernel-9/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>sYstemk1t</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-09-03</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-09-03</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Windows-Kernel/">Windows-Kernel</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipayimg.jpg" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatimg.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/09/04/Windows-Kernel-13/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Windows-Kernel-13</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/09/03/Windows-Kernel-8/"><span class="level-item">Windows-Kernel-8</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="sYstemk1t"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">sYstemk1t</p><p class="is-size-6 is-block">翩若惊鸿，婉若游龙</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShenZhen, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">138</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/sYstemk1t" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/sYstemk1t"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://r00tk1ts.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">r00tk1t</span></span><span class="level-right"><span class="level-item tag">r00tk1ts.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/yicunyiye/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">yicunyiye</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Bugku/"><span class="level-start"><span class="level-item">Bugku</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/C-%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">C++黑客编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CrackMe/"><span class="level-start"><span class="level-item">CrackMe</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/C%E4%B8%8E%E6%8C%87%E9%92%88/"><span class="level-start"><span class="level-item">C与指针</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C程序设计语言</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/MFC/"><span class="level-start"><span class="level-item">MFC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"><span class="level-start"><span class="level-item">Windows-API开发详解</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">Windows-PE权威指南</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows32%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">Windows32汇编语言设计</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><span class="level-start"><span class="level-item">Windows内核原理与实现</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">Windows核心编程</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">Windows程序设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"><span class="level-start"><span class="level-item">加密与解密</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8F%8D%E6%B1%87%E7%BC%96/"><span class="level-start"><span class="level-item">反汇编</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">汇编语言</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%9F%BA%E4%BA%8Ex86%E5%A4%84%E7%90%86%E5%99%A8/"><span class="level-start"><span class="level-item">汇编语言-基于x86处理器</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">网络编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">逆向工程权威指南</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">逆向工程核心原理</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">黑客编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-06T07:11:40.000Z">2020-11-06</time></p><p class="title"><a href="/2020/11/06/Assembly-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/">Assembly - 寻址方式</a></p><p class="categories"><a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">汇编语言</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-04T07:13:16.000Z">2020-11-04</time></p><p class="title"><a href="/2020/11/04/MFC-%E5%9F%BA%E7%A1%80/">MFC - 基础</a></p><p class="categories"><a href="/categories/MFC/">MFC</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-04T04:08:14.000Z">2020-11-04</time></p><p class="title"><a href="/2020/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/">Windows应用程序 - 远程线程注入</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-04T03:56:25.000Z">2020-11-04</time></p><p class="title"><a href="/2020/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5/">Windows应用程序 - 隐式链接</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-04T02:59:12.000Z">2020-11-04</time></p><p class="title"><a href="/2020/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E9%93%BE%E6%8E%A5%E5%BA%93/">Windows应用程序 - 链接库</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">36</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CrackMe/"><span class="tag">CrackMe</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HOOK/"><span class="tag">HOOK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hacker/"><span class="tag">Hacker</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MFC/"><span class="tag">MFC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reverse/"><span class="tag">Reverse</span><span class="tag">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scoket/"><span class="tag">Scoket</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-Kernel/"><span class="tag">Windows-Kernel</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="tag">Windows-PE权威指南</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><span class="tag">Windows核心编程</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">Windows程序设计</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c</span><span class="tag">8</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/head.jpg" alt="sYstemk1t&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2020 sYstemk1t</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>