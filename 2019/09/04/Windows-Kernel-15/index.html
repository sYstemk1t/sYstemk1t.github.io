<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Windows-Kernel-15 - sYstemk1t&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="sYstemk1t"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="sYstemk1t"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="在应用程序中使用虚拟内存"><meta property="og:type" content="blog"><meta property="og:title" content="Windows-Kernel-15"><meta property="og:url" content="http://systemk1t.github.io/2019/09/04/Windows-Kernel-15/"><meta property="og:site_name" content="sYstemk1t&#039;s blog"><meta property="og:description" content="在应用程序中使用虚拟内存"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://systemk1t.github.io/2019/09/04/Windows-Kernel-15/0.png"><meta property="article:published_time" content="2019-09-04T06:40:45.000Z"><meta property="article:modified_time" content="2019-09-04T10:32:44.586Z"><meta property="article:author" content="sYstemk1t"><meta property="article:tag" content="Windows-Kernel"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2019/09/04/Windows-Kernel-15/0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://systemk1t.github.io/2019/09/04/Windows-Kernel-15/"},"headline":"sYstemk1t's blog","image":["http://systemk1t.github.io/2019/09/04/Windows-Kernel-15/0.png"],"datePublished":"2019-09-04T06:40:45.000Z","dateModified":"2019-09-04T10:32:44.586Z","author":{"@type":"Person","name":"sYstemk1t"},"description":"在应用程序中使用虚拟内存"}</script><link rel="canonical" href="http://systemk1t.github.io/2019/09/04/Windows-Kernel-15/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/head.jpg" alt="sYstemk1t&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-04T06:40:45.000Z" title="2019-09-04T06:40:45.000Z">2019-09-04</time>发表</span><span class="level-item"><time dateTime="2019-09-04T10:32:44.586Z" title="2019-09-04T10:32:44.586Z">2019-09-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Windows核心编程</a></span><span class="level-item">1 小时读完 (大约7699个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Windows-Kernel-15</h1><div class="content"><hr>
<h1 id="在应用程序中使用虚拟内存"><a href="#在应用程序中使用虚拟内存" class="headerlink" title="在应用程序中使用虚拟内存"></a>在应用程序中使用虚拟内存</h1><a id="more"></a>

<p>Windows提供了三种内存管理的方法：</p>
<ul>
<li>虚拟内存，用来管理大型对象或数据结构</li>
<li>内存映射文件，用来管理大型数据流（通常来自文件）以及在大哥计算机上运行的多个进行之间的共享数据</li>
<li>内存堆栈，用来管理大量的小对象</li>
</ul>
<p><strong>用于管理虚拟内存的函数可以用来直接保留一个地址空间区域，将物理存储器（来自页文件）提交给该区域，并且可以设置自己的保护属性</strong></p>
<h2 id="在地址空间中保留一个区域"><a href="#在地址空间中保留一个区域" class="headerlink" title="在地址空间中保留一个区域"></a>在地址空间中保留一个区域</h2><p>通过调用VirtualAlloc函数，可以在进程的地址空间中保留一个区域：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_ _Post_writable_byte_size_(dwSize)</span><br><span class="line">LPVOID</span><br><span class="line">WINAPI</span><br><span class="line">VirtualAlloc(</span><br><span class="line">    _In_opt_ LPVOID lpAddress,</span><br><span class="line">    _In_ SIZE_T dwSize,</span><br><span class="line">    _In_ DWORD flAllocationType,</span><br><span class="line">    _In_ DWORD flProtect</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>pAddress 告知系统想要预定的地址空间中的哪一块。由于系统会记录所有闲置地址区间，通常只需要传递NULL就可以了。<br>通常分配方向是随机的，但是可以指定一些标志对分配方向进行一些控制（MEM_TOP_DOWN）</p>
<p><strong>第一个lpAddress指明了系统要预定的地址空间中的哪一块</strong></p>
<p><strong>第二个dwSize用于设定保留区域的大小</strong></p>
<p><strong>第三个flAllocationType：它告诉系统你想保留一个区域还是提交物理寄存器</strong></p>
<p><strong>第四个flProtect用于指明应该赋予该地址空间区域的保护属性</strong></p>
<p>对于大多数程序员来说，能够让系统在指定的内存地址预定区域是个不同寻常的概念，传统的概念应该是让系统帮我们寻找一块足够大的内存并分配之，然后返回这块内存的地址。但是由于现在每个进程都有自己的地址空间，因此可以要求操作系统在我们希望的内存区域预定区域。</p>
<p>例如想要在虚拟地址起始50MB的地方分配，传递52428800（50x1024x1024）给lpAddress 如果这个内存地址有足够大的闲置区域，则系统会把该区域预定下来。如果没有闲置的区域，或者区域不够大。则VirtualAlloc返回NULL。另外若传递的lpAddress不在可供用户模式选择的地址空间也会直接返回NULL</p>
<p>因为系统是按照分配粒度来分配的。所以实际返回的地址是以lpAddress为准向下取整的（64KB分配粒度）基地址。</p>
<p>dwSize是我们想要预定区域的大小，以字节为单位。大小必须是页面的整数（4KB, 8KB 或16KB） 如果预定62KB 最终得到的区域大小会是64KB</p>
<p>flAllocationType 告知所分配的区域是否需要调拨物理存储器（这种区分是必要的，因为VirtualAlloc也可以用于调拨物理存储器）<br>要预定地址空间必须传 MEM_RESERVE</p>
<p>如果想预定尽可能高的地址（因为要使用很长一段时间，防止引起内存碎片）传NULL给lpAddress 同时传 MEM_TOP_DOWN |MEM_RESERVE 给flAllocationType</p>
<p>flProtect给区域指定保护属性。区域的保护属性对于调拨给该区域的物理存储器不起任何作用。无论区域指定什么保护属性，只要还没给它调拨物理内存，试图访问区域内的任何内存地址都会引发访问违规。</p>
<p><img src="/2019/09/04/Windows-Kernel-15/0.png"></p>
<p>看一上例子，使用VirtualAlloc预定了一块区域但是还没有调拨物理内存，试图写入整型数据直接导致异常。</p>
<p>在预定区域并制定保护属性时，应该考虑在调拨物理内存时最常用的保护属性。例如：PAGE_READWRITE保护属性来调拨物理存储器，则使用PAGE_READWRITE来预定区域。当区域和物理存储器的保护属性一致时，系统内部处理的效率会更高。<br>可以使用以下保护属性。<br>PAGE_NOACCESS, PAGE_READWRITE, PAGE_READONLY,PAGE_EXECUTE,PAGE_EXECUTE_READ,或PAGE_EXECUTE_READWRITE.<br>不能使用PAGE_WRITECOPY和PAGE_EXECUTE_WRITECOPY(否则VirtualAlloc不会预定区域而直接返回NULL）<br>同时也不能使用PAGE_GUARD, PAGE_NOCACHE或PAGE_WRITECOMBINE(也会返回NULL）<br>这些都只能用来调拨物理存储器。</p>
<h2 id="在保留区域中提交存储区"><a href="#在保留区域中提交存储区" class="headerlink" title="在保留区域中提交存储区"></a>在保留区域中提交存储区</h2><p>当保留一个区域后，必须将物理存储器提交给该区域人，然后才能访问该区域中包含的内存地址。系统从它的页文件中将已提交的物理存储器分配给一个区域。</p>
<p><strong>若要提交物理寄存器，必须再次调用VirtualAlloc函数，不过得把第三个参数修改为MEM_COMMIT标志。</strong></p>
<p>指定保护属性通常和预定区域相同。（当然也可以指定不同的保护属性）</p>
<p>通过参数lpAddress（起始地址）和dwSize（存储器的大小）告知系统需要调拨多少物理内存</p>
<p>例如一下例子：应用程序已经在5242880处预定了一个512KB的区域。从改区域的2KB地址开始调拨6KB的物理存储器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * p = (<span class="keyword">char</span>*)VirtualAlloc((PVOID)(<span class="number">5242880</span> + (<span class="number">2</span> * <span class="number">1024</span>)), </span><br><span class="line">		<span class="number">6</span> * <span class="number">1024</span>, MEM_COMMIT, PAGE_READWRITE);</span><br></pre></td></tr></table></figure>

<p>根据页对齐的特性，最终系统会调拨8KB的物理存储器。 5242880到5251071（5242880 + 8KB - 1）之间。这些页面都具有PAGE_READWRITE保护属性。</p>
<p>同一区域中的不同页面可以具有不同的保护属性。</p>
<h2 id="同时进行区域的保护和内存的提交"><a href="#同时进行区域的保护和内存的提交" class="headerlink" title="同时进行区域的保护和内存的提交"></a>同时进行区域的保护和内存的提交</h2><p>有时候需要同时预定区域并调拨物理内存，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PVOID pvMem = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">99</span> * <span class="number">1024</span>,</span><br><span class="line">		MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br></pre></td></tr></table></figure>

<p>系统之所以要搜索地址空间，原因是已将 p v A d d r e s s参数设定为N U L L。如果为p v A d d r e s s设定了内存地址，系统就要查看在该内存地址上是否存在足够大的未保留地址空间。如果系统找不到足够大的未保留地址空间，Vi r t u a l A l l o c将返回N U L L。</p>
<p>最后需要说明的是，Vi r t u a l A l l o c将返回保留区域和提交区域的虚拟地址，然后该虚拟地址被保存在p v M e m变量中。如果系统无法找到足够大的地址空间，或者不能提交该物理存储器，Vi r t u a l A l l o c将返回N U L L。</p>
<p>当用这种方式来保留一个区域和提交物理存储器时，将特定的地址作为 p v A d d r e s s参数传递给 Vi r t u a l A l l o c当然是可能的。否则就必须用 O R将M E M _ TO P _ D O W N 标志与f d w A l l o c a t i o n Ty p e参数连接起来，并为p v A d d r e s s参数传递N U L L，让系统在进程的地址空间的顶部选定一个适当的区域。</p>
<p>如果cpu不支持大页面分配，GetLargePageMinimum会返回0. 如果要分配的页面大于该函数的返回值，就可以使用Windows大页面支持。<br>只要在分配VirtualAlloc并将MEM_LARGE_PAGE和fdwAllocationType按位或运算即可。<br>还需要满足一下条件：<br>1） 要分配的内存大小必须是GetLargePageMinimum函数返回的整数倍。<br>2）fdwAllocationType 必须传递MEM_RESERVE | MEM_COMMIT 再或上MEM_LARGE_PAGE (也就是必须同时预定+调拨物理内存）<br>3）fdwProtect必须传递PAGE_READWRIE</p>
<h2 id="何时提交物理存储器"><a href="#何时提交物理存储器" class="headerlink" title="何时提交物理存储器"></a>何时提交物理存储器</h2><p>作者举了一个例子：<br>假设一个电子表格程序，支持200行，256列。 每个单元格需要维护一个CELLDATA的结构体数据大小是128字节。<br>如果一开始就申明好数据<br>CELLDATA CellData[200][256];</p>
<p>那么这个二维数据需要6553600个字节（200x256x128）</p>
<p>这样程序一开始就需要分配大量内存，而用户可能只会使用其中的少数几个单元格。内存使用率很低。<br>通常电子表格都是使用其他数据结构来实现的，比如链表。这样当某个电子表格确实存放了数据，才需要创建与之对应的CELLDATA结构。<br>但是同时存在一个问题，如果要访问第五行，第十列的单元格内容。这种遍历方法会很慢（事实上，可以采用二维索引表来记录对应单元格的数据地址，采用链表作为数据存储结构。这样能提升访问效率）<br>虚拟内存也可以提供一种折中方案。享受数组方法所带来的快速而便捷的访问，又能节省存储器</p>
<p>为了使用虚拟内存，需要执行以下步骤。</p>
<p>1）预定一块足够大的区域来容纳CELLDATA结构的整个数组，只预定根本不会消耗物理存储器。<br>2）当用户在某个单元格中输入数据时，首先确定CELLDATA结构在区域中的内存地址。由于这时还没有给该地址映射物理存储器，试图访问会引发内存错误。<br>3）给第二步中的内存地址调拨足够的物理存储器。<br>4）设置CELLDATA结构成员</p>
<p>有几个问题：<br>如果个某个单元格调拨过物理存储器，由于分配粒度和页面对齐等原因，实际上会给相邻的区域也调拨物理存储器。那么如何判断相邻的区域是否已经调拨了物理存储器呢？<br>1）总是尝试调拨物理存储器，这样如果该区域已经被调拨，系统并不会额外再给其调拨物理存储器。<br>2）使用VirtualQuery来判断是否已经给CELLDATA结构调拨物理存储器。（其实这种方法会增大开销，因为VirtualQuery函数执行开销不低）<br>3）记录哪些页面已经调拨而哪些页面未调拨。这样可以使程序运行更快，同时避免了频繁调拨VirtualAlloc。<br>4）使用结构化异常处理（structured exception handling）SEH是操作系统的一项特性，可以在系统发生某种情况通知应用程序。给应用程序设置一个结构化异常处理程序，当程序试图访问未调拨物理存储器的内存时，系统会通知我们的应用程序。接着应用程序可以调拨物理存储器，并告知系统重新执行那条引发异常的指令。</p>
<h2 id="撤销调拨物理存储器及释放区域"><a href="#撤销调拨物理存储器及释放区域" class="headerlink" title="撤销调拨物理存储器及释放区域"></a>撤销调拨物理存储器及释放区域</h2><p>要撤销调拨给区域的物理存储器，或者释放地址空间中的一整块区域，调用VirtualFree函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">VirtualFree(</span><br><span class="line">    _Pre_notnull_ _When_(dwFreeType == MEM_DECOMMIT, _Post_invalid_) _When_(dwFreeType == MEM_RELEASE, _Post_ptr_invalid_) LPVOID lpAddress,</span><br><span class="line">    _In_ SIZE_T dwSize,</span><br><span class="line">    _In_ DWORD dwFreeType</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>例如进程不再需要访问区域中的物理存储器，只需要调用VirtualFree一次，就能够释放整个区域以及调拨给该区域的物理存储器。</p>
<p>pvAddress必须是区域的基地址。也就是预定区域时VirtualAlloc返回的值。<br>dwSize 传递0. 因为系统会记录每个分配区域的大小。传递非0值会导致失败。<br>dwFreeType 传递 MEM_RELEASE 告知系统撤销调拨给区域的所有物理存储器，并释放区域。<br>这种方式会释放整个已经预定的区域，例如预定了一个128KB的区域，并调拨了64KB的物理存储器，必须释放整个128KB区域。</p>
<p>如果仅想撤销调拨给区域的物理存储器但不想释放整个区域，则这样操作。<br>pvAddress传递要撤销调拨区域的第一个页地址<br>dwSize 指定想要释放的物理存储器的大小<br>dwFreeType传递MEM_DECOMMIT</p>
<p>另外撤销调拨也是基于页面粒度的，如果给定的地址在一个页面的中间，那么系统会撤销调拨整个页面。<br>同样如果pvAddress+dwSize也位于一个页面的中间，那么系统会撤销调拨包含该地址的整个页面。</p>
<p>如果dwSize为0，pvAddress又是区域的基地址（起始地址）则VirtualFree会撤销调拨该区域的所有页面。<br>一旦系统撤销调拨给页面的物理存储器，那么所释放的物理存储器就可以用于系统中的其他进程，试图访问已撤销调拨的内存地址将引发访问违规。</p>
<h3 id="何时回收物理存储器"><a href="#何时回收物理存储器" class="headerlink" title="何时回收物理存储器"></a>何时回收物理存储器</h3><p>作者又举了电子表格的例子：<br>如果应用程序在x86机器上运行， 那么存储页面大小就是4KB，每个页面可以存放32（4096/128）个CELLDATA结构。如果用户删了CellData[0][1]的内容，只要CellData[0][0]到CellData[0][31]之间的所有单元格都不用了，就可以撤销调拨该物理存储页。如何知道这些单元格还没有用呢？<br>1）最理想的方案是将CELLDATA结构设计成正好等于一个页面的大小。这样每个页面只有一个结构，因此不再需要某个结构的数据时直接撤销调拨给该页面的物理存储器。但是实际情况可能很少会用到那么大的数据结构。<br>2）另一种方案是记录哪些结构正在使用。为了节省内存，可以用一个位图。如果一个包含100个结构的数据，那么只需要维护一个包含100个位的组。一开始所有位都被设置为0，表示没有任何结构。当用到任何结构时，将位设置为1.不需要某些结构时，把对应的位设置为0.接着检查位于同一个页中的相邻结构所对应的个个位。如果同一个页面所有相邻结构都不需要了，那么就可以撤销调拨该页面。<br>3）另一种解决方案是，实现一个垃圾收集函数。（需要系统在第一次调拨物理存储器时把所有字节都清0）。必须在结构中留出一个BOOL成员（例如bInUse）。每次把结构体放到已调拨内存中，需要把bInUse设置为TRUE。接着在程序运行时，定期调用垃圾回收函数。该函数会遍历所有潜在的数据结构并检查是否已经给各个结构调拨过物理存储器。如果已经调拨过会检查bInUse，看是否为0，如果为0.表示该结构没被用到。如果bInUse为TRUE表明结构还在使用。一旦垃圾收集函数检查完一个给定页面中所有结构，并发现所有结构都没被使用，他会调用VirtualFree来撤销调拨物理存储器。</p>
<p>前两个方法适合大数据页面的情况。二第三个适合结构较小的方案。</p>
<h2 id="改变保护属性"><a href="#改变保护属性" class="headerlink" title="改变保护属性"></a>改变保护属性</h2><p>虽然实际应用中很少需要改变保护属性，但这仍然是可行的。<br>假设有一段代码来管理一个链表，并把链表中的节点保存在一个已预订的区域中。然后设计一个处理函数，在每个函数的开头把物理存储页的保护属性改成PAGE_READWRITE，并在函数结束前把保护属性改成PAGE_NOACCESS<br>这样可以保护链表的数据，使他免受其他缺陷程序的影响。如果进程中的其他代码试图用一个错误指针来访问链表数据，将会引发访问违规。如果在应用程序中定位一个很难发现的缺陷，可以试试看保护属性，他可以发挥难以置信的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Success_(<span class="keyword">return</span> != FALSE)</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">VirtualProtect(</span><br><span class="line">    _In_ LPVOID lpAddress,</span><br><span class="line">    _In_ SIZE_T dwSize,</span><br><span class="line">    _In_ DWORD flNewProtect,</span><br><span class="line">    _Out_ PDWORD lpflOldProtect</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>lpAddress是内存的基地址（用户分区）<br>dwSize想要改变保护属性的大小，以字节为单位，<br>flNewProtect 除了PAGE_WRITECOPY和PAGE_EXECUTE_WRITECOPY以外的任何PAGE_*保护属性。<br>lpfOldProtect 返回原来的保护属性。必须传递一个有效的地址给lpfOldProtect，否则会调用失败。</p>
<p>保护属性是与整个物理存储页关联的，以下代码实际上是在给两个物理存储页指定保护属性<strong>PAGE_NOACCESS</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VirtualProtect(pvRgnBase + (<span class="number">3</span> * <span class="number">1024</span>), <span class="number">2</span> * <span class="number">1024</span>,</span><br><span class="line">		PAGE_NOACCESS, &amp;flOldProtect);</span><br></pre></td></tr></table></figure>

<p>若干连续的物理存储页跨越了不同的区域时，<strong>VirtualProtect</strong>是不能改变他们的保护属性的。如果有相邻的区域，有想改变跨区域的连续页面的保护属性，需要调用<strong>VirtualProtect</strong>多次。</p>
<h2 id="清楚物理存储器内容"><a href="#清楚物理存储器内容" class="headerlink" title="清楚物理存储器内容"></a>清楚物理存储器内容</h2><p>当修改物理存储页的时候，系统尽量把改动保持在内存中。但是，当应用程序在运行时候，系统可能要从exe文件，dll文件或者页交换文件中载入新的页面到内存。为了满足最近的载入请求，系统会在内存中查找可用的页面，如果找到的页面已经被修改过，那么系统还必须将它们换出到页面文件中。</p>
<p>windows提供了一项特性（重置物理存储器）告知系统一个或几个物理存储页中的数据没有被修改过。如果系统正在查找一页闲置内存，并找到了一个修改过的页面，那么系统必须把该内存页写入到页交换文件中。这个操作比较慢，会影响性能。对于大多数应用程序来说，我们都希望系统把修改后的页面保存到页交换文件中。</p>
<p>但是，有些应用程序只在一小段时间使用存储器，之后也不需要保留存储器中的内容。为了提高性能，应用程序可以告知系统不要在交换文件中保存指定的存储页。这是一种告知系统一个页面未被修改过的一种方法。如果系统要将一个内存页挪做他用，他不会将页面的内容保存到页交换文件中，这样就提高的了性能。<br>为了重置存储器，应用程序调用VirtualAlloc函数，并在第三个参数传入MEM_RESET标志。</p>
<p>调用VirtualAlloc时，如果被引用到的页面在页交换文件中，那么系统会直接抛弃这些页面。下次应用程序再访问存储器，会使用新的，全部清零的内存页。如果重置的页面在内存中，系统会将其标记为未修改过。这样系统就绝不会把他们写到页交换文件中。（注意，即使该内存页没有被清零，我们也不应该继续读取其中的内容，因为系统随时可能会把该页挪做他用。因此一旦做了页重置，就应当将其视为无效数据）</p>
<p>还有一些注意事项：<br>1）调用VirtualAlloc，基地址通常会被向下取整到页面大小的整数倍，而大小会被向下取整到页面大小的整数倍；在重置存储器时，这种方式对基地址进行取整是非常危险的；如果传入MEM_RESET那么VirtualAlloc会从相反的方向进行取整操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PINT pnData = (PINT)VirtualAlloc(<span class="literal">NULL</span>, <span class="number">1024</span>, </span><br><span class="line">		MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	pnData[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">	pnData[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">	VirtualAlloc((PVOID)pnData, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), MEM_RESET, PAGE_READWRITE);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>该代码先调拨了一页存储器，然后告知系统最前4个字节（sizeof(4)）不再使用，可以被重置。事实上重置会调用失败。VirtualAlloc返回NULL，GetLastError返回ERROR_INVALID_ADDRESS<br>因为在执行MEM_RESET的时候为了防止误操作把其他重要的数据抛弃。会把大小向下取整到0，而重置0字节是没有意义的。把大小向下取整到页面的整数倍也是出于同样的原因：如果垃圾数据并未占满整个页，那么我们并不希望重置整个页，因为其中可能还包含有效数据。这样系统就确保只会重置整个页面都是垃圾数据的内存页。</p>
<p><strong>MEM_RESET</strong>只能单独使用，不能和其他标志进行按位或。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PVOID pvMem = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">1024</span>,</span><br><span class="line">		MEM_RESERVE | MEM_COMMIT | MEM_RESET, PAGE_READWRITE);</span><br></pre></td></tr></table></figure>

<p>该代码会失败并返回NULL</p>
<p>在使用<strong>MEM_RESET</strong>调用<strong>VirtualAlloc</strong>时，需要传递一个有效的保护属性值，实际上函数并没有用到这个值。</p>
<p>1）调用GlobalMemoryStatus获得机器中的内存总量<br>2）调用VirtualAlloc函数来调拨存储器，调用的数量为第一步中得到的数量。这个操作非常快，除非进程去试图访问野蛮，否则系统是不会为页面分配内存的。<br>如果VirtualAlloc在最新的机器上可能会返回NULL，这可能是因为机器中的内存总量比进程可用地址空间还要多（例如在装配了4GB以上内存的机器运行一个32位程序）<br>3）调用ZeroMemory函数以访问刚才调拨的内存，这会给系统很大的压力。并导致原来在内存中的一些页面被写入到交换文件。</p>
<h2 id="地址扩展窗口"><a href="#地址扩展窗口" class="headerlink" title="地址扩展窗口"></a>地址扩展窗口</h2><p>随着时间的推移，应用程序需要越来越多的内存。服务器程序尤其如此，将数据保存在内存中而减少磁盘和内存的页交换以提高性能。32位地址空间不大够用</p>
<p>Windows提供了一项特性，即地址窗口扩展（Address Windowing Extension，也称作AWE）在创建AWE以后，Microsoft有以下两个目标：<br>1）允许应用程序以一种特殊的方式分配内存，操作系统保证不会将以这种方式分配的内存换出到磁盘上。<br>2）允许应用程序访问比进程地址空间还要多的内存。</p>
<p>AWE可以让应用程序分配一块或多块内存。当一开始分配时，在进程的地址空间中是看不到这些内存块的。应用程序通过调用VirtualAlloc预定地址空间区域，这就是地址窗口。然后程序调用一个函数，每调用一个函数，就把一块内存指定到该地址窗口。（把内存地址指定到地址窗口是毫秒级别的）</p>
<p>使用地址窗口，一次只能访问一块内存。因此需要在代码中显式调用函数来把不同的内存块指定到地址窗口中。（这增加了代码编写的难度）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First, reserve a 1MB region for the address window</span></span><br><span class="line">ULONG_PTR ulRAMBytes = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">PVOID pvWindow = VirtualAlloc(<span class="literal">NULL</span>, ulRAMBytes,</span><br><span class="line">	MEM_RESERVE | MEM_PHYSICAL, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the number of bytes in a page for this CPU platform</span></span><br><span class="line">SYSTEM_INFO sinf;</span><br><span class="line">GetSystemInfo(&amp;sinf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate the required number of RAM pages for the</span></span><br><span class="line"><span class="comment">// desired number of bytes</span></span><br><span class="line">ULONG_PTR ulRAMPages = (ulRAMBytes + sinf.dwPageSize - <span class="number">1</span>) / sinf.dwPageSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate array for RAM page&#x27;s page frame numbers</span></span><br><span class="line">ULONG_PTR * aRAMPages = (ULONG_PTR *) <span class="keyword">new</span> ULONG_PTR[ulRAMPages];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate the pages of RAM (requires Lock Pages in Memory user right)</span></span><br><span class="line">AllocateUserPhysicalPages(</span><br><span class="line">	GetCurrentProcess(),	<span class="comment">// Allocate the storage for our process</span></span><br><span class="line">	&amp;ulRAMPages,			<span class="comment">// Input: # of RAM pages, Output: # pages allocated</span></span><br><span class="line">	aRAMPages);				<span class="comment">// Output: Opaque array indicating pages allocated</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Assign the RAM pages to our window</span></span><br><span class="line">MapUserPhysicalPages(</span><br><span class="line">	pvWindow,				<span class="comment">// The address of the address window</span></span><br><span class="line">	ulRAMPages,				<span class="comment">// Number of entries in array</span></span><br><span class="line">	aRAMPages);				<span class="comment">// Array of RAM pages</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Access the RAM pages via the pvWindow virtual address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the block of RAM pages</span></span><br><span class="line">FreeUserPhysicalPages(</span><br><span class="line">	GetCurrentProcess(),	<span class="comment">// Free the RAM allocated for our process</span></span><br><span class="line">	&amp;ulRAMPages,			<span class="comment">// Input: # of RAM pages, Output: # pages freed</span></span><br><span class="line">	aRAMPages);				<span class="comment">// Input: Array indicating the RAM pages to free</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy the address window</span></span><br><span class="line">VirtualFree(pvWindow, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="keyword">delete</span>[] aRAMPages;</span><br></pre></td></tr></table></figure>

<p>程序通过调用VirtualAlloc函数来预定1MB的地址窗口（实际应用会更大，当然他受限制与进程地址空间中最大的，连续的闲置区域）MEM_RESERVE表示要预定一块地址区域。MEM_PHYSICAL标志表示该区域最终会以物理内存（RAM）作为后备（不使用物理页交换文件作为后备）。 AWE的一个限制是所有映射到地址窗口的存储器必须是可读可写 的。 因此页保护属性传递PAGE_READWRITE.<br>不用使用VirtualProtect函数来改变页保护属性。</p>
<p>分配物理存储器调用一下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Success_(<span class="keyword">return</span> != FALSE)</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">AllocateUserPhysicalPages(</span><br><span class="line">    _In_ HANDLE hProcess,</span><br><span class="line">    _Inout_ PULONG_PTR NumberOfPages,</span><br><span class="line">    _Out_writes_to_(*NumberOfPages, *NumberOfPages) PULONG_PTR PageArray</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>



<p>这个函数会根据NumberOfPages参数所指向的值来分配相应数量的的内存页，然后将这些页分配给hProcess参数所标识的进程。</p>
<p>操作系统会给每个页面指定一个页框号（page frame number）系统会将每个页面的页框号保存到PageArray所指向的数组。页框号本身对于应用程序来说没有什么用处。<br>同时函数返回以后NumberOfPages的值表示成功分配的页面数量。通常这个值和传递值相同也可能会更小。</p>
<p>只有当前进程才能通过AllocateUserPhysicalPages分配得到内存页面，AWE不允许将内存页面映射到其他进程的地址空间中。（不能在进程中共享内存块）</p>
<p>当然，物理R A M是一种非常宝贵的资源，并且应用程序只能分配尚未指定用途<br>的R A M。应该非常节省地使用 AW E，否则你的进程和其他进程将会过分地在内存与<br>磁盘之间进行页面的交换，从而严重影响系统的运行性能。此外，如果可用 R A M的<br>数量比较少，也会对系统创建新进程、线程和其他资源的能力产生不利的影响。应用<br>程序可以使用G l o b a l M e m o r y S t a t u s E x函数来监控物理存储器的使用情况.</p>
<p>为了保护R A M的分配，A l l o c a t e U s e r P h y s i c a l P a g e s函数要求调用者拥有Lock Pagesin Memory（锁定内存中的页面）的用户权限，并且已经激活该权限，否则该函数的运行将会失败。按照默认设置，该权限不被赋予任何用户或用户组。该权限被赋予Local System（本地系统）帐户，它通常用于服务程序。如果想要运行一个调用A l l o c a t e U s e r P h y s i c a l P a g e s函数的交互式应用程序，那么管理员必须在你登录和运行应用程序之前为你赋予该权限。</p>
<p>接下来调用一下函数把内存块指定给地址窗口:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Success_(<span class="keyword">return</span> != FALSE)</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">MapUserPhysicalPages(</span><br><span class="line">    _In_ PVOID VirtualAddress,</span><br><span class="line">    _In_ ULONG_PTR NumberOfPages,</span><br><span class="line">    _In_reads_opt_(NumberOfPages) PULONG_PTR PageArray</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>VirtualAddress是指定给地址窗口的虚拟地址。</p>
<p>NumberOfPages表示要通过这个地址窗口看到多少个页面的内存。</p>
<p>PageArray 表示通过该地址窗口看到哪些页面的内存。</p>
<p>如果地址窗口的大小小于我们试图映射的页面数，则会调用失败。一般该函数的执行时间是毫秒级别。</p>
<p>也可以调用M a p U s e r P h y s i c a l P a g e s函数来取消对当前R A M块的分配，方法是为a R A M P a g e s参数传递N U L L。下面是它的一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR ulRAMBytes = <span class="number">1024</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>一旦R A M块被分配给地址窗口，只需要引用相对于地址窗口的基地址（在我的示例代码中是p v Wi n d o w）的虚拟地址，就可以很容易地访问该R A M内存。</p>
<p>当不再需要R A M块时，应该调用F r e e U s e r P h y s i c a l P a g e s函数将它释放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Success_(<span class="keyword">return</span> != FALSE)</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">FreeUserPhysicalPages(</span><br><span class="line">    _In_ HANDLE hProcess,</span><br><span class="line">    _Inout_ PULONG_PTR NumberOfPages,</span><br><span class="line">    _In_reads_(*NumberOfPages) PULONG_PTR PageArray</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>hProcess表示要释放哪个进程的内存页。<br>NumberOfPages表示要释放多少个页面<br>PageArray表示要释放的页面框号。<br>如果内存块已经被映射到窗口，那么系统会取消映射并释放内存块。</p>
<p>最后为了完成清理工作，程序调用VirtualFree并传入窗口的虚拟地址，以0位区域大小，并传入MEM_RELEASE标志。</p>
<p>这个例子创建了一个地址窗口和一个内存块。使得访问内存并不需要和磁盘进行页交换。应用程序也可以创建多个地址窗口，并分配多个内存块。并把内存块指定给任何一个地址窗口。但系统不允许一个内存块同时出现在两个地址窗口中。</p>
<p>AWE运行应用程序不会和磁盘进行页交换。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Windows-Kernel-15</p><p><a href="http://systemk1t.github.io/2019/09/04/Windows-Kernel-15/">http://systemk1t.github.io/2019/09/04/Windows-Kernel-15/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>sYstemk1t</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-09-04</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-09-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Windows-Kernel/">Windows-Kernel</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipayimg.jpg" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatimg.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/09/05/PE%E5%AF%BC%E5%85%A5%E8%A1%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">PE导入表</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/09/04/Windows-Kernel-14/"><span class="level-item">Windows-Kernel-14</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="sYstemk1t"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">sYstemk1t</p><p class="is-size-6 is-block">翩若惊鸿，婉若游龙</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShenZhen, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">123</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/sYstemk1t" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/sYstemk1t"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://r00tk1ts.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">r00tk1t</span></span><span class="level-right"><span class="level-item tag">r00tk1ts.github.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Bugku/"><span class="level-start"><span class="level-item">Bugku</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/C-%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">C++黑客编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CrackMe/"><span class="level-start"><span class="level-item">CrackMe</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/C%E4%B8%8E%E6%8C%87%E9%92%88/"><span class="level-start"><span class="level-item">C与指针</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C程序设计语言</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">Windows PE权威指南</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"><span class="level-start"><span class="level-item">Windows-API开发详解</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows32%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">Windows32汇编语言设计</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><span class="level-start"><span class="level-item">Windows内核原理与实现</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">Windows核心编程</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">Windows程序设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"><span class="level-start"><span class="level-item">加密与解密</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8F%8D%E6%B1%87%E7%BC%96/"><span class="level-start"><span class="level-item">反汇编</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">汇编语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%9F%BA%E4%BA%8Ex86%E5%A4%84%E7%90%86%E5%99%A8/"><span class="level-start"><span class="level-item">汇编语言-基于x86处理器</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">网络编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">逆向工程权威指南</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">逆向工程核心原理</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">黑客编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-16T21:39:58.000Z">2020-09-17</time></p><p class="title"><a href="/2020/09/17/c-%E5%A4%9A%E6%80%81/">c++ - 多态</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-16T01:28:28.000Z">2020-09-16</time></p><p class="title"><a href="/2020/09/16/C-%E7%BB%A7%E6%89%BF/">C++ - 继承</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-15T12:11:54.000Z">2020-09-15</time></p><p class="title"><a href="/2020/09/15/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/">C++ - 运算符重载</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-09-14T08:31:15.000Z">2020-09-14</time></p><p class="title"><a href="/2020/09/14/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">C++ 拷贝构造函数</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-08-21T11:10:02.000Z">2020-08-21</time></p><p class="title"><a href="/2020/08/21/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B6%88%E6%81%AF/">Windows程序设计 - 窗口和消息</a></p><p class="categories"><a href="/categories/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">Windows程序设计</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">35</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CrackMe/"><span class="tag">CrackMe</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HOOK/"><span class="tag">HOOK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hacker/"><span class="tag">Hacker</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reverse/"><span class="tag">Reverse</span><span class="tag">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scoket/"><span class="tag">Scoket</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-Kernel/"><span class="tag">Windows-Kernel</span><span class="tag">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-PE/"><span class="tag">Windows-PE</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">Windows程序设计</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c</span><span class="tag">8</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/head.jpg" alt="sYstemk1t&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2020 sYstemk1t</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>