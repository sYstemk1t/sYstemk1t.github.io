<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Windows-Kernel-3 - sYstemk1t&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="sYstemk1t"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="sYstemk1t"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="内核对象"><meta property="og:type" content="blog"><meta property="og:title" content="Windows-Kernel-3"><meta property="og:url" content="http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/"><meta property="og:site_name" content="sYstemk1t&#039;s blog"><meta property="og:description" content="内核对象"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/0.png"><meta property="og:image" content="http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/1.png"><meta property="og:image" content="http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/2.png"><meta property="og:image" content="http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/3.png"><meta property="og:image" content="http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/4.png"><meta property="article:published_time" content="2019-08-24T01:00:20.000Z"><meta property="article:modified_time" content="2019-08-24T01:04:41.275Z"><meta property="article:author" content="sYstemk1t"><meta property="article:tag" content="Windows-Kernel"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2019/08/24/Windows-Kernel-3/0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/"},"headline":"sYstemk1t's blog","image":["http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/0.png","http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/1.png","http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/2.png","http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/3.png","http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/4.png"],"datePublished":"2019-08-24T01:00:20.000Z","dateModified":"2019-08-24T01:04:41.275Z","author":{"@type":"Person","name":"sYstemk1t"},"description":"内核对象"}</script><link rel="canonical" href="http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="fontawesome"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/head.jpg" alt="sYstemk1t&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-08-24T01:00:20.000Z" title="2019-08-24T01:00:20.000Z">2019-08-24</time>发表</span><span class="level-item"><time dateTime="2019-08-24T01:04:41.275Z" title="2019-08-24T01:04:41.275Z">2019-08-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">Windows核心编程</a></span><span class="level-item">1 小时读完 (大约7260个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Windows-Kernel-3</h1><div class="content"><hr>
<h1 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h1><a id="more"></a>

<h2 id="什么是内核对象"><a href="#什么是内核对象" class="headerlink" title="什么是内核对象"></a>什么是内核对象</h2><p><strong>每个内核对象只是内核分配的一个内存块，并且只能由该内核访问。该内存块是一种数据结构，它的成员负责维护对象的各种信息。</strong></p>
<h3 id="内核对象的使用计数"><a href="#内核对象的使用计数" class="headerlink" title="内核对象的使用计数"></a>内核对象的使用计数</h3><p>内核对象由内核拥有，而不是进程拥有。</p>
<p><strong>假如你的进程调用了一个创建内核对象的函数，然后你的进程终止运行，那么内核对象不一定会被撤销，在大多数情况下，对象被撤销，但是如果另一个进程正在使用你的进程创建内核对象，那么内核知道，在另一个进程停止使用该对象之前不要撤销该对象，必须记住：内核对象的存在时间可以比创建该对象的进程长</strong></p>
<p><strong>内核知道有多少进程正在使用某个内核对象，因为每个对象包含一个使用计数。使用计数是所有内核对象类型常用的数据类型之一。</strong></p>
<p><strong>当一个对象被创建的时候，它的计数被置为1，当另外一个进程访问内核对象的时候，使用计数就递增1，当进程终止的时候，内核对象就自动确定该进程打开的所有内核对象的使用计数。当内核对象的使用计数为0，内核就撤销该对象</strong></p>
<p>使用Winobj查看内核对象</p>
<p><img src="/2019/08/24/Windows-Kernel-3/0.png"></p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p><strong>内核对象能够得到安全描述符的保护。安全描述符用于描述谁创建了对象，谁能够访问或操作该对象。</strong></p>
<p>用于创建内核对象的函数几乎都有一个指向<strong>SECURITY_ATTRIBUTES</strong>结构的指针作为其参数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateFileMapping&#123;</span><br><span class="line">    HANDLE hFile,</span><br><span class="line">    PSECURITY_ATTRIBUTES,</span><br><span class="line">    DWORD flProtect,</span><br><span class="line">    DWORD dwMaximumSizeHigh,</span><br><span class="line">    DWORD dwMaximumSizeLow,</span><br><span class="line">    PCTSTR pszName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大多数应用程序只是为该函数传递NULL，这样就可以创建带有默认安全性的内核对象；</p>
<p><strong>默认安全性意味着对象的管理小组的任何成员和对象的创建者都拥有对该对象的全部访问权，而其他所有人均无权访问该对象。</strong></p>
<h2 id="进程的内核对象句柄表"><a href="#进程的内核对象句柄表" class="headerlink" title="进程的内核对象句柄表"></a>进程的内核对象句柄表</h2><p><strong>当一个进程被初始化时，系统要为它分配一个句柄表。该句柄表只用于内核对象不用于用户对象或者GDI对象</strong></p>
<p>进程句柄表是一个由数据结构组成的数组。每个结构包含一个指向内核对象的指针，一个访问掩码和一些标志。</p>
<h3 id="创建内核对象"><a href="#创建内核对象" class="headerlink" title="创建内核对象"></a>创建内核对象</h3><p><strong>当进程初次初始化时，它的句柄表是空的，当进程中的线程调用创建内核对象的函数的时候，内核就为该对象分配一个内存块，并对它初始化。这时候，内核对进程的句柄表进行扫描，找出一个空项。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PSECURITY_ATTRIBUTE psa,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPTHREAD_START_ROUTINE pfnStartAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID pvParam,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    PDWORD pdwThreadId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PCTSTR pszFileNAme,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwShareMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    PSECURITY_ATTRIBUTES psa,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwCreationDistribution,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hTemplateFile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateFileMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">    PSECURITY_ATTRIBUTES psa,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD flPRotect,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwMaximumSizeHigh,</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwMaximumSizeLow,</span></span></span><br><span class="line"><span class="function"><span class="params">    PCTSTR pszName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PSECURITY_ATTRIBUTES psa,</span></span></span><br><span class="line"><span class="function"><span class="params">    LONG lInitialCount,</span></span></span><br><span class="line"><span class="function"><span class="params">    LONG lMaximumCount,</span></span></span><br><span class="line"><span class="function"><span class="params">    PCTSTR pszName)</span></span>;</span><br></pre></td></tr></table></figure>



<p>用于创建内核对象的所有函数均返回与进程相关的句柄，这些句柄可以被在相同的进程中运行的任何或所有线程成功的加以使用。该句柄值实际上是放入进程的句柄表中的索引，它用于标识内核对象的信息存放的位置。</p>
<p>每当调用一个将内核对象句柄接受为参数的函数时，就要传递由一个 C r e a t e * &amp;函数返回的值。从内部来说，该函数要查看进程的句柄表，以获取要生成的内核对象的地址，然后按定义得很好的方式来生成该对象的数据结构。</p>
<p>如果调用一个函数以便创建内核对象，但是调用失败了，那么返回的句柄值通常是0（NULL）。发生这种情况是因为系统的内存非常短缺，或者遇到了安全方面的问题。不过有少数函数在运行失败时返回的句柄值是-1（INVALID_HANDLE_VALUE）。例如，如果CreateFile未能打开指定的文件，那么它将返回INVALID_HANDLE_VALUE，而不是返回NULL。当查看创建内核对象的函数返回值时，必须格外小心。特别要注意的是，只有当调用CreateFile函数时，才能将该值与INVALID_HANDLE_VALUE进行比较。下面的代码是不正确的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hMutex = CreateMutex(...);</span><br><span class="line"><span class="keyword">if</span> (hMutex == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="comment">//这段代码不会执行，因为CreateMutex调用失败的时候返回的是NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，下面的代码也不正确：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hFile = CreateFile(...);</span><br><span class="line"><span class="keyword">if</span> (hFIle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//这段代码不会执行，因为CreateFile调用失败的时候返回的是INVALID_HANDLE_VALUE(-1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="关闭内核对象"><a href="#关闭内核对象" class="headerlink" title="关闭内核对象"></a>关闭内核对象</h3><p>无论怎样创建内核对象，都要向系统指明将通过调用C l o s e H a n d l e来结束对该对象的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CloseHandle</span><span class="params">(HANDLE hobj)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果该句柄是有效的，那么系统就可以获得内核对象的数据结构的地址，并可确定该结构中的使用计数的数据成员。如果使用计数是0，该内核便从内存中撤消该内核对象。</p>
<p>如果将一个无效句柄传递给CloseHandle，将会出现两种情况之一。如果进程运行正常，CloseHandle返回FALSE，而GetLastError则返回ERROR_INVALID_HANDLE。如果进程正在排除错误，系统将通知调试程序，以便能排除它的错误。</p>
<p>在CloseHandle返回之前，它会清除进程的句柄表中的项目，该句柄现在对你的进程已经无效，不应该试图使用它。无论内核对象是否已经撤消，都会发生清除操作。当调用CloseHandle函数之后，将不再拥有对内核对象的访问权，不过，如果该对象的使用计数没有递减为0，那么该对象尚未被撤消。这没有问题，它只是意味着一个或多个其他进程正在使用该对象。当其他进程停止使用该对象时（通过调用CloseHandle），该对象将被撤消。</p>
<p>假如忘记调用CloseHandle函数，那么会不会出现内存泄漏呢？答案是可能的，但是也不一定。在进程运行时，进程有可能泄漏资源（如内核对象）。但是，当进程终止运行时，操作系统能够确保该进程使用的任何资源或全部资源均被释放，这是有保证的。对于内核对象来说，系统将执行下列操作：当进程终止运行时，系统会自动扫描进程的句柄表。如果该表拥有任何无效项目（即在终止进程运行前没有关闭的对象），系统将关闭这些对象句柄。如果这些对象中的任何对象的使用计数降为0，那么内核便撤消该对象。</p>
<p>因此，应用程序在运行时有可能泄漏内核对象，但是当进程终止运行时，系统将能确保所有内容均被正确地清除。另外，这个情况适用于所有对象、资源和内存块，也就是说，当进程终止运行时，系统将保证进程不会留下任何对象。</p>
<h2 id="跨越进程边界共享内核对象"><a href="#跨越进程边界共享内核对象" class="headerlink" title="跨越进程边界共享内核对象"></a>跨越进程边界共享内核对象</h2><p>需要跨进程共享的内核对象</p>
<p>a.利用文件映像对象，可以在同一台机器上运行的两个进程之间共享数据块。</p>
<p>b. 借助邮件槽和命名管道，在网络中的不同计算机上运行的进程可以相互发送数据块。</p>
<p>c. 互斥量，信号量和事件允许不同进程的线程同步执行。例如一个应用程序可能需要完成某一个任务以后向另一个应用程序发出通知。</p>
<p>为了操作系统的安全，OS将内核对象设计成进程相关。</p>
<p>windows中有3中机制允许进程共享内核对象：使用对象句柄继承；为对象命名；复制对象句柄。</p>
<h3 id="使用对象句柄继承"><a href="#使用对象句柄继承" class="headerlink" title="使用对象句柄继承"></a>使用对象句柄继承</h3><p>只有在进程之间有一个父-子关系的时候，才可以使用对象句柄继承。 父进程有一个或多个内核对象句柄可以使用，而且父进程创建一个子进程，并允许子进程访问父进程的内核对象。</p>
<p>  步骤</p>
<ul>
<li>父进程创建句柄的时候必须向系统指出该对象是可以继承的。（这里指的是对象句柄的继承）</li>
</ul>
<p>父进程需要初始化<strong>SECURITY_ATTRIBUTES</strong>结构 再将其传递给Create函数。 以下代码创建了一个可继承的互斥量对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">sa.nLength = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">sa.lpSecurityDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">sa.bInheritHandle = TRUE; <span class="comment">// Make the returned handle inheritable.</span></span><br><span class="line"> </span><br><span class="line">HANDLE hMutex = CreateMutex(&amp;sa, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>句柄表中每个记录项都有一个指明句柄是否可以继承的标志位。如果在创建句柄时传入的</p>
<p>SECURITY_ATTRIBUTES</p>
<p>结构参数为NULL返回的句柄是不可继承的，这个标志位为0.</p>
<p>将bInheritHandle成员设置为TRUE，将导致这个标志位被设为1.</p>
<p><img src="/2019/08/24/Windows-Kernel-3/1.png"></p>
<p>以上句柄表中，索引号为3的内核对象可以被继承。索引号为1的内核对象不可继承，索引号为2的内核对象不可用。</p>
<ul>
<li>为了使对象句柄继承，接下来是生成子进程。通过CreateProcess函数完成</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">CreateProcessW(</span><br><span class="line">    _In_opt_ LPCWSTR lpApplicationName,</span><br><span class="line">    _Inout_opt_ LPWSTR lpCommandLine,</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">    _In_ BOOL bInheritHandles,</span><br><span class="line">    _In_ DWORD dwCreationFlags,</span><br><span class="line">    _In_opt_ LPVOID lpEnvironment,</span><br><span class="line">    _In_opt_ LPCWSTR lpCurrentDirectory,</span><br><span class="line">    _In_ LPSTARTUPINFOW lpStartupInfo,</span><br><span class="line">    _Out_ LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">    );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>bInheritHandles参数，通常情况传递FALSE（不希望子进程继承父进程句柄表中的“可继承句柄”）<br>如果传递TRUE，子进程就会继承父进程的“可继承的句柄值”。创建进程以后系统先建一张空的句柄表，然后遍历其父进程句柄表并复制所有可继承属性的内核对象。</p>
<p>并且复制项的位置和他在父进程表中的位置是完全一样的。主进程中的Handle值在子进程中仍然可用。</p>
<p>同时会增加被复制的内核对象的引用计数器。</p>
<p>表3是一个子进程的句柄表</p>
<p><img src="/2019/08/24/Windows-Kernel-3/2.png"></p>
<p>1,2 项未初始化不可用</p>
<p>第三项是从父进程复制过来的内核对象，地址完全相同索引号也一致，并且标志是可继承。</p>
<p>内核对象的内容被保存在内核地址空间中–系统上所有运行的进程共享这个空间。（内核模式分区）</p>
<p>在32位系统下 是 0x8000 0000  到  0xFFFF FFFF之间。  对于64位系统，则是  0x0000 0400 0000 0000 到  0xFFFF FFFF FFFF FFFF之间。</p>
<p>子进程同样调用CreateProcess创建自己的孙进程，并将bInheritHandles参数设置为TRUE，孙进程也会继承该内核对象。并且3个进程的内核对象在句柄表中的内容和索引号一致。以此类推</p>
<p>对象继承只发生在创建进程的同时，如果子进程创建以后父进程又创建了新的内核对象则该对象并不被继承。</p>
<p>另外子进程本身并不会被通知从父进程那里继承了哪些内核对象（需要自行写代码通知）</p>
<p>通常用命令行参数传递。子进程的初始化代码将解析命令行并提取值。（因为内核对象具有相同的索引值和指针值）可以直接使用父句柄传递的句柄值</p>
<p>也可以等子进程创建完毕主线程发送一个消息给子进程中的一个线程处理（WaitForInputIdle）</p>
<p>另一种方式是在主进程所在的环境块添加环境变量设置继承句柄值，子进程会继承父进程的环境变量。通过调用GetEnvironmentVariable来获取继承到的内核对象的句柄值。</p>
<p>参考子进程继承父控制台的特例</p>
<h3 id="改变句柄的标志"><a href="#改变句柄的标志" class="headerlink" title="改变句柄的标志"></a>改变句柄的标志</h3><p>SetHandleInformation可以改变内核对象句柄的继承标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">SetHandleInformation(</span><br><span class="line">    _In_ HANDLE hObject,</span><br><span class="line">    _In_ DWORD dwMask,</span><br><span class="line">    _In_ DWORD dwFlags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>



<p>hObject一个有效的句柄</p>
<p>dwMask更改那些标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDLE_FLAG_INHERIT             0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDLE_FLAG_PROTECT_FROM_CLOSE  0x00000002</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dwFlags要设置的值。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open the inherit flag</span></span><br><span class="line">SetHandleInformation(hObj, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// clos the inherit flag</span></span><br><span class="line">SetHandleInformation(hObj, HANDLE_FLAG_INHERIT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HANDLE_FLAG_PROTECT_FROM_CLOSE</p>
<p>告知系统不允许关闭句柄</p>
<p>以下例子会触发一个异常（在调试器下）在运行模式下CloseHandle返回FALSE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SetHandleInformation(hObj, HANDLE_FLAG_PROTECT_FROM_CLOSE,HANDLE_FLAG_PROTECT_FROM_CLOSE);</span><br><span class="line">CloseHandle(hObj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>关闭保护</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetHandleInformation(hObj, HANDLE_FLAG_PROTECT_FROM_CLOSE, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>获取内核对象的标志信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">GetHandleInformation(</span><br><span class="line">    _In_ HANDLE hObject,</span><br><span class="line">    _Out_ LPDWORD lpdwFlags</span><br><span class="line">    );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取一个内核对象是否允许被继承的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD  dwFlags;</span><br><span class="line">GetHandleInformation(hObj, &amp;dwFlags);</span><br><span class="line">BOOL fHandleIsInheritable = (<span class="number">0</span> != (dwFlags &amp; HANDLE_FLAG_INHERIT));</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="为对象命名"><a href="#为对象命名" class="headerlink" title="为对象命名"></a>为对象命名</h3><p>垮进程共享内核对象的第二个方法是为对象命名。许多内核对象都可以命名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateMutexW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes,</span><br><span class="line">    _In_ BOOL bInitialOwner,</span><br><span class="line">    _In_opt_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateEventW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes,</span><br><span class="line">    _In_ BOOL bManualReset,</span><br><span class="line">    _In_ BOOL bInitialState,</span><br><span class="line">    _In_opt_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateSemaphoreW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,</span><br><span class="line">    _In_     LONG lInitialCount,</span><br><span class="line">    _In_     LONG lMaximumCount,</span><br><span class="line">    _In_opt_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateWaitableTimerW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpTimerAttributes,</span><br><span class="line">    _In_     BOOL bManualReset,</span><br><span class="line">    _In_opt_ LPCWSTR lpTimerName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateFileMappingW(</span><br><span class="line">    _In_ HANDLE hFile,</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpFileMappingAttributes,</span><br><span class="line">    _In_ DWORD flProtect,</span><br><span class="line">    _In_ DWORD dwMaximumSizeHigh,</span><br><span class="line">    _In_ DWORD dwMaximumSizeLow,</span><br><span class="line">    _In_opt_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">CreateJobObjectW(</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpJobAttributes,</span><br><span class="line">    _In_opt_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>所有这些Create函数有一个Name参数，传入NULL表示匿名内核对象。可以使用继承技术</p>
<p>或者使用DuplicateHandle来实现进程间的对象共享。</p>
<p>所有的命名内核对象共享一个命名空间。以下例子CreateSemaphore函数会返回NULL </p>
<p><img src="/2019/08/24/Windows-Kernel-3/3.png"></p>
<p>通过命名对象共享的一个例子</p>
<p>在进程A中创建了一个名字为“JeffMutex”的互斥量对象</p>
<p>HANDLE hMutexProcessA = CreateMutex(NULL, FALSE, TEXT(“JeffMutex”));</p>
<p>然后通过某进程生成了进程B（B不是A的子进程）在B进程中调用</p>
<p>HANDLE hMutexProcessB = CreateMutex(NULL, FALSE, TEXT(“JeffMutex”));</p>
<p>系统找到内核表中的JeffMutex判断类型，进行安全检查。都通过就会将记录赋值到进程B中的句柄表内，并且引用计数器+1</p>
<p>否则返回NULL</p>
<p>（可以采用CreateMutexEx设置信号量的访问权限。）</p>
<p>通过名称来实现内核对象共享时，进程B调用CreateMutex时，会向安全函数传递安全信息。如果已经存在一个指定名称的对象，这些参数就会被忽略。函数并不知道自己是创建了一个新的内核对象还是打开一个已有的。</p>
<p>可以调用GetLastError判断刚才是创建了一个还是打开了一个现有的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SECURITY_ATTRIBUTES sa;</span><br><span class="line">	sa.nLength = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">	sa.lpSecurityDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">	sa.bInheritHandle = TRUE;</span><br><span class="line">	HANDLE hMutex = CreateMutex(&amp;sa, FALSE, TEXT(<span class="string">&quot;JeffMutex&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Opened a handle to an existing object.</span></span><br><span class="line">		<span class="comment">//sa.lpSecurityDescriptor and the second parameter</span></span><br><span class="line">		<span class="comment">// are ignored.</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Opened a handle to an existing object.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Created a brand new object.</span></span><br><span class="line">		<span class="comment">//sa.lpSecurityDescriptor and the second parameter</span></span><br><span class="line">		<span class="comment">//FALSE are used to construct the object.</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Created a brand new object.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/2019/08/24/Windows-Kernel-3/4.png"></p>
<p>为了实现具名内核对象的共享，还可以使用一系列Open*函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenMutexW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenEventW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenSemaphoreW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenWaitableTimerW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpTimerName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenFileMappingW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">WINBASEAPI</span><br><span class="line">_Ret_maybenull_</span><br><span class="line">HANDLE</span><br><span class="line">WINAPI</span><br><span class="line">OpenJobObjectW(</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ LPCWSTR lpName</span><br><span class="line">    );</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以上函数原型一致，最后一个参数指向内核对象的名称。并且该参数不能为NULL<br>如果在系统内核表中无法搜索到同名的内核对象则返回NULL  GetLastError返回2 （ERROR_FILE_NOT_FOUND）</p>
<p>如果找到同名的内核对象但类型不同，返回NULL GetLastError返回6（ERROR_INVALID_HANDLE）</p>
<p>如果同名且类型相同，系统会检查访问权限。如果允许访问该内核对象，则会更新主调进程的句柄表，并使对象的使用计数器递增。</p>
<p>如果bInHeritHandle参数传入TRUE，那么返回的句柄就是“可继承”的</p>
<p>Create<em>如果不存在则创建， Open</em>如果不存在则返回NULL。</p>
<p>为了避免两个互不相干的程序冲突建议使用GUID来创建具名内核对象。</p>
<p>一个利用具名内核对象来防止应用程序创建多个实例的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//// &#123;89AE97EA-F13D-4104-B042-43C010033B48&#125;</span></span><br><span class="line">	HANDLE h = CreateMutex(<span class="literal">NULL</span>, FALSE,</span><br><span class="line">		TEXT(<span class="string">&quot;&#123;89AE97EA-F13D-4104-B042-43C010033B48&#125;&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS) &#123;</span><br><span class="line">		<span class="comment">// there is already an instance of this application running.</span></span><br><span class="line">		<span class="comment">// close the object and immediately return.</span></span><br><span class="line">		CloseHandle(h);</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	CloseHandle(h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该程序只会运行一个实例。</p>
<h3 id="终端服务命名空间"><a href="#终端服务命名空间" class="headerlink" title="终端服务命名空间"></a>终端服务命名空间</h3><p>终端服务程序（service）除了有一全局的命名空间，所有客户端能访问的内核对象要放在这个命名空间中。</p>
<p>每个客户端会话（Client session）都有自己的命名空间。对于两个会话正在运行同一个程序的时候，这样的安排可以避免彼此之间的干扰–一个会话不会访问另一个会话的对象，即使对象的名称相同。</p>
<p> 因为系统服务默认启动与Session 0 ，而用户的应用会在一个新的Session中启动。如果和系统服务间的通信不在一个命名空间中就会可能出问题。</p>
<p>可以通过ProcessIdToSessonId函数知道我们的应用程序在哪个Terminal Services会话中运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD processID = GetCurrentProcessId();</span><br><span class="line">	DWORD sessionID;</span><br><span class="line">	<span class="keyword">if</span> (ProcessIdToSessionId(processID, &amp;sessionID))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Process &#x27;%u&#x27; runs in Terminal Services session &#x27;%u&#x27;\n&quot;</span>,</span><br><span class="line">			processID, sessionID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// ProcessIdToSessionId might fail if you don&#x27;t have enough rights</span></span><br><span class="line">		<span class="comment">// to access the process for which you pass the ID as parameter.</span></span><br><span class="line">		<span class="comment">// Notice that it is not the case here because we&#x27;re using our own process ID.</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Unable to get Terminal Services session ID for process &#x27;%u&#x27;\n&quot;</span>,</span><br><span class="line">			processID);</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>一个服务（system service）的命名内核对象始终位于全局命名空间。默认情况下应用程序的命名内核对象在会话的命名空间内。</p>
<p>可以强制把命名对象放入全局命名空间”Global&quot;</p>
<p>HANDLE h = CreateEvent(NULL, FALSE, FALSE, TEXT(“Global\MyName”));</p>
<p>也可以显式把内核对象放入当前会话的命名空间 加上”Local&quot;前缀</p>
<p>HANDLE h = CreateEvent(NULL, FALSE, FALSE, TEXT(“Local\MyName”));</p>
<p>Global 和 Local是命名对象的保留字。除非强制一个特定的命名空间，否则不应在对象名中使用。 Session也是保留字，但是不能在当前Session中创建创建另外一个Session前缀的对象。GetLastError返回ERROR_ACCESS_DENIED</p>
<p>(保留关键字都是区分大小写的)</p>
<h3 id="专有命名空间"><a href="#专有命名空间" class="headerlink" title="专有命名空间"></a>专有命名空间</h3><p>如果想确保我们的应用程序创建的内核对象名称永远不会和其他应用程序的名称冲突，或者想保护他们免遭劫持，可以定义一个自定义的前缀，并把他作为自己的专有命名空间使用，这和使用Global和Local前缀是相似的。 一个单例进程的例子，以一种更安全的方式来实现前面的例子</p>
<p>研究以下问题</p>
<p>1）如何创建一个边界  </p>
<p>2）如何将对应于本地管理组（Local Administrators）的安全描述符（Security identifier， SID）和边界关联</p>
<p>3）如何创建或打开其名称被用作互斥量内核对象前缀的一个专有命名空间。</p>
<p>边界描述符会获得一个名称， 而且还会与一个特权用户组的SID相关联。 Windows就可以确保在用户隶属于这个权限时（SID），以其身份创建的应用程序才能在此SID对应的边界条件中创建相同的命名空间，从而访问在这个边界中创建的，以专有命名空间的名称作为前缀的内核对象。</p>
<p>如果由于SID泄漏，一个低权限的而已程序试图创建相同的边界描述符，那么当其试图创建或打开一个高权限账户保护的专有命名空间时，调用就会失败GetLastError返回</p>
<p>ERROR_ACCESS_DENIED.</p>
<p>原始代码 Singleton.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Module: Singleton.cpp</span></span><br><span class="line"><span class="comment">	Notices: Copyright (c) 2008 Jeffrey Richter &amp; Christophe Nasarre</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;..\CommonFiles\CmnHdr.h&quot;</span>	<span class="comment">// common header for Windows Via C++ sample</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windowsx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Sddl.h&gt;		// for SID management</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Main dialog</span></span><br><span class="line">HWND		g_hDlg;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Mutex, boundary and namespace used to detect previous running instance</span></span><br><span class="line">HANDLE		g_hSingleton = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE		g_hBoundary = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE		g_hNamespace = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Keep track whether or not the namespace wa created or open for clean-up</span></span><br><span class="line">BOOL		g_bNamespaceOpened = FALSE;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Names of boundary and private namespace</span></span><br><span class="line">PCTSTR		g_szBoundary = TEXT(<span class="string">&quot;3-Boundary&quot;</span>);</span><br><span class="line">PCTSTR		g_szNamespace = TEXT(<span class="string">&quot;3-Namespace&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DETAILS_CTRL	GetDlgItem(g_hDlg, IDC_EDIT_DETAILS)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Adds a string to the &quot;Details&quot; edit control</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddText</span><span class="params">(PCTSTR pszFormat, ...)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	va_list argList;</span><br><span class="line">	va_start(argList, pszFormat);</span><br><span class="line"> </span><br><span class="line">	TCHAR sz[<span class="number">20</span> * <span class="number">1024</span>] ;</span><br><span class="line"> </span><br><span class="line">	Edit_GetText(DETAILS_CTRL, sz, _countof(sz));</span><br><span class="line">	_vstprintf_s(</span><br><span class="line">		_tcschr(sz, TEXT(<span class="string">&#x27;\0&#x27;</span>)), _countof(sz) - _tcslen(sz),</span><br><span class="line">		pszFormat, argList);</span><br><span class="line">	Edit_SetText(DETAILS_CTRL, sz);</span><br><span class="line">	va_end(argList);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dlg_OnCommand</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, HWND hwndCtl, UINT codeNotify)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (id) &#123;</span><br><span class="line">	<span class="keyword">case</span> IDOK:</span><br><span class="line">	<span class="keyword">case</span> IDCANCEL:</span><br><span class="line">		<span class="comment">// User has clicked on the exit button</span></span><br><span class="line">		<span class="comment">// Or dismissed the dialog with ESCAPE</span></span><br><span class="line">		EndDialog(hwnd, id);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the boundary descriptor</span></span><br><span class="line">	g_hBoundary = CreateBoundaryDescriptor(g_szBoundary, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create a SID corresponding to the Local Administrator group</span></span><br><span class="line">	BYTE localAdminSID[SECURITY_MAX_SID_SIZE];</span><br><span class="line">	PSID pLocalAdminSID = &amp;localAdminSID;</span><br><span class="line">	DWORD cbSID = <span class="keyword">sizeof</span>(localAdminSID);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!CreateWellKnownSid(</span><br><span class="line">		WinBuiltinAdministratorsSid, <span class="literal">NULL</span>, pLocalAdminSID, &amp;cbSID)</span><br><span class="line">		) &#123;</span><br><span class="line">		AddText(TEXT(<span class="string">&quot;AddSIDToBoundaryDescriptor failed: %u\r\n&quot;</span>),</span><br><span class="line">			GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Associate the Local Admin SID to the boundary descriptor</span></span><br><span class="line">	<span class="comment">// --&gt; only applications running under an administrator user</span></span><br><span class="line">	<span class="comment">// will be able to access the kernel objects in the same namespace</span></span><br><span class="line">	<span class="keyword">if</span> (!AddSIDToBoundaryDescriptor(&amp;g_hBoundary, pLocalAdminSID)) &#123;</span><br><span class="line">		AddText(TEXT(<span class="string">&quot;AddSIDToBoundaryDescriptor failed: %u\r\n&quot;</span>),</span><br><span class="line">			GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Create the namespace for Local Administrators only</span></span><br><span class="line">	SECURITY_ATTRIBUTES sa;</span><br><span class="line">	sa.nLength = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">	sa.bInheritHandle = FALSE;</span><br><span class="line">	<span class="keyword">if</span> (!ConvertStringSecurityDescriptorToSecurityDescriptor(</span><br><span class="line">		TEXT(<span class="string">&quot;D:(A;;GA;;;BA)&quot;</span>),</span><br><span class="line">		SDDL_REVISION_1, &amp;sa.lpSecurityDescriptor, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		AddText(TEXT(<span class="string">&quot;Security Descriptor creation failed: %u\r\n&quot;</span>),</span><br><span class="line">			GetLastError());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	g_hNamespace =</span><br><span class="line">		CreatePrivateNamespace(&amp;sa, g_hBoundary, g_szNamespace);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Don&#x27;t forget to release memory for the security descriptor</span></span><br><span class="line">	LocalFree(sa.lpSecurityDescriptor);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Check the private namespace creation result</span></span><br><span class="line">	DWORD dwLastError = GetLastError();</span><br><span class="line">	<span class="keyword">if</span> (g_hNamespace == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// Nothing to do if access is denied</span></span><br><span class="line">		<span class="comment">// --&gt; this code must run under a Local Administrator acount</span></span><br><span class="line">		<span class="keyword">if</span> (dwLastError == ERROR_ACCESS_DENIED) &#123;</span><br><span class="line">			AddText(TEXT(<span class="string">&quot;Access denied when create the namespace.\r\n&quot;</span>));</span><br><span class="line">			AddText(TEXT(<span class="string">&quot;	You must be running as Administrator.\r\n\r\n&quot;</span>));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (dwLastError == ERROR_ALREADY_EXISTS) &#123;</span><br><span class="line">				<span class="comment">// if another instance has already created the namespace,</span></span><br><span class="line">				<span class="comment">// we need to open it instead.</span></span><br><span class="line">				AddText(TEXT(<span class="string">&quot;CreatePrivateNamespace failed: %u\r\n&quot;</span>), dwLastError);</span><br><span class="line">				g_hNamespace = OpenPrivateNamespace(g_hBoundary, g_szNamespace);</span><br><span class="line">				<span class="keyword">if</span> (g_hNamespace == <span class="literal">NULL</span>) &#123;</span><br><span class="line">					AddText(TEXT(<span class="string">&quot;	and OpenPrivateNamespace failed: %u\r\n&quot;</span>),</span><br><span class="line">						dwLastError);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					g_bNamespaceOpened = TRUE;</span><br><span class="line">					AddText(TEXT(<span class="string">&quot;	but OpenPrivateNamespace succeeded\r\n\r\n&quot;</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				AddText(TEXT(<span class="string">&quot;Unexpected error occured: %u\r\n\r\n&quot;</span>),</span><br><span class="line">					dwLastError);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Try to create the mutex object with a name</span></span><br><span class="line">	<span class="comment">// based on the private namespace</span></span><br><span class="line">	TCHAR szMutexName[<span class="number">64</span>];</span><br><span class="line">	StringCchPrintf(szMutexName, _countof(szMutexName), TEXT(<span class="string">&quot;%s\\%s&quot;</span>),</span><br><span class="line">		g_szNamespace, TEXT(<span class="string">&quot;Singleton&quot;</span>));</span><br><span class="line"> </span><br><span class="line">	g_hSingleton = CreateMutex(<span class="literal">NULL</span>, FALSE, szMutexName);</span><br><span class="line">	<span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS) &#123;</span><br><span class="line">		<span class="comment">// There is already an instance of this Singleton object</span></span><br><span class="line">		AddText(TEXT(<span class="string">&quot;Another instance of Singleton is running:\r\n&quot;</span>));</span><br><span class="line">		AddText(TEXT(<span class="string">&quot;--&gt; Impossible to access application features.\r\n&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// First time the Singleton object is created</span></span><br><span class="line">		AddText(TEXT(<span class="string">&quot;First instance of Singleton:\r\n&quot;</span>));</span><br><span class="line">		AddText(TEXT(<span class="string">&quot;--&gt; Access application features now.\r\n&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"> </span><br><span class="line"><span class="function">BOOL <span class="title">Dlg_OnInitDialog</span><span class="params">(HWND hwnd, HWND hwndFocus, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	chSETDLGICONS(hwnd, IDI_SINGLETON);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Keep track of the main dialog window handle</span></span><br><span class="line">	g_hDlg = hwnd;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Check whether another instance is already running</span></span><br><span class="line">	CheckInstances();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"> </span><br><span class="line"><span class="function">INT_PTR WINAPI <span class="title">Dlg_Proc</span><span class="params">(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (uMsg) &#123;</span><br><span class="line">		chHANDLE_DLGMSG(hwnd, WM_COMMAND, Dlg_OnCommand);</span><br><span class="line">		chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> APIENTRY _tWinMain(HINSTANCE hInstance,</span><br><span class="line">	HINSTANCE hPrevInstance,</span><br><span class="line">	LPTSTR	lpCmdLine,</span><br><span class="line">	<span class="keyword">int</span>		nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">	UNREFERENCED_PARAMETER(hPrevInstance);</span><br><span class="line">	UNREFERENCED_PARAMETER(lpCmdLine);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Show main window</span></span><br><span class="line">	DialogBox(hInstance, MAKEINTRESOURCE(IDD_SINGLETON), <span class="literal">NULL</span>, Dlg_Proc);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Don&#x27;t forget to clean up and release kernel resource</span></span><br><span class="line">	<span class="keyword">if</span> (g_hSingleton != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		CloseHandle(g_hSingleton);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (g_hNamespace != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (g_bNamespaceOpened) &#123; <span class="comment">// Open namespace</span></span><br><span class="line">			ClosePrivateNamespace(g_hNamespace, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ClosePrivateNamespace(g_hNamespace, PRIVATE_NAMESPACE_FLAG_DESTROY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (g_hBoundary != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		DeleteBoundaryDescriptor(g_hBoundary);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>CheckInstances函数的几个步骤。</p>
<ul>
<li>创建边界描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the boundary descriptor</span></span><br><span class="line">g_hBoundary = CreateBoundaryDescriptor(g_szBoundary, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意该函数的返回类型虽然是HANDLE，但是并非是一个内核对象的句柄。而是一个指针，指向了用户模式的结构，结构体中保护了边界的定义。</p>
<p>应该调用DeleteBoundaryDescriptor释放 （CloseHandle会失败）</p>
<ul>
<li>将一个特权用户组的SID与边界描述符关联起来：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Associate the Local Admin SID to the boundary descriptor</span></span><br><span class="line"><span class="comment">// --&gt; only applications running under an administrator user</span></span><br><span class="line"><span class="comment">// will be able to access the kernel objects in the same namespace</span></span><br><span class="line"><span class="keyword">if</span> (!AddSIDToBoundaryDescriptor(&amp;g_hBoundary, pLocalAdminSID)) &#123;</span><br><span class="line">	AddText(TEXT(<span class="string">&quot;AddSIDToBoundaryDescriptor failed: %u\r\n&quot;</span>),</span><br><span class="line">		GetLastError());</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在本例中创建了基于Local Administrator组的SID，并使用CreateWellKnownSid创建SID的描述符</p>
<ul>
<li>创建专有命名空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the namespace for Local Administrators only</span></span><br><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">sa.nLength = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">sa.bInheritHandle = FALSE;</span><br><span class="line"><span class="keyword">if</span> (!ConvertStringSecurityDescriptorToSecurityDescriptor(</span><br><span class="line">	TEXT(<span class="string">&quot;D:(A;;GA;;;BA)&quot;</span>),</span><br><span class="line">	SDDL_REVISION_1, &amp;sa.lpSecurityDescriptor, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">	AddText(TEXT(<span class="string">&quot;Security Descriptor creation failed: %u\r\n&quot;</span>),</span><br><span class="line">		GetLastError());</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_hNamespace =</span><br><span class="line">	CreatePrivateNamespace(&amp;sa, g_hBoundary, g_szNamespace);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>边界描述符添加的SID决定了谁能进入边界并创建命名空间。<br>是通过ConvertStringSecurityDescriptorToSecurityDescriptor创建的 关于安全描述符的语法接口参考MSDN</p>
<p>(<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/aa374928.aspx">https://msdn.microsoft.com/en-us/library/aa374928.aspx</a>)</p>
<p>如果试图创建一个已有的命名空间，CreatePrivateNamespace将返回NULL, GetLastError将返回ERROR_ALREADY_EXISTS</p>
<p>此时调用OpenPrivateNamespace来打开命名空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_hNamespace = OpenPrivateNamespace(g_hBoundary, g_szNamespace);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意CreatePrivateNamespace和 OpenPrivateNamespace返回的伪HANDLE并非内核句柄， 调用ClosePrivateNamespace来关闭伪句柄。</p>
<ul>
<li>进程终止前调用 DeleteBoundaryDescriptor 关闭边界</li>
</ul>
<h3 id="复制对象句柄"><a href="#复制对象句柄" class="headerlink" title="复制对象句柄"></a>复制对象句柄</h3><p>跨进程共享内核对象的最后一招是使用DuplicateHandle函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WINBASEAPI</span><br><span class="line">BOOL</span><br><span class="line">WINAPI</span><br><span class="line">DuplicateHandle(</span><br><span class="line">    _In_ HANDLE hSourceProcessHandle,</span><br><span class="line">    _In_ HANDLE hSourceHandle,</span><br><span class="line">    _In_ HANDLE hTargetProcessHandle,</span><br><span class="line">    _Outptr_ LPHANDLE lpTargetHandle,</span><br><span class="line">    _In_ DWORD dwDesiredAccess,</span><br><span class="line">    _In_ BOOL bInheritHandle,</span><br><span class="line">    _In_ DWORD dwOptions</span><br><span class="line">    );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获得一个进程句柄表中的记录项，在另一个进程的句柄表中创建这个记录项的一个副本。</p>
<p>参数1 和3 是进程内核对象的句柄。并且这两个句柄必须相对于调用DuplicateHandle函数的进程（hSourceProcessHandle 也可以调用DuplicateHandle）。 如果传递非进程句柄则会失败。</p>
<p>第二个参数是指向任何类型的内核对象的句柄。但是他的值一定不能和调用DuplicateHandle函数的那个进程相关。 必须和hSourceProcessHandle的这个进程有关。</p>
<p>函数最终会将源进程中的句柄信息复制到hTargetProcessHandle所表示的进程的句柄表中。</p>
<p>第四个参数是一个HANDLE指针，用于传递复制以后获得的句柄值。</p>
<p>后3个参数指定这个内核对象在目标进程中所对应的句柄表项，应该使用何种访问掩码和继承标志。 dwOptions可以为0 或者  DUPLICATE_SAME_ACCESS(保留同样的掩码)  和 DUPLICATE_CLOSE_SOURCE（关闭源进程中的句柄）</p>
<p>使用DuplicateHandle函数和继承有一个问题，目标进程不知道他现在能访问一个新的内核对象。必须通过某种进程间通信来通知目标进程。</p>
<p>一个DuplicateHandle的例子 两个进程互相拷贝:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All of the following code is excuted by process S.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a mutex object accessible by Process S.</span></span><br><span class="line">HANDLE hObjInProcessS = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a handle to Process T&#x27;s kernel object.</span></span><br><span class="line">HANDLE hProcessT = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessIdT);</span><br><span class="line"></span><br><span class="line">HANDLE hObjInProcessT;		<span class="comment">// An uninitialized handle relative to Process T.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Give Process T access to our mutex object.</span></span><br><span class="line">DuplicateHandle(GetCurrentProcess(), hObjInProcessS, hProcessT,</span><br><span class="line">	&amp;hObjInProcessT, <span class="number">0</span>, FALSE, DUPLICATE_SAME_ACCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use some IPC mechanism to get the handle value of hObjInProcessS into Process T.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We no longer need to commicate with Process T.</span></span><br><span class="line">CloseHandle(hProcessT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// When Process S no longer needs to use the mutex, it should close it.</span></span><br><span class="line">CloseHandle(hObjInProcessS);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>在本例中<strong>DuplicateHandle</strong>返回的句柄相对于进程T，因此绝对不要在进程S中释放此句柄 例如 CloseHandle(hObjInProcessT);</p>
<p>另一个例子在同一个进程中执行DuplicateHandle拷贝一个副本内核对象。注意创建和释放的周期</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a file-mapping object; the handle has read/write access.</span></span><br><span class="line">HANDLE hFileMapRW = CreateFileMapping(INVALID_HANDLE_VALUE,</span><br><span class="line">	<span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">10240</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create another handle to the file-mapping object;</span></span><br><span class="line"><span class="comment">// the handle has read-only access.</span></span><br><span class="line">HANDLE hFileMapRO;	<span class="comment">//uninitialized.</span></span><br><span class="line"></span><br><span class="line">DuplicateHandle(GetCurrentProcess(), hFileMapRW, GetCurrentProcess(),</span><br><span class="line">	&amp;hFileMapRO, FILE_MAP_READ, FALSE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the function that should only read from the file mapping.</span></span><br><span class="line">ReadFromTheFileMapping(hFileMapRO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the read-only file-mapping object.</span></span><br><span class="line">CloseHandle(hFileMapRO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can still read/write the file-mapping object using hFileMapRW.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// When the main code doesn&#x27;t access the file mapping anymore,</span></span><br><span class="line"><span class="comment">// Close it.</span></span><br><span class="line">CloseHandle(hFileMapRW);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div><div class="article-licensing box"><div class="licensing-title"><p>Windows-Kernel-3</p><p><a href="http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/">http://systemk1t.github.io/2019/08/24/Windows-Kernel-3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>sYstemk1t</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-08-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-08-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Windows-Kernel/">Windows-Kernel</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipayimg.jpg" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechatimg.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/08/27/Windows-Kernel-4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Windows-Kernel-4</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/08/22/Assembly-2/"><span class="level-item">Assembly-2</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="sYstemk1t"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">sYstemk1t</p><p class="is-size-6 is-block">翩若惊鸿，婉若游龙</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShenZhen, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">137</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/sYstemk1t" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/sYstemk1t"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://r00tk1ts.github.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">r00tk1t</span></span><span class="level-right"><span class="level-item tag">r00tk1ts.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.cnblogs.com/yicunyiye/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">yicunyiye</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Bugku/"><span class="level-start"><span class="level-item">Bugku</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/C-%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">C++黑客编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/CrackMe/"><span class="level-start"><span class="level-item">CrackMe</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/C%E4%B8%8E%E6%8C%87%E9%92%88/"><span class="level-start"><span class="level-item">C与指针</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C程序设计语言</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/MFC/"><span class="level-start"><span class="level-item">MFC</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"><span class="level-start"><span class="level-item">Windows-API开发详解</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">Windows-PE权威指南</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows32%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">Windows32汇编语言设计</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><span class="level-start"><span class="level-item">Windows内核原理与实现</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">Windows核心编程</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">Windows程序设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"><span class="level-start"><span class="level-item">加密与解密</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8F%8D%E6%B1%87%E7%BC%96/"><span class="level-start"><span class="level-item">反汇编</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">汇编语言</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%9F%BA%E4%BA%8Ex86%E5%A4%84%E7%90%86%E5%99%A8/"><span class="level-start"><span class="level-item">汇编语言-基于x86处理器</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">网络编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">逆向工程权威指南</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">逆向工程核心原理</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">黑客编程</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-04T07:13:16.000Z">2020-11-04</time></p><p class="title"><a href="/2020/11/04/MFC-%E5%9F%BA%E7%A1%80/">MFC - 基础</a></p><p class="categories"><a href="/categories/MFC/">MFC</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-04T04:08:14.000Z">2020-11-04</time></p><p class="title"><a href="/2020/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/">Windows应用程序 - 远程线程注入</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-04T03:56:25.000Z">2020-11-04</time></p><p class="title"><a href="/2020/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5/">Windows应用程序 - 隐式链接</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-04T02:59:12.000Z">2020-11-04</time></p><p class="title"><a href="/2020/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E9%93%BE%E6%8E%A5%E5%BA%93/">Windows应用程序 - 链接库</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-03T12:32:13.000Z">2020-11-03</time></p><p class="title"><a href="/2020/11/03/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/">Windows应用程序 - 内存映射文件</a></p><p class="categories"><a href="/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">Windows-API开发详解</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Assembly/"><span class="tag">Assembly</span><span class="tag">35</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CrackMe/"><span class="tag">CrackMe</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HOOK/"><span class="tag">HOOK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hacker/"><span class="tag">Hacker</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MFC/"><span class="tag">MFC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reverse/"><span class="tag">Reverse</span><span class="tag">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scoket/"><span class="tag">Scoket</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-Kernel/"><span class="tag">Windows-Kernel</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"><span class="tag">Windows-PE权威指南</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"><span class="tag">Windows核心编程</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="tag">Windows程序设计</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c</span><span class="tag">8</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/head.jpg" alt="sYstemk1t&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2020 sYstemk1t</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>